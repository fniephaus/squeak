/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.561 uuid: 13467880-93b9-4137-9bbc-7ebfd22436ab
   from
	StackInterpreter VMMaker.oscog-eem.561 uuid: 13467880-93b9-4137-9bbc-7ebfd22436ab
 */
static char __buildInfo[] = "StackInterpreter VMMaker.oscog-eem.561 uuid: 13467880-93b9-4137-9bbc-7ebfd22436ab " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include "sq.h"
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "dispdbg.h"
#include "sqMemoryAccess.h"


/* StackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline off
void
warning(char *s) { /* Print an error message but don't exit. */
	printf("\n%s\n", s);
}
void
warningat(char *s, int l) { /* ditto with line number. */
#if 0
	printf("\n%s %d\n", s, l);
#else /* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
#endif
}
#pragma auto_inline on

void
invalidCompactClassError(char *s) { /* Print a compact class index error message and exit. */
	printf("\nClass %s does not have the required compact class index\n", s);
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 */
#if WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif

/* end StackInterpreter class>>preambleCCode */

typedef struct {
	usqInt	segStart;
	usqInt	segSize;
	sqInt	swizzle;
	usqInt	containsPinned;
 } SpurSegmentInfo;


typedef struct {
	usqInt	start;
	usqInt	limit;
 } SpurNewSpaceSpace;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	top;
 } SpurContiguousObjStack;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	first;
	usqInt	last;
 } SpurCircularBuffer;


typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define InterpreterStackPage StackPage



/*** Constants ***/
#define ActiveProcessIndex 1
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BecameCompiledMethodFlag 2
#define BecamePointerObjectFlag 1
#define BitsPerByte 8
#define Byte0Mask 0xFF
#define Byte1Mask 0xFF00
#define Byte1Shift 8
#define Byte1ShiftNegated -8
#define Byte2Mask 0xFF0000
#define Byte3Mask 0xFF000000UL
#define Byte3Shift 24
#define Byte3ShiftNegated -24
#define CacheProbeMax 3
#define CharacterTable null
#define CharacterValueIndex 0
#define CheckObjectOverwrite 1
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 51
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 37
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 52
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 34
#define ClassInteger 5
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 32
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 33
#define ClassMessage 15
#define ClassMessageCompactIndex 35
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 36
#define ClassMutex 39
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassUnsafeAlien 54
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define ConstMinusOne 0xFFFFFFFFUL
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DontTenureButDoUnmark 3
#define DumpStackOnLowSpace 0
#define EndOfRun 0x101
#define EphemeronQueueRootIndex 4098
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootsSize 2048
#define FailImbalancedPrimitives 1
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerContext 4
#define FoxCallerSavedIP 4
#define FoxFrameFlags -8
#define FoxMethod -4
#define FoxReceiver -16
#define FoxSavedFP 0
#define FoxThisContext -12
#define FrameSlots 6
#define GCModeFull 1
#define GCModeIncr 2
#define GCModeScavenge 3
#define HeaderIndex 0
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x40000
#define LargeContextSize 256
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#define MarkStackRootIndex 0x1000
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxPrimitiveIndex 575
#define MaxQuickPrimitiveIndex 519
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x400
#define MethodCacheEntrySize 4
#define MethodCacheMask 0xFFC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 4096
#define MethodDictionaryIndex 1
#define MethodIndex 3
#define MillisecondClockMask 0x1FFFFFFF
#define MULTIPLEBYTECODESETS 0
#define MyListIndex 3
#define NewspeakVM 0
#define NextLinkIndex 0
#define NilObject 0
#define ObjStackFixedSlots 4
#define ObjStackFreex 2
#define ObjStackLimit 0xFF8
#define ObjStackMyx 1
#define ObjStackNextx 3
#define ObjStackPageSlots 0xFFC
#define ObjStackTopx 0
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrInappropriate 6
#define PrimErrLimitExceeded 15
#define PrimErrNamedInternal 13
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNotFound 11
#define PrimErrObjectIsPinned 16
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimitiveExternalCallIndex 117
#define PrimNoErr 0
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RememberedSetLimit 0x10000
#define RememberedSetRedZone 0x8000
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define ShiftForWord 2
#define SmallContextSlots 22
#define SmallIntegerShift 1
#define SpecialSelectors 23
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TenureByAge 1
#define TenureByClass 2
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TrueObject 2
#define ValueIndex 1
#define VMBIGENDIAN 0
#define WeaklingStackRootIndex 0x1001
#define XIndex 0
#define YIndex 1


/*** Function Prototypes ***/
sqInt interpret(void);
static sqInt accessibleObjectAfter(sqInt objOop);
sqInt activeProcess(void);
static void addFreeSubTree(sqInt freeTree);
sqInt addGCRoot(sqInt *varLoc);
static void addLastLinktoList(sqInt proc, sqInt aList);
static SpurCircularBuffer * addLast(SpurCircularBuffer * self_in_addLast, sqInt element);
static void addNewMethodToCache(sqInt classObj);
static sqInt addressAfter(sqInt objOop);
static sqInt addressCouldBeClassObj(sqInt maybeClassObj);
sqInt addressCouldBeObj(sqInt address);
static sqInt addressCouldBeOop(sqInt address);
static sqInt addressIsInPage(StackPage * self_in_addressIsInPage, char *address);
static SpurSegmentInfo * addSegmentOfSize(sqInt ammount);
static void addToEphemeronList(sqInt ephemeronCorpse);
static sqInt addToFreeTreebytes(sqInt freeChunk, sqInt chunkBytes);
static void addToWeakList(sqInt weakCorpse);
static void adjustSegmentSwizzlesBy(sqInt firstSegmentShift);
static sqInt allBridgesMarked(void);
static sqInt allObjectsUnmarked(void);
static sqInt allocateBytesclassIndex(sqInt numBytes, sqInt classIndex);
static char * allocateMemoryminimumimageFileheaderSize(sqInt heapSize, sqInt minimumMemory, sqImageFile fileStream, sqInt headerSize);
static sqInt allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static void allocateOrExtendSegmentInfos(void);
static sqInt allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, sqInt totalBytes, sqInt formatField, sqInt classIndex);
static sqInt allocationUnit(void);
static sqInt allUnscannedEphemeronsAreActive(void);
sqInt argumentCountOfClosure(sqInt closurePointer);
sqInt argumentCountOfMethodHeader(sqInt header);
sqInt argumentCountOf(sqInt methodPointer);
static sqInt arrayClassIndexPun(void);
sqInt arrayFormat(void);
void * arrayValueOf(sqInt arrayOop);
static sqInt asciiOfCharacter(sqInt characterObj);
void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static void assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln);
static sqInt becomeEffectFlagsFor(sqInt objOop);
sqInt becomewith(sqInt array1, sqInt array2);
static sqInt becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
void beRootIfOld(sqInt oop);
static sqInt bitsSetInFreeSpaceMaskForAllFreeLists(void);
sqInt booleanValueOf(sqInt obj);
static sqInt bootstrapping(void);
static sqInt bridgeAt(sqInt segIndex);
static sqInt bridgeFor(SpurSegmentInfo *aSegment);
static void bridgeFromto(SpurSegmentInfo *aSegment, SpurSegmentInfo *nextSegmentOrNil);
static sqInt bridgeSize(void);
static sqInt byteFormatMask(void);
sqInt byteLengthOf(sqInt objOop);
sqInt byteSizeOf(sqInt oop);
sqInt byteSwapped(sqInt w);
static usqLong bytesInObject(sqInt objOop);
static sqInt bytesPerOop(void);
EXPORT(sqInt) callbackEnter(sqInt *callbackID);
EXPORT(sqInt) callbackLeave(sqInt cbID);
sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader);
static sqInt changeClassOfto(sqInt rcvr, sqInt argClass);
sqInt characterForAscii(sqInt ascii);
sqInt characterObjectOf(sqInt characterCode);
void characterTable(void);
sqInt characterTag(void);
sqInt characterValueOf(sqInt oop);
sqInt checkAllAccessibleObjectsOkay(void);
static sqInt checkCodeIntegrity(sqInt fullGCFlag);
static sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
sqInt checkedIntegerValueOf(sqInt intOop);
sqInt checkedLongAt(sqInt byteAddress);
static sqInt checkForEventsMayContextSwitch(sqInt mayContextSwitch);
static sqInt checkHeapIntegrity(sqInt excludeUnmarkedNewSpaceObjs);
static sqInt checkImageVersionFromstartingAt(sqImageFile  f, squeakFileOffsetType  imageOffset);
static sqInt checkInterpreterIntegrity(void);
static sqInt checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
static sqInt checkOkayFields(sqInt oop);
sqInt checkOkayInterpreterObjects(sqInt writeBack);
sqInt checkOkayOop(usqInt oop);
static sqInt checkOkayStackPage(StackPage *thePage);
static sqInt checkOkayStackZone(sqInt writeBack);
sqInt checkOopHasOkayClass(usqInt obj);
static sqInt checkOopIntegritynamed(sqInt obj, char *name);
static sqInt checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i);
static void checkProfileTick(sqInt aPrimitiveMethod);
static sqInt checkStackIntegrity(void);
sqInt classAlien(void);
sqInt classArray(void);
sqInt classAtIndex(sqInt classIndex);
static sqInt classAtIndexput(sqInt classIndex, sqInt objOop);
sqInt classBitmap(void);
sqInt classByteArray(void);
sqInt classCharacter(void);
sqInt classExternalAddress(void);
sqInt classExternalData(void);
sqInt classExternalFunction(void);
sqInt classExternalLibrary(void);
sqInt classExternalStructure(void);
sqInt classFloat(void);
sqInt classFloatCompactIndex(void);
sqInt classIndexMask(void);
sqInt classIndexOf(sqInt objOop);
sqInt classLargeNegativeInteger(void);
sqInt classLargePositiveInteger(void);
static sqInt classNameOfIs(sqInt aClass, char *className);
sqInt classPoint(void);
sqInt classSemaphore(void);
sqInt classSmallInteger(void);
sqInt classString(void);
sqInt classTableMajorIndexShift(void);
sqInt classTableMinorIndexMask(void);
static sqInt classTablePageSize(void);
sqInt classTableRootObj(void);
static sqInt classTableRootSlots(void);
static sqInt classTagForClass(sqInt classObj);
sqInt classUnsafeAlien(void);
static void clearLeakMapAndMapAccessibleObjects(void);
static sqInt cloneContext(sqInt aContext);
sqInt clone(sqInt objOop);
static void collapseSegmentsPostSwizzle(void);
sqInt compactClassIndexOf(sqInt objOop);
static sqInt compare31or32Bitsequal(sqInt obj1, sqInt obj2);
static sqInt contexthasSender(sqInt thisCntx, sqInt aContext);
static sqInt contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP);
sqInt copiedValueCountOfClosure(sqInt closurePointer);
static sqInt copyAndForward(sqInt survivor);
sqInt copyBits(void);
sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
void countMarkedAndUnmarkdObjects(sqInt printFlags);
static void cr(void);
static void createActualMessageTo(sqInt lookupClass);
char * cStringOrNullFor(sqInt oop);
static double dbgFloatValueOf(sqInt oop);
static sqInt defaultEdenBytes(void);
static sqInt defaultNumStackPages(void);
static void detachFreeObject(sqInt freeChunk);
static sqInt displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
sqInt displayObject(void);
static sqInt divorceAllFrames(void);
static void divorceFramesIn(StackPage *aStackPage);
static sqInt doPrimitiveDivby(sqInt rcvr, sqInt arg);
static sqInt doPrimitiveModby(sqInt rcvr, sqInt arg);
sqInt doSignalSemaphoreWithIndex(sqInt index);
static void dummyReferToProxy(void);
EXPORT(sqInt) dumpImage(sqInt fileName);
void dumpPrimTraceLog(void);
sqInt eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots);
static void eliminateAndFreeForwarders(void);
static void ensureAdequateClassTableBitmap(void);
static sqInt ensureBehaviorHash(sqInt aBehavior);
static sqInt ensureCallerContext(char *theFP);
static void ensureImageFormatIsUpToDate(sqInt swapBytes);
static sqInt ensureRoomOnObjStackAt(sqInt objStackRootIndex);
static sqInt enterIntoClassTable(sqInt aBehavior);
static sqInt ephemeronFormat(void);
static void exactFitCompact(void);
static sqInt existInstancesInNewSpaceOf(sqInt classObj);
static void expungeDuplicateClasses(void);
static void externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static char * externalEnsureIsBaseFrame(char *aFramePtr);
static sqInt externalInstVarofContext(sqInt offset, sqInt aContext);
static sqInt externalQuickPrimitiveResponse(void);
static sqInt extraStackBytes(void);
sqInt failed(void);
static void failUnbalancedPrimitive(void);
sqInt falseObject(void);
void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchByteofObject(sqInt byteIndex, sqInt objOop);
static sqInt fetchClassOfNonImm(sqInt objOop);
sqInt fetchClassOf(sqInt oop);
double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static sqInt fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop);
sqInt fetchPointerofObject(sqInt fieldIndex, sqInt objOop);
static sqInt fetchStackPointerOf(sqInt aContext);
static void fillHighestObjectsWithMovableObjectsFromupTo(sqInt startObj, sqInt limitObj);
static sqInt findClassContainingMethodstartingAt(sqInt meth, sqInt classObj);
sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static char * findFrameAboveinPage(char *theFP, StackPage *thePage);
static sqInt findHomeForContext(sqInt aContext);
static sqInt findLargestFreeChunk(void);
static sqInt findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
static sqInt findMethodWithPrimitiveFromFPUpToContext(sqInt primitive, char *startFP, sqInt homeContext);
static sqInt findNewMethodInClassTag(sqInt classTagArg);
sqInt findSelectorOfMethod(sqInt methArg);
static char * findSPOfon(char *theFP, StackPage *thePage);
void findStringBeginningWith(char *aCString);
void findString(char *aCString);
static sqInt firstAccessibleObject(void);
sqInt firstByteFormat(void);
sqInt firstCompiledMethodFormat(void);
static sqInt firstCorpse(sqInt headOfCorpseList);
static void firstFitCompact(void);
static void * firstFixedFieldOfMaybeImmediate(sqInt oop);
void * firstFixedField(sqInt objOop);
void * firstIndexableField(sqInt objOop);
sqInt firstLongFormat(void);
sqInt firstShortFormat(void);
sqInt fixedFieldsFieldWidth(void);
sqInt fixedFieldsOfClassFormatMask(void);
static sqInt fixedFieldsOfClassFormat(sqInt classFormat);
static sqInt fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength);
static sqInt fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue);
double floatArg(sqInt index);
sqInt floatObjectOf(double aFloat);
double floatValueOf(sqInt oop);
static sqInt flushExternalPrimitiveOf(sqInt methodObj);
static sqInt followFieldofObject(sqInt fieldIndex, sqInt anObject);
static void followForwardedFrameContentsstackPointer(char *theFP, char *theSP);
static sqInt followForwardedInObjStackatIndex(sqInt objStack, sqInt objStackRootIndex);
static void followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth);
static sqInt followForwarded(sqInt objOop);
static void followForwardingPointersInStackZone(sqInt theBecomeEffectsFlags);
static void followNecessaryForwardingInMethod(sqInt methodObj);
sqInt forceInterruptCheck(void);
void forceInterruptCheckFromHeartbeat(void);
sqInt formatMask(void);
sqInt formatOfClass(sqInt classPointer);
static sqInt formatOf(sqInt objOop);
sqInt formatShift(void);
static sqInt forwardedFormat(void);
static sqInt frameCallerContext(char *theFP);
static char * frameCallerFP(char *theFP);
static char * frameCallerSavedIP(char *theFP);
static char * frameCallerSP(char *theFP);
static sqInt frameContext(char *theFP);
static sqInt frameHasContext(char *theFP);
static sqInt frameIsBlockActivation(char *theFP);
static sqInt frameMethod(char *theFP);
static sqInt frameNumArgs(char *theFP);
static char * frameOfMarriedContext(sqInt aContext);
static char * frameReceiverOffset(char *theFP);
static sqInt frameReceiver(char *theFP);
static sqInt freeChunkNextIndex(void);
static sqInt freeChunkParentIndex(void);
static sqInt freeChunkWithBytesat(sqInt bytes, sqInt address);
static sqInt freeListsObj(void);
static sqInt freeStackPageNoAssert(StackPage *aPage);
static void freeUntracedStackPages(void);
sqInt fullDisplayUpdate(void);
usqLong fullGC(void);
void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void) ;
sqInt getCurrentBytecode(void);
sqInt getFullScreenFlag(void);
sqInt getInterruptKeycode(void);
sqInt getInterruptPending(void);
static sqInt getLongFromFileswap(sqImageFile  aFile, sqInt swapFlag);
usqLong getNextWakeupUsecs(void);
sqInt getSavedWindowSize(void);
static sqInt getShortFromFileswap(sqImageFile aFile, sqInt swapFlag);
sqInt * getStackPointer(void);
sqInt getThisSessionID(void);
static sqInt goodContextSize(sqInt oop);
static usqInt growOldSpaceByAtLeast(sqInt minAmmount);
static sqInt handleForwardedSelectorFaultFor(sqInt selectorOop);
static sqInt handleForwardedSendFaultForTag(sqInt classTag);
static sqInt handleSpecialSelectorSendFaultForfpsp(sqInt obj, char *theFP, char *theSP);
static void handleStackOverflow(void);
static sqInt handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
static sqInt hasYoungReferents(sqInt objOop);
usqLong headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
sqInt headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
static sqInt headerOf(sqInt methodPointer);
static sqInt hiddenRootSlots(void);
sqInt highBit(usqInt anUnsignedValue);
sqInt identityHashHalfWordMask(void);
static usqInt iframeMethod(char *theFP);
void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
static sqInt imageFormatVersion(void);
static sqInt imageSizeToWrite(void);
static sqInt inactiveOrFailedToDeferScan(sqInt anEphemeron);
sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
void incrementalGC(void);
sqInt indexablePointersFormat(void);
static void inFreeTreeReplacewith(sqInt treeNode, sqInt newNode);
static sqInt initialInstanceOf(sqInt classObj);
static void initializeObjectMemory(sqInt bytesToShift);
static sqInt initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage);
sqInt initialPCForHeadermethod(sqInt methodHeader, sqInt theMethod);
static void initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address);
sqInt instanceSizeOf(sqInt classObj);
sqInt instantiateClassindexableSize(sqInt classObj, sqInt nElements);
static sqInt instSpecOfClass(sqInt classPointer);
sqInt integerArg(sqInt index);
sqInt integerObjectOf(sqInt value);
sqInt integerValueOf(sqInt oop);
static sqInt interpreterAllocationReserveBytes(void);
void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
sqInt isArray(sqInt oop);
static sqInt isBaseFrame(char *theFP);
sqInt isBytes(sqInt oop);
sqInt isCharacterObject(sqInt oop);
sqInt isCharacterValue(sqInt anInteger);
sqInt isCompiledMethod(sqInt objOop);
static sqInt isContextHeader(sqInt aHeader);
static sqInt isContextNonImm(sqInt oop);
static sqInt isContext(sqInt oop);
static sqInt isEnumerableObjectNoAssert(sqInt objOop);
static sqInt isEnumerableObject(sqInt objOop);
static sqInt isEphemeron(sqInt objOop);
sqInt isFloatObject(sqInt oop);
static sqInt isForwardedClassTag(sqInt classIndex);
sqInt isForwardedObjectClassIndexPun(void);
sqInt isForwarded(sqInt objOop);
static sqInt isFree(StackPage * self_in_isFree);
static sqInt isFreeObject(sqInt objOop);
sqInt isImmediate(sqInt oop);
sqInt isIndexable(sqInt objOop);
static sqInt isInEden(sqInt objOop);
static sqInt isInFutureSpace(sqInt address);
sqInt isInMemory(sqInt address);
static sqInt isInNewSpace(sqInt objOop);
static sqInt isInOldSpace(sqInt address);
static sqInt isInPastSpace(sqInt address);
static sqInt isInRememberedSet(sqInt objOop);
static sqInt isInSegments(usqInt address);
sqInt isIntegerObject(sqInt oop);
sqInt isIntegerValue(sqInt intValue);
static sqInt isLiveContext(sqInt oop);
static sqInt isMachineCodeFrame(char *theFP);
sqInt isMarked(sqInt objOop);
static sqInt isMarriedOrWidowedContext(sqInt aContext);
static sqInt isNegativeIntegerValueOf(sqInt oop);
sqInt isNonImmediate(sqInt oop);
sqInt isOldObject(sqInt objOop);
sqInt isOopCompiledMethod(sqInt oop);
sqInt isOopForwarded(sqInt oop);
sqInt isOopImmutable(sqInt oop);
sqInt isOopMutable(sqInt oop);
sqInt isPinned(sqInt objOop);
sqInt isPointers(sqInt oop);
static sqInt isPrimitiveFunctionPointerAnIndex(void);
sqInt isQuickPrimitiveIndex(sqInt anInteger);
sqInt isReadMediatedContextInstVarIndex(sqInt index);
sqInt isReallyYoungObject(sqInt obj);
sqInt isReallyYoung(sqInt oop);
static sqInt isRemembered(sqInt objOop);
static sqInt isScavengeSurvivor(sqInt oop);
static sqInt isSegmentBridge(sqInt objOop);
static sqInt isSingleContext(sqInt aContext);
static sqInt isValidFreeObject(sqInt objOop);
static sqInt isValidObjStackAt(sqInt objStackRootIndex);
static sqInt isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx);
static sqInt isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage);
static sqInt isValidObjStack(sqInt objStack);
static sqInt isValidSegmentBridge(sqInt objOop);
static sqInt isWeakNonImm(sqInt objOop);
sqInt isWeak(sqInt oop);
static sqInt isWidowedContext(sqInt aOnceMarriedContext);
sqInt isWordsOrBytes(sqInt oop);
sqInt isWords(sqInt oop);
sqInt isWriteMediatedContextInstVarIndex(sqInt index);
sqInt isYoungObject(sqInt objOop);
sqInt isYoung(sqInt oop);
static sqInt isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
sqInt isKindOfClass(sqInt oop, sqInt aClass);
sqInt isKindOf(sqInt oop, char *className);
sqInt isMemberOf(sqInt oop, char *className);
static sqInt isonWeaklingList(sqInt oop, sqInt listHead);
static sqInt keyOfEphemeron(sqInt objOop);
static sqInt knownClassAtIndex(sqInt classIndex);
sqInt lastPointerOfWhileSwizzling(sqInt objOop);
sqInt lastPointerOf(sqInt objOop);
sqInt leakCheckBecome(void);
sqInt leakCheckFullGC(void);
sqInt leakCheckIncrementalGC(void);
sqInt leakCheckNewSpaceGC(void);
static sqInt lengthOfMaybeImmediate(sqInt oop);
static sqInt lengthOfNameOfClass(sqInt classOop);
sqInt lengthOf(sqInt objOop);
static sqInt lengthOfformat(sqInt objOop, sqInt fmt);
sqInt literalCountOfHeader(sqInt headerPointer);
sqInt literalCountOf(sqInt methodPointer);
sqInt literalofMethod(sqInt offset, sqInt methodPointer);
sqInt loadBitBltFrom(sqInt bb);
void loadInitialContext(void);
void longPrintOop(sqInt oop);
void longPrintReferencesTo(sqInt anOop);
sqInt longStoreBytecodeForHeader(sqInt methodHeader);
static sqInt lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag);
static sqInt lookupMethodInClass(sqInt class);
static sqInt lookupMethodInDictionary(sqInt dictionary);
static sqInt lookupMethodNoMNUEtcInClass(sqInt class);
static sqInt magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
static usqLong magnitude64BitValueOf(sqInt oop);
static StackPage * makeBaseFrameFor(sqInt aContext);
sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapInterpreterOops(void);
static void mapStackPages(void);
static sqInt markAndShouldScan(sqInt objOop);
static void markAndTraceClassOf(sqInt objOop);
static void markAndTraceObjStackandContents(sqInt stackOrNil, sqInt markAndTraceContents);
static sqInt markAndTraceStackPages(sqInt fullGCFlag);
static void markAndTraceStackPage(StackPage *thePage);
static void markAndTraceUntracedReachableStackPages(void);
void markAndTrace(sqInt objOop);
static sqInt markInactiveEphemerons(void);
static sqInt markStackPageMostRecentlyUsed(StackPage *page);
static sqInt markStackPageNextMostRecentlyUsed(StackPage *page);
static void markWeaklingsAndMarkAndFireEphemerons(void);
static sqInt marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static void marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext);
static sqInt marryFrameSP(char *theFP, char *theSP);
sqInt maybeSplObj(sqInt index);
sqInt methodArgumentCount(void);
sqInt methodArg(sqInt index);
sqInt methodClassAssociationOf(sqInt methodPointer);
static sqInt methodClassOf(sqInt methodPointer);
sqInt methodPrimitiveIndex(void);
sqInt methodReturnValue(sqInt oop);
sqInt methodUsesAlternateBytecodeSet(sqInt aMethodObj);
EXPORT(void) moduleUnloaded(char *aModuleName);
static char * moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static char * nameOfClass(sqInt classOop);
static sqInt newObjectHash(void);
static sqInt newSpaceIsEmpty(void);
static StackPage * newStackPage(void);
sqInt nilObject(void);
static void nilUnmarkedWeaklingSlots(void);
static sqInt nilUnmarkedWeaklingSlotsIn(sqInt aWeakling);
static sqInt noCheckPushonObjStack(sqInt objOop, sqInt objStack);
static sqInt noInlineTemporaryin(sqInt offset, char *theFP);
static sqInt noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop);
static sqInt noMarkedContextsOnPage(StackPage *thePage);
sqInt nonIndexablePointerFormat(void);
static sqInt noUnfiredEphemeronsAtEndOfRememberedSet(void);
static sqInt noUnscannedEphemerons(void);
static sqInt numFreeLists(void);
sqInt numPointerSlotsOf(sqInt objOop);
sqInt numSlotsHalfShift(void);
sqInt numSlotsMask(void);
static usqInt numSlotsOfAny(sqInt objOop);
usqInt numSlotsOf(sqInt objOop);
sqInt numStrongSlotsOfephemeronInactiveIf(sqInt objOop, int (*criterion)(sqInt key));
sqInt numTagBits(void);
static sqInt objCouldBeClassObj(sqInt objOop);
sqInt objectAfter(sqInt objOop);
static sqInt objectAfterlimit(sqInt objOop, sqInt limit);
sqInt objectArg(sqInt index);
sqInt objectBefore(sqInt objOop);
static sqInt objectStartingAt(sqInt address);
sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
static sqInt okayOop(sqInt signedOop);
static sqInt oopisGreaterThanOrEqualTo(sqInt anOop, sqInt otherOop);
static sqInt oopisGreaterThanOrEqualToandLessThanOrEqualTo(sqInt anOop, sqInt baseOop, sqInt limitOop);
static sqInt oopisGreaterThanOrEqualToandLessThan(sqInt anOop, sqInt baseOop, sqInt limitOop);
static sqInt oopisGreaterThan(sqInt anOop, sqInt otherOop);
static sqInt oopisLessThanOrEqualTo(sqInt anOop, sqInt otherOop);
static sqInt oopisLessThan(sqInt anOop, sqInt otherOop);
static sqInt pageIndexFor(void *pointer);
static sqInt pageListIsWellFormed(void);
void pinObject(sqInt objOop);
static sqInt popObjStack(sqInt objStack);
sqInt popRemappableOop(void);
sqInt popStack(void);
sqInt pop(sqInt nItems);
void popthenPush(sqInt nItems, sqInt oop);
sqInt positive32BitIntegerFor(sqInt integerValue);
sqInt positive32BitValueOf(sqInt oop);
sqInt positive64BitIntegerFor(sqLong integerValue);
sqLong positive64BitValueOf(sqInt oop);
unsigned long positiveMachineIntegerValueOf(sqInt oop);
static void postBecomeOrCompactScanClassTable(sqInt effectsFlags);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHash(void);
static void primitiveAsCharacter(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveCharacterValue(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClone(void);
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveClosureValue(void);
void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
EXPORT(void) primitiveCompareBytes(void);
static void primitiveConstantFill(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveContextXray(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
EXPORT(sqInt) primitiveCrashVM(void);
static void primitiveDeferDisplayUpdates(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveEnterCriticalSection(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
sqInt primitiveErrorTable(void);
EXPORT(void) primitiveEventProcessingControl(void);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
static void primitiveExitCriticalSection(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
static void primitiveExternalCall(void);
sqInt primitiveFail(void);
sqInt primitiveFailFor(sqInt reasonCode);
sqInt primitiveFailureCode(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFloatAdd(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveFullGC(void);
static void primitiveGetAttribute(void);
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
static void primitiveGrowMemoryByAtLeast(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
static void primitiveImageName(void);
static void primitiveIncrementalGC(void);
sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
sqInt primitiveIndexOf(sqInt methodPointer);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
static void primitiveKbdNext(void);
static void primitiveKbdPeek(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
EXPORT(sqInt) primitiveLongRunningPrimitive(void);
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(void);
static void primitiveLowSpaceSemaphore(void);
EXPORT(sqInt) primitiveMakeEphemeron(void);
static void primitiveMakePoint(void);
static void primitiveMarkHandlerMethod(void);
static void primitiveMarkUnwindMethod(void);
static void primitiveMaxIdentityHash(void);
usqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
EXPORT(sqInt) primitiveMillisecondClockMask(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
static void primitiveMouseButtons(void);
static void primitiveMousePoint(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveNotIdentical(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
static void primitiveObjectPointsTo(void);
static sqInt primitiveObjectperformwithArgumentslookedUpIn(sqInt actualReceiver, sqInt selector, sqInt argumentArray, sqInt lookupClass);
EXPORT(sqInt) primitiveOriginalMillisecondClock(void);
static void primitivePerform(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(sqInt) primitiveProfileSemaphore(void);
EXPORT(sqInt) primitiveProfileStart(void);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
EXPORT(void) primitiveRemLargeIntegers(void);
static void primitiveResume(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSetIdentityHash(void);
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignal(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSizeInBytes(void);
static void primitiveSizeInBytesOfInstance(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStoreStackp(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveSuspend(void);
static void primitiveTerminateTo(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUnloadModule(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
EXPORT(sqInt) primitiveUtcWithOffset(void);
static void primitiveVMParameter(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
EXPORT(void) primitiveVoidReceiver(void);
static void primitiveVoidVMState(void);
static void primitiveWait(void);
static void primitiveYield(void);
static void printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass);
static void printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
void printAllStacks(void);
void printCallStack(void);
static sqInt printCallStackFP(char *theFP);
sqInt printCallStackOf(sqInt aContextOrProcessOrFrame);
static sqInt printCallStackOfcurrentFP(sqInt aContext, char *currFP);
void printChar(sqInt aByte);
static sqInt printContextCallStackOf(sqInt aContext);
void printContext(sqInt aContext);
void printExternalHeadFrame(void);
static sqInt printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort);
static void printFrameFlagsForFP(char *theFP);
static void printFrameOopat(char *name, char *address);
EXPORT(void) printFramesInPage(StackPage *thePage);
EXPORT(void) printFramesOnStackPageListInUse(void);
static void printFrameThingandFrameat(char *name, char *theFP, char *address);
static void printFrameThingat(char *name, char *address);
sqInt printFrame(char *theFP);
void printFrameWithSP(char *theFP, char *theSP);
void printFreeChunk(sqInt freeChunk);
void printFreeList(sqInt chunkOrIndex);
void printHex(sqInt n);
void printInstancesOf(sqInt aClassOop);
void printInstancesWithClassIndex(sqInt classIndex);
void printMethodCache(void);
void printMethodCacheFor(sqInt thing);
void printMethodDictionaryOf(sqInt behavior);
void printMethodDictionary(sqInt dictionary);
void printMethodReferencesTo(sqInt anOop);
static void printNameOfClasscount(sqInt classOop, sqInt cnt);
static void printNum(sqInt n);
void printObjectsFromto(sqInt startAddress, sqInt endAddress);
static void printObjStackPagemyIndexpageType(sqInt objStackPage, sqInt myx, sqInt pageType);
static void printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType);
void printObjStack(sqInt objStack);
static void printOopShort(sqInt oop);
void printOop(sqInt oop);
void printProcessStack(sqInt aProcess);
sqInt printProcsOnList(sqInt procList);
void printReferencesTo(sqInt anOop);
sqInt printStackCallStackOf(char *aFramePointer);
void printStackPageList(void);
void printStackPageListInUse(void);
void printStackPages(void);
void printStackPagesInUse(void);
static void printStackPage(StackPage *page);
static sqInt printStringOf(sqInt oop);
void print(char *s);
static void processEphemerons(void);
static void processWeaklings(void);
static void processWeakSurvivor(sqInt weakObj);
void pushBool(sqInt trueOrFalse);
static sqInt pushedReceiverOrClosureOfFrame(char *theFP);
void pushFloat(double f);
sqInt pushInteger(sqInt integerValue);
static sqInt pushOnUnscannedEphemeronsStack(sqInt anEphemeron);
void pushRemappableOop(sqInt oop);
void push(sqInt object);
static sqInt pushonObjStack(sqInt objOop, sqInt objStack);
static void putLongtoFile(sqInt aWord, sqImageFile  aFile);
static void putShorttoFile(sqInt aShort, sqImageFile  aFile);
static void putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static sqInt quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
static sqInt rawHashBitsOf(sqInt objOop);
static usqInt rawNumSlotsOf(sqInt objOop);
static usqInt rawOverflowSlotsOf(sqInt objOop);
sqInt readableFormat(sqInt imageVersion);
static sqInt readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes);
size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
static sqInt rebuildFreeTreeFrom(sqInt sortedFreeChunks);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
sqInt remapObj(sqInt objOop);
sqInt rememberedBitShift(void);
static void remember(sqInt objOop);
static sqInt removeFirstLinkOfList(sqInt aList);
sqInt removeGCRoot(sqInt *varLoc);
static sqInt resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static void rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void));
static sqInt roomToPushNArgs(sqInt n);
static void runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(sqInt fullGCFlag, sqInt excludeUnmarkedNewSpaceObjs);
static void scanClassPostBecomeeffects(sqInt startClassObj, sqInt becomeEffects);
static void scavengeFutureSurvivorSpaceStartingAt(sqInt initialAddress);
static void scavengeLoop(void);
static sqInt scavengeReferentsOf(sqInt referrer);
static void scavengeRememberedSetStartingAt(sqInt n);
static float scavengerTenuringThreshold(void);
static sqInt scavengeUnfiredEphemeronsOnEphemeronList(void);
static void scavengingGCTenuringIf(sqInt tenuringCriterion);
static usqInt segLimit(SpurSegmentInfo * self_in_segLimit);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
void setBreakSelector(char *aString);
void setFullScreenFlag(sqInt value);
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))()) ;
void setInterruptKeycode(sqInt value);
void setInterruptPending(sqInt value);
static void setIsMarkedOfto(sqInt objOop, sqInt aBoolean);
void setNextWakeupUsecs(usqLong value);
void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static void setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext);
sqInt shiftForWord(void);
static sqInt shortPrintContext(sqInt aContext);
static sqInt shortPrintFrameAndCallers(char *theFP);
EXPORT(void) shortPrintFramesInPage(StackPage *thePage);
EXPORT(void) shortPrintFramesOnStackPageListInUse(void);
static sqInt shortPrintFrame(char *theFP);
void shortPrintFrameAndNCallers(char *theFP, sqInt n);
void shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress);
static void shortPrintOop(sqInt oop);
static sqInt shortReversePrintFrameAndCallers(char *aFramePointer);
static sqInt shouldBeTenured(sqInt survivor);
sqInt shouldRemapObj(sqInt objOop);
sqInt shouldRemapOop(sqInt oop);
sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
sqInt signalNoResume(sqInt aSemaphore);
sqInt signed32BitIntegerFor(sqInt integerValue);
int signed32BitValueOf(sqInt oop);
sqInt signed64BitIntegerFor(sqLong integerValue);
sqLong signed64BitValueOf(sqInt oop);
long signedMachineIntegerValueOf(sqInt oop);
static sqInt sixtyFourBitIndexableFormat(void);
usqInt sizeOfAlienData(sqInt oop);
sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
static usqLong sizeOfFree(sqInt objOop);
sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
sqInt slotSizeOf(sqInt oop);
static sqInt snapshot(sqInt embedded);
static void space(void);
sqInt specialSelector(sqInt index);
sqInt splObj(sqInt index);
double stackFloatValue(sqInt offset);
sqInt stackIntegerValue(sqInt offset);
static sqInt stackLimitBytes(void);
static sqInt stackLimitOffset(void);
sqInt stackObjectValue(sqInt offset);
static StackPage * stackPageAt(sqInt index);
static sqInt stackPageByteSize(void);
static StackPage * stackPageFor(void *pointer);
static sqInt stackPageHeadroom(void);
static sqInt stackPointerIndexForFrame(char *theFP);
unsigned long stackPositiveMachineIntegerValue(sqInt offset);
long stackSignedMachineIntegerValue(sqInt offset);
sqInt stackTop(void);
sqInt stackValue(sqInt offset);
void * startOfAlienData(sqInt oop);
static sqInt startOfObject(sqInt objOop);
sqInt startPCOfMethod(sqInt aCompiledMethod);
sqInt stObjectat(sqInt array, sqInt index);
sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
usqInt storeCheckBoundary(void);
sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
static char * storeSenderOfFramewithValue(char *theFP, sqInt anOop);
sqInt stringForCString(const char *aCString);
sqInt stSizeOf(sqInt oop);
sqInt success(sqInt successBoolean);
static sqInt sufficientSpaceAfterGC(sqInt numBytes);
sqInt superclassOf(sqInt classPointer);
static sqInt swizzleObjStackAt(sqInt objStackRootIndex);
static sqInt swizzleObj(sqInt objOop);
static sqInt synchronousSignal(sqInt aSemaphore);
sqInt tagMask(void);
sqInt tempCountOf(sqInt methodPointer);
sqInt temporaryCountOfMethodHeader(sqInt header);
void tenuringIncrementalGC(void);
static sqInt tenuringThreshold(void);
static sqInt topOfObjStack(sqInt objStack);
sqInt topRemappableOop(void);
static sqInt totalBytesInSegments(void);
static sqInt totalFreeListBytes(void);
static void transferTo(sqInt newProc);
sqInt trueObject(void);
static void unlinkSolitaryFreeTreeNode(sqInt freeTreeNode);
static void updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
static sqInt usedSize(SpurCircularBuffer * self_in_usedSize);
static sqInt validClassTableRootPages(void);
static sqInt validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
sqInt validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp);
static sqInt validObjStacks(void);
static sqInt validStackPageBaseFrames(void);
static sqInt validStackPageBaseFrame(StackPage *aPage);
sqInt vmEndianness(void);
static void voidLongRunningPrimitive(char *reason);
static sqInt voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims);
static sqInt wakeHighestPriority(void);
sqInt weakArrayFormat(void);
static sqInt withSmallIntegerTags(char *value);
static sqInt wordIndexableFormat(void);
static sqInt writeImageFileIO(void);
static sqInt writeSegmentnextSegmentSizetoFile(SpurSegmentInfo *segment, sqInt nextSegSize, FILE *aBinaryStream);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss sqInt specialObjectsOop;
_iss StackPage * stackPage;
_iss sqInt nilObj;
_iss usqInt method;
_iss char * framePointer;
_iss sqInt argumentCount;
_iss usqInt newSpaceLimit;
_iss usqInt newMethod;
_iss sqInt messageSelector;
_iss sqInt hiddenRootsObj;
_iss usqInt freeStart;
_iss usqInt instructionPointer;
_iss SpurCircularBuffer highestObjects;
_iss sqInt totalFreeOldSpace;
_iss usqInt endOfMemory;
_iss sqInt remapBufferCount;
_iss sqInt trueObj;
_iss sqInt falseObj;
_iss sqInt * freeLists;
_iss StackPage * pages;
_iss SpurSegmentInfo * segments;
_iss usqInt freeListsMask;
_iss usqInt pastSpaceStart;
_iss char * stackLimit;
_iss char * stackMemory;
_iss sqInt rememberedSetSize;
_iss sqInt bytesPerPage;
_iss SpurNewSpaceSpace pastSpace;
_iss sqInt weaklingStack;
_iss SpurContiguousObjStack unscannedEphemerons;
_iss SpurNewSpaceSpace futureSpace;
_iss sqInt numSegments;
_iss StackPage * mostRecentlyUsedPage;
_iss usqInt newSpaceStart;
_iss sqInt classTableFirstPage;
_iss sqInt firstFreeChunk;
_iss sqInt futureSurvivorStart;
_iss usqInt oldSpaceStart;
_iss sqInt jmpDepth;
_iss sqInt numRememberedEphemerons;
_iss sqInt classNameIndex;
_iss sqInt markStack;
_iss sqInt numClassTablePages;
_iss sqInt numStackPages;
_iss sqInt tempOop;
_iss sqLong nextProfileTick;
_iss char * objStackInvalidBecause;
_iss SpurNewSpaceSpace eden;
_iss sqInt profileProcess;
_iss sqInt tenureThreshold;
_iss sqInt ephemeronList;
_iss sqInt needGCFlag;
_iss sqInt numPages;
_iss sqInt extraRootCount;
_iss sqInt invalidObjStackPage;
_iss sqInt previousRememberedSetSize;
_iss unsigned char * classTableBitmap;
_iss sqInt longRunningPrimitiveCheckMethod;
_iss sqInt longRunningPrimitiveCheckSemaphore;
_iss sqInt ephemeronQueue;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt profileMethod;
_iss sqInt growHeadroom;
_iss usqLong nextWakeupUsecs;
_iss sqInt preemptionYields;
_iss sqInt profileSemaphore;
_iss sqInt highestRunnableProcessPriority;
_iss sqInt lastSubdividedFreeChunk;
_iss usqLong longRunningPrimitiveStartUsecs;
_iss usqLong longRunningPrimitiveStopUsecs;
_iss sqInt numSegInfos;
_iss sqInt statCheckForEvents;
_iss usqInt lowSpaceThreshold;
_iss usqLong statGCEndUsecs;
_iss sqInt classTableIndex;
_iss usqInt freeOldSpaceStart;
_iss sqInt lkupClass;
_iss sqInt metaclassNumSlots;
_iss sqInt pendingFinalizationSignals;
_iss sqInt shrinkThreshold;
_iss sqInt statIOProcessEvents;
_iss sqInt weakList;
_iss sqInt firstSegmentSize;
_iss usqLong gcStartUsecs;
_iss usqInt memory;
_iss usqInt scavengeThreshold;
_iss sqInt statCompactPassCount;
_iss sqInt thisClassIndex;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt fullScreenFlag;
_iss sqInt interruptPending;
_iss sqInt lastHash;
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
_iss sqInt marking;
_iss usqLong nextPollUsecs;
_iss sqInt scavengeInProgress;
_iss sqInt statForceInterruptCheck;
_iss sqInt statProcessSwitch;
_iss sqInt statStackOverflow;
_iss sqInt statStackPageDivorce;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt globalSessionID;
_iss sqInt interruptKeycode;
_iss sqInt maxExtSemTabSizeSet;
_iss usqLong statFullGCUsecs;
_iss sqInt statFullGCs;
_iss sqInt statGrowMemory;
_iss usqLong statScavengeGCUsecs;
_iss sqInt statScavenges;
_iss sqInt statTenures;
_iss sqInt tenuringProportion;
_iss sqInt canSwizzle;
_iss sqInt gcSemaphoreIndex;
_iss sqInt imageFloatsBigEndian;
_iss sqInt longRunningPrimitiveSignalUndelivered;
_iss sqInt methodDictLinearSearchLimit;
_iss StackPage * overflowedPage;
_iss sqInt savedWindowSize;
_iss sqInt signalLowSpace;
_iss sqInt statMarkCount;
_iss sqInt statPendingFinalizationSignals;
_iss sqInt statRootTableCount;
_iss sqInt tenureCriterion;
_iss sqInt theUnknownShort;
_iss sqInt classByteArrayCompactIndex;
_iss sqInt imageHeaderFlags;
_iss usqLong longRunningPrimitiveGCUsecs;
_iss sqInt overflowLimit;
_iss sqInt tenuringClassIndex;
_iss sqInt the2ndUnknownShort;
_iss long methodCache[MethodCacheSize + 1 /* 4097 */];
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt rememberedSet[RememberedSetLimit + 1 /* 65537 */];
_iss sqInt *extraRoots[ExtraRootsSize + 1 /* 2049 */];
_iss usqInt suspendedCallbacks[MaxJumpBuf + 1 /* 33 */];
_iss usqInt suspendedMethods[MaxJumpBuf + 1 /* 33 */];
_iss jmp_buf jmpBuf[MaxJumpBuf + 1 /* 33 */];
_iss unsigned long byteCount;
_iss sqInt preferredPinningSegment;
_iss usqInt sortedFreeChunks;
_iss usqLong statFGCDeltaUsecs;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
 #if SQ_USE_GLOBAL_STRUCT_REG
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
#endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
#if SQ_USE_GLOBAL_STRUCT_REG
#define fooxstr(s) foostr(s)
#define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
#else
static struct foo * foo = &fum;
#endif
#endif
static void (*primitiveFunctionPointer)();
sqInt inIOProcessEvents;
sqInt checkForLeaks;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
sqInt extraVMMemory;
sqInt deferDisplayUpdates;
void * showSurfaceFn;
struct VirtualMachine* interpreterProxy;
static void (*interruptCheckChain)(void) = 0;
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 577 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ (void (*)(void))0,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ (void (*)(void))0,
	/* 159 */ (void (*)(void))0,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ (void (*)(void))0,
	/* 164 */ (void (*)(void))0,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ primitiveCharacterValue,
	/* 172 */ (void (*)(void))0,
	/* 173 */ (void (*)(void))0,
	/* 174 */ (void (*)(void))0,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ (void (*)(void))0,
	/* 178 */ (void (*)(void))0,
	/* 179 */ (void (*)(void))0,
	/* 180 */ primitiveGrowMemoryByAtLeast,
	/* 181 */ primitiveSizeInBytesOfInstance,
	/* 182 */ primitiveSizeInBytes,
	/* 183 */ (void (*)(void))0,
	/* 184 */ (void (*)(void))0,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ primitiveMarkUnwindMethod,
	/* 199 */ primitiveMarkHandlerMethod,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveFlushCacheByMethod,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ (void (*)(void))0,
	/* 245 */ (void (*)(void))0,
	/* 246 */ (void (*)(void))0,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ (void (*)(void))0,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ (void (*)(void))0,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ (void (*)(void))0,
	/* 542 */ (void (*)(void))0,
	/* 543 */ (void (*)(void))0,
	/* 544 */ (void (*)(void))0,
	/* 545 */ (void (*)(void))0,
	/* 546 */ (void (*)(void))0,
	/* 547 */ (void (*)(void))0,
	/* 548 */ (void (*)(void))0,
	/* 549 */ (void (*)(void))0,
	/* 550 */ (void (*)(void))0,
	/* 551 */ (void (*)(void))0,
	/* 552 */ (void (*)(void))0,
	/* 553 */ (void (*)(void))0,
	/* 554 */ (void (*)(void))0,
	/* 555 */ (void (*)(void))0,
	/* 556 */ (void (*)(void))0,
	/* 557 */ (void (*)(void))0,
	/* 558 */ (void (*)(void))0,
	/* 559 */ (void (*)(void))0,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
char * breakSelector;
sqInt breakSelectorLength = -1;
const char *interpreterVersion = "Croquet Closure Stack VM [StackInterpreter VMMaker.oscog-eem.561]";
volatile int sendTrace;
sqInt suppressHeartbeatFlag;


/*** Macros ***/
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define eden() GIV(eden)
#define endOfMemory() GIV(endOfMemory)
#define flush() fflush(stdout)
#define freeStart() GIV(freeStart)
#define futureSpace() GIV(futureSpace)
#define memory() memory
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define newSpaceLimit() GIV(newSpaceLimit)
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define numSegments() GIV(numSegments)
#define oldSpaceStart() GIV(oldSpaceStart)
#define pageIndexForstackMemorybytesPerPage(pointer,stackmem,pageByteSize) (((char *)(pointer) - (stackmem) - 1) / (pageByteSize))
#define pastSpace() GIV(pastSpace)
#define printFloat(f) printf("%g", f)
#define rememberedSetSize() GIV(rememberedSetSize)
#define stackPageAtpages(index,pages) ((pages) + (index))
#define startOfMemory() memory
#define wordSize() 4



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentBytecode;
    sqInt lkupClassTag;
    char * localFP;
    char * localIP;
    sqInt localReturnValue;
    char * localSP;
    sqInt stackPageBytes;
    sqInt stackPagesBytes;
    void *theStackMemory;

	if (GIV(stackLimit) == 0) {
		/* begin initStackPagesAndInterpret */
		stackPageBytes = stackPageByteSize();
		/* begin computeStackZoneSize */
		null;
		stackPagesBytes = (GIV(numStackPages) * ((sizeof(InterpreterStackPage)) + (stackPageByteSize()))) + (extraStackBytes());
		theStackMemory = alloca(stackPagesBytes);
		memset(theStackMemory, 0, stackPagesBytes);
		initializeStacknumSlotspageSize(theStackMemory, ((sqInt) stackPagesBytes >> 2), ((sqInt) stackPageBytes >> 2));
		loadInitialContext();
		ioInitHeartbeat();
		interpret();
		return null;
	}
	browserPluginInitialiseIfNeeded();
	/* begin internalizeIPandSP */
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin fetchNextBytecode */
	
#  if MULTIPLEBYTECODESETS
	currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#  else /* MULTIPLEBYTECODESETS */
	currentBytecode = byteAtPointer(++localIP);

#  endif /* MULTIPLEBYTECODESETS */

	/* begin initExtensions */
	
#  if MULTIPLEBYTECODESETS
	extA = (extB = 0);

#  endif /* MULTIPLEBYTECODESETS */

	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(0bytecodeDispatch);
		switch (currentBytecode) {
		case 0:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(0pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 0 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 1:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(1pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 4 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 2:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(2pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 8 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 3:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(3pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 12 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 4:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(4pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 16 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 5:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(5pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 20 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 6:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(6pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 24 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 7:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(7pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 28 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 8:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(8pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 32 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 9:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(9pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 36 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 10:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(10pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 40 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 11:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(11pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 44 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 12:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(12pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 48 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 13:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(13pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 52 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 14:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(14pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 56 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 15:
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(15pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + 60 /* (currentBytecode bitAnd: 15) << 2 */));
			}
			break;
		case 16:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(0pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(0pushTemporaryVariable);
				/* begin internalPush: */
				object = (0 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 0 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 0 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 17:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(1pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(1pushTemporaryVariable);
				/* begin internalPush: */
				object = (1 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 18:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(2pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(2pushTemporaryVariable);
				/* begin internalPush: */
				object = (2 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 19:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(3pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(3pushTemporaryVariable);
				/* begin internalPush: */
				object = (3 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 20:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(4pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(4pushTemporaryVariable);
				/* begin internalPush: */
				object = (4 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 21:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(5pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(5pushTemporaryVariable);
				/* begin internalPush: */
				object = (5 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 22:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(6pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(6pushTemporaryVariable);
				/* begin internalPush: */
				object = (6 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 23:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(7pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(7pushTemporaryVariable);
				/* begin internalPush: */
				object = (7 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 24:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(8pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(8pushTemporaryVariable);
				/* begin internalPush: */
				object = (8 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 25:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(9pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(9pushTemporaryVariable);
				/* begin internalPush: */
				object = (9 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 26:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(10pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(10pushTemporaryVariable);
				/* begin internalPush: */
				object = (10 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 27:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(11pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(11pushTemporaryVariable);
				/* begin internalPush: */
				object = (11 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 28:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(12pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(12pushTemporaryVariable);
				/* begin internalPush: */
				object = (12 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 29:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(13pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(13pushTemporaryVariable);
				/* begin internalPush: */
				object = (13 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 30:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(14pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(14pushTemporaryVariable);
				/* begin internalPush: */
				object = (14 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 31:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(15pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushTemporaryVariable: */
				VM_LABEL(15pushTemporaryVariable);
				/* begin internalPush: */
				object = (15 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 32:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(0pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 4 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 33:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(1pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 34:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(2pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 12 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 35:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(3pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 36:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(4pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 20 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 37:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(5pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 38:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(6pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 28 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 39:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(7pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 40:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(8pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 36 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 41:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(9pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 42:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(10pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 44 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 43:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(11pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 44:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(12pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 52 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 45:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(13pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 46:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(14pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 60 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 47:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(15pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 48:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(16pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 68 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 49:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(17pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 50:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(18pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 76 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 51:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(19pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 52:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(20pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 84 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 53:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(21pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 54:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(22pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 92 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 55:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(23pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 56:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(24pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 100 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 57:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(25pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 58:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(26pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 108 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 59:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(27pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 60:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(28pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 116 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 61:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(29pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 62:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(30pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 0x7C /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 63:
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(31pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + (BaseHeaderSize)) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 64:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(0pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(0pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 4 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 65:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(1pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(1pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 66:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(2pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(2pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 12 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 67:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(3pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(3pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 68:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(4pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(4pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 20 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 69:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(5pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(5pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 70:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(6pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(6pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 28 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 71:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(7pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(7pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 72:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(8pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(8pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 36 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 73:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(9pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(9pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 74:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(10pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(10pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 44 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 75:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(11pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(11pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 76:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(12pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(12pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 52 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 77:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(13pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(13pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 78:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(14pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(14pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 60 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 79:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(15pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(15pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 80:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(16pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(16pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 68 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 81:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(17pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(17pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 82:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(18pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(18pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 76 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 83:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(19pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(19pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 84:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(20pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(20pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 84 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 85:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(21pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(21pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 86:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(22pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(22pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 92 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 87:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(23pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(23pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 88:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(24pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(24pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 100 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 89:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(25pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(25pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 90:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(26pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(26pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 108 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 91:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(27pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(27pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 92:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(28pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(28pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 116 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 93:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(29pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(29pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 94:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(30pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(30pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 0x7C /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 95:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(31pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushLiteralVariable: */
				VM_LABEL(31pushLiteralVariable);
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + (BaseHeaderSize)) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << 2 */);
				if (((longAt(litVar)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(litVar));
					referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

			}
			break;
		case 96:
		case 97:
		case 98:
		case 99:
		case 100:
		case 101:
		case 102:
		case 103:
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;

				VM_LABEL(0storeAndPopReceiverVariableBytecode);
				rcvr = longAt(localFP + FoxReceiver);
				top = longAtPointer(localSP);
				/* begin storePointer:ofObject:withValue: */
				VM_LABEL(0storePointerofObjectwithValue);
				assert(!(isForwarded(rcvr)));
				if (isOldObject(rcvr)) {

					/* most stores into young objects */

					if (((top & 3) == 0)
					 && ((((usqInt) top)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
							remember(rcvr);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
						}
					}
				}
				longAtput((rcvr + (BaseHeaderSize)) + ((currentBytecode & 7) << 2), top);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 104:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(0storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				if (0 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 0 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 0 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 105:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(1storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				if (1 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 106:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(2storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				if (2 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 107:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(3storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				if (3 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 108:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(4storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				if (4 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 109:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(5storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				if (5 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 110:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(6storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				if (6 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 111:
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(7storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				if (7 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 112:
			/* pushReceiverBytecode */
			{
				VM_LABEL(0pushReceiverBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(localFP + FoxReceiver));
			}
			break;
		case 113:
			/* pushConstantTrueBytecode */
			{
				VM_LABEL(0pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
			break;
		case 114:
			/* pushConstantFalseBytecode */
			{
				VM_LABEL(0pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
			break;
		case 115:
			/* pushConstantNilBytecode */
			{
				VM_LABEL(0pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
			}
			break;
		case 116:
			/* pushConstantMinusOneBytecode */
			{
				VM_LABEL(0pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			break;
		case 117:
			/* pushConstantZeroBytecode */
			{
				VM_LABEL(0pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			break;
		case 118:
			/* pushConstantOneBytecode */
			{
				VM_LABEL(0pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			break;
		case 119:
			/* pushConstantTwoBytecode */
			{
				VM_LABEL(0pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			break;
		case 120:
			/* returnReceiver */
			{
				VM_LABEL(0returnReceiver);
				localReturnValue = longAt(localFP + FoxReceiver);
				/* goto commonReturn */
			}
			
		commonReturn:
			/* commonReturn */
			{
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt ctxtOrNilOrZero;
				sqInt currentCtx;
				sqInt firstBytecode;
				char *frameToReturnTo;
				sqInt home;
				sqInt index;
				sqInt index1;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;
				sqInt primBits;
				char *theFP;
				char *theFP1;
				char *theFP2;
				sqInt theMethod;
				StackPage *thePage;
				StackPage *thePage1;
				sqInt unwindContextOrNilOrZero;
				sqInt value;
				sqInt value1;
				sqInt value2;

				VM_LABEL(0commonReturn);
				
				/* If this is a method simply return to the  sender/caller. */

				if (!((byteAt((localFP + FoxFrameFlags) + 3)) != 0)) {
					goto commonCallerReturn;
					goto l134;
				}
				closure = longAt(localFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((localFP + FoxFrameFlags) + 1)) << ShiftForWord)));

				/* Walk the closure's lexical chain to find the context or frame to return from (home). */

				home = null;
				while (closure != GIV(nilObj)) {
					home = longAt((closure + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2));
					closure = longAt((home + (BaseHeaderSize)) + (ClosureIndex << 2));
				}
				/* begin writeBackHeadFramePointers */
				VM_LABEL(0writeBackHeadFramePointers);
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());
				/* begin internalFindUnwindThroughContext: */
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin findUnwindThroughContext: */
				VM_LABEL(0findUnwindThroughContext);
				ctxtOrNilOrZero = findMethodWithPrimitiveFromFPUpToContext(198, GIV(framePointer), home);
				if (ctxtOrNilOrZero == 0) {
					theMethod = longAt((home + (BaseHeaderSize)) + (MethodIndex << 2));
					if ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? ((longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
				? ((firstBytecode = (theMethod + ((LiteralStart + ((((usqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
					(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
				: 0)
		: ((primBits = ((usqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#else /* MULTIPLEBYTECODESETS */
	((primBits = ((usqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#endif /* MULTIPLEBYTECODESETS */
	) == 198) {
						unwindContextOrNilOrZero = home;
						goto l139;
					}
				}
				unwindContextOrNilOrZero = ctxtOrNilOrZero;
			l139:	/* end findUnwindThroughContext: */;
				if (unwindContextOrNilOrZero == GIV(nilObj)) {

					/* error: can't find home on chain; cannot return */

					/* begin internalCannotReturn: */
					VM_LABEL(0internalCannotReturn);
					/* begin ensureFrameIsMarried:SP: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l136;
					}
					ourContext = marryFrameSP(localFP, localSP);
				l136:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorCannotReturn << 2));
					GIV(argumentCount) = 1;
					goto normalSend;
					goto l134;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					VM_LABEL(0internalAboutToReturnthrough);
					/* begin ensureFrameIsMarried:SP: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l137;
					}
					ourContext1 = marryFrameSP(localFP, localSP);
				l137:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext1);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorAboutToReturn << 2));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l134;
				}
				contextToReturnTo = null;
				if (((longAt((home + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));
					/* begin frameOfMarriedContext: */
					value = longAt((home + (BaseHeaderSize)) + (SenderIndex << 2));
					/* begin withoutSmallIntegerTags: */
					assert((value & 1));
					theFP = pointerForOop(value - 1);
					if ((longAt(theFP + FoxSavedFP)) == 0) {
						contextToReturnTo = longAt(theFP + FoxCallerContext);
					}
					else {
						/* begin frameCallerFP: */
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					contextToReturnTo = longAt((home + (BaseHeaderSize)) + (SenderIndex << 2));
					if ((((contextToReturnTo & 3) == 0)
 && (((longAt(contextToReturnTo)) & 0x3FFFFF) == ClassMethodContextCompactIndex))
					 && (((longAt((contextToReturnTo + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
						/* begin frameOfMarriedContext: */
						value1 = longAt((contextToReturnTo + (BaseHeaderSize)) + (SenderIndex << 2));
						/* begin withoutSmallIntegerTags: */
						assert((value1 & 1));
						frameToReturnTo = pointerForOop(value1 - 1);
						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					/* begin establishFrameForContextToReturnTo: */
					VM_LABEL(0establishFrameForContextToReturnTo);
					if (!(((contextToReturnTo & 3) == 0)
						 && (((longAt(contextToReturnTo)) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
						frameToReturnTo = 0;
						goto l135;
					}
					if (((longAt((contextToReturnTo + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
						if (isWidowedContext(contextToReturnTo)) {

							/* error: home's sender is dead; cannot return */

							frameToReturnTo = 0;
							goto l135;
						}
						/* begin frameOfMarriedContext: */
						value2 = longAt((contextToReturnTo + (BaseHeaderSize)) + (SenderIndex << 2));
						/* begin withoutSmallIntegerTags: */
						assert((value2 & 1));
						frameToReturnTo = pointerForOop(value2 - 1);
						goto l135;
					}
					if (!(((longAt((contextToReturnTo + (BaseHeaderSize)) + (InstructionPointerIndex << 2))) & 1))) {
						frameToReturnTo = 0;
						goto l135;
					}
					thePage1 = makeBaseFrameFor(contextToReturnTo);
					markStackPageMostRecentlyUsed(thePage1);
					frameToReturnTo = (thePage1->baseFP);
				l135:	/* end establishFrameForContextToReturnTo: */;
					if (frameToReturnTo == 0) {

						/* error: home's sender is dead; cannot return */

						/* begin internalCannotReturn: */
						VM_LABEL(1internalCannotReturn);
						/* begin ensureFrameIsMarried:SP: */
						if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(localFP)));
							ourContext2 = longAt(localFP + FoxThisContext);
							goto l138;
						}
						ourContext2 = marryFrameSP(localFP, localSP);
					l138:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext2);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorCannotReturn << 2));
						GIV(argumentCount) = 1;
						goto normalSend;
						goto l134;
					}
				}
				assert(pageListIsWellFormed());
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				index1 = pageIndexForstackMemorybytesPerPage(frameToReturnTo, GIV(stackMemory), GIV(bytesPerPage));
				newPage = stackPageAtpages(index1, GIV(pages));
				if (newPage != GIV(stackPage)) {
					/* begin frameCallerContext: */
					theFP2 = (GIV(stackPage)->baseFP);
					currentCtx = longAt(theFP2 + FoxCallerContext);
					assert(isContext(currentCtx));
					/* begin freeStackPage: */
					freeStackPageNoAssert(GIV(stackPage));
					assert(pageListIsWellFormed());
					while (1) {
						assert(isContext(currentCtx));
						if ((((longAt((currentCtx + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
						if (((longAt((currentCtx + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
							/* begin stackPageFor: */
							/* begin stackPageAt: */
							index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
							thePage = stackPageAtpages(index, GIV(pages));
							if (theFP != ((thePage->headFP))) {

								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */

								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							/* begin frameCallerContext: */
							theFP1 = (thePage->baseFP);
							currentCtx = longAt(theFP1 + FoxCallerContext);
							/* begin freeStackPage: */
							freeStackPageNoAssert(thePage);
							assert(pageListIsWellFormed());
						}
						else {
							nextCntx = longAt((currentCtx + (BaseHeaderSize)) + (SenderIndex << 2));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx));
							/* begin storePointerUnchecked:ofObject:withValue: */
							assert(!(isForwarded(currentCtx)));
							longAtput((currentCtx + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
							/* begin storePointerUnchecked:ofObject:withValue: */
							assert(!(isForwarded(currentCtx)));
							longAtput((currentCtx + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					assert(newPage != 0);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {

					/* pop the saved IP, push the return value and continue. */

					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						/* begin frameCallerFP: */
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					/* begin frameCallerSavedIP: */
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = (frameCallerSP(callerFP)) - BytesPerWord;
				}
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				
#        if MULTIPLEBYTECODESETS
				bytecodeSetSelector = ((((sqInt) (longAt((GIV(method) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
					? 256
					: 0);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				longAtPointerput(localSP, localReturnValue);
			}
		l134:	/* end case */;
			break;
		case 121:
			/* returnTrue */
			{
				VM_LABEL(0returnTrue);
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			break;
		case 122:
			/* returnFalse */
			{
				VM_LABEL(0returnFalse);
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			break;
		case 123:
			/* returnNil */
			{
				VM_LABEL(0returnNil);
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			break;
		case 124:
			/* returnTopFromMethod */
			{
				VM_LABEL(0returnTopFromMethod);
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			break;
		case 125:
			/* returnTopFromBlock */
			{
				VM_LABEL(0returnTopFromBlock);
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				sqInt index;
				sqInt isAContext;
				sqInt ourContext;
				char *theFP;
				StackPage *thePage;
				char *theSP;
				sqInt value;

				VM_LABEL(0commonCallerReturn);
				/* begin frameCallerFP: */
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {

					/* baseFrame */

					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					VM_LABEL(0baseFrameReturn);
					contextToReturnTo = longAt(localFP + FoxCallerContext);
					isAContext = ((contextToReturnTo & 3) == 0)
					 && (((longAt(contextToReturnTo)) & 0x3FFFFF) == ClassMethodContextCompactIndex);
					if (isAContext
					 && ((((longAt((contextToReturnTo + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
					 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						value = longAt((contextToReturnTo + (BaseHeaderSize)) + (SenderIndex << 2));
						/* begin withoutSmallIntegerTags: */
						assert((value & 1));
						theFP = pointerForOop(value - 1);
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index, GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
							freeStackPageNoAssert(GIV(stackPage));
						}
						else {

							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */

							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l141;
							}
							while (((callerFP = frameCallerFP(fp))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l141;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
						l141:	/* end findFrameAbove:inPage: */;
							moveFramesInthroughtoPage(thePage, frameAbove, GIV(stackPage));
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(isAContext
							 && (((longAt((contextToReturnTo + (BaseHeaderSize)) + (InstructionPointerIndex << 2))) & 1)))) {
							/* begin internalCannotReturn: */
							VM_LABEL(2internalCannotReturn);
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(localFP)));
								ourContext = longAt(localFP + FoxThisContext);
								goto l142;
							}
							ourContext = marryFrameSP(localFP, localSP);
						l142:	/* end ensureFrameIsMarried:SP: */;
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), ourContext);
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorCannotReturn << 2));
							GIV(argumentCount) = 1;
							goto normalSend;
							/* return self */
							goto l143;
						}
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
						freeStackPageNoAssert(GIV(stackPage));
					}
					/* begin setStackPageAndLimit: */
					assert(thePage != 0);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					/* begin setMethod: */
					GIV(method) = longAt(localFP + FoxMethod);
					assert(isOopCompiledMethod(GIV(method)));
					
#          if MULTIPLEBYTECODESETS
					bytecodeSetSelector = ((((sqInt) (longAt((GIV(method) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
						? 256
						: 0);

#          endif /* MULTIPLEBYTECODESETS */

					localIP = pointerForOop(longAtPointer(localSP));
					longAtPointerput(localSP, localReturnValue);
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					/* return self */
				l143:	/* end baseFrameReturn */;
					goto l140;
				}
				/* begin frameCallerSavedIP: */
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((localFP + FoxFrameFlags) + 1)) << ShiftForWord));
				localFP = callersFPOrNull;
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				
#        if MULTIPLEBYTECODESETS
				bytecodeSetSelector = ((((sqInt) (longAt((GIV(method) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
					? 256
					: 0);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				longAtPointerput(localSP, localReturnValue);
			}
		l140:	/* end case */;
			break;
		case 126:
		case 127:
			/* unknownBytecode */
			{
				VM_LABEL(0unknownBytecode);
				/* goto respondToUnknownBytecode */
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				sqInt ourContext;

				VM_LABEL(0respondToUnknownBytecode);
				GIV(messageSelector) = (SelectorUnknownBytecode < (numSlotsOf(GIV(specialObjectsOop)))
					? longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorUnknownBytecode << 2))
					: 0);
				if ((GIV(messageSelector) == null)
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l144;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l144:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 128:
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt object;
				sqInt object1;
				sqInt object2;
				sqInt objOop;
				sqInt referent;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(0extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + (variableIndex << 2)));
					goto l1;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					/* begin internalPush: */
					object1 = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object1);
					goto l1;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + (BaseHeaderSize)) + ((variableIndex + LiteralStart) << 2));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l1;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					VM_LABEL(32pushLiteralVariable);
					
					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */

					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + (BaseHeaderSize)) + ((variableIndex + LiteralStart) << 2));
					if (((longAt(litVar)) & 0x3FFFFF) == 8) {
						/* begin followForwarded: */
						assert(isForwarded(litVar));
						referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
						while (((referent & 3) == 0)
						 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
							referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
						}
						litVar = referent;
					}
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar + (BaseHeaderSize)) + (ValueIndex << 2)));

					goto l1;
				}
			}
		l1:	/* end case */;
			break;
		case 129:
			/* extendedStoreBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt referent;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(0extendedStoreBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(1storePointerofObjectwithValue);
					assert(!(isForwarded(longAt(localFP + FoxReceiver))));
					if (isOldObject(longAt(localFP + FoxReceiver))) {

						/* most stores into young objects */

						if ((((longAtPointer(localSP)) & 3) == 0)
						 && ((((usqInt) (longAtPointer(localSP)))) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(longAt(localFP + FoxReceiver)))) >> 29) & 1) != 0)) {
								remember(longAt(localFP + FoxReceiver));
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(longAt(localFP + FoxReceiver), (longAt(longAt(localFP + FoxReceiver))) | (1 << 29));
							}
						}
					}
					longAtput(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + (variableIndex << 2), longAtPointer(localSP));
					goto l2;
				}
				if (variableType == 1) {
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					goto l2;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + (BaseHeaderSize)) + ((variableIndex + LiteralStart) << 2));
					if (((longAt(litVar)) & 0x3FFFFF) == 8) {
						/* begin followForwarded: */
						assert(isForwarded(litVar));
						referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
						while (((referent & 3) == 0)
						 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
							referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
						}
						litVar = referent;
					}
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(2storePointerofObjectwithValue);
					assert(!(isForwarded(litVar)));
					if (isOldObject(litVar)) {

						/* most stores into young objects */

						if ((((longAtPointer(localSP)) & 3) == 0)
						 && ((((usqInt) (longAtPointer(localSP)))) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> 29) & 1) != 0)) {
								remember(litVar);
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(litVar, (longAt(litVar)) | (1 << 29));
							}
						}
					}
					longAtput((litVar + (BaseHeaderSize)) + (ValueIndex << 2), longAtPointer(localSP));
					goto l2;
				}
				error("illegal store");
			}
		l2:	/* end case */;
			break;
		case 130:
			/* extendedStoreAndPopBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt referent;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(0extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecode */
				VM_LABEL(1extendedStoreBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(3storePointerofObjectwithValue);
					assert(!(isForwarded(longAt(localFP + FoxReceiver))));
					if (isOldObject(longAt(localFP + FoxReceiver))) {

						/* most stores into young objects */

						if ((((longAtPointer(localSP)) & 3) == 0)
						 && ((((usqInt) (longAtPointer(localSP)))) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(longAt(localFP + FoxReceiver)))) >> 29) & 1) != 0)) {
								remember(longAt(localFP + FoxReceiver));
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(longAt(localFP + FoxReceiver), (longAt(longAt(localFP + FoxReceiver))) | (1 << 29));
							}
						}
					}
					longAtput(((longAt(localFP + FoxReceiver)) + (BaseHeaderSize)) + (variableIndex << 2), longAtPointer(localSP));
					goto l3;
				}
				if (variableType == 1) {
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					goto l3;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + (BaseHeaderSize)) + ((variableIndex + LiteralStart) << 2));
					if (((longAt(litVar)) & 0x3FFFFF) == 8) {
						/* begin followForwarded: */
						assert(isForwarded(litVar));
						referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
						while (((referent & 3) == 0)
						 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
							referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
						}
						litVar = referent;
					}
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(4storePointerofObjectwithValue);
					assert(!(isForwarded(litVar)));
					if (isOldObject(litVar)) {

						/* most stores into young objects */

						if ((((longAtPointer(localSP)) & 3) == 0)
						 && ((((usqInt) (longAtPointer(localSP)))) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> 29) & 1) != 0)) {
								remember(litVar);
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(litVar, (longAt(litVar)) | (1 << 29));
							}
						}
					}
					longAtput((litVar + (BaseHeaderSize)) + (ValueIndex << 2), longAtPointer(localSP));
					goto l3;
				}
				error("illegal store");
			l3:	/* end extendedStoreBytecode */;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 131:
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(0singleExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + (BaseHeaderSize)) + (((descriptor & 0x1F) + LiteralStart) << 2));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
			
		normalSend:
			/* normalSend */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(0normalSend);
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				/* begin fetchClassTagOf: */
				if (((tagBits = rcvr & 3)) != 0) {
					lkupClassTag = ((tagBits & 1) != 0
						? 1
						: tagBits);
					goto l145;
				}
				lkupClassTag = (longAt(rcvr)) & 0x3FFFFF;
			l145:	/* end fetchClassTagOf: */;
				assert(lkupClassTag != (nilObject()));
				/* goto commonSend */
			}
			
		commonSend:
			/* commonSend */
			{
				sqInt classTablePage;
				sqInt errorCode;
				sqInt hash;
				sqInt hash1;
				sqInt i;
				sqInt localPrimIndex;
				sqInt methodHeader;
				sqInt nArgs;
				sqInt numTemps;
				sqInt object;
				sqInt ok;
				sqInt probe;
				sqInt probe1;
				sqInt rcvr;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt succeeded;
				sqInt table;

				VM_LABEL(0commonSend);
				/* begin sendBreakpoint:receiver: */
				sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
				
				/* begin internalFindNewMethod */
				VM_LABEL(0internalFindNewMethod);
				/* begin lookupInMethodCacheSel:classTag: */

				/* shift drops two low-order zeros from addresses */

				hash1 = GIV(messageSelector) ^ lkupClassTag;

				/* first probe */

				probe1 = hash1 & MethodCacheMask;
				if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
					GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
					ok = 1;
					goto l150;
				}

				/* second probe */

				probe1 = (((usqInt) hash1) >> 1) & MethodCacheMask;
				if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
					GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
					ok = 1;
					goto l150;
				}
				probe1 = (((usqInt) hash1) >> 2) & MethodCacheMask;
				if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == lkupClassTag)) {
					GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
					ok = 1;
					goto l150;
				}
				ok = 0;
			l150:	/* end lookupInMethodCacheSel:classTag: */;
				if (!ok) {

					/* entry was not found in the cache; look it up the hard way */

					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & 3) == 0)
 && (((longAt(GIV(messageSelector))) & 0x3FFFFF) == 8))
					 || (lkupClassTag == 8)) {
						if (((GIV(messageSelector) & 3) == 0)
						 && (((longAt(GIV(messageSelector))) & 0x3FFFFF) == 8)) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
						}
						if (lkupClassTag == 8) {
							lkupClassTag = handleForwardedSendFaultForTag(lkupClassTag);
						}
						/* begin lookupInMethodCacheSel:classTag: */

						/* shift drops two low-order zeros from addresses */

						hash = GIV(messageSelector) ^ lkupClassTag;

						/* first probe */

						probe = hash & MethodCacheMask;
						if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
						 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
							GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
							primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
							ok = 1;
							goto l149;
						}

						/* second probe */

						probe = (((usqInt) hash) >> 1) & MethodCacheMask;
						if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
						 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
							GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
							primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
							ok = 1;
							goto l149;
						}
						probe = (((usqInt) hash) >> 2) & MethodCacheMask;
						if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
						 && ((GIV(methodCache)[probe + MethodCacheClass]) == lkupClassTag)) {
							GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
							primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
							ok = 1;
							goto l149;
						}
						ok = 0;
					l149:	/* end lookupInMethodCacheSel:classTag: */;
						if (ok) {
							null;
							goto l152;
						}
					}
					/* begin classAtIndex: */
					VM_LABEL(0classAtIndex);
					assert((lkupClassTag <= (tagMask()))
					 || (lkupClassTag >= (arrayClassIndexPun())));
					classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) lkupClassTag) >> 10) << 2));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l151;
					}
					GIV(lkupClass) = longAt((classTablePage + (BaseHeaderSize)) + ((lkupClassTag & ((1 << 10) - 1)) << 2));
				l151:	/* end classAtIndex: */;
					lookupMethodInClass(GIV(lkupClass));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToCache(GIV(lkupClass));
				}
			l152:	/* end internalFindNewMethod */;
				/* begin internalExecuteNewMethod */
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						VM_LABEL(0internalQuickPrimitiveResponse);
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 0xFF)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + (BaseHeaderSize)) + ((localPrimIndex - 264) << 2)));
							1;
							goto l147;
						}
						if (localPrimIndex == 256) {
							1;
							goto l147;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							1;
							goto l147;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							1;
							goto l147;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							1;
							goto l147;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 1) | 1));
						1;
					l147:	/* end internalQuickPrimitiveResponse */;
						goto l146;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					nArgs = GIV(argumentCount);
					savedStackPointer = GIV(stackPointer);
					savedFramePointer = GIV(framePointer);

					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					if (FailImbalancedPrimitives
					 && ((!GIV(primFailCode))
					 && (GIV(framePointer) == savedFramePointer))) {

						/* Don't fail if primitive has done something radical, e.g. perform: */

						if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
							flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
							GIV(stackPointer) = savedStackPointer;
							failUnbalancedPrimitive();
						}
					}
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						browserPluginReturnIfNeeded();
						null;
						goto l146;
					}
				}
				/* begin internalActivateNewMethod */
				VM_LABEL(0internalActivateNewMethod);
				methodHeader = longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2));
				numTemps = (((usqInt) methodHeader) >> 19) & 0x3F;

				/* could new rcvr be set at point of send? */

				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localIP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localFP);
				localFP = localSP;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
				/* begin setMethod:methodHeader: */
				GIV(method) = GIV(newMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert((headerOf(GIV(method))) == methodHeader);
				
#        if MULTIPLEBYTECODESETS
				bytecodeSetSelector = ((((sqInt) methodHeader)) < 0
					? 256
					: 0);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				object = ((1 + (((((usqInt) methodHeader) >> 25) & 15) << 8)) + (0)) + (0);
				longAtPointerput((localSP -= BytesPerOop), object);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), rcvr);
				for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				}
				localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize)) - 1);
				if (
#        if MULTIPLEBYTECODESETS
					((((sqInt) methodHeader)) < 0
										? methodHeader & (65536 << SmallIntegerShift)
										: (methodHeader & 536871934) != 0)
#        else /* MULTIPLEBYTECODESETS */
					(methodHeader & 536871934) != 0
#        endif /* MULTIPLEBYTECODESETS */
					) {

					/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
					   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

					localIP += 
#          if MULTIPLEBYTECODESETS
						((((sqInt) methodHeader)) < 0
												? 3
												: 0)
#          else /* MULTIPLEBYTECODESETS */
						0
#          endif /* MULTIPLEBYTECODESETS */
						;
					if (GIV(primFailCode) != 0) {
						if ((byteAt(localIP + 1)) == (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? 234
		: 129)
#else /* MULTIPLEBYTECODESETS */
	129
#endif /* MULTIPLEBYTECODESETS */
	)) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
								if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
									errorCode = longAt((table + (BaseHeaderSize)) + ((GIV(primFailCode) - 1) << 2));
									goto l148;
								}
							}
							errorCode = ((GIV(primFailCode) << 1) | 1);
						l148:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
				}
				assert((frameNumArgs(localFP)) == GIV(argumentCount));
				assert(!(frameIsBlockActivation(localFP)));
				assert(!(frameHasContext(localFP)));
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
			l146:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 132:
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				char *callerFP;
				char *callerFP1;
				char *fp;
				sqInt index;
				sqInt index1;
				sqInt litVar;
				sqInt litVar1;
				sqInt object;
				sqInt object1;
				sqInt object2;
				sqInt objOop;
				sqInt onCurrentPage;
				sqInt opType;
				sqInt rcvr;
				sqInt rcvr1;
				sqInt referent;
				sqInt referent1;
				char *spouseFP;
				char *theFP;
				char *theFPAbove;
				sqInt theIP;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;
				sqInt top;
				sqInt value;
				sqInt value1;

				VM_LABEL(0doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + (BaseHeaderSize)) + ((byte3 + LiteralStart) << 2));
					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l4;
				}
				if (opType == 1) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + (BaseHeaderSize)) + ((byte3 + LiteralStart) << 2));
					GIV(argumentCount) = byte2 & 0x1F;
					goto commonSupersend;
					goto l4;
				}
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				if (opType == 2) {
					/* begin pushMaybeContextReceiverVariable: */
					rcvr1 = longAt(localFP + FoxReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((longAt(rcvr1)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
						/* begin internalPush: */
						/* begin instVar:ofContext: */
						VM_LABEL(0instVarofContext);
						assert(byte3 < MethodIndex);
						assert(isContext(rcvr1));
						if (!(((longAt((rcvr1 + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))) {
							object1 = longAt((rcvr1 + (BaseHeaderSize)) + (byte3 << 2));
							goto l6;
						}
						/* begin writeBackHeadFramePointers */
						VM_LABEL(1writeBackHeadFramePointers);
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						/* begin setHeadFP:andSP:inPage: */
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (isWidowedContext(rcvr1)) {
							object1 = longAt((rcvr1 + (BaseHeaderSize)) + (byte3 << 2));
							goto l6;
						}
						/* begin frameOfMarriedContext: */
						value = longAt((rcvr1 + (BaseHeaderSize)) + (SenderIndex << 2));
						/* begin withoutSmallIntegerTags: */
						assert((value & 1));
						spouseFP = pointerForOop(value - 1);
						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							/* begin frameCallerFP: */
							callerFP1 = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP1 == 0) {

								/* base frame, context in saved ip slot (or base of stack in Cog) */

								object1 = longAt(spouseFP + FoxCallerContext);
								goto l6;
							}
							/* begin ensureFrameIsMarried:SP: */
							/* begin frameCallerStackPointer: */
							assert(!(isBaseFrame(spouseFP)));
							theSP = (spouseFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((spouseFP + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
							if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(callerFP1)));
								object1 = longAt(callerFP1 + FoxThisContext);
								goto l6;
							}
							object1 = marryFrameSP(callerFP1, theSP);
							goto l6;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(rcvr1)));
							object1 = (((stackPointerIndexForFrame(spouseFP)) << 1) | 1);
							goto l6;
						}
						if (byte3 == InstructionPointerIndex) {
							if (spouseFP == localFP) {
								theIP = oopForPointer(localIP);
							}
							else {
								/* begin stackPageFor: */
								/* begin stackPageAt: */
								index = pageIndexForstackMemorybytesPerPage(spouseFP, GIV(stackMemory), GIV(bytesPerPage));
								thePage = stackPageAtpages(index, GIV(pages));
								/* begin findFrameAbove:inPage: */
								fp = (thePage->headFP);
								if (fp == spouseFP) {
									theFPAbove = 0;
									goto l5;
								}
								while (((callerFP = frameCallerFP(fp))) != 0) {
									if (callerFP == spouseFP) {
										theFPAbove = fp;
										goto l5;
									}
									fp = callerFP;
								}
								error("did not find theFP in stack page");
								theFPAbove = 0;
							l5:	/* end findFrameAbove:inPage: */;
								theIP = (theFPAbove == 0
									? longAt((thePage->headSP))
									: oopForPointer(frameCallerSavedIP(theFPAbove)));
							}
							/* begin contextInstructionPointer:frame: */
							assert(validInstructionPointerinFrame(theIP, spouseFP));
							object1 = (((((theIP - (longAt(spouseFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
							goto l6;
						}
						error("bad index");
						object1 = 0;
					l6:	/* end instVar:ofContext: */;
						longAtPointerput((localSP -= BytesPerOop), object1);
					}
					else {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), longAt((rcvr1 + (BaseHeaderSize)) + (byte3 << 2)));
					}
					goto l4;
				}
				if (opType == 3) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + (BaseHeaderSize)) + ((byte3 + LiteralStart) << 2));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l4;
				}
				if (opType == 4) {
					/* begin pushLiteralVariable: */
					VM_LABEL(33pushLiteralVariable);
					
					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */

					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar1 = longAt((GIV(method) + (BaseHeaderSize)) + ((byte3 + LiteralStart) << 2));
					if (((longAt(litVar1)) & 0x3FFFFF) == 8) {
						/* begin followForwarded: */
						assert(isForwarded(litVar1));
						referent1 = longAt((litVar1 + (BaseHeaderSize)) + (0 << 2));
						while (((referent1 & 3) == 0)
						 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
							referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
						}
						litVar1 = referent1;
					}
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar1 + (BaseHeaderSize)) + (ValueIndex << 2)));

					goto l4;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + (BaseHeaderSize)) + ((byte3 + LiteralStart) << 2));
					if (((longAt(litVar)) & 0x3FFFFF) == 8) {
						/* begin followForwarded: */
						assert(isForwarded(litVar));
						referent = longAt((litVar + (BaseHeaderSize)) + (0 << 2));
						while (((referent & 3) == 0)
						 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
							referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
						}
						litVar = referent;
					}
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(5storePointerofObjectwithValue);
					assert(!(isForwarded(litVar)));
					if (isOldObject(litVar)) {

						/* most stores into young objects */

						if (((top & 3) == 0)
						 && ((((usqInt) top)) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> 29) & 1) != 0)) {
								remember(litVar);
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(litVar, (longAt(litVar)) | (1 << 29));
							}
						}
					}
					longAtput((litVar + (BaseHeaderSize)) + (ValueIndex << 2), top);
					goto l4;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				/* begin storeMaybeContextReceiverVariable:withValue: */
				rcvr = longAt(localFP + FoxReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((longAt(rcvr)) & 0x3FFFFF) == ClassMethodContextCompactIndex)
				 && (((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)))) {
					/* begin instVar:ofContext:put: */
					VM_LABEL(0instVarofContextput);
					assert(isMarriedOrWidowedContext(rcvr));
					/* begin writeBackHeadFramePointers */
					VM_LABEL(2writeBackHeadFramePointers);
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
						 && (!(isWidowedContext(rcvr))))) {
						/* begin storePointer:ofObject:withValue: */
						VM_LABEL(6storePointerofObjectwithValue);
						assert(!(isForwarded(rcvr)));
						if (isOldObject(rcvr)) {

							/* most stores into young objects */

							if (((top & 3) == 0)
							 && ((((usqInt) top)) < (((usqInt) GIV(newSpaceLimit))))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
									remember(rcvr);
									/* begin setIsRememberedOf:to: */
									flag("endianness");
									longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
								}
							}
						}
						longAtput((rcvr + (BaseHeaderSize)) + (byte3 << 2), top);
						if (byte3 == StackPointerIndex) {
							/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
						}
						null;
						goto l7;
					}
					/* begin frameOfMarriedContext: */
					value1 = longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2));
					/* begin withoutSmallIntegerTags: */
					assert((value1 & 1));
					theFP = pointerForOop(value1 - 1);
					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage1 = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage1 == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						null;
						goto l7;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, rcvr);
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(7storePointerofObjectwithValue);
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */

						if (((top & 3) == 0)
						 && ((((usqInt) top)) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
								remember(rcvr);
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
							}
						}
					}
					longAtput((rcvr + (BaseHeaderSize)) + (byte3 << 2), top);
					if (byte3 == StackPointerIndex) {
						/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l7:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(8storePointerofObjectwithValue);
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */

						if (((top & 3) == 0)
						 && ((((usqInt) top)) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
								remember(rcvr);
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
							}
						}
					}
					longAtput((rcvr + (BaseHeaderSize)) + (byte3 << 2), top);
				}
			}
		l4:	/* end case */;
			break;
		case 133:
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(0singleExtendedSuperBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + (BaseHeaderSize)) + (((descriptor & 0x1F) + LiteralStart) << 2));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto commonSupersend */
			}
			
		commonSupersend:
			/* superclassSend */
			{
				sqInt classPointer;
				sqInt err;
				sqInt err1;
				sqInt newHash;
				sqInt newHash1;
				sqInt superclass;

				VM_LABEL(0superclassSend);
				/* begin superclassOf: */
				classPointer = methodClassOf(GIV(method));
				superclass = longAt((classPointer + (BaseHeaderSize)) + (SuperclassIndex << 2));
				/* begin ensureBehaviorHash: */
				assert(addressCouldBeClassObj(superclass));
				if (((newHash = rawHashBitsOf(superclass))) == 0) {
					if (((err = enterIntoClassTable(superclass))) != 0) {
						-err;
						goto l153;
					}
					/* begin rawHashBitsOf: */
					flag("endianness");
					newHash = (longAt(superclass + 4)) & 0x3FFFFF;
					assert((classAtIndex(newHash)) == superclass);
				}
				newHash;
			l153:	/* end ensureBehaviorHash: */;
				/* begin classTagForClass: */
				assert(addressCouldBeClassObj(superclass));
				/* begin ensureBehaviorHash: */
				assert(addressCouldBeClassObj(superclass));
				if (((newHash1 = rawHashBitsOf(superclass))) == 0) {
					if (((err1 = enterIntoClassTable(superclass))) != 0) {
						lkupClassTag = -err1;
						goto l154;
					}
					/* begin rawHashBitsOf: */
					flag("endianness");
					newHash1 = (longAt(superclass + 4)) & 0x3FFFFF;
					assert((classAtIndex(newHash1)) == superclass);
				}
				lkupClassTag = newHash1;
			l154:	/* end ensureBehaviorHash: */;
				assert(lkupClassTag != (nilObject()));
				goto commonSend;
			}
			break;
		case 134:
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(0secondExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + (BaseHeaderSize)) + (((descriptor & 0x3F) + LiteralStart) << 2));
				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
			break;
		case 135:
			/* popStackBytecode */
			{
				VM_LABEL(0popStackBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 136:
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(0duplicateTopBytecode);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 137:
			/* pushActiveContextBytecode */
			{
				sqInt ourContext;

				VM_LABEL(0pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l8;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l8:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			break;
		case 138:
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				sqInt popValues;
				sqInt size;

				VM_LABEL(0pushNewArrayBytecode);
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin eeInstantiateClassIndex:format:numSlots: */
				assert((size >= 0)
				 && (ClassArrayCompactIndex != 0));
				assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
				array = allocateNewSpaceSlotsformatclassIndex(size, 2, ClassArrayCompactIndex);
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */

						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + (BaseHeaderSize)) + (i << 2), longAtPointer(localSP + (((size - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + (BaseHeaderSize)) + (i << 2), GIV(nilObj));
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 139:
			/* unknownBytecode */
			{
				VM_LABEL(1unknownBytecode);
				goto respondToUnknownBytecode;
			}
			break;
		case 140:
			/* pushRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(0pushRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin pushRemoteTemp:inVectorAt: */
				VM_LABEL(0pushRemoteTempinVectorAt);
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((tempVector + (BaseHeaderSize)) + (remoteTempIndex << 2)));
			}
			break;
		case 141:
			/* storeRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(0storeRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				VM_LABEL(9storePointerofObjectwithValue);
				assert(!(isForwarded(tempVector)));
				if (isOldObject(tempVector)) {

					/* most stores into young objects */

					if ((((longAtPointer(localSP)) & 3) == 0)
					 && ((((usqInt) (longAtPointer(localSP)))) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(tempVector))) >> 29) & 1) != 0)) {
							remember(tempVector);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(tempVector, (longAt(tempVector)) | (1 << 29));
						}
					}
				}
				longAtput((tempVector + (BaseHeaderSize)) + (remoteTempIndex << 2), longAtPointer(localSP));
			}
			break;
		case 142:
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(0storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin storeRemoteTemp:inVectorAt: */
				VM_LABEL(0storeRemoteTempinVectorAt);
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				VM_LABEL(10storePointerofObjectwithValue);
				assert(!(isForwarded(tempVector)));
				if (isOldObject(tempVector)) {

					/* most stores into young objects */

					if ((((longAtPointer(localSP)) & 3) == 0)
					 && ((((usqInt) (longAtPointer(localSP)))) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(tempVector))) >> 29) & 1) != 0)) {
							remember(tempVector);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(tempVector, (longAt(tempVector)) | (1 << 29));
						}
					}
				}
				longAtput((tempVector + (BaseHeaderSize)) + (remoteTempIndex << 2), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 143:
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt classIndex;
				sqInt context;
				sqInt err;
				sqInt i;
				sqInt initialIP;
				sqInt newClosure;
				sqInt newClosure1;
				sqInt newHash;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				sqInt numCopied;

				VM_LABEL(0pushClosureCopyCopiedValuesBytecode);
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */

				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = (byteAtPointer(++localIP)) << 8;
				blockSize += byteAtPointer(++localIP);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				VM_LABEL(0pushClosureNumArgscopiedValuesblockSize);
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l9;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
			l9:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				VM_LABEL(0closureInnumArgsinstructionPointernumCopiedValues);
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				/* begin eeInstantiateClassIndex:format:numSlots: */
				assert(((ClosureFirstCopiedValueIndex + numCopied) >= 0)
				 && (ClassBlockClosureCompactIndex != 0));
				assert((3) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex))));
				newClosure1 = allocateNewSpaceSlotsformatclassIndex(ClosureFirstCopiedValueIndex + numCopied, 3, ClassBlockClosureCompactIndex);

				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + (BaseHeaderSize)) + (ClosureStartPCIndex << 2), ((initialIP << 1) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + (BaseHeaderSize)) + (ClosureNumArgsIndex << 2), ((numArgs << 1) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */

						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(newClosure)));
						longAtput((newClosure + (BaseHeaderSize)) + ((i + ClosureFirstCopiedValueIndex) << 2), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 144:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(0shortUnconditionalJump);
				/* begin jump: */
				offset = 1 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 145:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(1shortUnconditionalJump);
				/* begin jump: */
				offset = 2 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 146:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(2shortUnconditionalJump);
				/* begin jump: */
				offset = 3 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 147:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(3shortUnconditionalJump);
				/* begin jump: */
				offset = 4 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 148:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(4shortUnconditionalJump);
				/* begin jump: */
				offset = 5 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 149:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(5shortUnconditionalJump);
				/* begin jump: */
				offset = 6 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 150:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(6shortUnconditionalJump);
				/* begin jump: */
				offset = 7 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 151:
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(7shortUnconditionalJump);
				/* begin jump: */
				offset = 8 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 152:
		case 153:
		case 154:
		case 155:
		case 156:
		case 157:
		case 158:
		case 159:
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(0shortConditionalJumpFalse);
				/* begin jumplfFalseBy: */
				VM_LABEL(0jumplfFalseBy);
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);

#          endif /* MULTIPLEBYTECODESETS */

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorMustBeBoolean << 2));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l11;
					}
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l11:	/* end jumplfFalseBy: */;
			}
			break;
		case 160:
		case 161:
		case 162:
		case 163:
		case 164:
		case 165:
		case 166:
		case 167:
			/* longUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(0longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 168:
		case 169:
		case 170:
		case 171:
			/* longJumpIfTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(0longJumpIfTrue);
				/* begin jumplfTrueBy: */
				VM_LABEL(0jumplfTrueBy);
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);

#          endif /* MULTIPLEBYTECODESETS */

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorMustBeBoolean << 2));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l12;
					}
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l12:	/* end jumplfTrueBy: */;
			}
			break;
		case 172:
		case 173:
		case 174:
		case 175:
			/* longJumpIfFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(0longJumpIfFalse);
				/* begin jumplfFalseBy: */
				VM_LABEL(1jumplfFalseBy);
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);

#          endif /* MULTIPLEBYTECODESETS */

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorMustBeBoolean << 2));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l13;
					}
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l13:	/* end jumplfFalseBy: */;
			}
			break;
		case 176:
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(0bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((result ^ (result << 1)) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l14;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l15;
					}
					/* begin floatValueOf: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 3) != 0) {
						isFloat = 0;
						goto l17;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!(isImmediate(rcvr)));
					ccIndex = (longAt(rcvr)) & 0x3FFFFF;
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l17;

					isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
				l17:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + (BaseHeaderSize), result1);
						rcvr1 = result1;
						goto l18;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l18:	/* end floatValueOf: */;
				l15:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l16;
					}
					/* begin floatValueOf: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 3) != 0) {
						isFloat1 = 0;
						goto l19;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!(isImmediate(arg)));
					ccIndex1 = (longAt(arg)) & 0x3FFFFF;
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l19;

					isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
				l19:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + (BaseHeaderSize), result2);
						arg1 = result2;
						goto l20;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l20:	/* end floatValueOf: */;
				l16:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l14;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((0 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l14:	/* end case */;
			break;
		case 177:
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(0bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((result ^ (result << 1)) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l21;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l22;
					}
					/* begin floatValueOf: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 3) != 0) {
						isFloat = 0;
						goto l24;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!(isImmediate(rcvr)));
					ccIndex = (longAt(rcvr)) & 0x3FFFFF;
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l24;

					isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
				l24:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + (BaseHeaderSize), result1);
						rcvr1 = result1;
						goto l25;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l25:	/* end floatValueOf: */;
				l22:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l23;
					}
					/* begin floatValueOf: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 3) != 0) {
						isFloat1 = 0;
						goto l26;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!(isImmediate(arg)));
					ccIndex1 = (longAt(arg)) & 0x3FFFFF;
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l26;

					isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
				l26:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + (BaseHeaderSize), result2);
						arg1 = result2;
						goto l27;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l27:	/* end floatValueOf: */;
				l23:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l21;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((1 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l21:	/* end case */;
			break;
		case 178:
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(0bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l28;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l29;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isFloat = 0;
					goto l31;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & 0x3FFFFF;
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l31;

				isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
			l31:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + (BaseHeaderSize), result);
					rcvr1 = result;
					goto l32;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l32:	/* end floatValueOf: */;
			l29:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l30;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 3) != 0) {
					isFloat1 = 0;
					goto l33;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(arg)));
				ccIndex1 = (longAt(arg)) & 0x3FFFFF;
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l33;

				isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
			l33:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + (BaseHeaderSize), result1);
					arg1 = result1;
					goto l34;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l34:	/* end floatValueOf: */;
			l30:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l28;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((2 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l28:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(0booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {

						/* short jumpIfFalse 152 - 159 */

						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l155;
					}
					if (bytecode == 172) {

						/* long jumpIfFalse */

						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l155;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */

						offset = ((bytecode - 168) << 8) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l155;
					}
				}
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = bytecode + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = bytecode;

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
		l155:	/* end case */;
			break;
		case 179:
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(0bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l35;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l36;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isFloat = 0;
					goto l38;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & 0x3FFFFF;
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l38;

				isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
			l38:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + (BaseHeaderSize), result);
					rcvr1 = result;
					goto l39;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l39:	/* end floatValueOf: */;
			l36:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l37;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 3) != 0) {
					isFloat1 = 0;
					goto l40;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(arg)));
				ccIndex1 = (longAt(arg)) & 0x3FFFFF;
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l40;

				isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
			l40:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + (BaseHeaderSize), result1);
					arg1 = result1;
					goto l41;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l41:	/* end floatValueOf: */;
			l37:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l35;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((3 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l35:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(0booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {

					/* short jumpIfFalse */

					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l156;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */

					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l156;
				}
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = bytecode + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = bytecode;

#        endif /* MULTIPLEBYTECODESETS */

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
		l156:	/* end case */;
			break;
		case 180:
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(0bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l42;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l43;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isFloat = 0;
					goto l45;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & 0x3FFFFF;
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l45;

				isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
			l45:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + (BaseHeaderSize), result);
					rcvr1 = result;
					goto l46;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l46:	/* end floatValueOf: */;
			l43:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l44;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 3) != 0) {
					isFloat1 = 0;
					goto l47;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(arg)));
				ccIndex1 = (longAt(arg)) & 0x3FFFFF;
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l47;

				isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
			l47:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + (BaseHeaderSize), result1);
					arg1 = result1;
					goto l48;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l48:	/* end floatValueOf: */;
			l44:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l42;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((4 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l42:	/* end case */;
			break;
		case 181:
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(0bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l49;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l50;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isFloat = 0;
					goto l52;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & 0x3FFFFF;
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l52;

				isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
			l52:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + (BaseHeaderSize), result);
					rcvr1 = result;
					goto l53;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l53:	/* end floatValueOf: */;
			l50:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l51;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 3) != 0) {
					isFloat1 = 0;
					goto l54;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(arg)));
				ccIndex1 = (longAt(arg)) & 0x3FFFFF;
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l54;

				isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
			l54:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + (BaseHeaderSize), result1);
					arg1 = result1;
					goto l55;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l55:	/* end floatValueOf: */;
			l51:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l49;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((5 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l49:	/* end case */;
			break;
		case 182:
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(0bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l56;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l57;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isFloat = 0;
					goto l59;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & 0x3FFFFF;
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l59;

				isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
			l59:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + (BaseHeaderSize), result);
					rcvr1 = result;
					goto l60;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l60:	/* end floatValueOf: */;
			l57:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l58;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 3) != 0) {
					isFloat1 = 0;
					goto l61;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(arg)));
				ccIndex1 = (longAt(arg)) & 0x3FFFFF;
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l61;

				isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
			l61:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + (BaseHeaderSize), result1);
					arg1 = result1;
					goto l62;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l62:	/* end floatValueOf: */;
			l58:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l56;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((6 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l56:	/* end case */;
			break;
		case 183:
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(0bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l63;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l64;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isFloat = 0;
					goto l66;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & 0x3FFFFF;
				isFloat = ClassFloatCompactIndex == ccIndex;
				goto l66;

				isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
			l66:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + (BaseHeaderSize), result);
					rcvr1 = result;
					goto l67;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l67:	/* end floatValueOf: */;
			l64:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l65;
				}
				/* begin floatValueOf: */
				/* begin is:instanceOf:compactClassIndex: */
				if ((arg & 3) != 0) {
					isFloat1 = 0;
					goto l68;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(arg)));
				ccIndex1 = (longAt(arg)) & 0x3FFFFF;
				isFloat1 = ClassFloatCompactIndex == ccIndex1;
				goto l68;

				isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
			l68:	/* end is:instanceOf:compactClassIndex: */;
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + (BaseHeaderSize), result1);
					arg1 = result1;
					goto l69;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l69:	/* end floatValueOf: */;
			l65:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l63;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((7 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l63:	/* end case */;
			break;
		case 184:
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(0bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					result = rcvr * arg;
					if ((arg == 0)
					 || (((result / arg) == rcvr)
					 && ((result ^ (result << 1)) >= 0))) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l70;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l71;
					}
					/* begin floatValueOf: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 3) != 0) {
						isFloat = 0;
						goto l73;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!(isImmediate(rcvr)));
					ccIndex = (longAt(rcvr)) & 0x3FFFFF;
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l73;

					isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
				l73:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + (BaseHeaderSize), result1);
						rcvr1 = result1;
						goto l74;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l74:	/* end floatValueOf: */;
				l71:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l72;
					}
					/* begin floatValueOf: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 3) != 0) {
						isFloat1 = 0;
						goto l75;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!(isImmediate(arg)));
					ccIndex1 = (longAt(arg)) & 0x3FFFFF;
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l75;

					isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
				l75:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + (BaseHeaderSize), result2);
						arg1 = result2;
						goto l76;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l76:	/* end floatValueOf: */;
				l72:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l70;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((8 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l70:	/* end case */;
			break;
		case 185:
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(0bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */

						result = rcvr / arg;
						if ((result ^ (result << 1)) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
							/* begin fetchNextBytecode */
							
#              if MULTIPLEBYTECODESETS
							currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#              else /* MULTIPLEBYTECODESETS */
							currentBytecode = byteAtPointer(++localIP);

#              endif /* MULTIPLEBYTECODESETS */

							goto l77;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					VM_LABEL(0primitiveFloatDividebyArg);
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l78;
					}
					/* begin floatValueOf: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((rcvr & 3) != 0) {
						isFloat = 0;
						goto l80;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!(isImmediate(rcvr)));
					ccIndex = (longAt(rcvr)) & 0x3FFFFF;
					isFloat = ClassFloatCompactIndex == ccIndex;
					goto l80;

					isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
				l80:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + (BaseHeaderSize), result1);
						rcvr1 = result1;
						goto l81;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l81:	/* end floatValueOf: */;
				l78:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l79;
					}
					/* begin floatValueOf: */
					/* begin is:instanceOf:compactClassIndex: */
					if ((arg & 3) != 0) {
						isFloat1 = 0;
						goto l82;
					}
					/* begin isClassOfNonImm:equalTo:compactClassIndex: */
					assert(!(isImmediate(arg)));
					ccIndex1 = (longAt(arg)) & 0x3FFFFF;
					isFloat1 = ClassFloatCompactIndex == ccIndex1;
					goto l82;

					isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
				l82:	/* end is:instanceOf:compactClassIndex: */;
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + (BaseHeaderSize), result2);
						arg1 = result2;
						goto l83;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l83:	/* end floatValueOf: */;
				l79:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */

						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l77;
					}
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((9 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l77:	/* end case */;
			break;
		case 186:
			/* bytecodePrimMod */
			{
				sqInt mod;

				VM_LABEL(0bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((mod << 1) | 1));
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l84;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((10 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l84:	/* end case */;
			break;
		case 187:
			/* bytecodePrimMakePoint */
			{
				sqInt argument;
				sqInt classIndex;
				sqInt classIndex1;
				sqInt classIndex2;
				sqInt err;
				sqInt err1;
				sqInt err2;
				sqInt newHash;
				sqInt newHash1;
				sqInt newHash2;
				sqInt pointResult;
				sqInt pointResult1;
				sqInt pointResult2;
				sqInt pt;
				sqInt rcvr;
				char *sp;

				VM_LABEL(0bytecodePrimMakePoint);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveMakePoint */
				VM_LABEL(0primitiveMakePoint);
				argument = longAt(GIV(stackPointer));
				rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				if ((rcvr & 1)) {
					if ((argument & 1)) {
						/* begin makePointwithxValue:yValue: */
						VM_LABEL(0makePointwithxValueyValue);
						/* begin eeInstantiateSmallClass:numSlots: */
						VM_LABEL(0eeInstantiateSmallClassnumSlots);
						/* begin ensureBehaviorHash: */
						assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
						if (((newHash = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
							if (((err = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
								classIndex = -err;
								goto l86;
							}
							/* begin rawHashBitsOf: */
							flag("endianness");
							newHash = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
							assert((classAtIndex(newHash)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
						}
						classIndex = newHash;
					l86:	/* end ensureBehaviorHash: */;
						/* begin eeInstantiateClassIndex:format:numSlots: */
						VM_LABEL(0eeInstantiateClassIndexformatnumSlots);
						assert(((YIndex + 1) >= 0)
						 && (classIndex != 0));
						assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex))));
						pointResult = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex);
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(pointResult)));
						longAtput((pointResult + (BaseHeaderSize)) + (XIndex << 2), ((((rcvr >> 1)) << 1) | 1));
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(pointResult)));
						longAtput((pointResult + (BaseHeaderSize)) + (YIndex << 2), ((((argument >> 1)) << 1) | 1));
						pt = pointResult;
					}
					else {
						/* begin makePointwithxValue:yValue: */
						VM_LABEL(1makePointwithxValueyValue);
						/* begin eeInstantiateSmallClass:numSlots: */
						VM_LABEL(1eeInstantiateSmallClassnumSlots);
						/* begin ensureBehaviorHash: */
						assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
						if (((newHash1 = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
							if (((err1 = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
								classIndex1 = -err1;
								goto l87;
							}
							/* begin rawHashBitsOf: */
							flag("endianness");
							newHash1 = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
							assert((classAtIndex(newHash1)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
						}
						classIndex1 = newHash1;
					l87:	/* end ensureBehaviorHash: */;
						/* begin eeInstantiateClassIndex:format:numSlots: */
						VM_LABEL(1eeInstantiateClassIndexformatnumSlots);
						assert(((YIndex + 1) >= 0)
						 && (classIndex1 != 0));
						assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex1))));
						pointResult1 = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex1);
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(pointResult1)));
						longAtput((pointResult1 + (BaseHeaderSize)) + (XIndex << 2), ((((rcvr >> 1)) << 1) | 1));
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(pointResult1)));
						longAtput((pointResult1 + (BaseHeaderSize)) + (YIndex << 2), ((0 << 1) | 1));
						pt = pointResult1;
						/* begin storePointer:ofObject:withValue: */
						VM_LABEL(11storePointerofObjectwithValue);
						assert(!(isForwarded(pt)));
						if (isOldObject(pt)) {

							/* most stores into young objects */

							if ((((longAt(GIV(stackPointer) + (0 * BytesPerWord))) & 3) == 0)
							 && ((((usqInt) (longAt(GIV(stackPointer) + (0 * BytesPerWord))))) < (((usqInt) GIV(newSpaceLimit))))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(pt))) >> 29) & 1) != 0)) {
									remember(pt);
									/* begin setIsRememberedOf:to: */
									flag("endianness");
									longAtput(pt, (longAt(pt)) | (1 << 29));
								}
							}
						}
						longAtput((pt + (BaseHeaderSize)) + (1 << 2), longAt(GIV(stackPointer) + (0 * BytesPerWord)));
					}
				}
				else {
					if (!(((rcvr & 3) == 0)
						 && (ClassFloatCompactIndex == ((longAt(rcvr)) & 0x3FFFFF)))) {
						/* begin success: */
						
						/* Don't overwrite an error code that has already been set. */

						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}

						null;
						goto l89;
					}
					/* begin makePointwithxValue:yValue: */
					VM_LABEL(2makePointwithxValueyValue);
					/* begin eeInstantiateSmallClass:numSlots: */
					VM_LABEL(2eeInstantiateSmallClassnumSlots);
					/* begin ensureBehaviorHash: */
					assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
					if (((newHash2 = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
						if (((err2 = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
							classIndex2 = -err2;
							goto l88;
						}
						/* begin rawHashBitsOf: */
						flag("endianness");
						newHash2 = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
						assert((classAtIndex(newHash2)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
					}
					classIndex2 = newHash2;
				l88:	/* end ensureBehaviorHash: */;
					/* begin eeInstantiateClassIndex:format:numSlots: */
					VM_LABEL(2eeInstantiateClassIndexformatnumSlots);
					assert(((YIndex + 1) >= 0)
					 && (classIndex2 != 0));
					assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex2))));
					pointResult2 = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex2);
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(pointResult2)));
					longAtput((pointResult2 + (BaseHeaderSize)) + (XIndex << 2), ((0 << 1) | 1));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(pointResult2)));
					longAtput((pointResult2 + (BaseHeaderSize)) + (YIndex << 2), ((0 << 1) | 1));
					pt = pointResult2;
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(12storePointerofObjectwithValue);
					assert(!(isForwarded(pt)));
					if (isOldObject(pt)) {

						/* most stores into young objects */

						if ((((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 3) == 0)
						 && ((((usqInt) (longAt(GIV(stackPointer) + (1 * BytesPerWord))))) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(pt))) >> 29) & 1) != 0)) {
								remember(pt);
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(pt, (longAt(pt)) | (1 << 29));
							}
						}
					}
					longAtput((pt + (BaseHeaderSize)) + (0 << 2), longAt(GIV(stackPointer) + (1 * BytesPerWord)));
					/* begin storePointer:ofObject:withValue: */
					VM_LABEL(13storePointerofObjectwithValue);
					assert(!(isForwarded(pt)));
					if (isOldObject(pt)) {

						/* most stores into young objects */

						if ((((longAt(GIV(stackPointer) + (0 * BytesPerWord))) & 3) == 0)
						 && ((((usqInt) (longAt(GIV(stackPointer) + (0 * BytesPerWord))))) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(pt))) >> 29) & 1) != 0)) {
								remember(pt);
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(pt, (longAt(pt)) | (1 << 29));
							}
						}
					}
					longAtput((pt + (BaseHeaderSize)) + (1 << 2), longAt(GIV(stackPointer) + (0 * BytesPerWord)));
				}
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), pt);
				GIV(stackPointer) = sp;
			l89:	/* end primitiveMakePoint */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l85;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((11 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l85:	/* end case */;
			break;
		case 188:
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerPointer;
				sqInt integerReceiver;
				sqInt object;
				sqInt shifted;
				char *sp;
				sqInt top;
				sqInt top1;
				sqInt top2;

				VM_LABEL(0bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				VM_LABEL(0primitiveBitShift);
				/* begin popInteger */
				/* begin popStack */
				top2 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				integerPointer = top2;
				/* begin checkedIntegerValueOf: */
				if ((integerPointer & 1)) {
					integerArgument = (integerPointer >> 1);
					goto l91;
				}
				else {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					integerArgument = 0;
					goto l91;
				}
			l91:	/* end popInteger */;
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top = top1;
				integerReceiver = positive32BitValueOf(top);
				if (!GIV(primFailCode)) {
					if (integerArgument >= 0) {

						/* Left shift -- must fail if we lose bits beyond 32 */

						/* begin success: */
						if (!(integerArgument <= 0x1F)) {

							/* Don't overwrite an error code that has already been set. */

							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
						}
						shifted = integerReceiver << integerArgument;
						/* begin success: */
						if (!((((usqInt) shifted) >> integerArgument) == integerReceiver)) {

							/* Don't overwrite an error code that has already been set. */

							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
						}
					}
					else {

						/* Right shift -- OK to lose bits */

						/* begin success: */
						if (!(integerArgument >= -31)) {

							/* Don't overwrite an error code that has already been set. */

							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
						}
						shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
					}
				}
				if (!GIV(primFailCode)) {
					/* begin push: */
					object = positive32BitIntegerFor(shifted);
					longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
					GIV(stackPointer) = sp;
				}
				else {
					/* begin unPop: */
					GIV(stackPointer) -= 2 * BytesPerWord;
				}
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l90;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((12 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l90:	/* end case */;
			break;
		case 189:
			/* bytecodePrimDiv */
			{
				sqInt quotient;

				VM_LABEL(0bytecodePrimDiv);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((quotient << 1) | 1));
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l92;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((13 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l92:	/* end case */;
			break;
		case 190:
			/* bytecodePrimBitAnd */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt object;
				char *sp;
				sqInt top;
				sqInt top1;
				sqInt top11;
				sqInt top2;

				VM_LABEL(0bytecodePrimBitAnd);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitAnd */
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top = top1;
				integerArgument = positive32BitValueOf(top);
				/* begin popPos32BitInteger */
				/* begin popStack */
				top11 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top2 = top11;
				integerReceiver = positive32BitValueOf(top2);
				if (!GIV(primFailCode)) {
					/* begin push: */
					object = positive32BitIntegerFor(integerReceiver & integerArgument);
					longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
					GIV(stackPointer) = sp;
				}
				else {
					/* begin unPop: */
					GIV(stackPointer) -= 2 * BytesPerWord;
				}
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l93;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((14 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l93:	/* end case */;
			break;
		case 191:
			/* bytecodePrimBitOr */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt object;
				char *sp;
				sqInt top;
				sqInt top1;
				sqInt top11;
				sqInt top2;

				VM_LABEL(0bytecodePrimBitOr);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitOr */
				/* begin popPos32BitInteger */
				/* begin popStack */
				top1 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top = top1;
				integerArgument = positive32BitValueOf(top);
				/* begin popPos32BitInteger */
				/* begin popStack */
				top11 = longAt(GIV(stackPointer));
				GIV(stackPointer) += BytesPerWord;
				top2 = top11;
				integerReceiver = positive32BitValueOf(top2);
				if (!GIV(primFailCode)) {
					/* begin push: */
					object = positive32BitIntegerFor(integerReceiver | integerArgument);
					longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
					GIV(stackPointer) = sp;
				}
				else {
					/* begin unPop: */
					GIV(stackPointer) -= 2 * BytesPerWord;
				}
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l94;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((15 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l94:	/* end case */;
			break;
		case 192:
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt classIndex;
				sqInt classIndex1;
				sqInt classTablePage;
				sqInt classTablePage1;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots3;
				usqInt numSlots4;
				usqInt numSlots5;
				usqInt numSlots6;
				sqInt objOop;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				sqInt result1;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;

				VM_LABEL(0bytecodePrimAt);
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & 3) == 0)
				 && ((index & 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */

					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						lkupClassTag = (longAt(rcvr)) & 0x3FFFFF;
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((16 * 2) << 2));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag))) {
							GIV(argumentCount) = 1;
							goto commonSend;
							goto l95;
						}
						if (primitiveFunctionPointer == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							VM_LABEL(0installinAtCacheatstring);
							assert(!(isContext(rcvr)));
							hdr = longLongAt(rcvr);
							fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
							if ((fmt == 3)
							 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */

								GIV(primFailCode) = PrimErrBadReceiver;
								0;
								goto l98;
							}
							/* begin lengthOf:format: */
							/* begin numSlotsOf: */
							flag("endianness");
							assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
							/* begin rawNumSlotsOf: */
							flag("endianness");
							numSlots4 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
							numSlots1 = (numSlots4 == 0xFF
								? (/* begin rawOverflowSlotsOf: */
									flag("endianness"),
									longAt(rcvr - (BaseHeaderSize)))
								: numSlots4);
							if (fmt <= 9) {
								totalLength = numSlots1;
								goto l97;
							}
							if (fmt >= 16) {

								/* bytes, including CompiledMethod */

								totalLength = (numSlots1 << 2) - (fmt & 7);
								goto l97;
							}
							if (fmt >= 12) {
								totalLength = (numSlots1 << (2 - 1)) - (fmt & 3);
								goto l97;
							}
							totalLength = (numSlots1 << (2 - 2)) - (fmt & 1);
						l97:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt > 5)
							 || (fmt == 2)) {
								fixedFields = 0;
								goto l103;
							}
							if (fmt < 2) {
								fixedFields = totalLength;
								goto l103;
							}
							/* begin fetchClassOfNonImm: */
							VM_LABEL(0fetchClassOfNonImm);
							classIndex = (longAt(rcvr)) & 0x3FFFFF;
							if (classIndex == 0x1F) {
								class = rcvr;
								goto l102;
							}
							assert(classIndex >= (arrayClassIndexPun()));
							/* begin classAtIndex: */
							VM_LABEL(1classAtIndex);
							assert((classIndex <= (tagMask()))
							 || (classIndex >= (arrayClassIndexPun())));
							classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
							if (classTablePage == GIV(nilObj)) {
								class = null;
								goto l102;
							}
							class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
						l102:	/* end fetchClassOfNonImm: */;
							fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
						l103:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
							1;
						l98:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								VM_LABEL(1installinAtCacheatstring);
								assert(!(isContext(rcvr)));
								hdr1 = longLongAt(rcvr);
								fmt1 = (((unsigned sqLong)hdr1) >> 24) & 0x1F;
								/* begin lengthOf:format: */
								/* begin numSlotsOf: */
								flag("endianness");
								assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
								/* begin rawNumSlotsOf: */
								flag("endianness");
								numSlots5 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
								numSlots2 = (numSlots5 == 0xFF
									? (/* begin rawOverflowSlotsOf: */
										flag("endianness"),
										longAt(rcvr - (BaseHeaderSize)))
									: numSlots5);
								if (fmt1 <= 9) {
									totalLength1 = numSlots2;
									goto l99;
								}
								if (fmt1 >= 16) {

									/* bytes, including CompiledMethod */

									totalLength1 = (numSlots2 << 2) - (fmt1 & 7);
									goto l99;
								}
								if (fmt1 >= 12) {
									totalLength1 = (numSlots2 << (2 - 1)) - (fmt1 & 3);
									goto l99;
								}
								totalLength1 = (numSlots2 << (2 - 2)) - (fmt1 & 1);
							l99:	/* end lengthOf:format: */;
								fixedFields1 = 0;

								/* special flag for strings */

								fmt1 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
								1;
							l101:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSend;
								goto l95;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						VM_LABEL(0commonVariableatcacheIndex);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if (((((usqInt) ((index >> 1)))) >= (((usqInt) 1)))
						 && ((((usqInt) ((index >> 1)))) <= (((usqInt) stSize)))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= 4) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								result = longAt((rcvr + (BaseHeaderSize)) + (((((index >> 1)) + fixedFields2) - 1) << 2));
								goto l106;
							}
							if (fmt2 < 16) {

								/* Bitmap */

								result1 = long32At((rcvr + (BaseHeaderSize)) + ((((index >> 1)) - 1) << 2));
								result = positive32BitIntegerFor(result1);
								goto l106;
							}
							if (fmt2 >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* String */

								result = (CharacterTable == null
									? ((byteAt((rcvr + (BaseHeaderSize)) + (((index >> 1)) - 1))) << 2) + 2
									: (/* begin fetchPointer:ofObject: */
										/* begin characterTable */
										error("shouldNotImplement"),
										longAt((objOop + (BaseHeaderSize)) + ((byteAt((rcvr + (BaseHeaderSize)) + (((index >> 1)) - 1))) << 2))));
								goto l106;
							}
							else {
								if ((fmt2 < 24)
								 || (((index >> 1)) >= ((((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((byteAt((rcvr + (BaseHeaderSize)) + (((index >> 1)) - 1))) << 1) | 1);
									goto l106;
								}
							}
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
					l106:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), result);
						goto l95;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((16 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l95:	/* end case */;
			break;
		case 193:
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt classIndex;
				sqInt classIndex1;
				sqInt classTablePage;
				sqInt classTablePage1;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt isCharacter;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots3;
				usqInt numSlots4;
				usqInt numSlots5;
				usqInt numSlots6;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;
				sqInt valToPut;
				sqInt value;

				VM_LABEL(0bytecodePrimAtPut);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				if (((rcvr & 3) == 0)
				 && ((index & 1))) {

					/* Index into atPutCache */

					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						lkupClassTag = (longAt(rcvr)) & 0x3FFFFF;
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((17 * 2) << 2));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), lkupClassTag))) {
							GIV(argumentCount) = 2;
							goto commonSend;
							goto l107;
						}
						if (primitiveFunctionPointer == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							VM_LABEL(2installinAtCacheatstring);
							assert(!(isContext(rcvr)));
							hdr = longLongAt(rcvr);
							fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
							if ((fmt == 3)
							 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */

								GIV(primFailCode) = PrimErrBadReceiver;
								0;
								goto l110;
							}
							/* begin lengthOf:format: */
							/* begin numSlotsOf: */
							flag("endianness");
							assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
							/* begin rawNumSlotsOf: */
							flag("endianness");
							numSlots4 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
							numSlots1 = (numSlots4 == 0xFF
								? (/* begin rawOverflowSlotsOf: */
									flag("endianness"),
									longAt(rcvr - (BaseHeaderSize)))
								: numSlots4);
							if (fmt <= 9) {
								totalLength = numSlots1;
								goto l109;
							}
							if (fmt >= 16) {

								/* bytes, including CompiledMethod */

								totalLength = (numSlots1 << 2) - (fmt & 7);
								goto l109;
							}
							if (fmt >= 12) {
								totalLength = (numSlots1 << (2 - 1)) - (fmt & 3);
								goto l109;
							}
							totalLength = (numSlots1 << (2 - 2)) - (fmt & 1);
						l109:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt > 5)
							 || (fmt == 2)) {
								fixedFields = 0;
								goto l115;
							}
							if (fmt < 2) {
								fixedFields = totalLength;
								goto l115;
							}
							/* begin fetchClassOfNonImm: */
							VM_LABEL(1fetchClassOfNonImm);
							classIndex = (longAt(rcvr)) & 0x3FFFFF;
							if (classIndex == 0x1F) {
								class = rcvr;
								goto l114;
							}
							assert(classIndex >= (arrayClassIndexPun()));
							/* begin classAtIndex: */
							VM_LABEL(2classAtIndex);
							assert((classIndex <= (tagMask()))
							 || (classIndex >= (arrayClassIndexPun())));
							classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
							if (classTablePage == GIV(nilObj)) {
								class = null;
								goto l114;
							}
							class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
						l114:	/* end fetchClassOfNonImm: */;
							fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
						l115:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields);
							1;
						l110:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								VM_LABEL(3installinAtCacheatstring);
								assert(!(isContext(rcvr)));
								hdr1 = longLongAt(rcvr);
								fmt1 = (((unsigned sqLong)hdr1) >> 24) & 0x1F;
								/* begin lengthOf:format: */
								/* begin numSlotsOf: */
								flag("endianness");
								assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
								/* begin rawNumSlotsOf: */
								flag("endianness");
								numSlots5 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
								numSlots2 = (numSlots5 == 0xFF
									? (/* begin rawOverflowSlotsOf: */
										flag("endianness"),
										longAt(rcvr - (BaseHeaderSize)))
									: numSlots5);
								if (fmt1 <= 9) {
									totalLength1 = numSlots2;
									goto l111;
								}
								if (fmt1 >= 16) {

									/* bytes, including CompiledMethod */

									totalLength1 = (numSlots2 << 2) - (fmt1 & 7);
									goto l111;
								}
								if (fmt1 >= 12) {
									totalLength1 = (numSlots2 << (2 - 1)) - (fmt1 & 3);
									goto l111;
								}
								totalLength1 = (numSlots2 << (2 - 2)) - (fmt1 & 1);
							l111:	/* end lengthOf:format: */;
								fixedFields1 = 0;

								/* special flag for strings */

								fmt1 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt1;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields1);
								1;
							l113:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSend;
								goto l107;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						VM_LABEL(0commonVariableatputcacheIndex);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if (((((usqInt) ((index >> 1)))) >= (((usqInt) 1)))
						 && ((((usqInt) ((index >> 1)))) <= (((usqInt) stSize)))) {
							fmt2 = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt2 <= 4) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields2 = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								VM_LABEL(14storePointerofObjectwithValue);
								assert(!(isForwarded(rcvr)));
								if (isOldObject(rcvr)) {

									/* most stores into young objects */

									if (((value & 3) == 0)
									 && ((((usqInt) value)) < (((usqInt) GIV(newSpaceLimit))))) {
										/* begin possibleRootStoreInto: */
										if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
											remember(rcvr);
											/* begin setIsRememberedOf:to: */
											flag("endianness");
											longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
										}
									}
								}
								longAtput((rcvr + (BaseHeaderSize)) + (((((index >> 1)) + fixedFields2) - 1) << 2), value);
								goto l118;
							}
							if (fmt2 < 16) {

								/* Bitmap */

								valToPut = positive32BitValueOf(value);
								if (!GIV(primFailCode)) {
									long32Atput((rcvr + (BaseHeaderSize)) + ((((index >> 1)) - 1) << 2), valToPut);
									null;
									goto l118;
								}
								GIV(primFailCode) = PrimErrBadArgument;
								goto l118;
							}
							if (fmt2 >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */

								isCharacter = (value & 3) == 2;
								if (!isCharacter) {
									GIV(primFailCode) = PrimErrBadArgument;
									goto l118;
								}
								valToPut = ((usqInt) (((usqInt)value))) >> 2;

							}
							else {
								if ((fmt2 >= 24)
								 && (((index >> 1)) < ((((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1))) {
									GIV(primFailCode) = PrimErrBadIndex;
									goto l118;
								}
								valToPut = ((value & 1)
									? (value >> 1)
									: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								GIV(primFailCode) = PrimErrBadArgument;
								goto l118;
							}
							byteAtput((rcvr + (BaseHeaderSize)) + (((index >> 1)) - 1), valToPut);
							goto l118;
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
					l118:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (3 - 1) * BytesPerOop), value);
						goto l107;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((17 * 2) << 2));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
		l107:	/* end case */;
			break;
		case 194:
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt isArray;
				sqInt isString;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots2;
				usqInt numSlots3;
				sqInt rcvr;
				sqInt sz;

				VM_LABEL(0bytecodePrimSize);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */

				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isString = 0;
					goto l122;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & 0x3FFFFF;
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l122;

				isString = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2))) == (classAtIndex(ccIndex));
			l122:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf:format: */
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
					/* begin rawNumSlotsOf: */
					flag("endianness");
					numSlots2 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
					numSlots = (numSlots2 == 0xFF
						? (/* begin rawOverflowSlotsOf: */
							flag("endianness"),
							longAt(rcvr - (BaseHeaderSize)))
						: numSlots2);
					if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) <= 9) {
						sz = numSlots;
						goto l120;
					}
					if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 16) {

						/* bytes, including CompiledMethod */

						sz = (numSlots << 2) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 7);
						goto l120;
					}
					if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 12) {
						sz = (numSlots << (2 - 1)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 3);
						goto l120;
					}
					sz = (numSlots << (2 - 2)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 1);
				l120:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 1) | 1));
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l119;
				}
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isArray = 0;
					goto l123;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex1 = (longAt(rcvr)) & 0x3FFFFF;
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l123;

				isArray = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassArray << 2))) == (classAtIndex(ccIndex1));
			l123:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf:format: */
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
					/* begin rawNumSlotsOf: */
					flag("endianness");
					numSlots3 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
					numSlots1 = (numSlots3 == 0xFF
						? (/* begin rawOverflowSlotsOf: */
							flag("endianness"),
							longAt(rcvr - (BaseHeaderSize)))
						: numSlots3);
					if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) <= 9) {
						sz = numSlots1;
						goto l121;
					}
					if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 16) {

						/* bytes, including CompiledMethod */

						sz = (numSlots1 << 2) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 7);
						goto l121;
					}
					if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 12) {
						sz = (numSlots1 << (2 - 1)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 3);
						goto l121;
					}
					sz = (numSlots1 << (2 - 2)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 1);
				l121:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 1) | 1));
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l119;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((18 * 2) << 2));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l119:	/* end case */;
			break;
		case 195:
			/* bytecodePrimNext */
			{
				VM_LABEL(0bytecodePrimNext);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((19 * 2) << 2));
				GIV(argumentCount) = ((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + (((19 * 2) + 1) << 2))) >> 1);
				goto normalSend;
			}
			break;
		case 196:
			/* bytecodePrimNextPut */
			{
				VM_LABEL(0bytecodePrimNextPut);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((20 * 2) << 2));
				GIV(argumentCount) = ((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + (((20 * 2) + 1) << 2))) >> 1);
				goto normalSend;
			}
			break;
		case 197:
			/* bytecodePrimAtEnd */
			{
				VM_LABEL(0bytecodePrimAtEnd);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((21 * 2) << 2));
				GIV(argumentCount) = ((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + (((21 * 2) + 1) << 2))) >> 1);
				goto normalSend;
			}
			break;
		case 198:
			/* bytecodePrimIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(0bytecodePrimIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & 3) == 0)
				 && (((longAt(rcvr)) & 0x3FFFFF) == 8)) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((arg & 3) == 0)
				 && (((longAt(arg)) & 0x3FFFFF) == 8)) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP);
				}
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			break;
		case 199:
			/* bytecodePrimClass */
			{
				sqInt aValue;
				sqInt classIndex;
				sqInt classTablePage;
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(0bytecodePrimClass);
				rcvr = longAtPointer(localSP);
				if (((rcvr & 3) == 0)
				 && (((longAt(rcvr)) & 0x3FFFFF) == 8)) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				/* begin internalStackTopPut: */
				/* begin fetchClassOf: */
				VM_LABEL(0fetchClassOf);
				if (((tagBits = rcvr & 3)) != 0) {
					aValue = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
					goto l124;
				}
				/* begin fetchClassOfNonImm: */
				classIndex = (longAt(rcvr)) & 0x3FFFFF;
				if (classIndex == 0x1F) {
					aValue = rcvr;
					goto l124;
				}
				assert(classIndex >= (arrayClassIndexPun()));
				/* begin classAtIndex: */
				VM_LABEL(3classAtIndex);
				assert((classIndex <= (tagMask()))
				 || (classIndex >= (arrayClassIndexPun())));
				classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
				if (classTablePage == GIV(nilObj)) {
					aValue = null;
					goto l124;
				}
				aValue = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
			l124:	/* end fetchClassOf: */;
				longAtPointerput(localSP, aValue);
				/* begin fetchNextBytecode */
				
#        if MULTIPLEBYTECODESETS
				currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#        else /* MULTIPLEBYTECODESETS */
				currentBytecode = byteAtPointer(++localIP);

#        endif /* MULTIPLEBYTECODESETS */

			}
			break;
		case 200:
			/* bytecodePrimSpecialSelector24 */
			{
				VM_LABEL(0bytecodePrimSpecialSelector24);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((24 * 2) << 2));
				GIV(argumentCount) = ((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + (((24 * 2) + 1) << 2))) >> 1);
				goto normalSend;
			}
			break;
		case 201:
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(0bytecodePrimValue);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isBlock = 0;
					goto l126;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & 0x3FFFFF;
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l126;

				isBlock = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassBlockClosure << 2))) == (classAtIndex(ccIndex));
			l126:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l125;
					}
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((25 * 2) << 2));
				goto normalSend;
			}
		l125:	/* end case */;
			break;
		case 202:
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(0bytecodePrimValueWithArg);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & 3) != 0) {
					isBlock = 0;
					goto l128;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & 0x3FFFFF;
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l128;

				isBlock = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassBlockClosure << 2))) == (classAtIndex(ccIndex));
			l128:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						
#            if MULTIPLEBYTECODESETS
						currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#            else /* MULTIPLEBYTECODESETS */
						currentBytecode = byteAtPointer(++localIP);

#            endif /* MULTIPLEBYTECODESETS */

						goto l127;
					}
					GIV(primFailCode) = 0;
				}
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((26 * 2) << 2));
				goto normalSend;
			}
		l127:	/* end case */;
			break;
		case 203:
			/* bytecodePrimDo */
			{
				VM_LABEL(0bytecodePrimDo);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((27 * 2) << 2));
				GIV(argumentCount) = ((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + (((27 * 2) + 1) << 2))) >> 1);
				goto normalSend;
			}
			break;
		case 204:
			/* bytecodePrimNew */
			{
				VM_LABEL(0bytecodePrimNew);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((28 * 2) << 2));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 205:
			/* bytecodePrimNewWithArg */
			{
				VM_LABEL(0bytecodePrimNewWithArg);
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((29 * 2) << 2));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			break;
		case 206:
			/* bytecodePrimPointX */
			{
				sqInt rcvr;
				sqInt successBoolean;

				VM_LABEL(0bytecodePrimPointX);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				/* begin success: */
				successBoolean = ((longAt(rcvr)) & 0x3FFFFF) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
				if (!successBoolean) {

					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					longAtPointerput(localSP, longAt((rcvr + (BaseHeaderSize)) + (XIndex << 2)));
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l129;
				}
				GIV(primFailCode) = 0;
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((30 * 2) << 2));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l129:	/* end case */;
			break;
		case 207:
			/* bytecodePrimPointY */
			{
				sqInt rcvr;
				sqInt successBoolean;

				VM_LABEL(0bytecodePrimPointY);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				/* begin success: */
				successBoolean = ((longAt(rcvr)) & 0x3FFFFF) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
				if (!successBoolean) {

					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					longAtPointerput(localSP, longAt((rcvr + (BaseHeaderSize)) + (YIndex << 2)));
					/* begin fetchNextBytecode */
					
#          if MULTIPLEBYTECODESETS
					currentBytecode = (byteAtPointer(++localIP)) + bytecodeSetSelector;

#          else /* MULTIPLEBYTECODESETS */
					currentBytecode = byteAtPointer(++localIP);

#          endif /* MULTIPLEBYTECODESETS */

					goto l130;
				}
				GIV(primFailCode) = 0;
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((0x1F * 2) << 2));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l130:	/* end case */;
			break;
		case 208:
		case 209:
		case 210:
		case 211:
		case 212:
		case 213:
		case 214:
		case 215:
		case 216:
		case 217:
		case 218:
		case 219:
		case 220:
		case 221:
		case 222:
		case 223:
			/* sendLiteralSelector0ArgsBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(0sendLiteralSelector0ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + (BaseHeaderSize)) + (((currentBytecode & 15) + LiteralStart) << 2));
				GIV(argumentCount) = 0;
				rcvr = longAtPointer(localSP + (0 * BytesPerOop));
				/* begin fetchClassTagOf: */
				if (((tagBits = rcvr & 3)) != 0) {
					lkupClassTag = ((tagBits & 1) != 0
						? 1
						: tagBits);
					goto l131;
				}
				lkupClassTag = (longAt(rcvr)) & 0x3FFFFF;
			l131:	/* end fetchClassTagOf: */;
				assert(lkupClassTag != (nilObject()));
				goto commonSend;
			}
			break;
		case 224:
		case 225:
		case 226:
		case 227:
		case 228:
		case 229:
		case 230:
		case 231:
		case 232:
		case 233:
		case 234:
		case 235:
		case 236:
		case 237:
		case 238:
		case 239:
			/* sendLiteralSelector1ArgBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(0sendLiteralSelector1ArgBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + (BaseHeaderSize)) + (((currentBytecode & 15) + LiteralStart) << 2));
				GIV(argumentCount) = 1;
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				/* begin fetchClassTagOf: */
				if (((tagBits = rcvr & 3)) != 0) {
					lkupClassTag = ((tagBits & 1) != 0
						? 1
						: tagBits);
					goto l132;
				}
				lkupClassTag = (longAt(rcvr)) & 0x3FFFFF;
			l132:	/* end fetchClassTagOf: */;
				assert(lkupClassTag != (nilObject()));
				goto commonSend;
			}
			break;
		case 240:
		case 241:
		case 242:
		case 243:
		case 244:
		case 245:
		case 246:
		case 247:
		case 248:
		case 249:
		case 250:
		case 251:
		case 252:
		case 253:
		case 254:
		case 255:
			/* sendLiteralSelector2ArgsBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(0sendLiteralSelector2ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + (BaseHeaderSize)) + (((currentBytecode & 15) + LiteralStart) << 2));
				GIV(argumentCount) = 2;
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				/* begin fetchClassTagOf: */
				if (((tagBits = rcvr & 3)) != 0) {
					lkupClassTag = ((tagBits & 1) != 0
						? 1
						: tagBits);
					goto l133;
				}
				lkupClassTag = (longAt(rcvr)) & 0x3FFFFF;
			l133:	/* end fetchClassTagOf: */;
				assert(lkupClassTag != (nilObject()));
				goto commonSend;
			}
			break;
		}
	}

	/* undo the pre-increment of IP before returning */

	localIP -= 1;
	/* begin externalizeIPandSP */
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}


/*	Answer the accessible object following the given object or 
	free chunk in the heap. Return nil when heap is exhausted.
	This is for primitiveNextObject subsequent to primtiiveSomeObject. */

static sqInt
accessibleObjectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objAfter;

	objAfter = objOop;
	while(1) {
		objAfter = objectAfterlimit(objAfter, GIV(endOfMemory));
		if (objAfter == GIV(endOfMemory)) {
			return null;
		}
		if (((longAt(objAfter)) & 0x3FFFFF) > 0x1F) {
			return objAfter;
		}
	}
}


/*	Answer the current activeProcess. */
/*	useful for VM debugging */

sqInt
activeProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
}


/*	Add a freeChunk sub tree back into the large free chunk tree.
	This is for allocateOldSpaceChunkOf[Exactly]Bytes:[suchThat:]. */
/*	N.B. *can't* use numSlotsOfAny: because of rounding up of odd slots
	and/or step in size at 1032 bytes in 32-bits or 2048 bytes in 64-bits. */

static void
addFreeSubTree(sqInt freeTree)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bytesInArg;
    usqLong bytesInNode;
    sqInt subNode;
    sqInt treeNode;

	assert(isFreeObject(freeTree));
	bytesInArg = bytesInObject(freeTree);
	assert((bytesInArg / ((allocationUnit()) / (wordSize()))) >= (numFreeLists()));
	treeNode = GIV(freeLists)[0];
	assert(treeNode != 0);
	while(1) {
		bytesInNode = bytesInObject(treeNode);
		assert(bytesInArg != bytesInNode);
		if (bytesInNode > bytesInArg) {
			subNode = longAt((treeNode + (BaseHeaderSize)) + (3 << 2));
			if (subNode == 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(treeNode));
				assert((freeTree == 0)
				 || (isFreeObject(freeTree)));
				longAtput((treeNode + (BaseHeaderSize)) + (3 << 2), freeTree);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeTree));
				assert((treeNode == 0)
				 || (isFreeObject(treeNode)));
				longAtput((freeTree + (BaseHeaderSize)) + (2 << 2), treeNode);
				return;
			}
		}
		else {
			subNode = longAt((treeNode + (BaseHeaderSize)) + (4 << 2));
			if (subNode == 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(treeNode));
				assert((freeTree == 0)
				 || (isFreeObject(freeTree)));
				longAtput((treeNode + (BaseHeaderSize)) + (4 << 2), freeTree);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(freeTree));
				assert((treeNode == 0)
				 || (isFreeObject(treeNode)));
				longAtput((freeTree + (BaseHeaderSize)) + (2 << 2), treeNode);
				return;
			}
		}
		treeNode = subNode;
	}
}


/*	Add the given variable location to the extra roots table. */

sqInt
addGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(extraRootCount) >= ExtraRootsSize) {
		return 0;
	}
	GIV(extraRoots)[(GIV(extraRootCount) += 1)] = varLoc;
	return 1;
}


/*	Add the given process to the end of the given linked list
	and set the backpointer of process to its new list. */

static void
addLastLinktoList(sqInt proc, sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt lastLink;

	assert((fetchPointerofObject(NextLinkIndex, proc)) == (nilObject()));
	if ((longAt((aList + (BaseHeaderSize)) + (FirstLinkIndex << 2))) == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		if (isOldObject(aList)) {

			/* most stores into young objects */

			if (((proc & 3) == 0)
			 && ((((usqInt) proc)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aList))) >> 29) & 1) != 0)) {
					remember(aList);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(aList, (longAt(aList)) | (1 << 29));
				}
			}
		}
		longAtput((aList + (BaseHeaderSize)) + (FirstLinkIndex << 2), proc);
	}
	else {
		lastLink = longAt((aList + (BaseHeaderSize)) + (LastLinkIndex << 2));
		assert(lastLink != proc);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(lastLink)));
		if (isOldObject(lastLink)) {

			/* most stores into young objects */

			if (((proc & 3) == 0)
			 && ((((usqInt) proc)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(lastLink))) >> 29) & 1) != 0)) {
					remember(lastLink);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(lastLink, (longAt(lastLink)) | (1 << 29));
				}
			}
		}
		longAtput((lastLink + (BaseHeaderSize)) + (NextLinkIndex << 2), proc);
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(aList)));
	if (isOldObject(aList)) {

		/* most stores into young objects */

		if (((proc & 3) == 0)
		 && ((((usqInt) proc)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(aList))) >> 29) & 1) != 0)) {
				remember(aList);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(aList, (longAt(aList)) | (1 << 29));
			}
		}
	}
	longAtput((aList + (BaseHeaderSize)) + (LastLinkIndex << 2), proc);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(proc)));
	if (isOldObject(proc)) {

		/* most stores into young objects */

		if (((aList & 3) == 0)
		 && ((((usqInt) aList)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(proc))) >> 29) & 1) != 0)) {
				remember(proc);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(proc, (longAt(proc)) | (1 << 29));
			}
		}
	}
	longAtput((proc + (BaseHeaderSize)) + (MyListIndex << 2), aList);
}

static SpurCircularBuffer *
addLast(SpurCircularBuffer * self_in_addLast, sqInt element)
{
    usqInt newLast;

	newLast = ((self_in_addLast->last)) + (wordSize());
	if (newLast >= ((self_in_addLast->limit))) {
		newLast = (self_in_addLast->start);
	}
	if ((newLast == ((self_in_addLast->first)))
	 && (((self_in_addLast->last)) >= ((self_in_addLast->start)))) {

		/* wrapped; bump first */

		if ((((self_in_addLast->first) = newLast + (wordSize()))) >= ((self_in_addLast->limit))) {
			(self_in_addLast->first) = (self_in_addLast->start);
		}
	}
	(self_in_addLast->last) = newLast;
	assert((((self_in_addLast->first)) >= ((self_in_addLast->start)))
	 && (((self_in_addLast->first)) < ((self_in_addLast->limit))));
	assert((((self_in_addLast->last)) >= ((self_in_addLast->start)))
	 && (((self_in_addLast->last)) < ((self_in_addLast->limit))));
	longAtput(newLast, element);
	return self_in_addLast;
}


/*	Add the given entry to the method cache.
	The policy is as follows:
	Look for an empty entry anywhere in the reprobe chain.
	If found, install the new entry there.
	If not found, then install the new entry at the first probe position
	and delete the entries in the rest of the reprobe chain.
	This has two useful purposes:
	If there is active contention over the first slot, the second
	or third will likely be free for reentry after ejection.
	Also, flushing is good when reprobe chains are getting full. */

static void
addNewMethodToCache(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt hash;
    sqInt p;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt probe;


	/* drop low-order zeros from addresses (if classObj not classTag) */

	hash = GIV(messageSelector) ^ (classTagForClass(classObj));
	if (((GIV(newMethod) & 3) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> 24) & 0x1F) >= 24)) {
		primitiveIndex = 
#    if MULTIPLEBYTECODESETS
			((((sqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
						? ((longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
								? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + ((((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
									(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
								: 0)
						: ((primBits = ((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
							(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#    else /* MULTIPLEBYTECODESETS */
			((primBits = ((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
					(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#    endif /* MULTIPLEBYTECODESETS */
			;
		/* begin functionPointerFor:inClass: */
		primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	}
	else {
		primitiveFunctionPointer = primitiveInvokeObjectAsMethod;
	}
	for (p = 0; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == 0) {

			/* Found an empty entry -- use it */

			GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
			GIV(methodCache)[probe + MethodCacheClass] = (classTagForClass(classObj));
			GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
			GIV(methodCache)[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));

			/* this for primitiveExternalMethod */

			GIV(lastMethodCacheProbeWrite) = probe;
			return;
		}
	}

	/* first probe */

	probe = hash & MethodCacheMask;
	GIV(methodCache)[probe + MethodCacheSelector] = GIV(messageSelector);
	GIV(methodCache)[probe + MethodCacheClass] = (classTagForClass(classObj));
	GIV(methodCache)[probe + MethodCacheMethod] = GIV(newMethod);
	GIV(methodCache)[probe + MethodCachePrimFunction] = (((long) primitiveFunctionPointer));

	/* this for primitiveExternalMethod */
	/* ...and zap the following entries */

	GIV(lastMethodCacheProbeWrite) = probe;
	for (p = 1; p < CacheProbeMax; p += 1) {
		probe = (((usqInt) hash) >> p) & MethodCacheMask;
		GIV(methodCache)[probe + MethodCacheSelector] = 0;
	}
}


/*	Answer the address immediately following an object. */

static sqInt
addressAfter(sqInt objOop)
{
    usqInt numSlots;
    usqInt numSlots1;
    sqInt slotBytes;

	/* begin numSlotsOfAny: */
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(objOop - (BaseHeaderSize)))
		: numSlots1);
	slotBytes = (numSlots == 0
		? 8
		: (numSlots + (numSlots & 1)) << 2);
	return (objOop + (BaseHeaderSize)) + slotBytes;
}


/*	Answer if maybeClassObj looks like a class object */

static sqInt
addressCouldBeClassObj(sqInt maybeClassObj)
{
	return (addressCouldBeObj(maybeClassObj))
	 && (objCouldBeClassObj(maybeClassObj));
}

sqInt
addressCouldBeObj(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((address & ((BaseHeaderSize) - 1)) == 0)
	 && ((((((usqInt) address)) >= (((usqInt) GIV(oldSpaceStart))))
 && ((((usqInt) address)) < (((usqInt) GIV(endOfMemory)))))
	 || ((oopisGreaterThanOrEqualToandLessThan(address, ((eden()).start), GIV(freeStart)))
	 || ((oopisGreaterThanOrEqualToandLessThan(address, ((pastSpace()).start), GIV(pastSpaceStart)))
	 || (GIV(scavengeInProgress)
	 && (oopisGreaterThanOrEqualToandLessThan(address, ((futureSpace()).start), GIV(futureSurvivorStart)))))));
}

static sqInt
addressCouldBeOop(sqInt address)
{
	return ((address & 3) != 0)
	 || (addressCouldBeObj(address));
}


/*	For assert-checking */

static sqInt
addressIsInPage(StackPage * self_in_addressIsInPage, char *address)
{
	return (((self_in_addressIsInPage->lastAddress)) < address)
	 && (address < ((self_in_addressIsInPage->baseAddress)));
}

static SpurSegmentInfo *
addSegmentOfSize(sqInt ammount)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt allocatedSize;
    sqInt i;
    sqInt idx;
    sqInt lastSegIndex;
    SpurSegmentInfo *newSeg;
    sqInt newSegIndex;
    void *segAddress;
    sqInt segIndex;

	null;
	segAddress = sqAllocateMemorySegmentOfSizeAboveAllocatedSizeInto(ammount, ((void *)((((GIV(segments)[0]).segSize)) + (((GIV(segments)[0]).segStart)))), (&allocatedSize));
	if (!(segAddress == null)) {
		/* begin insertSegmentFor: */
		assert((((unsigned long)segAddress)) > (segLimit(&GIV(segments)[0])));
		if (GIV(numSegments) == GIV(numSegInfos)) {
			allocateOrExtendSegmentInfos();
		}
		assert(GIV(numSegments) < GIV(numSegInfos));
		segIndex = (lastSegIndex = GIV(numSegments) - 1);
		GIV(numSegments) += 1;
		while(1) {
			if ((((unsigned long)segAddress)) >= ((((GIV(segments)[segIndex]).segSize)) + (((GIV(segments)[segIndex]).segStart)))) {
				segIndex += 1;
				for (idx = lastSegIndex; idx >= segIndex; idx += -1) {
					GIV(segments)[idx + 1] = (GIV(segments)[idx]);
				}
				newSegIndex = segIndex;
				goto l1;
			}
			segIndex -= 1;
		}
	l1:	/* end insertSegmentFor: */;
		newSeg = (&(GIV(segments)[newSegIndex]));
		(newSeg->segStart = ((unsigned long)segAddress));
		(newSeg->segSize = allocatedSize);
		bridgeFromto((&(GIV(segments)[newSegIndex - 1])), newSeg);
		bridgeFromto(newSeg, (!(newSegIndex == (GIV(numSegments) - 1))
			? (&(GIV(segments)[newSegIndex + 1]))
			: 0));
		/* begin addFreeChunkWithBytes:at: */
		address = (newSeg->segStart);
		freeChunkWithBytesat(allocatedSize - (2 * (BaseHeaderSize)), address);
		GIV(totalFreeOldSpace) += allocatedSize - (2 * (BaseHeaderSize));
		assert((addressAfter(objectStartingAt((newSeg->segStart)))) == ((segLimit(newSeg)) - (bridgeSize())));
		for (i = 0; i < GIV(numSegments); i += 1) {
			assert(isInSegments(((GIV(segments)[i]).segStart)));
			assert(isInSegments((segLimit(&GIV(segments)[i])) - (wordSize())));
			assert((!(isInSegments(segLimit(&GIV(segments)[i]))))
			 || ((i < (GIV(numSegments) - 1))
			 && ((segLimit(&GIV(segments)[i])) == (((GIV(segments)[i + 1]).segStart)))));
			assert((!(isInSegments((((GIV(segments)[i]).segStart)) - (wordSize()))))
			 || ((i > 0)
			 && ((segLimit(&GIV(segments)[i - 1])) == (((GIV(segments)[i]).segStart)))));
		}
		return newSeg;
	}
	return null;
}


/*	ephemeronCorpse is the corpse of an ephemeron that was copied and
	forwarded. Later on its surviving copy must be scanned to nil weak
	references. Thread the corpse onto the weakList. Later, the weakList can
	be followed, and
	the forwarding pointer followed to locate the survivor. */

static void
addToEphemeronList(sqInt ephemeronCorpse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeronListOffset;

	assert(!(isScavengeSurvivor(keyOfEphemeron(followForwarded(ephemeronCorpse)))));
	ephemeronListOffset = (!(GIV(ephemeronList))
		? 0
		: GIV(ephemeronList));
	/* begin setCorpseOffsetOf:to: */
	assert(isYoung(ephemeronCorpse));
	assert(isForwarded(ephemeronCorpse));
	/* begin setHashBitsOf:to: */
	flag("endianness");
	assert((((((usqInt) ephemeronListOffset) >> 5) >= 0) && ((((usqInt) ephemeronListOffset) >> 5) <= (identityHashHalfWordMask()))));
	longAtput(ephemeronCorpse + 4, ((((longAt(ephemeronCorpse + 4)) | 0x3FFFFF) - 0x3FFFFF)) + (((usqInt) ephemeronListOffset) >> 5));
	/* begin setFormatOf:to: */
	assert((((ephemeronListOffset & 0x1F) >= 0) && ((ephemeronListOffset & 0x1F) <= (formatMask()))));
	flag("endianness");
	longAtput(ephemeronCorpse, ((longAt(ephemeronCorpse)) & (~(0x1F << 24))) + ((ephemeronListOffset & 0x1F) << 24));
	GIV(ephemeronList) = ((usqInt) (ephemeronCorpse - GIV(newSpaceStart))) >> 3;
	assert((firstCorpse(GIV(ephemeronList))) == ephemeronCorpse);
}


/*	Add freeChunk to the large free chunk tree.
	For the benefit of sortedFreeObject:, answer the treeNode it is added
	to, if it is added to the next list of a freeTreeNode, otherwise answer 0. */

static sqInt
addToFreeTreebytes(sqInt freeChunk, sqInt chunkBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqLong childBytes;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt parent;

	assert(isFreeObject(freeChunk));
	assert(chunkBytes == (bytesInObject(freeChunk)));
	assert((chunkBytes / (allocationUnit())) >= (numFreeLists()));
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert((0 == 0)
	 || (isFreeObject(0)));
	longAtput((freeChunk + (BaseHeaderSize)) + (0 << 2), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert((0 == 0)
	 || (isFreeObject(0)));
	longAtput((freeChunk + (BaseHeaderSize)) + (2 << 2), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert((0 == 0)
	 || (isFreeObject(0)));
	longAtput((freeChunk + (BaseHeaderSize)) + (3 << 2), 0);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert((0 == 0)
	 || (isFreeObject(0)));
	longAtput((freeChunk + (BaseHeaderSize)) + (4 << 2), 0);
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		childBytes = bytesInObject(child);
		if (childBytes == chunkBytes) {

			/* size match; add to list at node. */

			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(freeChunk));
			assert(((longAt((child + (BaseHeaderSize)) + (0 << 2))) == 0)
			 || (isFreeObject(longAt((child + (BaseHeaderSize)) + (0 << 2)))));
			longAtput((freeChunk + (BaseHeaderSize)) + (0 << 2), longAt((child + (BaseHeaderSize)) + (0 << 2)));
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(child));
			assert((freeChunk == 0)
			 || (isFreeObject(freeChunk)));
			longAtput((child + (BaseHeaderSize)) + (0 << 2), freeChunk);
			return child;
		}
		parent = child;
		/* begin fetchPointer:ofFreeChunk: */
		fieldIndex = (childBytes > chunkBytes
			? 3
			: 4);
		child = longAt((child + (BaseHeaderSize)) + (fieldIndex << 2));
	}
	if (parent == 0) {
		assert((GIV(freeLists)[0]) == 0);
		GIV(freeLists)[0] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | 1;
		return 0;
	}
	assert(GIV(freeListsMask) & 1);
	/* begin storePointer:ofFreeChunk:withValue: */
	assert(isFreeObject(freeChunk));
	assert((parent == 0)
	 || (isFreeObject(parent)));
	longAtput((freeChunk + (BaseHeaderSize)) + (2 << 2), parent);
	/* begin storePointer:ofFreeChunk:withValue: */
	fieldIndex1 = (childBytes > chunkBytes
		? 3
		: 4);
	assert(isFreeObject(parent));
	assert((freeChunk == 0)
	 || (isFreeObject(freeChunk)));
	longAtput((parent + (BaseHeaderSize)) + (fieldIndex1 << 2), freeChunk);
	return 0;
}


/*	weakCorpse is the corpse of a weak array that was copied and forwarded.
	Later on its surviving copy must be scanned to nil weak references.
	Thread the corpse onto the weakList. Later, the weakList can be followed,
	and the forwarding pointer followed to locate the survivor. */

static void
addToWeakList(sqInt weakCorpse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt weakListOffset;

	weakListOffset = (!(GIV(weakList))
		? 0
		: GIV(weakList));
	/* begin setCorpseOffsetOf:to: */
	assert(isYoung(weakCorpse));
	assert(isForwarded(weakCorpse));
	/* begin setHashBitsOf:to: */
	flag("endianness");
	assert((((((usqInt) weakListOffset) >> 5) >= 0) && ((((usqInt) weakListOffset) >> 5) <= (identityHashHalfWordMask()))));
	longAtput(weakCorpse + 4, ((((longAt(weakCorpse + 4)) | 0x3FFFFF) - 0x3FFFFF)) + (((usqInt) weakListOffset) >> 5));
	/* begin setFormatOf:to: */
	assert((((weakListOffset & 0x1F) >= 0) && ((weakListOffset & 0x1F) <= (formatMask()))));
	flag("endianness");
	longAtput(weakCorpse, ((longAt(weakCorpse)) & (~(0x1F << 24))) + ((weakListOffset & 0x1F) << 24));
	GIV(weakList) = ((usqInt) (weakCorpse - GIV(newSpaceStart))) >> 3;
	assert((firstCorpse(GIV(weakList))) == weakCorpse);
}


/*	Adjust swizzles by firstSegmentShift. Also computes segStarts as
	they were in the image when it was written, so that oops' segments
	can be determined and hence oops correctly swizzled. */

static void
adjustSegmentSwizzlesBy(sqInt firstSegmentShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oldBaseAddr;
    SpurSegmentInfo *segInfo;

	oldBaseAddr = GIV(oldSpaceStart) - firstSegmentShift;
	for (i = 0; i < GIV(numSegments); i += 1) {
		segInfo = (&(GIV(segments)[i]));
		(segInfo->segStart = ((segInfo->segStart)) + oldBaseAddr);
		(segInfo->swizzle = ((segInfo->swizzle)) - oldBaseAddr);
	}
	GIV(canSwizzle) = 1;
}

static sqInt
allBridgesMarked(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt bridgeObj;
    sqInt i;
    usqInt numSlots;

	for (i = 0; i < GIV(numSegments); i += 1) {
		/* begin objectStartingAt: */
		address = (((((&(GIV(segments)[i])))->segSize)) + ((((&(GIV(segments)[i])))->segStart))) - (2 * (BaseHeaderSize));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
		bridgeObj = (numSlots == 0xFF
			? address + (BaseHeaderSize)
			: address);
		assert(isValidSegmentBridge(bridgeObj));
		if (!(isMarked(bridgeObj))) {
			return 0;
		}
	}
	return 1;
}

static sqInt
allObjectsUnmarked(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (isMarked(objOop1)) {
			return 0;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (isMarked(objOop1)) {
			return 0;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (isMarked(objOop11)) {
				return 0;
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
	return 1;
}


/*	Allocate an object of numBytes. Answer nil if no available memory.
	classIndex must be that of a byte class (e.g. ByteString).
	The object is *NOT FILLED*. */

static sqInt
allocateBytesclassIndex(sqInt numBytes, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt formatField;
    sqInt newObj;
    sqInt numBytes1;
    sqInt numSlots;

	assert(addressCouldBeClassObj(classAtIndex(classIndex)));
	assert((instSpecOfClass(classAtIndex(classIndex))) == (firstByteFormat()));
	/* begin allocateSlots:format:classIndex: */
	numSlots = ((numBytes + (wordSize())) - 1) / (wordSize());
	formatField = 16 + (((wordSize()) - numBytes) & ((wordSize()) - 1));
	if (numSlots >= 0xFF) {
		newObj = GIV(freeStart) + (BaseHeaderSize);

		/* double header */
		/* roundTo allocationUnit */

		numBytes1 = ((BaseHeaderSize) + (BaseHeaderSize)) + ((numSlots + (numSlots & 1)) * 4);
	}
	else {
		newObj = GIV(freeStart);
		numBytes1 = (BaseHeaderSize) + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * 4));
	}
	if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		return allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes1, formatField, classIndex);
	}
	if (numSlots >= 0xFF) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */

		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, 0xFF << 24);
		longLongAtput(newObj, (((((usqLong) 0xFF)) << 56) + (formatField << 24)) + classIndex);
	}
	else {
		longLongAtput(newObj, (((((usqLong) numSlots)) << 56) + (formatField << 24)) + classIndex);
	}
	assert((numBytes1 % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes1;
	return newObj;
}


/*	Translate to C function call with (case sensitive) camelCase. The purpose
	of this
	method is to document the translation.
	The default implementation is sqAllocateMemory(minimumMemory, heapSize).
	This may
	be redefined to make use of the image file and header size parameters for
	efficient implementation with mmap().
	See CCodeGenerator>>writeDefaultMacrosOn: which specifies a default
	implementation.  */

static char *
allocateMemoryminimumimageFileheaderSize(sqInt heapSize, sqInt minimumMemory, sqImageFile fileStream, sqInt headerSize)
{
	return pointerForOop(allocateMemoryMinimumImageFileHeaderSize(heapSize, minimumMemory, fileStream, headerSize));
}


/*	Allocate an object with numSlots in newSpace. This is for the `ee'
	execution engine allocations,
	and must be satisfied. If no memory is available, abort. If the allocation
	pushes freeStart past
	scavengeThreshold and a scavenge is not already scheduled, schedule a
	scavenge.  */
/*	Object headers are 8 bytes in length if the slot size fits in the num
	slots field (max implies overflow),
	16 bytes otherwise (num slots in preceeding word).
	Objects always have at least one slot, for the forwarding pointer,
	and are multiples of 8 bytes in length. */

static sqInt
allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newObj;
    sqInt numBytes;

	if (numSlots >= 0xFF) {
		newObj = GIV(freeStart) + (BaseHeaderSize);

		/* double header */
		/* roundTo allocationUnit */

		numBytes = ((BaseHeaderSize) + (BaseHeaderSize)) + ((numSlots + (numSlots & 1)) * 4);
	}
	else {
		newObj = GIV(freeStart);
		numBytes = (BaseHeaderSize) + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * 4));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateNewSpaceSlots:format:classIndex:");
			return 0;
		}
	}
	if (numSlots >= 0xFF) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */

		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, 0xFF << 24);
		longLongAtput(newObj, (((((usqLong) 0xFF)) << 56) + (formatField << 24)) + classIndex);
	}
	else {
		longLongAtput(newObj, (((((usqLong) numSlots)) << 56) + (formatField << 24)) + classIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	return newObj;
}


/*	Increase the number of allocated segInfos by 16. */

static void
allocateOrExtendSegmentInfos(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newNumSegs;

	if (GIV(numSegInfos) == 0) {
		GIV(numSegInfos) = 16;
		GIV(segments) = calloc(GIV(numSegInfos), sizeof(SpurSegmentInfo));
		return;
	}
	newNumSegs = GIV(numSegInfos) + 16;
	GIV(segments) = realloc(GIV(segments), newNumSegs * (sizeof(SpurSegmentInfo)));
	if (GIV(segments) == 0) {
		error("out of memory; cannot allocate more segments");
	}
	memset(GIV(segments) + GIV(numSegInfos), 0, (newNumSegs - GIV(numSegInfos)) * (sizeof(SpurSegmentInfo)));
	GIV(numSegInfos) = newNumSegs;
}


/*	Answer the oop of a chunk of space in oldSpace with numSlots slots. The
	header will have been filled-in but not the contents. */

static sqInt
allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, sqInt totalBytes, sqInt formatField, sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqLong childBytes;
    sqInt chunk;
    sqInt chunk1;
    sqInt index;
    sqInt initialIndex;
    sqInt nodeBytes;
    sqInt parent;

	/* begin allocateOldSpaceChunkOfBytes: */
	assert(((GIV(lastSubdividedFreeChunk) = 0)) == 0);

	/* be optimistic (& don't wait for the write) */

	GIV(totalFreeOldSpace) -= totalBytes;
	initialIndex = ((sqInt) totalBytes >> 3);
	if ((initialIndex < 32)
	 && ((1 << initialIndex) <= GIV(freeListsMask))) {
		if (GIV(freeListsMask) & (1 << initialIndex)) {
			if (((chunk1 = GIV(freeLists)[initialIndex])) != 0) {
				assert(chunk1 == (startOfObject(chunk1)));
				assert(isValidFreeObject(chunk1));
				/* begin unlinkFreeChunk:atIndex: */
				assert(((bytesInObject(chunk1)) == (initialIndex * (allocationUnit())))
				 && ((initialIndex > 1)
				 && ((startOfObject(chunk1)) == chunk1)));
				GIV(freeLists)[initialIndex] = (longAt((chunk1 + (BaseHeaderSize)) + (0 << 2)));
				chunk = chunk1;
				goto l1;
			}
			GIV(freeListsMask) -= 1 << initialIndex;
		}
		index = initialIndex;
		while ((((index += index)) < 32)
		 && ((1 << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1 << index)) {
				if (((chunk1 = GIV(freeLists)[index])) != 0) {
					assert(chunk1 == (startOfObject(chunk1)));
					assert(isValidFreeObject(chunk1));
					/* begin unlinkFreeChunk:atIndex: */
					assert(((bytesInObject(chunk1)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk1)) == chunk1)));
					GIV(freeLists)[index] = (longAt((chunk1 + (BaseHeaderSize)) + (0 << 2)));
					chunk1;
					assert((bytesInObject(chunk1)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * 8) - totalBytes, (((rawNumSlotsOf(chunk1)) == 0xFF
	? chunk1 - (BaseHeaderSize)
	: chunk1)) + totalBytes);
					chunk = chunk1;
					goto l1;
				}
				GIV(freeListsMask) -= 1 << index;
			}
		}
		index = initialIndex + 1;
		while ((((index += 1)) < 32)
		 && ((1 << index) <= GIV(freeListsMask))) {
			if (GIV(freeListsMask) & (1 << index)) {
				if (((chunk1 = GIV(freeLists)[index])) != 0) {
					assert(chunk1 == (startOfObject(chunk1)));
					assert(isValidFreeObject(chunk1));
					/* begin unlinkFreeChunk:atIndex: */
					assert(((bytesInObject(chunk1)) == (index * (allocationUnit())))
					 && ((index > 1)
					 && ((startOfObject(chunk1)) == chunk1)));
					GIV(freeLists)[index] = (longAt((chunk1 + (BaseHeaderSize)) + (0 << 2)));
					chunk1;
					assert((bytesInObject(chunk1)) == (index * (allocationUnit())));
					freeChunkWithBytesat((index * 8) - totalBytes, (((rawNumSlotsOf(chunk1)) == 0xFF
	? chunk1 - (BaseHeaderSize)
	: chunk1)) + totalBytes);
					chunk = chunk1;
					goto l1;
				}
				GIV(freeListsMask) -= 1 << index;
			}
		}
	}
	parent = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		assert(isValidFreeObject(child));
		childBytes = bytesInObject(child);
		if (childBytes == totalBytes) {

			/* size match; try to remove from list at node. */

			chunk1 = longAt((child + (BaseHeaderSize)) + (0 << 2));
			if (chunk1 != 0) {
				assert(isValidFreeObject(chunk1));
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(child));
				assert(((longAt((chunk1 + (BaseHeaderSize)) + (0 << 2))) == 0)
				 || (isFreeObject(longAt((chunk1 + (BaseHeaderSize)) + (0 << 2)))));
				longAtput((child + (BaseHeaderSize)) + (0 << 2), longAt((chunk1 + (BaseHeaderSize)) + (0 << 2)));
				chunk = ((rawNumSlotsOf(chunk1)) == 0xFF
					? chunk1 - (BaseHeaderSize)
					: chunk1);
				goto l1;
			}
			nodeBytes = childBytes;
			parent = child;

			/* break out of loop to remove interior node */

			child = 0;
		}
		else {

			/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
			   leave room for the forwarding pointer/next free link, we can only break chunks
			   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */

			if (childBytes <= (totalBytes + 8)) {

				/* node too small; walk down the larger size of the tree */

				child = longAt((child + (BaseHeaderSize)) + (4 << 2));
			}
			else {

				/* parent will be smallest node >= chunkBytes + allocationUnit */

				parent = child;
				nodeBytes = childBytes;
				child = longAt((child + (BaseHeaderSize)) + (3 << 2));
			}
		}
	}
	if (parent == 0) {

		/* optimism was unfounded */

		GIV(totalFreeOldSpace) += totalBytes;
		chunk = null;
		goto l1;
	}
	assert((nodeBytes == totalBytes)
	 || (nodeBytes >= (totalBytes + (2 * (allocationUnit())))));
	assert((bytesInObject(parent)) == nodeBytes);
	chunk1 = longAt((parent + (BaseHeaderSize)) + (0 << 2));
	if (chunk1 != 0) {
		assert((totalBytes == nodeBytes)
		 || ((totalBytes + (allocationUnit())) < nodeBytes));
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(parent));
		assert(((longAt((chunk1 + (BaseHeaderSize)) + (0 << 2))) == 0)
		 || (isFreeObject(longAt((chunk1 + (BaseHeaderSize)) + (0 << 2)))));
		longAtput((parent + (BaseHeaderSize)) + (0 << 2), longAt((chunk1 + (BaseHeaderSize)) + (0 << 2)));
		if (totalBytes != nodeBytes) {
			freeChunkWithBytesat(nodeBytes - totalBytes, (((rawNumSlotsOf(chunk1)) == 0xFF
	? chunk1 - (BaseHeaderSize)
	: chunk1)) + totalBytes);
		}
		chunk = ((rawNumSlotsOf(chunk1)) == 0xFF
			? chunk1 - (BaseHeaderSize)
			: chunk1);
		goto l1;
	}
	chunk1 = parent;
	unlinkSolitaryFreeTreeNode(chunk1);
	if (totalBytes != nodeBytes) {
		freeChunkWithBytesat(nodeBytes - totalBytes, (((rawNumSlotsOf(chunk1)) == 0xFF
	? chunk1 - (BaseHeaderSize)
	: chunk1)) + totalBytes);
	}
	chunk = ((rawNumSlotsOf(chunk1)) == 0xFF
		? chunk1 - (BaseHeaderSize)
		: chunk1);
l1:	/* end allocateOldSpaceChunkOfBytes: */;
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (!(chunk)) {
		return null;
	}
	if (numSlots >= 0xFF) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */

		flag("endianness");
		longAtput(chunk, numSlots);
		longAtput(chunk + 4, 0xFF << 24);
		longLongAtput(chunk + (BaseHeaderSize), (((((usqLong) 0xFF)) << 56) + (formatField << 24)) + classIndex);
		assert((GIV(lastSubdividedFreeChunk) == 0)
		 || ((addressAfter(chunk + (BaseHeaderSize))) == GIV(lastSubdividedFreeChunk)));
		return chunk + (BaseHeaderSize);
	}
	longLongAtput(chunk, (((((usqLong) numSlots)) << 56) + (formatField << 24)) + classIndex);
	assert((GIV(lastSubdividedFreeChunk) == 0)
	 || ((addressAfter(chunk)) == GIV(lastSubdividedFreeChunk)));
	return chunk;
}


/*	All objects are a multiple of 8 bytes in length */

static sqInt
allocationUnit(void)
{
	return 8;
}

static sqInt
allUnscannedEphemeronsAreActive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt key;
    sqInt p;
    sqInt pLimiT;

	for (p = ((GIV(unscannedEphemerons).start)), pLimiT = (((GIV(unscannedEphemerons).top)) - (wordSize())); p <= pLimiT; p += 1) {
		/* begin keyOfEphemeron: */
		assert((isNonImmediate(longAt(p)))
		 && (isEphemeron(longAt(p))));
		key = longAt(((longAt(p)) + (BaseHeaderSize)) + (0 << 2));
		if (((key & 3) != 0)
		 || (isMarked(key))) {
			return 0;
		}
	}
	return 1;
}


/*	for Cogit */

sqInt
argumentCountOfClosure(sqInt closurePointer)
{
    sqInt oop;

	/* begin quickFetchInteger:ofObject: */
	oop = longAt((closurePointer + (BaseHeaderSize)) + (ClosureNumArgsIndex << 2));
	assert((oop & 1));
	return (oop >> 1);
}

sqInt
argumentCountOfMethodHeader(sqInt header)
{
	return (((usqInt) header) >> 25) & 15;
}

sqInt
argumentCountOf(sqInt methodPointer)
{
	return (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 25) & 15;
}


/*	Class puns are class indices not used by any class. There is an entry
	for the pun that refers to the notional class of objects with this class
	index. But because the index doesn't match the class it won't show up
	in allInstances, hence hiding the object with a pun as its class index.
	The puns occupy indices 16 through 31. */

static sqInt
arrayClassIndexPun(void)
{
	return 16;
}

sqInt
arrayFormat(void)
{
	return 2;
}


/*	Return the address of first indexable field of resulting array object, or
	fail if
	the instance variable does not contain an indexable bytes or words object. */
/*	Note: May be called by translated primitive code. */

void *
arrayValueOf(sqInt arrayOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (((arrayOop & 3) == 0)
	 && (((((usqInt) (longAt(arrayOop))) >> 24) & 0x1F) > 5)) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Returns an integer object */

static sqInt
asciiOfCharacter(sqInt characterObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((characterObj & 3) == 2) {
		return (CharacterTable == null
			? ((usqInt) (((unsigned long) characterObj))) >> 1
			: longAt((characterObj + (BaseHeaderSize)) + (CharacterValueIndex << 2)));
	}
	GIV(primFailCode) = PrimErrBadArgument;
	return ConstZero;
}

void
assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp)
{
	assertValidExecutionPointersimbarline(lip, lifp, lisp, !0, __LINE__);
}

static void
assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assertl(inInterpreter, ln);
	assertl(GIV(stackPage) == (stackPageFor(lfp)), ln);
	assertl(GIV(stackPage) == (mostRecentlyUsedPage()), ln);
	/* begin assertValidStackLimits: */
	assertl((GIV(stackLimit) == ((GIV(stackPage)->realStackLimit)))
	 || (GIV(stackLimit) == (((char *) (((usqInt) -1))))), ln);
	assertl((((GIV(stackPage)->stackLimit)) == ((GIV(stackPage)->realStackLimit)))
	 || (((GIV(stackPage)->stackLimit)) == (((char *) (((usqInt) -1))))), ln);
	assertl(lfp < ((GIV(stackPage)->baseAddress)), ln);
	assertl(lsp < lfp, ln);
	assertl(lfp > lsp, ln);
	assertl(lsp >= (((GIV(stackPage)->realStackLimit)) - (stackLimitOffset())), ln);
	assertl((lfp - lsp) < LargeContextSize, ln);
	assertl(validInstructionPointerinFrame(lip, lfp), ln);
	assertl((frameIsBlockActivation(lfp))
	 || ((pushedReceiverOrClosureOfFrame(lfp)) == (frameReceiver(lfp))), ln);
	assertl(GIV(method) == (frameMethod(lfp)), ln);
	
#  if MULTIPLEBYTECODESETS
	assertl((methodUsesAlternateBytecodeSet(GIV(method))) == (bytecodeSetSelector == 256), ln);

#  endif /* MULTIPLEBYTECODESETS */

}


/*	Answer the appropriate become effect flags for objOop, or 0 if none.
	The effect flags affect how much work is done after the become in
	following forwarding pointers. */

static sqInt
becomeEffectFlagsFor(sqInt objOop)
{
	return (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) <= 5
		? BecamePointerObjectFlag
		: (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) >= 24
				? BecameCompiledMethodFlag
				: 0));
}

sqInt
becomewith(sqInt array1, sqInt array2)
{
	return becomewithtwoWaycopyHash(array1, array2, 1, 1);
}


/*	All references to each object in array1 are swapped with all references to
	the corresponding object in array2. That is, all pointers to one object
	are replaced
	with with pointers to the other. The arguments must be arrays of the same
	length. 
	Answers PrimNoErr if the primitive succeeds, otherwise a relevant error
	code. 
 */
/*	Implementation: Uses lazy forwarding to defer updating references until
	message send.
 */

static sqInt
becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt becomeEffectsFlags = 0;
    sqInt c;
    sqInt classTablePage;
    sqInt clone1;
    sqInt clone2;
    sqInt contextSize;
    sqInt contextSize1;
    sqInt ec;
    sqInt effectsFlags;
    sqInt effectsFlags1;
    sqInt fieldOffset;
    sqInt fieldOffset1;
    sqInt first;
    sqInt fmt;
    sqInt fmt1;
    sqInt hash;
    sqInt hash1;
    sqInt hash2;
    sqInt hash3;
    sqInt hash4;
    sqInt hashBits;
    sqInt headerTemp;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    sqInt i3;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt iLimiT11;
    sqInt iLimiT2;
    sqInt last;
    sqInt list;
    sqInt m;
    sqInt newObj1;
    sqInt newObj2;
    sqInt next;
    sqInt numLiterals;
    sqInt numLiterals1;
    sqInt o1ClassIndex;
    sqInt o1HasYoung;
    sqInt o2ClassIndex;
    sqInt o2HasYoung;
    sqInt obj1;
    sqInt obj11;
    sqInt obj2;
    sqInt obj21;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt objOop5;
    sqInt oop;
    sqInt oop1;
    sqInt procLists;
    sqInt referent;
    sqInt referent1;
    sqInt referent11;
    sqInt referent2;
    sqInt referent21;
    sqInt referent3;
    sqInt referent31;
    sqInt referent4;
    sqInt referent5;
    sqInt s;
    sqInt sched;
    sqInt schedAssoc;
    sqInt sp;
    sqInt sp1;
    sqInt temp1;
    sqInt temp2;
    sqInt tmp;

	assert(becomeEffectsFlags == 0);
	if ((checkForLeaks & 4) != 0) {
		/* begin runLeakCheckerForFullGC: */
		runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(1, 0);
		/* return self */
	}
	if (!(((array1 & 3) == 0)
		 && (((((usqInt) (longAt(array1))) >> 24) & 0x1F) == 2))) {
		return PrimErrBadReceiver;
	}
	if (!((((array2 & 3) == 0)
 && (((((usqInt) (longAt(array2))) >> 24) & 0x1F) == 2))
		 && ((numSlotsOf(array1)) == (numSlotsOf(array2))))) {
		return PrimErrBadArgument;
	}
	if (twoWayFlag
	 || (copyHashFlag)) {
		/* begin containsOnlyValidBecomeObjects:and: */
		/* begin lastPointerOf: */
		fmt = (((usqInt) (longAt(array1))) >> 24) & 0x1F;
		assert(fmt != (forwardedFormat()));
		if (fmt <= 5) {
			if ((fmt == 3)
			 && (((longAt(array1)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */

				/* begin fetchStackPointerOf: */
				sp = longAt((array1 + (BaseHeaderSize)) + (StackPointerIndex << 2));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l4;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array1)));
				contextSize = (sp >> 1);
			l4:	/* end fetchStackPointerOf: */;
				fieldOffset = (CtxtTempFrameStart + contextSize) * BytesPerOop;
				goto l5;
			}
			fieldOffset = (((numSlotsOf(array1)) - 1) * BytesPerOop) + (BaseHeaderSize);
			goto l5;
		}
		if (fmt < 24) {
			fieldOffset = 0;
			goto l5;
		}
		numLiterals = 
#    if MULTIPLEBYTECODESETS
			((((sqInt) (longAt((array1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
						? (((usqInt) (longAt((array1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
						: (((usqInt) (longAt((array1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#    else /* MULTIPLEBYTECODESETS */
			(((usqInt) (longAt((array1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#    endif /* MULTIPLEBYTECODESETS */
			;
		fieldOffset = (((numLiterals + LiteralStart) - 1) * BytesPerOop) + (BaseHeaderSize);
	l5:	/* end lastPointerOf: */;

		/* same size as array2 */

		effectsFlags = 0;
		while (fieldOffset >= (BaseHeaderSize)) {
			oop = longAt(array1 + fieldOffset);
			if ((oop & 3) != 0) {
				ec = PrimErrInappropriate;
				goto l2;
			}
			if (((longAt(oop)) & 0x3FFFFF) == 8) {
				/* begin followForwarded: */
				assert(isForwarded(oop));
				referent = longAt((oop + (BaseHeaderSize)) + (0 << 2));
				while (((referent & 3) == 0)
				 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
					referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
				}
				oop = referent;
				longAtput(array1 + fieldOffset, oop);
			}
			if (((((usqInt) (longAt(oop))) >> 30) & 1) != 0) {
				ec = PrimErrObjectIsPinned;
				goto l2;
			}
			effectsFlags = effectsFlags | (becomeEffectFlagsFor(oop));
			oop = longAt(array2 + fieldOffset);
			if ((oop & 3) != 0) {
				ec = PrimErrInappropriate;
				goto l2;
			}
			if (((longAt(oop)) & 0x3FFFFF) == 8) {
				/* begin followForwarded: */
				assert(isForwarded(oop));
				referent1 = longAt((oop + (BaseHeaderSize)) + (0 << 2));
				while (((referent1 & 3) == 0)
				 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
					referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
				}
				oop = referent1;
				longAtput(array2 + fieldOffset, oop);
			}
			if (((((usqInt) (longAt(oop))) >> 30) & 1) != 0) {
				ec = PrimErrObjectIsPinned;
				goto l2;
			}
			effectsFlags = effectsFlags | (becomeEffectFlagsFor(oop));
			fieldOffset -= BytesPerOop;
		}
		becomeEffectsFlags = effectsFlags;
		ec = 0;
	l2:	/* end containsOnlyValidBecomeObjects:and: */;
	}
	else {
		followForwardedObjectFieldstoDepth(array2, 0);
		/* begin containsOnlyValidBecomeObjects: */
		/* begin lastPointerOf: */
		fmt1 = (((usqInt) (longAt(array1))) >> 24) & 0x1F;
		assert(fmt1 != (forwardedFormat()));
		if (fmt1 <= 5) {
			if ((fmt1 == 3)
			 && (((longAt(array1)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */

				/* begin fetchStackPointerOf: */
				sp1 = longAt((array1 + (BaseHeaderSize)) + (StackPointerIndex << 2));
				if (!((sp1 & 1))) {
					contextSize1 = 0;
					goto l6;
				}
				assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(array1)));
				contextSize1 = (sp1 >> 1);
			l6:	/* end fetchStackPointerOf: */;
				fieldOffset1 = (CtxtTempFrameStart + contextSize1) * BytesPerOop;
				goto l7;
			}
			fieldOffset1 = (((numSlotsOf(array1)) - 1) * BytesPerOop) + (BaseHeaderSize);
			goto l7;
		}
		if (fmt1 < 24) {
			fieldOffset1 = 0;
			goto l7;
		}
		numLiterals1 = 
#    if MULTIPLEBYTECODESETS
			((((sqInt) (longAt((array1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
						? (((usqInt) (longAt((array1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
						: (((usqInt) (longAt((array1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#    else /* MULTIPLEBYTECODESETS */
			(((usqInt) (longAt((array1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#    endif /* MULTIPLEBYTECODESETS */
			;
		fieldOffset1 = (((numLiterals1 + LiteralStart) - 1) * BytesPerOop) + (BaseHeaderSize);
	l7:	/* end lastPointerOf: */;

		/* same size as array2 */

		effectsFlags1 = 0;
		while (fieldOffset1 >= (BaseHeaderSize)) {
			oop1 = longAt(array1 + fieldOffset1);
			if ((oop1 & 3) != 0) {
				ec = PrimErrInappropriate;
				goto l3;
			}
			if (((longAt(oop1)) & 0x3FFFFF) == 8) {
				/* begin followForwarded: */
				assert(isForwarded(oop1));
				referent2 = longAt((oop1 + (BaseHeaderSize)) + (0 << 2));
				while (((referent2 & 3) == 0)
				 && (((longAt(referent2)) & 0x3FFFFF) == 8)) {
					referent2 = longAt((referent2 + (BaseHeaderSize)) + (0 << 2));
				}
				oop1 = referent2;
				longAtput(array1 + fieldOffset1, oop1);
			}
			if (((((usqInt) (longAt(oop1))) >> 30) & 1) != 0) {
				ec = PrimErrObjectIsPinned;
				goto l3;
			}
			effectsFlags1 = effectsFlags1 | (becomeEffectFlagsFor(oop1));
			fieldOffset1 -= BytesPerOop;
		}
		becomeEffectsFlags = effectsFlags1;
		ec = 0;
	l3:	/* end containsOnlyValidBecomeObjects: */;
	}
	if (ec != 0) {
		return ec;
	}
	/* begin preBecomeAction */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	if (twoWayFlag) {
		/* begin innerBecomeObjectsIn:and:copyHash: */
		for (i3 = 0, iLimiT2 = ((numSlotsOf(array1)) - 1); i3 <= iLimiT2; i3 += 1) {
			obj11 = longAt((array1 + (BaseHeaderSize)) + (i3 << 2));
			obj21 = longAt((array2 + (BaseHeaderSize)) + (i3 << 2));
			/* begin doBecome:and:copyHash: */
			if (!copyHashFlag) {

				/* in-lined
				   clasIndex := (self isInClassTable: obj) ifTrue: [self rawHashBitsOf: obj] ifFalse: [0]
				   for speed. */

				/* begin rawHashBitsOf: */
				flag("endianness");
				o1ClassIndex = (longAt(obj11 + 4)) & 0x3FFFFF;
				if ((o1ClassIndex != 0)
				 && ((classAtIndex(o1ClassIndex)) != obj11)) {
					o1ClassIndex = 0;
				}
				/* begin rawHashBitsOf: */
				flag("endianness");
				o2ClassIndex = (longAt(obj21 + 4)) & 0x3FFFFF;
				if ((o2ClassIndex != 0)
				 && ((classAtIndex(o2ClassIndex)) != obj21)) {
					o2ClassIndex = 0;
				}
			}
			if ((numSlotsOf(obj11)) == (numSlotsOf(obj21))) {
				/* begin inPlaceBecome:and:copyHashFlag: */
				assert((numSlotsOf(obj11)) == (numSlotsOf(obj21)));
				temp1 = ((((usqInt) (longAt(obj11))) >> 29) & 1) != 0;
				temp2 = ((((usqInt) (longAt(obj21))) >> 29) & 1) != 0;
				headerTemp = longLongAt(obj11);
				longLongAtput(obj11, longLongAt(obj21));
				longLongAtput(obj21, headerTemp);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(obj11, (temp1
					? (longAt(obj11)) | (1 << 29)
					: (longAt(obj11)) & (~(1 << 29))));
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(obj21, (temp2
					? (longAt(obj21)) | (1 << 29)
					: (longAt(obj21)) & (~(1 << 29))));
				if (!copyHashFlag) {
					/* begin rawHashBitsOf: */
					flag("endianness");
					temp1 = (longAt(obj11 + 4)) & 0x3FFFFF;
					/* begin setHashBitsOf:to: */
					/* begin rawHashBitsOf: */
					flag("endianness");
					hash = (longAt(obj21 + 4)) & 0x3FFFFF;
					flag("endianness");
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
					longAtput(obj11 + 4, ((((longAt(obj11 + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash);
					/* begin setHashBitsOf:to: */
					flag("endianness");
					assert(((temp1 >= 0) && (temp1 <= (identityHashHalfWordMask()))));
					longAtput(obj21 + 4, ((((longAt(obj21 + 4)) | 0x3FFFFF) - 0x3FFFFF)) + temp1);
				}
				o1HasYoung = (o2HasYoung = 0);
				for (i11 = 0, iLimiT11 = ((numSlotsOf(obj11)) - 1); i11 <= iLimiT11; i11 += 1) {
					temp1 = longAt((obj11 + (BaseHeaderSize)) + (i11 << 2));
					temp2 = longAt((obj21 + (BaseHeaderSize)) + (i11 << 2));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(obj11)));
					longAtput((obj11 + (BaseHeaderSize)) + (i11 << 2), temp2);
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(obj21)));
					longAtput((obj21 + (BaseHeaderSize)) + (i11 << 2), temp1);
					if (((temp2 & 3) == 0)
					 && ((((usqInt) temp2)) < (((usqInt) GIV(newSpaceLimit))))) {
						o1HasYoung = 1;
					}
					if (((temp1 & 3) == 0)
					 && ((((usqInt) temp1)) < (((usqInt) GIV(newSpaceLimit))))) {
						o2HasYoung = 1;
					}
				}
				if (isOldObject(obj11)) {
					if (o1HasYoung) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(obj11))) >> 29) & 1) != 0)) {
							remember(obj11);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(obj11, (longAt(obj11)) | (1 << 29));
						}
					}
				}
				if (isOldObject(obj21)) {
					if (o2HasYoung) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(obj21))) >> 29) & 1) != 0)) {
							remember(obj21);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(obj21, (longAt(obj21)) | (1 << 29));
						}
					}
				}
			}
			else {
				/* begin outOfPlaceBecome:and:copyHashFlag: */
				clone1 = (((longAt(obj11)) & 0x3FFFFF) == ClassMethodContextCompactIndex
					? cloneContext(obj11)
					: clone(obj11));
				clone2 = (((longAt(obj21)) & 0x3FFFFF) == ClassMethodContextCompactIndex
					? cloneContext(obj21)
					: clone(obj21));
				if (copyHashFlag) {
					/* begin setHashBitsOf:to: */
					/* begin rawHashBitsOf: */
					flag("endianness");
					hash4 = (longAt(obj21 + 4)) & 0x3FFFFF;
					flag("endianness");
					assert(((hash4 >= 0) && (hash4 <= (identityHashHalfWordMask()))));
					longAtput(clone1 + 4, ((((longAt(clone1 + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash4);
					/* begin setHashBitsOf:to: */
					/* begin rawHashBitsOf: */
					flag("endianness");
					hash1 = (longAt(obj11 + 4)) & 0x3FFFFF;
					flag("endianness");
					assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
					longAtput(clone2 + 4, ((((longAt(clone2 + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash1);
				}
				else {
					/* begin setHashBitsOf:to: */
					/* begin rawHashBitsOf: */
					flag("endianness");
					hash2 = (longAt(obj11 + 4)) & 0x3FFFFF;
					flag("endianness");
					assert(((hash2 >= 0) && (hash2 <= (identityHashHalfWordMask()))));
					longAtput(clone1 + 4, ((((longAt(clone1 + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash2);
					/* begin setHashBitsOf:to: */
					/* begin rawHashBitsOf: */
					flag("endianness");
					hash3 = (longAt(obj21 + 4)) & 0x3FFFFF;
					flag("endianness");
					assert(((hash3 >= 0) && (hash3 <= (identityHashHalfWordMask()))));
					longAtput(clone2 + 4, ((((longAt(clone2 + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash3);
				}
				/* begin forward:to: */
				/* begin setFormatOf:to: */
				assert(((7 >= 0) && (7 <= (formatMask()))));
				flag("endianness");
				longAtput(obj11, ((longAt(obj11)) & (~(0x1F << 24))) + (7 << 24));
				/* begin setClassIndexOf:to: */
				assert(((8 >= 0) && (8 <= (classIndexMask()))));
				flag("endianness");
				longAtput(obj11, ((longAt(obj11)) & (~0x3FFFFF)) + 8);
				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(obj11));
				assert(!(isOopForwarded(clone2)));
				if (isOldObject(obj11)) {

					/* most stores into young objects */

					if (((clone2 & 3) == 0)
					 && ((((usqInt) clone2)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(obj11))) >> 29) & 1) != 0)) {
							remember(obj11);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(obj11, (longAt(obj11)) | (1 << 29));
						}
					}
				}
				longAtput((obj11 + (BaseHeaderSize)) + (0 << 2), clone2);
				/* begin forward:to: */
				/* begin setFormatOf:to: */
				assert(((7 >= 0) && (7 <= (formatMask()))));
				flag("endianness");
				longAtput(obj21, ((longAt(obj21)) & (~(0x1F << 24))) + (7 << 24));
				/* begin setClassIndexOf:to: */
				assert(((8 >= 0) && (8 <= (classIndexMask()))));
				flag("endianness");
				longAtput(obj21, ((longAt(obj21)) & (~0x3FFFFF)) + 8);
				/* begin storePointer:ofForwarder:withValue: */
				assert(isForwarded(obj21));
				assert(!(isOopForwarded(clone1)));
				if (isOldObject(obj21)) {

					/* most stores into young objects */

					if (((clone1 & 3) == 0)
					 && ((((usqInt) clone1)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(obj21))) >> 29) & 1) != 0)) {
							remember(obj21);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(obj21, (longAt(obj21)) | (1 << 29));
						}
					}
				}
				longAtput((obj21 + (BaseHeaderSize)) + (0 << 2), clone1);
			}
			if (copyHashFlag) {
				goto l8;
			}
			if (o1ClassIndex != 0) {
				if (o2ClassIndex != 0) {

					/* both were in the table; just swap entries */

					/* begin classAtIndex: */
					assert((o1ClassIndex <= (tagMask()))
					 || (o1ClassIndex >= (arrayClassIndexPun())));
					classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) o1ClassIndex) >> 10) << 2));
					if (classTablePage == GIV(nilObj)) {
						tmp = null;
						goto l9;
					}
					tmp = longAt((classTablePage + (BaseHeaderSize)) + ((o1ClassIndex & ((1 << 10) - 1)) << 2));
				l9:	/* end classAtIndex: */;
					classAtIndexput(o1ClassIndex, obj21);
					classAtIndexput(o2ClassIndex, tmp);
				}
				else {

					/* o2 wasn't in the table; put it there */

					/* begin followForwarded: */
					assert(isForwarded(obj21));
					referent21 = longAt((obj21 + (BaseHeaderSize)) + (0 << 2));
					while (((referent21 & 3) == 0)
					 && (((longAt(referent21)) & 0x3FFFFF) == 8)) {
						referent21 = longAt((referent21 + (BaseHeaderSize)) + (0 << 2));
					}
					newObj2 = referent21;
					assert((rawHashBitsOf(newObj2)) == 0);
					/* begin setHashBitsOf:to: */
					flag("endianness");
					assert(((o1ClassIndex >= 0) && (o1ClassIndex <= (identityHashHalfWordMask()))));
					longAtput(newObj2 + 4, ((((longAt(newObj2 + 4)) | 0x3FFFFF) - 0x3FFFFF)) + o1ClassIndex);
					classAtIndexput(o1ClassIndex, newObj2);
				}
			}
			else {
				if (o2ClassIndex != 0) {
					/* begin followForwarded: */
					assert(isForwarded(obj11));
					referent31 = longAt((obj11 + (BaseHeaderSize)) + (0 << 2));
					while (((referent31 & 3) == 0)
					 && (((longAt(referent31)) & 0x3FFFFF) == 8)) {
						referent31 = longAt((referent31 + (BaseHeaderSize)) + (0 << 2));
					}
					newObj1 = referent31;
					assert((rawHashBitsOf(newObj1)) == 0);
					/* begin setHashBitsOf:to: */
					flag("endianness");
					assert(((o2ClassIndex >= 0) && (o2ClassIndex <= (identityHashHalfWordMask()))));
					longAtput(newObj1 + 4, ((((longAt(newObj1 + 4)) | 0x3FFFFF) - 0x3FFFFF)) + o2ClassIndex);
					classAtIndexput(o2ClassIndex, newObj1);
				}
			}
		l8:	/* end doBecome:and:copyHash: */;
			if (((longAt(obj11)) & 0x3FFFFF) == 8) {
				/* begin followForwarded: */
				assert(isForwarded(obj11));
				referent5 = longAt((obj11 + (BaseHeaderSize)) + (0 << 2));
				while (((referent5 & 3) == 0)
				 && (((longAt(referent5)) & 0x3FFFFF) == 8)) {
					referent5 = longAt((referent5 + (BaseHeaderSize)) + (0 << 2));
				}
				obj11 = referent5;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(array1)));
				if (isOldObject(array1)) {

					/* most stores into young objects */

					if (((obj11 & 3) == 0)
					 && ((((usqInt) obj11)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(array1))) >> 29) & 1) != 0)) {
							remember(array1);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(array1, (longAt(array1)) | (1 << 29));
						}
					}
				}
				longAtput((array1 + (BaseHeaderSize)) + (i3 << 2), obj11);
			}
			if (((longAt(obj21)) & 0x3FFFFF) == 8) {
				/* begin followForwarded: */
				assert(isForwarded(obj21));
				referent11 = longAt((obj21 + (BaseHeaderSize)) + (0 << 2));
				while (((referent11 & 3) == 0)
				 && (((longAt(referent11)) & 0x3FFFFF) == 8)) {
					referent11 = longAt((referent11 + (BaseHeaderSize)) + (0 << 2));
				}
				obj21 = referent11;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(array2)));
				if (isOldObject(array2)) {

					/* most stores into young objects */

					if (((obj21 & 3) == 0)
					 && ((((usqInt) obj21)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(array2))) >> 29) & 1) != 0)) {
							remember(array2);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(array2, (longAt(array2)) | (1 << 29));
						}
					}
				}
				longAtput((array2 + (BaseHeaderSize)) + (i3 << 2), obj21);
			}
		}
	}
	else {
		/* begin innerBecomeObjectsIn:to:copyHash: */
		for (i2 = 0, iLimiT1 = ((numSlotsOf(array1)) - 1); i2 <= iLimiT1; i2 += 1) {
			obj1 = longAt((array1 + (BaseHeaderSize)) + (i2 << 2));
			obj2 = longAt((array2 + (BaseHeaderSize)) + (i2 << 2));
			/* begin doBecome:to:copyHash: */
			/* begin forward:to: */
			/* begin setFormatOf:to: */
			assert(((7 >= 0) && (7 <= (formatMask()))));
			flag("endianness");
			longAtput(obj1, ((longAt(obj1)) & (~(0x1F << 24))) + (7 << 24));
			/* begin setClassIndexOf:to: */
			assert(((8 >= 0) && (8 <= (classIndexMask()))));
			flag("endianness");
			longAtput(obj1, ((longAt(obj1)) & (~0x3FFFFF)) + 8);
			/* begin storePointer:ofForwarder:withValue: */
			assert(isForwarded(obj1));
			assert(!(isOopForwarded(obj2)));
			if (isOldObject(obj1)) {

				/* most stores into young objects */

				if (((obj2 & 3) == 0)
				 && ((((usqInt) obj2)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(obj1))) >> 29) & 1) != 0)) {
						remember(obj1);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(obj1, (longAt(obj1)) | (1 << 29));
					}
				}
			}
			longAtput((obj1 + (BaseHeaderSize)) + (0 << 2), obj2);
			if (copyHashFlag) {
				/* begin rawHashBitsOf: */
				flag("endianness");
				hashBits = (longAt(obj2 + 4)) & 0x3FFFFF;
				if ((classAtIndex(hashBits)) != obj2) {
					/* begin rawHashBitsOf: */
					flag("endianness");
					hashBits = (longAt(obj1 + 4)) & 0x3FFFFF;
					/* begin setHashBitsOf:to: */
					flag("endianness");
					assert(((hashBits >= 0) && (hashBits <= (identityHashHalfWordMask()))));
					longAtput(obj2 + 4, ((((longAt(obj2 + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hashBits);
				}
			}
			if (((longAt(obj1)) & 0x3FFFFF) == 8) {
				/* begin followForwarded: */
				assert(isForwarded(obj1));
				referent4 = longAt((obj1 + (BaseHeaderSize)) + (0 << 2));
				while (((referent4 & 3) == 0)
				 && (((longAt(referent4)) & 0x3FFFFF) == 8)) {
					referent4 = longAt((referent4 + (BaseHeaderSize)) + (0 << 2));
				}
				obj1 = referent4;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(array1)));
				if (isOldObject(array1)) {

					/* most stores into young objects */

					if (((obj1 & 3) == 0)
					 && ((((usqInt) obj1)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(array1))) >> 29) & 1) != 0)) {
							remember(array1);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(array1, (longAt(array1)) | (1 << 29));
						}
					}
				}
				longAtput((array1 + (BaseHeaderSize)) + (i2 << 2), obj1);
			}
			assert(!(isForwarded(obj2)));
		}
	}
	/* begin postBecomeScanClassTable */
	assert(validClassTableRootPages());
	if (!(becomeEffectsFlags & (BecamePointerObjectFlag + BecameCompiledMethodFlag))) {
		goto l1;
	}
	postBecomeOrCompactScanClassTable(becomeEffectsFlags);
l1:	/* end postBecomeScanClassTable */;
	/* begin postBecomeAction: */
	if (becomeEffectsFlags != 0) {
		followForwardingPointersInStackZone(becomeEffectsFlags);
		if (becomeEffectsFlags & BecameCompiledMethodFlag) {
			/* begin followForwardedMethodsInMethodCache */
			for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
				c = GIV(methodCache)[i + MethodCacheClass];
				s = GIV(methodCache)[i + MethodCacheSelector];
				m = GIV(methodCache)[i + MethodCacheMethod];
				if ((c != 0)
				 && ((s != 0)
				 && ((m != 0)
				 && (((m & 3) == 0)
				 && (((longAt(m)) & 0x3FFFFF) == 8))))) {
					/* begin followForwarded: */
					assert(isForwarded(m));
					referent3 = longAt((m + (BaseHeaderSize)) + (0 << 2));
					while (((referent3 & 3) == 0)
					 && (((longAt(referent3)) & 0x3FFFFF) == 8)) {
						referent3 = longAt((referent3 + (BaseHeaderSize)) + (0 << 2));
					}
					m = referent3;
					GIV(methodCache)[i + MethodCacheMethod] = m;
				}
			}
		}
		/* begin followForwardedMethods */
		/* begin followForwardingPointersInScheduler */

		/* the GC follows pointers in the special objects array for us. */

		schedAssoc = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2));
		assert(!(isForwarded(schedAssoc)));
		/* begin followNonImmediateField:ofObject: */
		objOop4 = longAt((schedAssoc + (BaseHeaderSize)) + (ValueIndex << 2));
		assert(isNonImmediate(objOop4));
		if (((longAt(objOop4)) & 0x3FFFFF) == 8) {
			objOop4 = fixFollowedFieldofObjectwithInitialValue(ValueIndex, schedAssoc, objOop4);
		}
		sched = objOop4;
		/* begin followNonImmediateField:ofObject: */
		objOop5 = longAt((sched + (BaseHeaderSize)) + (ProcessListsIndex << 2));
		assert(isNonImmediate(objOop5));
		if (((longAt(objOop5)) & 0x3FFFFF) == 8) {
			objOop5 = fixFollowedFieldofObjectwithInitialValue(ProcessListsIndex, sched, objOop5);
		}
		procLists = objOop5;
		for (i1 = 0, iLimiT = ((numSlotsOf(procLists)) - 1); i1 <= iLimiT; i1 += 1) {
			/* begin followNonImmediateField:ofObject: */
			objOop1 = longAt((procLists + (BaseHeaderSize)) + (i1 << 2));
			assert(isNonImmediate(objOop1));
			if (((longAt(objOop1)) & 0x3FFFFF) == 8) {
				objOop1 = fixFollowedFieldofObjectwithInitialValue(i1, procLists, objOop1);
			}
			list = objOop1;
			/* begin followNonImmediateField:ofObject: */
			objOop2 = longAt((list + (BaseHeaderSize)) + (FirstLinkIndex << 2));
			assert(isNonImmediate(objOop2));
			if (((longAt(objOop2)) & 0x3FFFFF) == 8) {
				objOop2 = fixFollowedFieldofObjectwithInitialValue(FirstLinkIndex, list, objOop2);
			}
			first = objOop2;
			/* begin followNonImmediateField:ofObject: */
			objOop3 = longAt((list + (BaseHeaderSize)) + (LastLinkIndex << 2));
			assert(isNonImmediate(objOop3));
			if (((longAt(objOop3)) & 0x3FFFFF) == 8) {
				objOop3 = fixFollowedFieldofObjectwithInitialValue(LastLinkIndex, list, objOop3);
			}
			last = objOop3;
			while (first != last) {
				/* begin followNonImmediateField:ofObject: */
				objOop = longAt((first + (BaseHeaderSize)) + (NextLinkIndex << 2));
				assert(isNonImmediate(objOop));
				if (((longAt(objOop)) & 0x3FFFFF) == 8) {
					objOop = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, first, objOop);
				}
				next = objOop;
				first = next;
			}
		}
	}
	becomeEffectsFlags = 0;
	if ((checkForLeaks & 4) != 0) {
		/* begin runLeakCheckerForFullGC: */
		runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(1, 0);
		/* return self */
	}
	return PrimNoErr;
}


/*	If this object is old, mark it as a root (because a new object
	may be stored into it). */

void
beRootIfOld(sqInt oop)
{
	if (isOldObject(oop)) {

		/* No, oop is an old object */

		/* begin possibleRootStoreInto: */
		if (!(((((usqInt) (longAt(oop))) >> 29) & 1) != 0)) {
			remember(oop);
			/* begin setIsRememberedOf:to: */
			flag("endianness");
			longAtput(oop, (longAt(oop)) | (1 << 29));
		}
	}
}

static sqInt
bitsSetInFreeSpaceMaskForAllFreeLists(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;

	for (i = 0, iLimiT = (32 - 1); i <= iLimiT; i += 1) {
		if (((GIV(freeLists)[i]) != 0)
		 && (((1 << i) & GIV(freeListsMask)) == 0)) {
			return 0;
		}
	}
	return 1;
}


/*	convert true and false (Smalltalk) to true or false(C) */

sqInt
booleanValueOf(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (obj == GIV(trueObj)) {
		return 1;
	}
	if (obj == GIV(falseObj)) {
		return 0;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */

	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	return null;
}

static sqInt
bootstrapping(void)
{
	return 0;
}

static sqInt
bridgeAt(sqInt segIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    usqInt numSlots;

	/* begin objectStartingAt: */
	address = (((((&(GIV(segments)[segIndex])))->segSize)) + ((((&(GIV(segments)[segIndex])))->segStart))) - (2 * (BaseHeaderSize));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	return (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
}

static sqInt
bridgeFor(SpurSegmentInfo *aSegment)
{
    sqInt address;
    usqInt numSlots;

	/* begin objectStartingAt: */
	address = (((aSegment->segSize)) + ((aSegment->segStart))) - (2 * (BaseHeaderSize));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	return (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
}


/*	Create a bridge from aSegment to the next segment,
	or create a terminating bridge if there is no next segment. */

static void
bridgeFromto(SpurSegmentInfo *aSegment, SpurSegmentInfo *nextSegmentOrNil)
{
    sqInt bridgeSpan;
    sqInt clifton;
    usqInt segEnd;

	segEnd = ((aSegment->segSize)) + ((aSegment->segStart));

	/* clifton is where the Avon bridge begins... */

	clifton = segEnd - (2 * (BaseHeaderSize));
	bridgeSpan = (nextSegmentOrNil == null
		? 2 * (BaseHeaderSize)
		: (((nextSegmentOrNil->segStart)) - segEnd) + (2 * (BaseHeaderSize)));
	initSegmentBridgeWithBytesat(bridgeSpan, clifton);
	assert((addressAfter(objectStartingAt(clifton))) == ((nextSegmentOrNil == null
	? segLimit(aSegment)
	: (nextSegmentOrNil->segStart))));
}

static sqInt
bridgeSize(void)
{
	return 2 * (BaseHeaderSize);
}

static sqInt
byteFormatMask(void)
{
	return 24;
}


/*	Answer the number of indexable bytes in the given object.
	Does not adjust contexts by stackPointer.
	This is basically a special copy of lengthOf: for BitBlt. But it is also
	whoorishly used for the Cogit. */

sqInt
byteLengthOf(sqInt objOop)
{
    sqInt fmt;
    sqInt numBytes;

	fmt = (((usqInt) (longAt(objOop))) >> 24) & 0x1F;
	numBytes = (numSlotsOf(objOop)) << 2;
	if (fmt <= 9) {
		return numBytes;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		return numBytes - (fmt & 7);
	}
	if (fmt >= 12) {
		return numBytes - ((fmt & 3) << 1);
	}
	return numBytes - ((fmt & 1) << 2);
}

sqInt
byteSizeOf(sqInt oop)
{
    sqInt format;

	if ((oop & 3) != 0) {
		return 0;
	}
	format = (((usqInt) (longAt(oop))) >> 24) & 0x1F;
	if (format < 9) {
		return (numSlotsOf(oop)) << 2;
	}
	if (format >= 16) {
		return ((numSlotsOf(oop)) << 2) - (format & 7);
	}
	if (format >= 12) {
		return ((numSlotsOf(oop)) << 2) - ((format & 3) << 1);
	}
	if (format >= 10) {
		return ((numSlotsOf(oop)) << 2) - ((format & 1) << 2);
	}
	return (numSlotsOf(oop)) << 2;
}


/*	Answer the given integer with its bytes in the reverse order. */

sqInt
byteSwapped(sqInt w)
{
	return ((((((usqInt) w >> 24)) & Byte0Mask) + ((((usqInt) w >> 8)) & Byte1Mask)) + ((((usqInt) w << 8)) & Byte2Mask)) + ((((usqInt) w << 24)) & Byte3Mask);
}


/*	Answer the total number of bytes in an object including header and
	possible overflow size header.
 */

static usqLong
bytesInObject(sqInt objOop)
{
    usqInt headerNumSlots;
    sqInt numSlots;

	/* begin rawNumSlotsOf: */
	flag("endianness");
	headerNumSlots = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
	numSlots = (headerNumSlots == 0xFF
		? longAt(objOop - (BaseHeaderSize))
		: (headerNumSlots == 0
				? 1
				: headerNumSlots));
	return ((numSlots + (numSlots & 1)) << 2) + ((headerNumSlots == 0xFF
	? (BaseHeaderSize) + (BaseHeaderSize)
	: BaseHeaderSize));
}

static sqInt
bytesPerOop(void)
{
	return BytesPerOop;
}


/*	Re-enter the interpreter for executing a callback */
/*	For now, do not allow a callback unless we're in a primitiveResponse */

EXPORT(sqInt)
callbackEnter(sqInt *callbackID)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt xArray;

	if (!(asserta(primitiveFunctionPointer != 0))) {
		return 0;
	}
	if (!(asserta(GIV(jmpDepth) < MaxJumpBuf))) {
		return 0;
	}

	/* Suspend the currently active process */

	GIV(jmpDepth) += 1;
	GIV(suspendedCallbacks)[GIV(jmpDepth)] = (longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2)));
	GIV(suspendedMethods)[GIV(jmpDepth)] = GIV(newMethod);
	/* begin signalExternalSemaphores */
	xArray = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ExternalObjectsArray << 2));
	doSignalExternalSemaphores(stSizeOf(xArray));
	if ((GIV(suspendedCallbacks)[GIV(jmpDepth)]) == (longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2)))) {
		transferTo(wakeHighestPriority());
	}
	forceInterruptCheck();
	if ((setjmp(GIV(jmpBuf)[GIV(jmpDepth)])) == 0) {

		/* Fill in callbackID */

		callbackID[0] = GIV(jmpDepth);
		interpret();
	}
	putToSleepyieldingIf(longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2)), GIV(preemptionYields));
	transferTo(GIV(suspendedCallbacks)[GIV(jmpDepth)]);

	/* see comment above */

	GIV(newMethod) = GIV(suspendedMethods)[GIV(jmpDepth)];
	GIV(argumentCount) = (((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 25) & 15;

	/* clean out the primPops etc since we'll be returning via primitive */

	GIV(jmpDepth) -= 1;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	return 1;
}


/*	Leave from a previous callback */
/*	For now, do not allow a callback return unless we're in a
	primitiveResponse 
 */

EXPORT(sqInt)
callbackLeave(sqInt cbID)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(asserta(primitiveFunctionPointer != 0))) {
		return 0;
	}
	if (!(cbID == GIV(jmpDepth))) {
		return 0;
	}
	if (cbID < 1) {
		return 0;
	}
	longjmp(GIV(jmpBuf)[GIV(jmpDepth)], 1);
	return null;
}


/*	Context switch should not be allowed on every method activation. In
	particular the implementation of ensure: and ifCurtailed: depends on there
	being no
	suspension point on failing primitive 198 (primitiveMarkUnwindMethod).
	slowPrimitiveResponse states
	``N.B. This means there is no suspension point on primitive failure
	which methods such as ensure: and ifCurtailed: rely on.''
	Rather than prevent context switch on all primitives but the ones we
	really need
	to be suspension points (primitiveSignal et al) we choose to allow context
	switch for all but primitiveMarkUnwindMethod. */

sqInt
canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt firstBytecode;
    sqInt primBits;
    sqInt primitiveIndex;

	primitiveIndex = 
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader)) < 0
				? (methodHeader & (65536 << SmallIntegerShift)
						? ((firstBytecode = (theMethod + ((LiteralStart + ((((usqInt) methodHeader) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
							(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
						: 0)
				: ((primBits = ((usqInt) methodHeader) >> 1),
					(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#  else /* MULTIPLEBYTECODESETS */
		((primBits = ((usqInt) methodHeader) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#  endif /* MULTIPLEBYTECODESETS */
		;
	return 
#  if 1
		primitiveIndex != 198
#  else /* 1 */
		(primitiveIndex == 0)
			 || ((((primitiveIndex >= 85) && (primitiveIndex <= 88)))
			 || (primitiveIndex == 167))
#  endif /* 1 */
		;
}


/*	Attempt to change the class of the receiver to the argument given that the
	format of the receiver matches the format of the argument. If successful,
	answer 0, otherwise answer an error code indicating the reason for
	failure. 
	Fail if the format of the receiver is incompatible with the format of the
	argument, or if the argument is a fixed class and the receiver's size
	differs from the size
	that an instance of the argument should have. */

static sqInt
changeClassOfto(sqInt rcvr, sqInt argClass)
{
    sqInt classFormat;
    sqInt classIndex;
    sqInt fixedFields;
    sqInt fmt;
    sqInt instBytes;
    sqInt instFormat;
    sqInt newFormat;
    sqInt normalizedInstFormat;
    sqInt numBytes;

	classFormat = ((longAt((argClass + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1);
	fixedFields = classFormat & ((1 << 16) - 1);
	instFormat = (((usqInt) (longAt(rcvr))) >> 24) & 0x1F;
	/* begin classFormatForInstanceFormat: */
	if (instFormat < 10) {
		normalizedInstFormat = instFormat;
		goto l2;
	}
	if (instFormat >= 16) {
		normalizedInstFormat = instFormat & -8;
		goto l2;
	}
	normalizedInstFormat = (instFormat >= 12
		? instFormat & -4
		: instFormat & -2);
l2:	/* end classFormatForInstanceFormat: */;
	if (normalizedInstFormat == classFormat) {
		newFormat = instFormat;
	}
	else {
		if (normalizedInstFormat <= 5) {
			if (classFormat > 5) {
				return PrimErrInappropriate;
			}
			if ((numSlotsOf(rcvr)) < fixedFields) {
				return PrimErrBadReceiver;
			}
			newFormat = classFormat;
		}
		else {
			/* begin byteLengthOf: */
			fmt = (((usqInt) (longAt(rcvr))) >> 24) & 0x1F;
			numBytes = (numSlotsOf(rcvr)) << 2;
			if (fmt <= 9) {
				instBytes = numBytes;
				goto l1;
			}
			if (fmt >= 16) {

				/* bytes, including CompiledMethod */

				instBytes = numBytes - (fmt & 7);
				goto l1;
			}
			if (fmt >= 12) {
				instBytes = numBytes - ((fmt & 3) << 1);
				goto l1;
			}
			instBytes = numBytes - ((fmt & 1) << 2);
		l1:	/* end byteLengthOf: */;
			
			switch (normalizedInstFormat) {
			case 9:
				if ((classFormat < 9)
				 || (classFormat >= 24)) {
					return PrimErrInappropriate;
				}
				newFormat = classFormat;
				break;
			case 10:
				if ((classFormat < 9)
				 || (classFormat >= 24)) {
					return PrimErrInappropriate;
				}
				if ((classFormat == 9)
				 && (instBytes & 1)) {
					return PrimErrBadReceiver;
				}
				newFormat = classFormat;
				break;
			case 12:
				if ((classFormat < 9)
				 || (classFormat >= 24)) {
					return PrimErrInappropriate;
				}
				
				switch (classFormat) {
				case 9:
					if (instBytes & 3) {
						return PrimErrBadReceiver;
					}
					newFormat = classFormat;
					break;
				case 10:
					if (instBytes & 1) {
						return PrimErrBadReceiver;
					}
					newFormat = classFormat;
					break;
				case 16:
					newFormat = classFormat + ((4 - instBytes) & 3);
					break;
				default:
					error("Case not found and no otherwise clause");
				}
				break;
			case 16:
				if ((classFormat < 9)
				 || (classFormat >= 24)) {
					return PrimErrInappropriate;
				}
				
				switch (classFormat) {
				case 9:
					if (instBytes & 7) {
						return PrimErrBadReceiver;
					}
					break;
				case 10:
					if (instBytes & 3) {
						return PrimErrBadReceiver;
					}
					break;
				case 12:
					if (instBytes & 1) {
						return PrimErrBadReceiver;
					}
					break;
				default:
					error("Case not found and no otherwise clause");
				}
				newFormat = classFormat;
				break;
			case 24:
				if (classFormat != 24) {
					return PrimErrInappropriate;
				}
				newFormat = instFormat;
				break;
			default:
				error("Case not found and no otherwise clause");
			}
		}
	}
	if (((classIndex = ensureBehaviorHash(argClass))) < 0) {
		return -classIndex;
	}
	/* begin setFormatOf:to: */
	assert(((newFormat >= 0) && (newFormat <= (formatMask()))));
	flag("endianness");
	longAtput(rcvr, ((longAt(rcvr)) & (~(0x1F << 24))) + (newFormat << 24));
	/* begin setClassIndexOf:to: */
	assert(((classIndex >= 0) && (classIndex <= (classIndexMask()))));
	flag("endianness");
	longAtput(rcvr, ((longAt(rcvr)) & (~0x3FFFFF)) + classIndex);
	return 0;
}


/*	Above ObjectMemory, arg must lie in range 0-255! */

sqInt
characterForAscii(sqInt ascii)
{
    sqInt objOop;

	return (CharacterTable == null
		? (ascii << 2) + 2
		: (/* begin fetchPointer:ofObject: */
			/* begin characterTable */
			error("shouldNotImplement"),
			longAt((objOop + (BaseHeaderSize)) + (ascii << 2))));
}

sqInt
characterObjectOf(sqInt characterCode)
{
	return (characterCode << 2) + 2;
}

void
characterTable(void)
{
	error("shouldNotImplement");
}

sqInt
characterTag(void)
{
	return 2;
}


/*	Immediate characters are unsigned */

sqInt
characterValueOf(sqInt oop)
{
	return ((usqInt) (((usqInt)oop))) >> 2;
}


/*	Ensure that all accessible objects in the heap are okay. */

sqInt
checkAllAccessibleObjectsOkay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt ok;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	ok = 1;
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		ok = ok && (checkOkayFields(objOop1));


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		ok = ok && (checkOkayFields(objOop1));


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			ok = ok && (checkOkayFields(objOop11));

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
	return ok;
}


/*	This is a no-op in the StackVM */

static sqInt
checkCodeIntegrity(sqInt fullGCFlag)
{
	return 1;
}


/*	Check for a hit of the longRunningPrimitive probe and if so attempt to
	signal the
	longRunningPrimitiveCheckSemaphore. Answer if a process switch occurred as
	a result. */

static sqInt
checkDeliveryOfLongRunningPrimitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((GIV(longRunningPrimitiveCheckSemaphore) != null)
	 && (GIV(longRunningPrimitiveSignalUndelivered)))) {

		/* but not yet delivered */

		GIV(longRunningPrimitiveSignalUndelivered) = 0;

		/* Signal the LRP check semaphore if it is present */

		GIV(longRunningPrimitiveGCUsecs) = ((GIV(gcStartUsecs) < GIV(longRunningPrimitiveStopUsecs))
		 && (GIV(statGCEndUsecs) > GIV(longRunningPrimitiveStartUsecs))
			? GIV(statGCEndUsecs) - GIV(gcStartUsecs)
			: 0);
		return synchronousSignal(GIV(longRunningPrimitiveCheckSemaphore));
	}
	return 0;
}


/*	Note: May be called by translated primitive code. */

sqInt
checkedIntegerValueOf(sqInt intOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Assumes zero-based array indexing. */

sqInt
checkedLongAt(sqInt byteAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt) byteAddress)) < (((usqInt) GIV(newSpaceLimit))))
 && ((((usqInt) byteAddress)) >= (((usqInt) GIV(newSpaceStart)))))
		 || (isInSegments(byteAddress)))) {
		warning("checkedLongAt bad address");
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return longAt(byteAddress);
}


/*	Check for possible interrupts and handle one if necessary.
	Answer if a context switch has occurred. */

static sqInt
checkForEventsMayContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong now;
    sqInt sema;
    sqInt switched;


	/* restore the stackLimit if it has been smashed. */

	GIV(statCheckForEvents) += 1;
	/* begin restoreStackLimit */
	(GIV(stackPage)->stackLimit = (GIV(stackPage)->realStackLimit));
	GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	ioSynchronousCheckForEvents();
	/* begin checkCogCompiledCodeCompactionCalledFor */
	if (GIV(needGCFlag)) {

		/* sufficientSpaceAfterGC: runs the incremental GC and
		   then, if not enough space is available, the fullGC. */

		if (!(sufficientSpaceAfterGC(0))) {
			setSignalLowSpaceFlagAndSaveProcess();
		}
	}
	if (!mayContextSwitch) {
		return 0;
	}
	switched = 0;
	if ((GIV(profileProcess) != GIV(nilObj))
	 || ((GIV(nextProfileTick) > 0)
	 && ((ioHighResClock()) >= GIV(nextProfileTick)))) {

		/* Take a sample (if not already done so) for the profiler if it is active.  This
		   must be done before any of the synchronousSignals below or else we will
		   attribute a pause in ioRelinquishProcessor to the newly activated process. */

		if (GIV(profileProcess) == GIV(nilObj)) {
			GIV(profileProcess) = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
			GIV(profileMethod) = GIV(nilObj);
		}
		if ((GIV(profileSemaphore) != GIV(nilObj))
		 && (synchronousSignal(GIV(profileSemaphore)))) {
			switched = 1;
		}
		GIV(nextProfileTick) = 0;
	}
	if (checkDeliveryOfLongRunningPrimitiveSignal()) {
		switched = 1;
	}
	if (GIV(signalLowSpace)) {
		GIV(signalLowSpace) = 0;
		sema = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheLowSpaceSemaphore << 2));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (((now = ioUTCMicroseconds())) >= GIV(nextPollUsecs)) {
		GIV(statIOProcessEvents) += 1;
		ioProcessEvents();

		/* msecs to wait before next call to ioProcessEvents.  Note that strictly
		   speaking we might need to update 'now' at this point since
		   ioProcessEvents could take a very long time on some platforms */

		GIV(nextPollUsecs) = now + 20000;
	}

	if (GIV(interruptPending)) {

		/* reset interrupt flag */

		GIV(interruptPending) = 0;
		sema = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheInterruptSemaphore << 2));
		if ((sema != GIV(nilObj))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
	}
	if (GIV(nextWakeupUsecs) != 0) {
		if (now >= GIV(nextWakeupUsecs)) {

			/* set timer interrupt to 0 for 'no timer' */

			GIV(nextWakeupUsecs) = 0;
			sema = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheTimerSemaphore << 2));
			if ((sema != GIV(nilObj))
			 && (synchronousSignal(sema))) {
				switched = 1;
			}
		}
	}
	if (GIV(pendingFinalizationSignals) > 0) {
		sema = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheFinalizationSemaphore << 2));
		if ((((longAt(sema)) & 0x3FFFFF) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2)))))
		 && (synchronousSignal(sema))) {
			switched = 1;
		}
		GIV(pendingFinalizationSignals) = 0;
	}
	if (signalExternalSemaphores()) {
		switched = 1;
	}
	return switched;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Scan all objects in the heap checking that every
	pointer points to a header. Scan the rootTable, remapBuffer and
	extraRootTable checking that every entry is a pointer to a header.
	Check that the number of roots is correct and that all rootTable
	entries have their rootBit set. Answer if all checks pass. */

static sqInt
checkHeapIntegrity(sqInt excludeUnmarkedNewSpaceObjs)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex2;
    sqInt classIndex3;
    sqInt classOop;
    sqInt classTablePage;
    sqInt classTablePage1;
    sqInt classTablePage2;
    sqInt containsYoung;
    sqInt fi;
    sqInt fieldOop;
    sqInt i;
    sqInt i1;
    sqInt limit;
    sqInt numRememberedRootsInHeap;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt ok;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt ptr;
    sqInt ri;

	ok = 1;
	numRememberedRootsInHeap = 0;
	/* begin allHeapEntitiesDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop)) < (((usqInt) limit))) {
		if (!((((longAt(objOop)) & 0x3FFFFF) == 0)
			 || ((isYoungObject(objOop))
			 && ((!(isMarked(objOop)))
			 && (excludeUnmarkedNewSpaceObjs))))) {
			containsYoung = 0;
			if (((((usqInt) (longAt(objOop))) >> 29) & 1) != 0) {
				numRememberedRootsInHeap += 1;
				if (!(isInRememberedSet(objOop))) {
					print("remembered object ");
					printHex(objOop);
					print(" is not in remembered table");
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
			}
			if (((longAt(objOop)) & 0x3FFFFF) == 8) {
				fieldOop = longAt((objOop + (BaseHeaderSize)) + (0 << 2));
				if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
					print("object leak in forwarder ");
					printHex(objOop);
					print(" to unmapped ");
					printHex(fieldOop);
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
				if (((fieldOop & 3) == 0)
				 && ((((usqInt) fieldOop)) < (((usqInt) GIV(newSpaceLimit))))) {
					containsYoung = 1;
				}
			}
			else {
				/* begin classAtIndex: */
				classIndex1 = (classIndex = (longAt(objOop)) & 0x3FFFFF);
				assert((classIndex1 <= (tagMask()))
				 || (classIndex1 >= (arrayClassIndexPun())));
				classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex1) >> 10) << 2));
				if (classTablePage == GIV(nilObj)) {
					classOop = null;
					goto l4;
				}
				classOop = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex1 & ((1 << 10) - 1)) << 2));
			l4:	/* end classAtIndex: */;
				if (((classOop == null)
 || (classOop == GIV(nilObj)))
				 && (!((objOop == (objectAfter(GIV(trueObj))))
 || (((numSlotsOfAny(objOop)) == ObjStackPageSlots)
 && (isValidObjStackPagemyIndex(objOop, longAt((objOop + (BaseHeaderSize)) + (ObjStackMyx << 2)))))))) {
					print("object leak in ");
					printHex(objOop);
					print(" invalid class index ");
					printHex(classIndex);
					print(" -> ");
					print((classOop == null
						? "nil"
						: "nilObj"));
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
				for (ptr = (BaseHeaderSize); ptr <= (lastPointerOf(objOop)); ptr += BytesPerOop) {
					fieldOop = longAt(objOop + ptr);
					if ((fieldOop & 3) == 0) {
						fi = (ptr - (BaseHeaderSize)) / (wordSize());
						if ((fieldOop & ((wordSize()) - 1)) != 0) {
							print("misaligned oop in ");
							printHex(objOop);
							print(" @ ");
							printNum(fi);
							print(" = ");
							printHex(fieldOop);
							/* begin cr */
							printf("\n");
							/* begin eek */
							ok = 0;
						}
						else {
							if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
								print("object leak in ");
								printHex(objOop);
								print(" @ ");
								printNum(fi);
								print(" = ");
								printHex(fieldOop);
								/* begin cr */
								printf("\n");
								/* begin eek */
								ok = 0;
							}
							if ((((fieldOop & 3) == 0)
 && ((((usqInt) fieldOop)) < (((usqInt) GIV(newSpaceLimit)))))
							 && ((((usqInt) fieldOop)) >= (((usqInt) GIV(newSpaceStart))))) {
								containsYoung = 1;
							}
						}
					}
				}
			}
			if (containsYoung
			 && (!(((objOop & 3) == 0)
 && ((((usqInt) objOop)) < (((usqInt) GIV(newSpaceLimit))))))) {
				if (!(((((usqInt) (longAt(objOop))) >> 29) & 1) != 0)) {
					print("unremembered object ");
					printHex(objOop);
					print(" contains young oop(s)");
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = objectAfterlimit(objOop, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop)) < (((usqInt) GIV(freeStart)))) {
		if (!((((longAt(objOop)) & 0x3FFFFF) == 0)
			 || ((isYoungObject(objOop))
			 && ((!(isMarked(objOop)))
			 && (excludeUnmarkedNewSpaceObjs))))) {
			containsYoung = 0;
			if (((((usqInt) (longAt(objOop))) >> 29) & 1) != 0) {
				numRememberedRootsInHeap += 1;
				if (!(isInRememberedSet(objOop))) {
					print("remembered object ");
					printHex(objOop);
					print(" is not in remembered table");
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
			}
			if (((longAt(objOop)) & 0x3FFFFF) == 8) {
				fieldOop = longAt((objOop + (BaseHeaderSize)) + (0 << 2));
				if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
					print("object leak in forwarder ");
					printHex(objOop);
					print(" to unmapped ");
					printHex(fieldOop);
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
				if (((fieldOop & 3) == 0)
				 && ((((usqInt) fieldOop)) < (((usqInt) GIV(newSpaceLimit))))) {
					containsYoung = 1;
				}
			}
			else {
				/* begin classAtIndex: */
				classIndex2 = (classIndex = (longAt(objOop)) & 0x3FFFFF);
				assert((classIndex2 <= (tagMask()))
				 || (classIndex2 >= (arrayClassIndexPun())));
				classTablePage1 = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex2) >> 10) << 2));
				if (classTablePage1 == GIV(nilObj)) {
					classOop = null;
					goto l5;
				}
				classOop = longAt((classTablePage1 + (BaseHeaderSize)) + ((classIndex2 & ((1 << 10) - 1)) << 2));
			l5:	/* end classAtIndex: */;
				if (((classOop == null)
 || (classOop == GIV(nilObj)))
				 && (!((objOop == (objectAfter(GIV(trueObj))))
 || (((numSlotsOfAny(objOop)) == ObjStackPageSlots)
 && (isValidObjStackPagemyIndex(objOop, longAt((objOop + (BaseHeaderSize)) + (ObjStackMyx << 2)))))))) {
					print("object leak in ");
					printHex(objOop);
					print(" invalid class index ");
					printHex(classIndex);
					print(" -> ");
					print((classOop == null
						? "nil"
						: "nilObj"));
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
				for (ptr = (BaseHeaderSize); ptr <= (lastPointerOf(objOop)); ptr += BytesPerOop) {
					fieldOop = longAt(objOop + ptr);
					if ((fieldOop & 3) == 0) {
						fi = (ptr - (BaseHeaderSize)) / (wordSize());
						if ((fieldOop & ((wordSize()) - 1)) != 0) {
							print("misaligned oop in ");
							printHex(objOop);
							print(" @ ");
							printNum(fi);
							print(" = ");
							printHex(fieldOop);
							/* begin cr */
							printf("\n");
							/* begin eek */
							ok = 0;
						}
						else {
							if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
								print("object leak in ");
								printHex(objOop);
								print(" @ ");
								printNum(fi);
								print(" = ");
								printHex(fieldOop);
								/* begin cr */
								printf("\n");
								/* begin eek */
								ok = 0;
							}
							if ((((fieldOop & 3) == 0)
 && ((((usqInt) fieldOop)) < (((usqInt) GIV(newSpaceLimit)))))
							 && ((((usqInt) fieldOop)) >= (((usqInt) GIV(newSpaceStart))))) {
								containsYoung = 1;
							}
						}
					}
				}
			}
			if (containsYoung
			 && (!(((objOop & 3) == 0)
 && ((((usqInt) objOop)) < (((usqInt) GIV(newSpaceLimit))))))) {
				if (!(((((usqInt) (longAt(objOop))) >> 29) & 1) != 0)) {
					print("unremembered object ");
					printHex(objOop);
					print(" contains young oop(s)");
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = objectAfterlimit(objOop, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop1)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop1)) != 0);
		if (!((((longAt(objOop1)) & 0x3FFFFF) == 0)
			 || ((isYoungObject(objOop1))
			 && ((!(isMarked(objOop1)))
			 && (excludeUnmarkedNewSpaceObjs))))) {
			containsYoung = 0;
			if (((((usqInt) (longAt(objOop1))) >> 29) & 1) != 0) {
				numRememberedRootsInHeap += 1;
				if (!(isInRememberedSet(objOop1))) {
					print("remembered object ");
					printHex(objOop1);
					print(" is not in remembered table");
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
			}
			if (((longAt(objOop1)) & 0x3FFFFF) == 8) {
				fieldOop = longAt((objOop1 + (BaseHeaderSize)) + (0 << 2));
				if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
					print("object leak in forwarder ");
					printHex(objOop1);
					print(" to unmapped ");
					printHex(fieldOop);
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
				if (((fieldOop & 3) == 0)
				 && ((((usqInt) fieldOop)) < (((usqInt) GIV(newSpaceLimit))))) {
					containsYoung = 1;
				}
			}
			else {
				/* begin classAtIndex: */
				classIndex3 = (classIndex = (longAt(objOop1)) & 0x3FFFFF);
				assert((classIndex3 <= (tagMask()))
				 || (classIndex3 >= (arrayClassIndexPun())));
				classTablePage2 = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex3) >> 10) << 2));
				if (classTablePage2 == GIV(nilObj)) {
					classOop = null;
					goto l6;
				}
				classOop = longAt((classTablePage2 + (BaseHeaderSize)) + ((classIndex3 & ((1 << 10) - 1)) << 2));
			l6:	/* end classAtIndex: */;
				if (((classOop == null)
 || (classOop == GIV(nilObj)))
				 && (!((objOop1 == (objectAfter(GIV(trueObj))))
 || (((numSlotsOfAny(objOop1)) == ObjStackPageSlots)
 && (isValidObjStackPagemyIndex(objOop1, longAt((objOop1 + (BaseHeaderSize)) + (ObjStackMyx << 2)))))))) {
					print("object leak in ");
					printHex(objOop1);
					print(" invalid class index ");
					printHex(classIndex);
					print(" -> ");
					print((classOop == null
						? "nil"
						: "nilObj"));
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
				for (ptr = (BaseHeaderSize); ptr <= (lastPointerOf(objOop1)); ptr += BytesPerOop) {
					fieldOop = longAt(objOop1 + ptr);
					if ((fieldOop & 3) == 0) {
						fi = (ptr - (BaseHeaderSize)) / (wordSize());
						if ((fieldOop & ((wordSize()) - 1)) != 0) {
							print("misaligned oop in ");
							printHex(objOop1);
							print(" @ ");
							printNum(fi);
							print(" = ");
							printHex(fieldOop);
							/* begin cr */
							printf("\n");
							/* begin eek */
							ok = 0;
						}
						else {
							if ((heapMapAtWord(pointerForOop(fieldOop))) == 0) {
								print("object leak in ");
								printHex(objOop1);
								print(" @ ");
								printNum(fi);
								print(" = ");
								printHex(fieldOop);
								/* begin cr */
								printf("\n");
								/* begin eek */
								ok = 0;
							}
							if ((((fieldOop & 3) == 0)
 && ((((usqInt) fieldOop)) < (((usqInt) GIV(newSpaceLimit)))))
							 && ((((usqInt) fieldOop)) >= (((usqInt) GIV(newSpaceStart))))) {
								containsYoung = 1;
							}
						}
					}
				}
			}
			if (containsYoung
			 && (!(((objOop1 & 3) == 0)
 && ((((usqInt) objOop1)) < (((usqInt) GIV(newSpaceLimit))))))) {
				if (!(((((usqInt) (longAt(objOop1))) >> 29) & 1) != 0)) {
					print("unremembered object ");
					printHex(objOop1);
					print(" contains young oop(s)");
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
			}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(endOfMemory));
	}
	
	
	if (numRememberedRootsInHeap != (rememberedSetSize())) {
		print("root count mismatch. #heap roots ");
		printNum(numRememberedRootsInHeap);
		print("; #roots ");
		printNum(rememberedSetSize());
		/* begin cr */
		printf("\n");
		/* begin eek */
		flag("no support for remembered set overflow yet");
	}
	/* begin rememberedSetWithIndexDo: */
	for (i1 = 0; i1 < GIV(rememberedSetSize); i1 += 1) {
		if (((GIV(rememberedSet)[i1]) & ((wordSize()) - 1)) != 0) {
			print("misaligned oop in remembered set @ ");
			printNum(i1);
			print(" = ");
			printHex(GIV(rememberedSet)[i1]);
			/* begin cr */
			printf("\n");
			/* begin eek */
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(GIV(rememberedSet)[i1]))) == 0) {
				print("object leak in remembered set @ ");
				printNum(i1);
				print(" = ");
				printHex(GIV(rememberedSet)[i1]);
				/* begin cr */
				printf("\n");
				/* begin eek */
				ok = 0;
			}
			else {
				if ((((GIV(rememberedSet)[i1]) & 3) == 0)
				 && ((((usqInt) (GIV(rememberedSet)[i1]))) < (((usqInt) GIV(newSpaceLimit))))) {
					print("non-root in remembered set @ ");
					printNum(i1);
					print(" = ");
					printHex(GIV(rememberedSet)[i1]);
					/* begin cr */
					printf("\n");
					/* begin eek */
					ok = 0;
				}
			}
		}

	}
	for (ri = 1; ri <= GIV(remapBufferCount); ri += 1) {
		obj = GIV(remapBuffer)[ri];
		if ((obj & ((wordSize()) - 1)) != 0) {
			print("misaligned remapRoot @ ");
			printNum(ri);
			print(" = ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			/* begin eek */
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in remapRoots @ ");
				printNum(ri);
				print(" = ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				/* begin eek */
				ok = 0;
			}
		}
	}
	for (ri = 1; ri <= GIV(extraRootCount); ri += 1) {
		obj = (GIV(extraRoots)[ri])[0];
		if ((obj & ((wordSize()) - 1)) != 0) {
			print("misaligned extraRoot @ ");
			printNum(ri);
			print(" => ");
			printHex(obj);
			/* begin cr */
			printf("\n");
			/* begin eek */
			ok = 0;
		}
		else {
			if ((heapMapAtWord(pointerForOop(obj))) == 0) {
				print("object leak in extraRoots @ ");
				printNum(ri);
				print(" => ");
				printHex(obj);
				/* begin cr */
				printf("\n");
				/* begin eek */
				ok = 0;
			}
		}
	}
	return ok;
}


/*	Read and verify the image file version number and return true if the the
	given image file needs to be byte-swapped. As a side effect, position the
	file stream just after the version number of the image header. This code
	prints a warning and does a hard-exit if it cannot find a valid version
	number. 
 */
/*	This code is based on C code by Ian Piumarta. */

static sqInt
checkImageVersionFromstartingAt(sqImageFile  f, squeakFileOffsetType  imageOffset)
{
    sqInt firstVersion;
    sqInt version;


	/* check the version number */

	sqImageFileSeek(f, imageOffset);
	version = (firstVersion = getLongFromFileswap(f, 0));
	if ((version == (imageFormatVersion()))
	 || (version == ((BytesPerWord == 4
	? 6504
	: 68002)))) {
		return 0;
	}
	sqImageFileSeek(f, imageOffset);
	version = getLongFromFileswap(f, 1);
	if ((version == (imageFormatVersion()))
	 || (version == ((BytesPerWord == 4
	? 6504
	: 68002)))) {
		return 1;
	}
	if (imageOffset == 0) {

		/* try skipping the first 512 bytes (prepended by certain Mac file transfer utilities) */

		sqImageFileSeek(f, 512);
		version = getLongFromFileswap(f, 0);
		if ((version == (imageFormatVersion()))
		 || (version == ((BytesPerWord == 4
	? 6504
	: 68002)))) {
			return 0;
		}
		sqImageFileSeek(f, 512);
		version = getLongFromFileswap(f, 1);
		if ((version == (imageFormatVersion()))
		 || (version == ((BytesPerWord == 4
	? 6504
	: 68002)))) {
			return 1;
		}
	}
	print("This interpreter (vers. ");
	printNum(imageFormatVersion());
	print(") cannot read image file (vers. ");
	printNum(firstVersion);
	print(").");
	/* begin cr */
	printf("\n");
	print("Press CR to quit...");
	getchar();
	ioExitWithErrorCode(1);
	return 0;
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccessibleObjects has set a bit at each
	object's header. Check that all oops in the interpreter's state
	points to a header. Answer if all checks pass. */

static sqInt
checkInterpreterIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ok;

	ok = 1;
	if (!(checkOopIntegritynamed(GIV(specialObjectsOop), "specialObjectsOop"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(newMethod), "newMethod"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(profileProcess), "profileProcess"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(profileMethod), "profileMethod"))) {
		ok = 0;
	}
	if (!(checkOopIntegritynamed(GIV(profileSemaphore), "profileSemaphore"))) {
		ok = 0;
	}
	if (!(GIV(tempOop) == 0)) {
		if (!(checkOopIntegritynamed(GIV(tempOop), "tempOop"))) {
			ok = 0;
		}
	}
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		if (!(checkOopIntegritynamedindex(GIV(suspendedCallbacks)[i], "suspendedCallbacks", i))) {
			ok = 0;
		}
		if (!(checkOopIntegritynamedindex(GIV(suspendedMethods)[i], "suspendedMethods", i))) {
			ok = 0;
		}
	}
	
	return ok;
}


/*	Another version of isWidowedContext: for debugging.
	This will not bereave a widowed context. */

static sqInt
checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt frameCtxt;
    sqInt index;
    char *limitFP;
    sqInt referent;
    char *theFP;
    StackPage *thePage;
    sqInt value;

	if (!((((aContext & 3) == 0)
 && (((longAt(aContext)) & 0x3FFFFF) == ClassMethodContextCompactIndex))
		 && (((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)))) {
		return 0;
	}
	/* begin frameOfMarriedContext: */
	value = longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	theFP = pointerForOop(value - 1);
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	limitFP = ((thePage == GIV(stackPage))
	 && (currentFP != null)
		? currentFP
		: (thePage->headFP));
	if (!((theFP >= limitFP)
		 && ((isNonImmediate(((sqInt)(frameCallerFP(theFP)))))
		 && (((withSmallIntegerTags(frameCallerFP(theFP))) == (longAt((aContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2))))
		 && ((byteAt((theFP + FoxFrameFlags) + 2)) != 0))))) {
		return 0;
	}
	frameCtxt = longAt(theFP + FoxThisContext);
	if (((longAt(frameCtxt)) & 0x3FFFFF) == 8) {
		/* begin followForwarded: */
		assert(isForwarded(frameCtxt));
		referent = longAt((frameCtxt + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		frameCtxt = referent;
	}
	return frameCtxt == aContext;
}


/*	Check if the argument is an ok object.
	If this is a pointers object, check that its fields are all okay oops. */

static sqInt
checkOkayFields(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldOop;
    sqInt hasYoung;
    sqInt i;

	if ((oop == null)
	 || (oop == 0)) {
		return 1;
	}
	if ((oop & 1)) {
		return 1;
	}
	if (!(checkOkayOop(oop))) {
		return 0;
	}
	if (!(checkOopHasOkayClass(oop))) {
		return 0;
	}
	if (!((((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 5)
		 || (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 24))) {
		return 1;
	}
	hasYoung = (!1)
	 && (isYoung(fetchClassOfNonImm(oop)));
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 24) {
		i = ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((oop + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((oop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((oop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((oop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) - 1;
	}
	else {
		if (((oop & 3) == 0)
		 && (((longAt(oop)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
			i = (CtxtTempFrameStart + (fetchStackPointerOf(oop))) - 1;
		}
		else {
			i = (lengthOfformat(oop, (((usqInt) (longAt(oop))) >> 24) & 0x1F)) - 1;
		}
	}
	while (i >= 0) {
		fieldOop = longAt((oop + (BaseHeaderSize)) + (i << 2));
		if (!((fieldOop & 1))) {
			hasYoung = hasYoung
			 || (((fieldOop & 3) == 0)
			 && ((((usqInt) fieldOop)) < (((usqInt) GIV(newSpaceLimit)))));
			if (!(checkOkayOop(fieldOop))) {
				return 0;
			}
			if (!(checkOopHasOkayClass(fieldOop))) {
				return 0;
			}
		}
		i -= 1;
	}
	if (hasYoung) {
		/* begin checkOkayYoungReferrer: */
		if ((((usqInt) oop)) < (((usqInt) GIV(newSpaceLimit)))) {
			return 1;
		}
		if (!(((((usqInt) (longAt(oop))) >> 29) & 1) != 0)) {
			print("remembered bit is not set in ");
			printHex(oop);
			/* begin cr */
			printf("\n");
			return 0;
		}
		if (isInRememberedSet(oop)) {
			return 1;
		}
		printHex(oop);
		print(" has remembered bit set but is not in remembered set");
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}

sqInt
checkOkayInterpreterObjects(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt ok;
    sqInt oop;
    sqInt oopOrZero;

	ok = 1;
	ok = ok && (checkOkayFields(GIV(nilObj)));
	ok = ok && (checkOkayFields(GIV(falseObj)));
	ok = ok && (checkOkayFields(GIV(trueObj)));
	ok = ok && (checkOkayFields(GIV(specialObjectsOop)));
	ok = ok && (checkOkayFields(GIV(messageSelector)));
	ok = ok && (checkOkayFields(GIV(newMethod)));
	ok = ok && (checkOkayFields(GIV(lkupClass)));
	for (i = 0; i < MethodCacheEntries; i += MethodCacheEntrySize) {
		oopOrZero = GIV(methodCache)[i + MethodCacheSelector];
		if (!(oopOrZero == 0)) {
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheSelector]));
			
			ok = ok && (checkOkayFields(GIV(methodCache)[i + MethodCacheMethod]));
		}
	}
	for (i = 1, iLimiT = GIV(remapBufferCount); i <= iLimiT; i += 1) {
		oop = GIV(remapBuffer)[i];
		if (!((oop & 1))) {
			ok = ok && (checkOkayFields(oop));
		}
	}
	ok = ok && (checkOkayStackZone(writeBack));
	return ok;
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
	Answer true if OK. Otherwise print reason and answer false. */

sqInt
checkOkayOop(usqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;


	/* address and size checks */

	if ((oop & 3) != 0) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		print("oop ");
		printHex(oop);
		print(" is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		print("oop ");
		printHex(oop);
		print(" size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = (longAt(oop)) & 0x3FFFFF)) >= 16)) {
		print("oop ");
		printHex(oop);
		print(" is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((rawNumSlotsOf(oop)) == 0xFF)
	 && ((rawNumSlotsOf(oop - (BaseHeaderSize))) != 0xFF)) {
		print("oop ");
		printHex(oop);
		print(" header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = (((usqInt) (longAt(oop))) >> 24) & 0x1F;
	if ((fmt == 6) || (fmt == 8)) {
		print("oop ");
		printHex(oop);
		print(" has an unknown format type");
		return 0;
	}
	if ((fmt == 7) != (classIndex == 8)) {
		print("oop ");
		printHex(oop);
		print(" has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (1 << 22) || (1 << (22 + 32));
	if (((longLongAt(oop)) & unusedBits) != 0) {
		print("oop ");
		printHex(oop);
		print(" has some unused header bits set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = ((1 << 0x1F) || (1 << 30)) || (1 << 29);
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		print("oop ");
		printHex(oop);
		print(" has some header bits unused in young objects set; should be zero");
		return 0;
	}
	return 1;
}

static sqInt
checkOkayStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt ok;
    sqInt oop;
    char *theFP;
    char *theSP;

	theSP = (thePage->headSP);
	theFP = (thePage->headFP);

	/* Skip the instruction pointer on top of stack of inactive pages. */

	ok = 1;
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		/* begin frameReceiverOffset: */
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((oop & 1))) {
				ok = ok && (checkOkayFields(oop));
			}
			theSP += BytesPerWord;
		}
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			ok = ok && (checkOkayFields(longAt(theFP + FoxThisContext)));
		}
		ok = ok && (checkOkayFields(longAt(theFP + FoxMethod)));
		if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */

	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((oop & 1))) {
			ok = ok && (checkOkayFields(oop));
		}
		theSP += BytesPerWord;
	}
	return ok;
}


/*	Check that all objects in the stack zone are okay */

static sqInt
checkOkayStackZone(sqInt writeBack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ok;
    StackPage *thePage;

	if (writeBack) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			ok = ok && (checkOkayStackPage(thePage));
		}
	}
	return ok;
}


/*	Attempt to verify that the given obj has a reasonable behavior. The class
	must be a
	valid, non-integer oop and must not be nilObj. It must be a pointers
	object with three
	or more fields. Finally, the instance specification field of the behavior
	must match that
	of the instance. If OK answer true. If not, print reason and answer false. */

sqInt
checkOopHasOkayClass(usqInt obj)
{
    usqInt objClass;
    sqInt objFormat;

	if (!(checkOkayOop(obj))) {
		return 0;
	}
	objClass = ((usqInt) (fetchClassOfNonImm(obj)));
	if ((objClass & 3) != 0) {
		print("obj ");
		printHex(obj);
		print(" an immediate is not a valid class or behavior");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (!(okayOop(objClass))) {
		print("obj ");
		printHex(obj);
		print(" class obj is not ok");
		/* begin cr */
		printf("\n");
		return 0;
	}
	if (!((((((usqInt) (longAt(objClass))) >> 24) & 0x1F) <= 5)
		 && ((numSlotsOf(objClass)) >= 3))) {
		print("obj ");
		printHex(obj);
		print(" a class (behavior) must be a pointers object of size >= 3");
		/* begin cr */
		printf("\n");
		return 0;
	}
	objFormat = (((obj & 3) == 0)
	 && (((((usqInt) (longAt(obj))) >> 24) & 0x1F) >= 16)
		? ((((((usqInt) (longAt(obj))) >> 24) & 0x1F) | 7) - 7)
		: (((usqInt) (longAt(obj))) >> 24) & 0x1F);
	if (((((usqInt) (((longAt((objClass + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) != objFormat) {
		print("obj ");
		printHex(obj);
		print(" and its class (behavior) formats differ");
		/* begin cr */
		printf("\n");
		return 0;
	}
	return 1;
}

static sqInt
checkOopIntegritynamed(sqInt obj, char *name)
{
	if ((heapMapAtWord(pointerForOop(obj))) != 0) {
		return 1;
	}
	print(name);
	print(" leak ");
	printHex(obj);
	/* begin cr */
	printf("\n");
	return 0;
}

static sqInt
checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i)
{
	if ((heapMapAtWord(pointerForOop(obj))) != 0) {
		return 1;
	}
	print(name);
	print(" leak @ ");
	printNum(i);
	print(" = ");
	printHex(obj);
	/* begin cr */
	printf("\n");
	return 0;
}


/*	Check if the profile timer has expired and if so take a sample.
	If the primitive has failed sample the profileMethod as nil. */

static void
checkProfileTick(sqInt aPrimitiveMethod)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(GIV(nextProfileTick) != 0);
	if ((ioHighResClock()) >= GIV(nextProfileTick)) {
		GIV(profileProcess) = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
		GIV(profileMethod) = (!GIV(primFailCode)
			? aPrimitiveMethod
			: GIV(nilObj));
		forceInterruptCheck();
		GIV(nextProfileTick) = 0;
	}
}


/*	Perform an integrity/leak check using the heapMap. Assume
	clearLeakMapAndMapAccesibleObjects has set a bit at each
	object's header. Scan all objects accessible from the stack
	checking that every pointer points to a header. Answer if no
	dangling pointers were detected. */

static sqInt
checkStackIntegrity(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt ok;
    sqInt oop;
    char *theFP;
    StackPage *thePage;
    char *theSP;

	ok = 1;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(thePage))) {
			if (thePage == GIV(stackPage)) {
				theSP = GIV(stackPointer);
				theFP = GIV(framePointer);
			}
			else {
				theSP = (thePage->headSP);
				theFP = (thePage->headFP);
			}
			if (!(thePage == GIV(stackPage))) {
				theSP += BytesPerWord;
			}
			while (1) {
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (((oop & 3) == 0)
					 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame temp", theFP, theSP);
						ok = 0;
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					oop = longAt(theFP + FoxThisContext);
					if (((oop & 3) != 0)
					 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
						printFrameThingandFrameat("object leak in frame ctxt", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!(((oop & 3) == 0)
						 && (((longAt(oop)) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
						printFrameThingandFrameat("frame ctxt should be context", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((((oop & 3) == 0)
 && (((longAt(oop)) & 0x3FFFFF) == ClassMethodContextCompactIndex))
						 && (((longAt((oop + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)))) {
						printFrameThingandFrameat("frame ctxt should be married", theFP, theFP + FoxThisContext);
						ok = 0;
					}
					if (!((((oop & 3) == 0)
 && (((longAt(oop)) & 0x3FFFFF) == ClassMethodContextCompactIndex))
						 && ((((longAt((oop + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
						 && ((frameOfMarriedContext(oop)) == theFP)))) {
						printFrameThingandFrameat("frame ctxt should be married to this frame ", theFP, theFP + FoxThisContext);
						ok = 0;
					}
				}
				oop = longAt(theFP + FoxMethod);
				if (((oop & 3) != 0)
				 || ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame mthd", theFP, theFP + FoxMethod);
					ok = 0;
				}
				if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
				theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
				theFP = callerFP;
			}
			theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & 3) == 0)
				 && ((heapMapAtWord(pointerForOop(oop))) == 0)) {
					printFrameThingandFrameat("object leak in frame arg", theFP, theSP);
					ok = 0;
				}
				theSP += BytesPerWord;
			}
		}
	}
	return ok;
}

sqInt
classAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassAlien << 2));
}


/*	a.k.a. self fetchPointer: ClassArrayCompactIndex ofObject:
	classTableFirstPage 
 */

sqInt
classArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassArray << 2));
}

sqInt
classAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	return longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
}


/*	for become & GC of classes */

static sqInt
classAtIndexput(sqInt classIndex, sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTablePage;

	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	assert((objOop == GIV(nilObj))
	 || ((rawHashBitsOf(objOop)) == classIndex));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		error("attempt to add class to empty page");
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(classTablePage)));
	if (isOldObject(classTablePage)) {

		/* most stores into young objects */

		if (((objOop & 3) == 0)
		 && ((((usqInt) objOop)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(classTablePage))) >> 29) & 1) != 0)) {
				remember(classTablePage);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(classTablePage, (longAt(classTablePage)) | (1 << 29));
			}
		}
	}
	return longAtput((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2), objOop);
}

sqInt
classBitmap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassBitmap << 2));
}


/*	a.k.a. self fetchPointer: ClassByteArrayCompactIndex ofObject:
	classTableFirstPage 
 */

sqInt
classByteArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteArray << 2));
}

sqInt
classCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassCharacter << 2));
}

sqInt
classExternalAddress(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassExternalAddress << 2));
}

sqInt
classExternalData(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassExternalData << 2));
}

sqInt
classExternalFunction(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassExternalFunction << 2));
}

sqInt
classExternalLibrary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassExternalLibrary << 2));
}

sqInt
classExternalStructure(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassExternalStructure << 2));
}

sqInt
classFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2));
}

sqInt
classFloatCompactIndex(void)
{
	return ClassFloatCompactIndex;
}


/*	22-bit class mask => ~ 4M classes */

sqInt
classIndexMask(void)
{
	return 0x3FFFFF;
}

sqInt
classIndexOf(sqInt objOop)
{
	return (longAt(objOop)) & 0x3FFFFF;
}

sqInt
classLargeNegativeInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin knownClassAtIndex: */
	assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize()))));
	return longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (ClassLargeNegativeIntegerCompactIndex << 2));
}

sqInt
classLargePositiveInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin knownClassAtIndex: */
	assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize()))));
	return longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (ClassLargePositiveIntegerCompactIndex << 2));
}


/*	Check if aClass's name is className */

static sqInt
classNameOfIs(sqInt aClass, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt length;
    sqInt name;
    char *srcName;

	if ((lengthOfformat(aClass, (((usqInt) (longAt(aClass))) >> 24) & 0x1F)) <= GIV(classNameIndex)) {
		return 0;
	}
	name = longAt((aClass + (BaseHeaderSize)) + (GIV(classNameIndex) << 2));
	if (!(((name & 3) == 0)
		 && (((((usqInt) (longAt(name))) >> 24) & 0x1F) >= 16))) {
		return 0;
	}
	length = stSizeOf(name);
	srcName = ((char *) (arrayValueOf(name)));
	for (i = 0; i < length; i += 1) {
		if (!((srcName[i]) == (className[i]))) {
			return 0;
		}
	}
	return (className[length]) == 0;
}

sqInt
classPoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2));
}

sqInt
classSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2));
}

sqInt
classSmallInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassInteger << 2));
}

sqInt
classString(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2));
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */

sqInt
classTableMajorIndexShift(void)
{
	return 10;
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTableMinorIndexMask */

sqInt
classTableMinorIndexMask(void)
{
	return (1 << 10) - 1;
}


/*	1024 entries per page (2^10); 22 bit classIndex implies 2^12 pages */
/*	self basicNew classTablePageSize */

static sqInt
classTablePageSize(void)
{
	return 1 << 10;
}


/*	For Cogit & bootstrap */

sqInt
classTableRootObj(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(hiddenRootsObj);
}


/*	Answer the number of slots for class table pages in the hidden root
	object. 
 */

static sqInt
classTableRootSlots(void)
{
	return 1 << (22 - 10);
}


/*	Answer the classObj's identityHash to use as a tag in the first-level
	method lookup cache.
 */

static sqInt
classTagForClass(sqInt classObj)
{
    sqInt err;
    sqInt newHash;

	assert(addressCouldBeClassObj(classObj));
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj));
	if (((newHash = rawHashBitsOf(classObj))) == 0) {
		if (((err = enterIntoClassTable(classObj))) != 0) {
			return -err;
		}
		/* begin rawHashBitsOf: */
		flag("endianness");
		newHash = (longAt(classObj + 4)) & 0x3FFFFF;
		assert((classAtIndex(newHash)) == classObj);
	}
	return newHash;
}

sqInt
classUnsafeAlien(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassUnsafeAlien << 2));
}


/*	Perform an integrity/leak check using the heapMap. Set a bit at each
	object's header. */

static void
clearLeakMapAndMapAccessibleObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	clearHeapMap();
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		heapMapAtWordPut(pointerForOop(objOop1), 1);


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		heapMapAtWordPut(pointerForOop(objOop1), 1);


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			heapMapAtWordPut(pointerForOop(objOop11), 1);

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
}

static sqInt
cloneContext(sqInt aContext)
{
    sqInt cloned;
    sqInt frameNumArgs;
    sqInt i;
    usqInt numSlots;
    sqInt sp;
    char *spouseFP;
    usqInt sz;
    sqInt value;
    sqInt valuePointer;
    sqInt valuePointer1;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(aContext)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(aContext + 4))))) >> 24;
	sz = (numSlots == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(aContext - (BaseHeaderSize)))
		: numSlots);
	cloned = allocateNewSpaceSlotsformatclassIndex(sz, 3, ClassMethodContextCompactIndex);
	if (cloned != 0) {
		for (i = 0; i <= StackPointerIndex; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			valuePointer = externalInstVarofContext(i, aContext);
			assert(!(isForwarded(cloned)));
			longAtput((cloned + (BaseHeaderSize)) + (i << 2), valuePointer);
		}
		for (i = MethodIndex; i <= ReceiverIndex; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(cloned)));
			longAtput((cloned + (BaseHeaderSize)) + (i << 2), longAt((aContext + (BaseHeaderSize)) + (i << 2)));
		}
		if ((((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(aContext)))) {
			/* begin frameOfMarriedContext: */
			value = longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2));
			/* begin withoutSmallIntegerTags: */
			assert((value & 1));
			spouseFP = pointerForOop(value - 1);
			sp = (stackPointerIndexForFrame(spouseFP)) - 1;
			for (i = 0; i <= sp; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				valuePointer1 = (i < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
					? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - i) * BytesPerWord))
					: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - i) * BytesPerWord)));
				assert(!(isForwarded(cloned)));
				longAtput((cloned + (BaseHeaderSize)) + ((i + CtxtTempFrameStart) << 2), valuePointer1);
			}
		}
		else {
			sp = (fetchStackPointerOf(aContext)) - 1;
			for (i = 0; i <= sp; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(cloned)));
				longAtput((cloned + (BaseHeaderSize)) + ((i + CtxtTempFrameStart) << 2), longAt((aContext + (BaseHeaderSize)) + ((i + CtxtTempFrameStart) << 2)));
			}
		}
	}
	return cloned;
}

sqInt
clone(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hasYoung;
    sqInt i;
    sqInt newObj;
    sqInt newObj1;
    sqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt referent;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(objOop - (BaseHeaderSize)))
		: numSlots1);
	if (numSlots > ((1 << 16) - 1)) {
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, ((numSlots == 0
	? 8
	: (numSlots + (numSlots & 1)) << 2)) + ((numSlots >= 0xFF
	? (BaseHeaderSize) + (BaseHeaderSize)
	: BaseHeaderSize)), (((usqInt) (longAt(objOop))) >> 24) & 0x1F, (longAt(objOop)) & 0x3FFFFF);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= 0xFF) {
			newObj1 = GIV(freeStart) + (BaseHeaderSize);

			/* double header */
			/* roundTo allocationUnit */

			numBytes = ((BaseHeaderSize) + (BaseHeaderSize)) + ((numSlots + (numSlots & 1)) * 4);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = (BaseHeaderSize) + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * 4));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, (((usqInt) (longAt(objOop))) >> 24) & 0x1F, (longAt(objOop)) & 0x3FFFFF);
			goto l1;
		}
		if (numSlots >= 0xFF) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */

			flag("endianness");
			longAtput(GIV(freeStart), numSlots);
			longAtput(GIV(freeStart) + 4, 0xFF << 24);
			longLongAtput(newObj1, (((((usqLong) 0xFF)) << 56) + (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) << 24)) + ((longAt(objOop)) & 0x3FFFFF));
		}
		else {
			longLongAtput(newObj1, (((((usqLong) numSlots)) << 56) + (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) << 24)) + ((longAt(objOop)) & 0x3FFFFF));
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l1:	/* end allocateSlots:format:classIndex: */;
	}
	if (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) <= 5) {
		hasYoung = 0;
		for (i = 0; i < numSlots; i += 1) {
			oop = longAt((objOop + (BaseHeaderSize)) + (i << 2));
			if (((oop & 3) == 0)
			 && (((longAt(oop)) & 0x3FFFFF) == 8)) {
				/* begin followForwarded: */
				assert(isForwarded(oop));
				referent = longAt((oop + (BaseHeaderSize)) + (0 << 2));
				while (((referent & 3) == 0)
				 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
					referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
				}
				oop = referent;
			}
			if (((oop & 3) == 0)
			 && (isYoungObject(oop))) {
				hasYoung = 1;
			}
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(newObj)));
			longAtput((newObj + (BaseHeaderSize)) + (i << 2), oop);
		}
		if (hasYoung
		 && (!(isYoungObject(newObj)))) {
			remember(newObj);
			/* begin setIsRememberedOf:to: */
			flag("endianness");
			longAtput(newObj, (longAt(newObj)) | (1 << 29));
		}
	}
	else {
		for (i = 0; i < numSlots; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(newObj)));
			longAtput((newObj + (BaseHeaderSize)) + (i << 2), longAt((objOop + (BaseHeaderSize)) + (i << 2)));
		}
	}
	return newObj;
}


/*	The image has been loaded, old segments reconstructed, and the heap
	swizzled into a single contiguous segment. Collapse the segments into one. */

static void
collapseSegmentsPostSwizzle(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurSegmentInfo * cascade0;

	GIV(canSwizzle) = 0;
	null;
	GIV(numSegments) = 1;
	cascade0 = (&(GIV(segments)[0]));
	(cascade0->segStart = oldSpaceStart());
	(cascade0->segSize = (endOfMemory()) - (oldSpaceStart()));
	
	assert(isSegmentBridge(bridgeAt(0)));
	assert((numSlotsOfAny(bridgeAt(0))) == 0);
}

sqInt
compactClassIndexOf(sqInt objOop)
{
	return (longAt(objOop)) & 0x3FFFFF;
}


/*	May set success to false */
/*	First compare two ST integers... */

static sqInt
compare31or32Bitsequal(sqInt obj1, sqInt obj2)
{
	if (((obj1 & 1))
	 && ((obj2 & 1))) {
		return obj1 == obj2;
	}
	return (positive32BitValueOf(obj1)) == (positive32BitValueOf(obj2));
}


/*	Does thisCntx have aContext in its sender chain?
	Cheapo implementation above extant machinery. */

static sqInt
contexthasSender(sqInt thisCntx, sqInt aContext)
{
    sqInt handlerOrNilOrZero;

	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(-1, thisCntx, aContext);
	return handlerOrNilOrZero == 0;
}


/*	For asserts. Check that theIP maps back correctly to the context's pc.
	The CallPrimitive bytecode presents a complication. */

static sqInt
contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP)
{
    sqInt encodedip;
    sqInt methodHeader;
    sqInt pc;

	pc = longAt((aContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2));
	/* begin contextInstructionPointer:frame: */
	assert(validInstructionPointerinFrame(theIP, theFP));
	encodedip = (((((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
	return 
#  if MULTIPLEBYTECODESETS
		(pc == encodedip)
			 || (((methodHeader = longAt(((longAt((aContext + (BaseHeaderSize)) + (MethodIndex << 2))) + (BaseHeaderSize)) + (HeaderIndex << 2))),
			(((((sqInt) methodHeader)) < 0
				? methodHeader & (65536 << SmallIntegerShift)
				: (methodHeader & 536871934) != 0))
				 && ((((encodedip >> 1)) - ((pc >> 1))) == (((((sqInt) methodHeader)) < 0
				? 3
				: 0)))))
#  else /* MULTIPLEBYTECODESETS */
		pc == encodedip
#  endif /* MULTIPLEBYTECODESETS */
		;
}


/*	for Cogit */

sqInt
copiedValueCountOfClosure(sqInt closurePointer)
{
	return (numSlotsOf(closurePointer)) - ClosureFirstCopiedValueIndex;
}


/*	copyAndForward: survivor copies a survivor object either to
	futureSurvivorSpace or, if it is to be promoted, to oldSpace.
	It leaves a forwarding pointer behind. If the object is weak
	then corpse is threaded onto the weakList for later treatment. */

static sqInt
copyAndForward(sqInt survivor)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bytesInObj;
    sqInt hash;
    sqInt newLocation;
    sqInt newOop;
    sqInt newStart;
    sqInt nTenures;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt startOfSurvivor;

	assert((isInEden(survivor))
	 || (isInPastSpace(survivor)));

	/* Must remember hash before copying because threading
	   on to the weak & ephemeron lists smashes the hash field. */

	bytesInObj = bytesInObject(survivor);
	/* begin rawHashBitsOf: */
	flag("endianness");
	hash = (longAt(survivor + 4)) & 0x3FFFFF;
	if ((shouldBeTenured(survivor))
	 || ((GIV(futureSurvivorStart) + bytesInObj) > ((GIV(futureSpace).limit)))) {
		/* begin copyToOldSpace: */
		nTenures = GIV(statTenures);
		flag("why not just pass header??");
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(survivor)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots1 = ((usqInt) (((usqInt)(longAt(survivor + 4))))) >> 24;
		numSlots = (numSlots1 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(survivor - (BaseHeaderSize)))
			: numSlots1);
		newOop = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, ((numSlots == 0
	? 8
	: (numSlots + (numSlots & 1)) << 2)) + ((numSlots >= 0xFF
	? (BaseHeaderSize) + (BaseHeaderSize)
	: BaseHeaderSize)), (((usqInt) (longAt(survivor))) >> 24) & 0x1F, (longAt(survivor)) & 0x3FFFFF);
		if (!(newOop)) {
			growOldSpaceByAtLeast(0);
			newOop = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, ((numSlots == 0
	? 8
	: (numSlots + (numSlots & 1)) << 2)) + ((numSlots >= 0xFF
	? (BaseHeaderSize) + (BaseHeaderSize)
	: BaseHeaderSize)), (((usqInt) (longAt(survivor))) >> 24) & 0x1F, (longAt(survivor)) & 0x3FFFFF);
			if (!(newOop)) {
				error("out of memory");
			}
		}
		memcpy(((void *)(newOop + (BaseHeaderSize))), ((void *)(survivor + (BaseHeaderSize))), numSlots * (wordSize()));
		remember(newOop);
		/* begin setIsRememberedOf:to: */
		flag("endianness");
		longAtput(newOop, (longAt(newOop)) | (1 << 29));
		GIV(statTenures) = nTenures + 1;
		newLocation = newOop;
		/* begin forwardSurvivor:to: */
		assert(isInNewSpace(survivor));
		assert((isInFutureSpace(newLocation))
		 || (isInOldSpace(newLocation)));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(survivor)));
		longAtput((survivor + (BaseHeaderSize)) + (0 << 2), newLocation);
		/* begin setFormatOf:to: */
		assert(((7 >= 0) && (7 <= (formatMask()))));
		flag("endianness");
		longAtput(survivor, ((longAt(survivor)) & (~(0x1F << 24))) + (7 << 24));
		/* begin setClassIndexOf:to: */
		assert(((8 >= 0) && (8 <= (classIndexMask()))));
		flag("endianness");
		longAtput(survivor, ((longAt(survivor)) & (~0x3FFFFF)) + 8);
	}
	else {
		/* begin copyToFutureSpace:bytes: */
		assert((GIV(futureSurvivorStart) + bytesInObj) <= ((GIV(futureSpace).limit)));
		startOfSurvivor = ((rawNumSlotsOf(survivor)) == 0xFF
			? survivor - (BaseHeaderSize)
			: survivor);
		newStart = GIV(futureSurvivorStart);
		GIV(futureSurvivorStart) += bytesInObj;
		memcpy(((void *)newStart), ((void *)startOfSurvivor), bytesInObj);
		newLocation = newStart + (survivor - startOfSurvivor);
		/* begin forwardSurvivor:to: */
		assert(isInNewSpace(survivor));
		assert((isInFutureSpace(newLocation))
		 || (isInOldSpace(newLocation)));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(survivor)));
		longAtput((survivor + (BaseHeaderSize)) + (0 << 2), newLocation);
		/* begin setFormatOf:to: */
		assert(((7 >= 0) && (7 <= (formatMask()))));
		flag("endianness");
		longAtput(survivor, ((longAt(survivor)) & (~(0x1F << 24))) + (7 << 24));
		/* begin setClassIndexOf:to: */
		assert(((8 >= 0) && (8 <= (classIndexMask()))));
		flag("endianness");
		longAtput(survivor, ((longAt(survivor)) & (~0x3FFFFF)) + 8);
		if (((((usqInt) (longAt(newLocation))) >> 24) & 0x1F) == 4) {
			addToWeakList(survivor);
		}
		if ((isEphemeron(newLocation))
		 && (!(isScavengeSurvivor(keyOfEphemeron(newLocation))))) {
			addToEphemeronList(survivor);
		}
	}
	if (hash != 0) {
		/* begin setHashBitsOf:to: */
		flag("endianness");
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		longAtput(newLocation + 4, ((((longAt(newLocation + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash);
	}
	return newLocation;
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up BitBltPlugin:=copyBits
	and call it. This entire mechanism should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided */

sqInt
copyBits(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBits", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(void))fn)();
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=copyBitsFrom:to:at: and call it. This entire mechanism
	should eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

sqInt
copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("copyBitsFromtoat", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt, sqInt, sqInt))fn)(x0, x1, y);
}


/*	print the count of marked and unmarked objects.
	In addition if 1 is set in printFlags, short-print marked objects,
	and/or if 2 is set, short-print unmarked obejcts. */

void
countMarkedAndUnmarkdObjects(sqInt printFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt limit;
    sqInt nm;
    sqInt nu;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt o;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	nm = (nu = 0);
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (isMarked(objOop1)) {
			nm += 1;
			if (printFlags & 1) {
				shortPrintOop(objOop1);
			}
		}
		else {
			nu += 1;
			if (printFlags & 2) {
				shortPrintOop(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (isMarked(objOop1)) {
			nm += 1;
			if (printFlags & 1) {
				shortPrintOop(objOop1);
			}
		}
		else {
			nu += 1;
			if (printFlags & 2) {
				shortPrintOop(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (isMarked(objOop11)) {
				nm += 1;
				if (printFlags & 1) {
					shortPrintOop(objOop11);
				}
			}
			else {
				nu += 1;
				if (printFlags & 2) {
					shortPrintOop(objOop11);
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
	print("n marked: ");
	printNum(nm);
	/* begin cr */
	printf("\n");
	print("n unmarked: ");
	printNum(nu);
	/* begin cr */
	printf("\n");
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

static void
cr(void)
{
	printf("\n");
}


/*	Bundle up the selector, arguments and lookupClass into a Message object. 
	In the process it pops the arguments off the stack, and pushes the message
	object. 
	This can then be presented as the argument of e.g. #doesNotUnderstand: */

static void
createActualMessageTo(sqInt lookupClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    sqInt i;
    sqInt message;
    char *sp;


	/* This is a useful break-point */

	assert((isImmediate(GIV(messageSelector)))
	 || (addressCouldBeObj(GIV(messageSelector))));
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert((GIV(argumentCount) >= 0)
	 && (ClassArrayCompactIndex != 0));
	assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
	argumentArray = allocateNewSpaceSlotsformatclassIndex(GIV(argumentCount), 2, ClassArrayCompactIndex);
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert(((MessageLookupClassIndex + 1) >= 0)
	 && (ClassMessageCompactIndex != 0));
	assert((1) == (instSpecOfClass(knownClassAtIndex(ClassMessageCompactIndex))));
	message = allocateNewSpaceSlotsformatclassIndex(MessageLookupClassIndex + 1, 1, ClassMessageCompactIndex);

	for (i = ((GIV(argumentCount) - 1) * BytesPerOop); i >= 0; i += (-BytesPerOop)) {
		longAtput((argumentArray + (BaseHeaderSize)) + i, popStack());
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(message)));
	longAtput((message + (BaseHeaderSize)) + (MessageSelectorIndex << 2), GIV(messageSelector));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(message)));
	longAtput((message + (BaseHeaderSize)) + (MessageArgumentsIndex << 2), argumentArray);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(message)));
	longAtput((message + (BaseHeaderSize)) + (MessageLookupClassIndex << 2), lookupClass);
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), message);
	GIV(stackPointer) = sp;
	GIV(argumentCount) = 1;
}


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

char *
cStringOrNullFor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    char *cString;
    sqInt isString;
    sqInt len;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isString = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isString = ClassByteStringCompactIndex == ccIndex;
	goto l2;

	isString = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2))) == (classAtIndex(ccIndex));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!isString) {
		if (oop != GIV(nilObj)) {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(oop - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 9) {
		len = numSlots;
		goto l1;
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		len = (numSlots << 2) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 7);
		goto l1;
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 12) {
		len = (numSlots << (2 - 1)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 3);
		goto l1;
	}
	len = (numSlots << (2 - 2)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 1);
l1:	/* end lengthOf:format: */;
	if (len == 0) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!(cString)) {
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop), len);
	cString[len] = 0;
	return cString;
}


/*	This version answers the value of a float or nil if not a flat *WITHOUT*
	setting successFlag or any other such nonsense. It is hence safe for use
	in debug printing. Sheesh. */

static double
dbgFloatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double result;

	flag("Dan");
	if (((oop & 3) == 0)
	 && ((fetchClassOfNonImm(oop)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))))) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		return result;
	}
	return null;
}


/*	Return the default amount of memory to allocate for the eden space.
	The actual value can be set via vmParameterAt: and/or a preference in the
	ini file. */

static sqInt
defaultEdenBytes(void)
{
	return (2 * 1024) * 1024;
}


/*	Return the default number of stack pages allocate at startup.
	This default suits Qwaq Forums (specifically general rendering).
	It is probably a bit high for normal use but QF is profligate with
	processes. The actual value can be set via vmParameterAt: and/or a
	preference in the ini file. */

static sqInt
defaultNumStackPages(void)
{
	return 160;
}


/*	This is a rare operation, so its efficiency isn't critical.
	Having a valid prev link for tree nodes would help. */

static void
detachFreeObject(sqInt freeChunk)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt child;
    usqLong childBytes;
    usqLong chunkBytes;
    sqInt f;
    sqInt fieldIndex;
    sqInt index;
    sqInt next;
    sqInt node;
    sqInt prev;
    sqInt result;

	chunkBytes = bytesInObject(freeChunk);
	/* begin allocateOldSpaceChunkOfExactlyBytes:suchThat: */
	index = ((sqInt) chunkBytes >> 3);
	if (index < 32) {
		if (GIV(freeListsMask) & (1 << index)) {
			if (((node = GIV(freeLists)[index])) == 0) {
				GIV(freeListsMask) -= 1 << index;
			}
			else {
				prev = 0;
				while (node != 0) {
					assert(node == (startOfObject(node)));
					assert(isValidFreeObject(node));
					next = longAt((node + (BaseHeaderSize)) + (0 << 2));
					if (node == freeChunk) {
						if (prev == 0) {
							GIV(freeLists)[index] = next;
						}
						else {
							/* begin storePointer:ofFreeChunk:withValue: */
							assert(isFreeObject(prev));
							assert((next == 0)
							 || (isFreeObject(next)));
							longAtput((prev + (BaseHeaderSize)) + (0 << 2), next);
						}
						GIV(totalFreeOldSpace) -= chunkBytes;
						result = node;
						goto l1;
					}
					prev = node;
					node = next;
				}
			}
		}
		result = null;
		goto l1;
	}
	node = 0;
	child = GIV(freeLists)[0];
	while (child != 0) {
		assert(isValidFreeObject(child));
		childBytes = bytesInObject(child);
		if (childBytes == chunkBytes) {

			/* size match; try to remove from list at node first. */

			node = child;
			while (1) {
				prev = node;
				node = longAt((node + (BaseHeaderSize)) + (0 << 2));
				if (!(node != 0)) break;
				if (node == freeChunk) {
					assert(isValidFreeObject(node));
					/* begin storePointer:ofFreeChunk:withValue: */
					assert(isFreeObject(prev));
					assert(((longAt((node + (BaseHeaderSize)) + (0 << 2))) == 0)
					 || (isFreeObject(longAt((node + (BaseHeaderSize)) + (0 << 2)))));
					longAtput((prev + (BaseHeaderSize)) + (0 << 2), longAt((node + (BaseHeaderSize)) + (0 << 2)));
					GIV(totalFreeOldSpace) -= chunkBytes;
					result = ((rawNumSlotsOf(node)) == 0xFF
						? node - (BaseHeaderSize)
						: node);
					goto l1;
				}
			}
			if (!(child == freeChunk)) {
				result = null;
				goto l1;
			}
			next = longAt((child + (BaseHeaderSize)) + (0 << 2));
			if (next == 0) {

				/* no list; remove the interior node */

				unlinkSolitaryFreeTreeNode(child);
			}
			else {

				/* list; replace node with it */

				inFreeTreeReplacewith(child, next);
			}
			GIV(totalFreeOldSpace) -= chunkBytes;
			result = ((rawNumSlotsOf(child)) == 0xFF
				? child - (BaseHeaderSize)
				: child);
			goto l1;
		}
		else {

			/* no size match; walk down the tree */

			/* begin fetchPointer:ofFreeChunk: */
			fieldIndex = (childBytes < chunkBytes
				? 4
				: 3);
			child = longAt((child + (BaseHeaderSize)) + (fieldIndex << 2));
		}
	}
	result = null;
l1:	/* end allocateOldSpaceChunkOfExactlyBytes:suchThat: */;
	assert(result == (startOfObject(freeChunk)));
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

static sqInt
displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt d;
    sqInt dispBits;
    sqInt dispBitsIndex;
    sqInt displayObj;
    sqInt h;
    sqInt left;
    sqInt right;
    sqInt successBoolean;
    sqInt surfaceHandle;
    sqInt top;
    sqInt w;

	displayObj = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheDisplay << 2));
	if (!(aForm == displayObj)) {
		return null;
	}
	/* begin success: */
	successBoolean = (((displayObj & 3) == 0)
 && (((((usqInt) (longAt(displayObj))) >> 24) & 0x1F) <= 5))
	 && ((lengthOfformat(displayObj, (((usqInt) (longAt(displayObj))) >> 24) & 0x1F)) >= 4);
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		dispBits = longAt((displayObj + (BaseHeaderSize)) + (0 << 2));
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		d = fetchIntegerofObject(3, displayObj);
	}
	if (l < 0) {
		left = 0;
	}
	else {
		left = l;
	}
	if (r > w) {
		right = w;
	}
	else {
		right = r;
	}
	if (t < 0) {
		top = 0;
	}
	else {
		top = t;
	}
	if (b > h) {
		bottom = h;
	}
	else {
		bottom = b;
	}
	if (!((left <= right)
		 && (top <= bottom))) {
		return null;
	}
	if (!GIV(primFailCode)) {
		if ((dispBits & 1)) {
			surfaceHandle = (dispBits >> 1);
			if (showSurfaceFn == 0) {
				showSurfaceFn = ioLoadFunctionFrom("ioShowSurface", "SurfacePlugin");
				if (showSurfaceFn == 0) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

					return null;
				}
			}
			((sqInt (*)(sqInt, sqInt, sqInt, sqInt, sqInt))showSurfaceFn)(surfaceHandle, left, top, right-left, bottom-top);
		}
		else {
			assert(isNonImmediate(dispBits));

			/* index in memory byte array */

			dispBitsIndex = dispBits + (BaseHeaderSize);
			ioShowDisplay(dispBitsIndex, w, h, d, left, right, top, bottom);
		}
	}
}

sqInt
displayObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheDisplay << 2));
}

static sqInt
divorceAllFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    StackPage *aPage;
    sqInt i;

	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	/* begin ensureFrameIsMarried:SP: */
	if ((byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), GIV(stackPointer));
l1:	/* end ensureFrameIsMarried:SP: */;
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			divorceFramesIn(aPage);
		}
	}
	/* begin zeroStackPage */
	assert((GIV(stackPage) == 0)
	 || ((((GIV(stackPage)->headFP)) == GIV(framePointer))
	 && (((GIV(stackPage)->headSP)) == GIV(stackPointer))));
	GIV(stackPage) = 0;
	return activeContext;
}

static void
divorceFramesIn(StackPage *aStackPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    char *calleeFP;
    sqInt theContext;
    char *theFP;
    sqInt theIP;
    char *theSP;
    sqInt valuePointer;

	GIV(statStackPageDivorce) += 1;
	theFP = (aStackPage->headFP);
	theSP = (aStackPage->headSP);
	theIP = longAt(theSP);

	/* theSP points at hottest item on frame's stack */

	theSP += BytesPerWord;
	calleeContext = null;
	while (1) {
		/* begin ensureFrameIsMarried:SP: */
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			theContext = longAt(theFP + FoxThisContext);
			goto l1;
		}
		theContext = marryFrameSP(theFP, theSP);
	l1:	/* end ensureFrameIsMarried:SP: */;
		updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
		/* begin storePointerUnchecked:ofObject:withValue: */
		/* begin contextInstructionPointer:frame: */
		assert(validInstructionPointerinFrame(theIP, theFP));
		valuePointer = (((((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
		assert(!(isForwarded(theContext)));
		longAtput((theContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2), valuePointer);
		assert((frameReceiver(theFP)) == (fetchPointerofObject(ReceiverIndex, theContext)));
		if (calleeContext != null) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(calleeContext)));
			if (isOldObject(calleeContext)) {

				/* most stores into young objects */

				if (((theContext & 3) == 0)
				 && ((((usqInt) theContext)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(calleeContext))) >> 29) & 1) != 0)) {
						remember(calleeContext);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(calleeContext, (longAt(calleeContext)) | (1 << 29));
					}
				}
			}
			longAtput((calleeContext + (BaseHeaderSize)) + (SenderIndex << 2), theContext);
		}
		calleeContext = theContext;
		calleeFP = theFP;
		theIP = ((sqInt)(frameCallerSavedIP(theFP)));
		/* begin frameCallerFP: */
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(theFP != 0)) break;

		/* theSP points at stacked hottest item on frame's stack */

		/* begin frameCallerSP: */
		assert(!(isBaseFrame(calleeFP)));
		theSP = (calleeFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((calleeFP + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	if (isOldObject(theContext)) {

		/* most stores into young objects */

		if ((((longAt(calleeFP + FoxCallerContext)) & 3) == 0)
		 && ((((usqInt) (longAt(calleeFP + FoxCallerContext)))) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(theContext))) >> 29) & 1) != 0)) {
				remember(theContext);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(theContext, (longAt(theContext)) | (1 << 29));
			}
		}
	}
	longAtput((theContext + (BaseHeaderSize)) + (SenderIndex << 2), longAt(calleeFP + FoxCallerContext));
	(aStackPage->baseFP = 0);
}


/*	Rounds negative results towards negative infinity, rather than zero. */

static sqInt
doPrimitiveDivby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt posArg;
    sqInt posRcvr;
    sqInt result;

	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		return 1;
	}
	if (integerRcvr > 0) {
		if (integerArg > 0) {
			result = integerRcvr / integerArg;
		}
		else {

			/* round negative result toward negative infinity */

			posArg = 0 - integerArg;
			result = 0 - ((integerRcvr + (posArg - 1)) / posArg);
		}
	}
	else {
		posRcvr = 0 - integerRcvr;
		if (integerArg > 0) {

			/* round negative result toward negative infinity */

			result = 0 - ((posRcvr + (integerArg - 1)) / integerArg);
		}
		else {
			posArg = 0 - integerArg;
			result = posRcvr / posArg;
		}
	}
	/* begin success: */
	if (!((result ^ (result << 1)) >= 0)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return result;
}

static sqInt
doPrimitiveModby(sqInt rcvr, sqInt arg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerRcvr;
    sqInt integerResult;

	if (((rcvr & arg) & 1) != 0) {
		integerRcvr = (rcvr >> 1);
		integerArg = (arg >> 1);
		/* begin success: */
		if (!(integerArg != 0)) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		return 1;
	}

	/* ensure that the result has the same sign as the integerArg */

	integerResult = integerRcvr % integerArg;
	if (integerArg < 0) {
		if (integerResult > 0) {
			integerResult += integerArg;
		}
	}
	else {
		if (integerResult < 0) {
			integerResult += integerArg;
		}
	}
	/* begin success: */
	if (!((integerResult ^ (integerResult << 1)) >= 0)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return integerResult;
}


/*	Signal the external semaphore with the given index. Answer if a context
	switch occurs as a result. Do not bounds check. This has been done in the
	caller.  */

sqInt
doSignalSemaphoreWithIndex(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    sqInt semaphoreClass;
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ExternalObjectsArray << 2));
	semaphoreClass = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2));

	/* Note: semaphore indices are 1-based */

	sema = longAt((xArray + (BaseHeaderSize)) + ((index - 1) << 2));
	return ((sema & 1) == 0)
	 && (((fetchClassOfNonImm(sema)) == semaphoreClass)
	 && (synchronousSignal(sema)));
}

static void
dummyReferToProxy(void)
{
	interpreterProxy = interpreterProxy;
}


/*	Dump the entire image out to the given file. Intended for debugging only. */

EXPORT(sqInt)
dumpImage(sqInt fileName)
{
    sqInt dataSize;
    sqImageFile f;
    sqInt result;

	f = sqImageFileOpen(pointerForOop(fileName), "wb");
	if (f == null) {
		return -1;
	}
	dataSize = (endOfMemory()) - (startOfMemory());
	result = sqImageFileWrite(pointerForOop(memory), sizeof(unsigned char), dataSize, f);
	sqImageFileClose(f);
	return result;
}


/*	Dummy definition to allow the StackInterpreter to link against the Cog
	run-time. 
 */

void
dumpPrimTraceLog(void)
{
}


/*	Instantiate an instance of a compact class. ee stands for execution engine
	and implies that this allocation will *NOT* cause a GC. N.B. the
	instantiated object
	IS NOT FILLED and must be completed before returning it to Smalltalk.
	Since this
	call is used in routines that do just that we are safe. Break this rule
	and die in GC.
	Result is guaranteed to be young. */

sqInt
eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots)
{
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	return allocateNewSpaceSlotsformatclassIndex(numSlots, objFormat, knownClassIndex);
}


/*	As the final phase of global garbage collect, sweep the heap to follow
	forwarders, then free forwarders, coalescing with free space as we go. */

static void
eliminateAndFreeForwarders(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurNewSpaceSpace *aNewSpace;
    sqInt bytes;
    sqInt f;
    sqInt firstFree;
    float fractionSurvived;
    sqInt i;
    sqInt iLimiT;
    sqInt index;
    sqInt lastFree;
    sqInt lowestFree;
    sqInt next;
    sqInt o;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt oldStart;
    sqInt p;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt start;
    SpurNewSpaceSpace temp;

	flag("this might be unnecessary.  if we were to track firstFreeChunk we might be able to repeat the freeUnmarkedObjectsAndSortAndCoalesceFreeSpace; compact cycle until firstFreeChunk reaches a fixed point");
	assert(!(isForwarded(GIV(nilObj))));
	assert(!(isForwarded(GIV(falseObj))));
	assert(!(isForwarded(GIV(trueObj))));
	assert(!(isForwarded(freeListsObj())));
	assert(!(isForwarded(GIV(hiddenRootsObj))));
	assert(!(isForwarded(GIV(classTableFirstPage))));
	if (((longAt(GIV(specialObjectsOop))) & 0x3FFFFF) == 8) {
		/* begin followForwarded: */
		assert(isForwarded(GIV(specialObjectsOop)));
		referent = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		GIV(specialObjectsOop) = referent;
	}
	/* begin followForwardedObjStacks */
	followForwardedInObjStackatIndex(GIV(markStack), MarkStackRootIndex);
	followForwardedInObjStackatIndex(GIV(weaklingStack), WeaklingStackRootIndex);
	followForwardedInObjStackatIndex(GIV(ephemeronQueue), EphemeronQueueRootIndex);
	/* begin followRememberedForwardersAndForgetFreeObjects */
	index = 0;
	while (index < GIV(rememberedSetSize)) {
		obj = GIV(rememberedSet)[index];
		if (((longAt(obj)) & 0x3FFFFF) == 0) {

			/* free; remove by overwriting with last element */

			GIV(rememberedSetSize) -= 1;
			GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
		}
		else {
			if (((longAt(obj)) & 0x3FFFFF) == 8) {
				/* begin followForwarded: */
				assert(isForwarded(obj));
				referent2 = longAt((obj + (BaseHeaderSize)) + (0 << 2));
				while (((referent2 & 3) == 0)
				 && (((longAt(referent2)) & 0x3FFFFF) == 8)) {
					referent2 = longAt((referent2 + (BaseHeaderSize)) + (0 << 2));
				}
				obj = referent2;
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(obj, (longAt(obj)) | (1 << 29));
				GIV(rememberedSet)[index] = obj;
			}
			index += 1;
		}
	}
	/* begin doScavenge: */
	GIV(scavengeInProgress) = 1;
	/* begin scavenge: */
	GIV(tenureCriterion) = DontTenureButDoUnmark;
	scavengeLoop();
	processWeaklings();
	/* begin computeTenuringThreshold */
	fractionSurvived = (((GIV(futureSpace).limit)) == ((GIV(futureSpace).start))
		? 0.0
		: (((double) (GIV(futureSurvivorStart) - ((GIV(futureSpace).start))) )) / (((GIV(futureSpace).limit)) - ((GIV(futureSpace).start))));
	GIV(tenureThreshold) = (fractionSurvived > 0.9
		? (round(((((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) * (1.0 - GIV(tenuringProportion))))) + ((GIV(pastSpace).start))
		: 0);
	/* begin exchangeSurvivorSpaces */
	temp = GIV(pastSpace);
	GIV(pastSpace) = GIV(futureSpace);
	GIV(futureSpace) = temp;
	/* begin initFutureSpaceStart */
	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	GIV(pastSpaceStart) = ((sqInt) oldStart);
	assert(oopisGreaterThanOrEqualToandLessThanOrEqualTo(GIV(pastSpaceStart), ((pastSpace()).start), ((pastSpace()).limit)));
	GIV(freeStart) = ((eden()).start);
	/* begin initSpaceForAllocationCheck: */
	aNewSpace = (&(eden()));
	if (!(GIV(memory) == null)) {
		for (p = ((aNewSpace->start)); p < ((aNewSpace->limit)); p += (wordSize())) {
			longAtput(p, p);
		}

	}
	GIV(scavengeInProgress) = 0;
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));

	/* sweep, following forwarders in all live objects, and finding the first forwarder. */

	lowestFree = 0;
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!((((usqInt) objOop)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop)) != 0);
		if ((((longAt(objOop)) & 0x3FFFFF) == 0)
		 || (((longAt(objOop)) & 0x3FFFFF) == 8)) {
			if (lowestFree == 0) {
				lowestFree = objOop;
			}
		}
		else {
			for (i = 0, iLimiT = ((numPointerSlotsOf(objOop)) - 1); i <= iLimiT; i += 1) {
				f = longAt((objOop + (BaseHeaderSize)) + (i << 2));
				if (((f & 3) == 0)
				 && (((longAt(f)) & 0x3FFFFF) == 8)) {
					/* begin followForwarded: */
					assert(isForwarded(f));
					referent1 = longAt((f + (BaseHeaderSize)) + (0 << 2));
					while (((referent1 & 3) == 0)
					 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
						referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
					}
					f = referent1;
					assert(!(isYoung(f)));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop)));
					longAtput((objOop + (BaseHeaderSize)) + (i << 2), f);
				}
			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = objectAfterlimit(objOop, GIV(endOfMemory));
	}
	
	
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (lowestFree == 0) {

		/* yeah, right... */

		return;
	}

	/* Sweep from lowest forwarder, coalescing runs of forwarders and free objects. */

	firstFree = (lastFree = 0);
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = lowestFree;
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop1)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop1)) != 0);
		if (((longAt(objOop1)) & 0x3FFFFF) == 0) {

			/* two cases, isolated, in which case leave alone, or adjacent,
			   in which case, remove from free set prior to coalesce. */

			next = objectAfterlimit(objOop1, GIV(endOfMemory));
			assert((next == GIV(endOfMemory))
			 || (!(isFreeObject(next))));
			if ((firstFree != 0)
			 || ((next != GIV(endOfMemory))
			 && (((longAt(next)) & 0x3FFFFF) == 8))) {
				if (firstFree == 0) {
					firstFree = objOop1;
				}
				lastFree = objOop1;
				detachFreeObject(objOop1);
				/* begin checkFreeSpace */
				assert(bitsSetInFreeSpaceMaskForAllFreeLists());
				assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
			}
		}
		else {
			if (((longAt(objOop1)) & 0x3FFFFF) == 8) {
				if (firstFree == 0) {
					firstFree = objOop1;
				}
				lastFree = objOop1;
			}
			else {
				if (firstFree != 0) {
					start = ((rawNumSlotsOf(firstFree)) == 0xFF
						? firstFree - (BaseHeaderSize)
						: firstFree);
					bytes = (addressAfter(lastFree)) - start;
					/* begin addFreeChunkWithBytes:at: */
					freeChunkWithBytesat(bytes, start);
					GIV(totalFreeOldSpace) += bytes;
					/* begin checkFreeSpace */
					assert(bitsSetInFreeSpaceMaskForAllFreeLists());
					assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
				}
				firstFree = 0;
			}
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(endOfMemory));
	}
	
	
	if (firstFree != 0) {
		start = ((rawNumSlotsOf(firstFree)) == 0xFF
			? firstFree - (BaseHeaderSize)
			: firstFree);
		bytes = (addressAfter(lastFree)) - start;
		/* begin addFreeChunkWithBytes:at: */
		freeChunkWithBytesat(bytes, start);
		GIV(totalFreeOldSpace) += bytes;
	}
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
}


/*	The classTableBitmap is used to reclaim unused and/or duplicate entries
	in the classTable. As such it is notionally 2^(22 - 3) bytes big, or 512k,
	a little too large to be comfortable allocating statically (especially on
	small machines). So make it big enough for the max classTableIndex's base
	2 ceiling. */

static void
ensureAdequateClassTableBitmap(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt requiredSize;

	requiredSize = (1 << (highBit(GIV(numClassTablePages)))) * (((sqInt) (1 << 10) >> 3));
	if (!(GIV(classTableBitmap) == null)) {
		free(GIV(classTableBitmap));
	}
	GIV(classTableBitmap) = malloc(requiredSize);
	if (!(GIV(classTableBitmap))) {
		error("could not allocate classTableBitmap");
	}
	memset(GIV(classTableBitmap), 0, requiredSize);
}

static sqInt
ensureBehaviorHash(sqInt aBehavior)
{
    sqInt err;
    sqInt newHash;

	assert(addressCouldBeClassObj(aBehavior));
	if (((newHash = rawHashBitsOf(aBehavior))) == 0) {
		if (((err = enterIntoClassTable(aBehavior))) != 0) {
			return -err;
		}
		/* begin rawHashBitsOf: */
		flag("endianness");
		newHash = (longAt(aBehavior + 4)) & 0x3FFFFF;
		assert((classAtIndex(newHash)) == aBehavior);
	}
	return newHash;
}


/*	Answerr the caller context for a frame. If the frame has a caller
	frame that doesn't have a context, then marry the caller frame. */

static sqInt
ensureCallerContext(char *theFP)
{
    char *callerFP;
    char *theSP;

	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */

		return longAt(theFP + FoxCallerContext);
	}
	/* begin ensureFrameIsMarried:SP: */
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
	if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP)));
		return longAt(callerFP + FoxThisContext);
	}
	return marryFrameSP(callerFP, theSP);
}


/*	Ensure the image data has been updated to suit the current VM. */

static void
ensureImageFormatIsUpToDate(sqInt swapBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt addr1;
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    sqInt fmt;
    sqInt limit;
    sqInt limit1;
    sqInt methodHeader;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop111;
    sqInt objOop12;
    sqInt objOop2;
    sqInt objOop21;
    sqInt objOop3;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj11;
    sqInt prevObj2;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj11;
    sqInt prevPrevObj2;
    sqInt stopAddr;
    sqInt swapFloatWords;
    sqInt temp;
    sqInt temp1;
    sqInt wordAddr;

	if (swapBytes) {
		/* begin reverseBytesInImage */
		/* begin reverseBytesInMemory */
		/* begin reverseBytesFrom:to: */
		addr = GIV(oldSpaceStart);
		while ((((usqInt) addr)) < (((usqInt) GIV(endOfMemory)))) {
			longAtput(addr, ((((((usqInt) (longAt(addr)) >> 24)) & Byte0Mask) + ((((usqInt) (longAt(addr)) >> 8)) & Byte1Mask)) + ((((usqInt) (longAt(addr)) << 8)) & Byte2Mask)) + ((((usqInt) (longAt(addr)) << 24)) & Byte3Mask));
			addr += BytesPerWord;
		}
		/* begin updateObjectsPostByteSwap */
		swapFloatWords = VMBIGENDIAN != GIV(imageFloatsBigEndian);
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		/* begin allNewSpaceObjectsDo: */
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

		prevPrevObj = (prevObj = null);
		assert((bootstrapping())
		 || ((((pastSpace()).start)) < (((eden()).start))));
		/* begin objectStartingAt: */
		address = ((pastSpace()).start);
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
		objOop1 = (numSlots == 0xFF
			? address + (BaseHeaderSize)
			: address);
		limit = GIV(pastSpaceStart);
		while ((((usqInt) objOop1)) < (((usqInt) limit))) {
			assert(isEnumerableObjectNoAssert(objOop1));
			fmt = (((usqInt) (longAt(objOop1))) >> 24) & 0x1F;
			if (fmt >= 16) {

				/* oop contains bytes */

				wordAddr = objOop1 + BaseHeaderSize;
				if (fmt >= 24) {

					/* compiled method; start after methodHeader and literals */

					methodHeader = longAt(objOop1 + BaseHeaderSize);
					wordAddr += ((
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerWord;
				}
				/* begin reverseBytesFrom:to: */
				stopAddr = objOop1 + (((numSlotsOf(objOop1)) << 2) + (BaseHeaderSize));
				addr1 = wordAddr;
				while ((((usqInt) addr1)) < (((usqInt) stopAddr))) {
					longAtput(addr1, ((((((usqInt) (longAt(addr1)) >> 24)) & Byte0Mask) + ((((usqInt) (longAt(addr1)) >> 8)) & Byte1Mask)) + ((((usqInt) (longAt(addr1)) << 8)) & Byte2Mask)) + ((((usqInt) (longAt(addr1)) << 24)) & Byte3Mask));
					addr1 += BytesPerWord;
				}
			}
			if (fmt == 10) {

				/* Bitmap, Float etc */

				if (swapFloatWords
				 && (((longAt(objOop1)) & 0x3FFFFF) == ClassFloatCompactIndex)) {
					temp1 = longAt(objOop1 + BaseHeaderSize);
					longAtput(objOop1 + BaseHeaderSize, longAt((objOop1 + BaseHeaderSize) + 4));
					longAtput((objOop1 + BaseHeaderSize) + 4, temp1);
				}
				else {
					;
				}
			}


			prevPrevObj = prevObj;
			prevObj = objOop1;
			objOop1 = objectAfterlimit(objOop1, limit);
		}
		/* begin objectStartingAt: */
		address1 = ((eden()).start);
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
		objOop1 = (numSlots1 == 0xFF
			? address1 + (BaseHeaderSize)
			: address1);
		while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
			assert(isEnumerableObjectNoAssert(objOop1));
			fmt = (((usqInt) (longAt(objOop1))) >> 24) & 0x1F;
			if (fmt >= 16) {

				/* oop contains bytes */

				wordAddr = objOop1 + BaseHeaderSize;
				if (fmt >= 24) {

					/* compiled method; start after methodHeader and literals */

					methodHeader = longAt(objOop1 + BaseHeaderSize);
					wordAddr += ((
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerWord;
				}
				/* begin reverseBytesFrom:to: */
				stopAddr = objOop1 + (((numSlotsOf(objOop1)) << 2) + (BaseHeaderSize));
				addr1 = wordAddr;
				while ((((usqInt) addr1)) < (((usqInt) stopAddr))) {
					longAtput(addr1, ((((((usqInt) (longAt(addr1)) >> 24)) & Byte0Mask) + ((((usqInt) (longAt(addr1)) >> 8)) & Byte1Mask)) + ((((usqInt) (longAt(addr1)) << 8)) & Byte2Mask)) + ((((usqInt) (longAt(addr1)) << 24)) & Byte3Mask));
					addr1 += BytesPerWord;
				}
			}
			if (fmt == 10) {

				/* Bitmap, Float etc */

				if (swapFloatWords
				 && (((longAt(objOop1)) & 0x3FFFFF) == ClassFloatCompactIndex)) {
					temp1 = longAt(objOop1 + BaseHeaderSize);
					longAtput(objOop1 + BaseHeaderSize, longAt((objOop1 + BaseHeaderSize) + 4));
					longAtput((objOop1 + BaseHeaderSize) + 4, temp1);
				}
				else {
					;
				}
			}


			prevPrevObj = prevObj;
			prevObj = objOop1;
			objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
		}
		
		
		/* begin allOldSpaceObjectsDo: */
		/* begin allOldSpaceObjectsFrom:do: */
		/* begin allOldSpaceEntitiesFrom:do: */
		prevPrevObj1 = (prevObj1 = null);
		objOop11 = GIV(nilObj);
		while (1) {
			assert((objOop11 % (allocationUnit())) == 0);
			if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
			assert((longLongAt(objOop11)) != 0);
			if (isEnumerableObject(objOop11)) {
				fmt = (((usqInt) (longAt(objOop11))) >> 24) & 0x1F;
				if (fmt >= 16) {

					/* oop contains bytes */

					wordAddr = objOop11 + BaseHeaderSize;
					if (fmt >= 24) {

						/* compiled method; start after methodHeader and literals */

						methodHeader = longAt(objOop11 + BaseHeaderSize);
						wordAddr += ((
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerWord;
					}
					/* begin reverseBytesFrom:to: */
					stopAddr = objOop11 + (((numSlotsOf(objOop11)) << 2) + (BaseHeaderSize));
					addr1 = wordAddr;
					while ((((usqInt) addr1)) < (((usqInt) stopAddr))) {
						longAtput(addr1, ((((((usqInt) (longAt(addr1)) >> 24)) & Byte0Mask) + ((((usqInt) (longAt(addr1)) >> 8)) & Byte1Mask)) + ((((usqInt) (longAt(addr1)) << 8)) & Byte2Mask)) + ((((usqInt) (longAt(addr1)) << 24)) & Byte3Mask));
						addr1 += BytesPerWord;
					}
				}
				if (fmt == 10) {

					/* Bitmap, Float etc */

					if (swapFloatWords
					 && (((longAt(objOop11)) & 0x3FFFFF) == ClassFloatCompactIndex)) {
						temp1 = longAt(objOop11 + BaseHeaderSize);
						longAtput(objOop11 + BaseHeaderSize, longAt((objOop11 + BaseHeaderSize) + 4));
						longAtput((objOop11 + BaseHeaderSize) + 4, temp1);
					}
					else {
						;
					}
				}

			}

			prevPrevObj1 = prevObj1;
			prevObj1 = objOop11;
			objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
		}
		
		
	}
	else {
		/* begin convertFloatsToPlatformOrder */
		if (VMBIGENDIAN == GIV(imageFloatsBigEndian)) {
			null;
			goto l1;
		}
		assert(ClassFloatCompactIndex != 0);
		/* begin allObjectsDo: */
		/* begin allNewSpaceObjectsDo: */
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

		prevPrevObj2 = (prevObj2 = null);
		assert((bootstrapping())
		 || ((((pastSpace()).start)) < (((eden()).start))));
		/* begin objectStartingAt: */
		address2 = ((pastSpace()).start);
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots2 = ((usqInt) (((usqInt)(longAt(address2 + 4))))) >> 24;
		objOop12 = (numSlots2 == 0xFF
			? address2 + (BaseHeaderSize)
			: address2);
		limit1 = GIV(pastSpaceStart);
		while ((((usqInt) objOop12)) < (((usqInt) limit1))) {
			assert(isEnumerableObjectNoAssert(objOop12));
			if (((longAt(objOop12)) & 0x3FFFFF) == ClassFloatCompactIndex) {
				temp = longAt(objOop12 + BaseHeaderSize);
				longAtput(objOop12 + BaseHeaderSize, longAt((objOop12 + BaseHeaderSize) + 4));
				longAtput((objOop12 + BaseHeaderSize) + 4, temp);
			}


			prevPrevObj2 = prevObj2;
			prevObj2 = objOop12;
			objOop12 = objectAfterlimit(objOop12, limit1);
		}
		/* begin objectStartingAt: */
		address11 = ((eden()).start);
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots11 = ((usqInt) (((usqInt)(longAt(address11 + 4))))) >> 24;
		objOop12 = (numSlots11 == 0xFF
			? address11 + (BaseHeaderSize)
			: address11);
		while ((((usqInt) objOop12)) < (((usqInt) GIV(freeStart)))) {
			assert(isEnumerableObjectNoAssert(objOop12));
			if (((longAt(objOop12)) & 0x3FFFFF) == ClassFloatCompactIndex) {
				temp = longAt(objOop12 + BaseHeaderSize);
				longAtput(objOop12 + BaseHeaderSize, longAt((objOop12 + BaseHeaderSize) + 4));
				longAtput((objOop12 + BaseHeaderSize) + 4, temp);
			}


			prevPrevObj2 = prevObj2;
			prevObj2 = objOop12;
			objOop12 = objectAfterlimit(objOop12, GIV(freeStart));
		}
		
		
		/* begin allOldSpaceObjectsDo: */
		/* begin allOldSpaceObjectsFrom:do: */
		/* begin allOldSpaceEntitiesFrom:do: */
		prevPrevObj11 = (prevObj11 = null);
		objOop111 = GIV(nilObj);
		while (1) {
			assert((objOop111 % (allocationUnit())) == 0);
			if (!((((usqInt) objOop111)) < (((usqInt) GIV(endOfMemory))))) break;
			assert((longLongAt(objOop111)) != 0);
			if (isEnumerableObject(objOop111)) {
				if (((longAt(objOop111)) & 0x3FFFFF) == ClassFloatCompactIndex) {
					temp = longAt(objOop111 + BaseHeaderSize);
					longAtput(objOop111 + BaseHeaderSize, longAt((objOop111 + BaseHeaderSize) + 4));
					longAtput((objOop111 + BaseHeaderSize) + 4, temp);
				}

			}

			prevPrevObj11 = prevObj11;
			prevObj11 = objOop111;
			objOop111 = objectAfterlimit(objOop111, GIV(endOfMemory));
		}
		
		
	l1:	/* end convertFloatsToPlatformOrder */;
	}
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such as
	the markStack or the ephemeronQueue. It is a linked list of segments,
	with the hot end at the head of the list. It is a word object. The stack
	pointer is in ObjStackTopx and 0 means empty. The list goes through
	ObjStackNextx. We don't want to shrink objStacks, since they're used
	in GC and its good to keep their memory around. So unused pages
	created by popping emptying pages are kept on the ObjStackFreex list. */

static sqInt
ensureRoomOnObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeOrNewPage;
    sqInt stackOrNil;
    sqInt thang;

	stackOrNil = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (objStackRootIndex << 2));
	if ((stackOrNil == GIV(nilObj))
	 || ((longAt((stackOrNil + (BaseHeaderSize)) + (ObjStackTopx << 2))) >= ObjStackLimit)) {
		freeOrNewPage = (stackOrNil == GIV(nilObj)
			? 0
			: longAt((stackOrNil + (BaseHeaderSize)) + (ObjStackFreex << 2)));
		if (freeOrNewPage != 0) {

			/* the free page list is always on the new page. */

			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
			null;
			longAtput((stackOrNil + (BaseHeaderSize)) + (ObjStackFreex << 2), 0);
			assert((!GIV(marking))
			 || (isMarked(freeOrNewPage)));
		}
		else {
			freeOrNewPage = allocateSlotsInOldSpacebytesformatclassIndex(ObjStackPageSlots, ((ObjStackPageSlots + (ObjStackPageSlots & 1)) << 2) + ((BaseHeaderSize) + (BaseHeaderSize)), 10, 18);
			if (!(freeOrNewPage)) {
				error("no memory to allocate or extend obj stack");
			}
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
			null;
			longAtput((freeOrNewPage + (BaseHeaderSize)) + (ObjStackFreex << 2), 0);
			if (GIV(marking)) {
				setIsMarkedOfto(freeOrNewPage, 1);
			}
		}
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		null;
		longAtput((freeOrNewPage + (BaseHeaderSize)) + (ObjStackMyx << 2), objStackRootIndex);
		/* begin storePointer:ofObjStack:withValue: */
		thang = (stackOrNil == GIV(nilObj)
			? 0
			: stackOrNil);
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		null;
		longAtput((freeOrNewPage + (BaseHeaderSize)) + (ObjStackNextx << 2), thang);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(freeOrNewPage)) == (wordIndexableFormat()));
		null;
		longAtput((freeOrNewPage + (BaseHeaderSize)) + (ObjStackTopx << 2), 0);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if (isOldObject(GIV(hiddenRootsObj))) {

			/* most stores into young objects */

			if (((freeOrNewPage & 3) == 0)
			 && ((((usqInt) freeOrNewPage)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> 29) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(hiddenRootsObj), (longAt(GIV(hiddenRootsObj))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (objStackRootIndex << 2), freeOrNewPage);
		assert(isValidObjStackAt(objStackRootIndex));
		/* begin updateRootOfObjStackAt:with: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if (isOldObject(GIV(hiddenRootsObj))) {

			/* most stores into young objects */

			if (((freeOrNewPage & 3) == 0)
			 && ((((usqInt) freeOrNewPage)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> 29) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(hiddenRootsObj), (longAt(GIV(hiddenRootsObj))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (objStackRootIndex << 2), freeOrNewPage);
		
		switch (objStackRootIndex) {
		case MarkStackRootIndex:
			GIV(markStack) = freeOrNewPage;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = freeOrNewPage;
			break;
		case EphemeronQueueRootIndex:
			GIV(ephemeronQueue) = freeOrNewPage;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		stackOrNil = freeOrNewPage;
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return stackOrNil;
}


/*	Enter aBehavior into the class table and answer 0. Otherwise answer a
	primitive failure code. */

static sqInt
enterIntoClassTable(sqInt aBehavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt initialMajorIndex;
    sqInt majorIndex;
    sqInt minorIndex;
    sqInt p;
    sqInt page;

	majorIndex = ((usqInt) GIV(classTableIndex)) >> 10;

	/* classTableIndex should never index the first page; it's reserved for known classes */

	initialMajorIndex = majorIndex;
	assert(initialMajorIndex > 0);
	minorIndex = GIV(classTableIndex) & ((1 << 10) - 1);
	while(1) {
		page = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (majorIndex << 2));
		if (page == GIV(nilObj)) {
			page = allocateSlotsInOldSpacebytesformatclassIndex(1 << 10, (((1 << 10) == 0
	? 8
	: ((1 << 10) + ((1 << 10) & 1)) << 2)) + (((1 << 10) >= 0xFF
	? (BaseHeaderSize) + (BaseHeaderSize)
	: BaseHeaderSize)), 2, 16);
			if (!(page)) {
				return PrimErrNoMemory;
			}
			/* begin fillObj:numSlots:with: */
			assert(oopisLessThan(((page + (BaseHeaderSize)) + ((1 << 10) * (bytesPerOop()))) - 1, addressAfter(page)));
			for (p = (page + (BaseHeaderSize)); p < ((page + (BaseHeaderSize)) + ((1 << 10) * (wordSize()))); p += 8) {
				longAtput(p, GIV(nilObj));
				longAtput(p + 4, GIV(nilObj));
			}
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(GIV(hiddenRootsObj))));
			if (isOldObject(GIV(hiddenRootsObj))) {

				/* most stores into young objects */

				if (((page & 3) == 0)
				 && ((((usqInt) page)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> 29) & 1) != 0)) {
						remember(GIV(hiddenRootsObj));
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(GIV(hiddenRootsObj), (longAt(GIV(hiddenRootsObj))) | (1 << 29));
					}
				}
			}
			longAtput((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (majorIndex << 2), page);
			GIV(numClassTablePages) += 1;
			minorIndex = 0;
		}
		for (i = minorIndex, iLimiT = ((1 << 10) - 1); i <= iLimiT; i += 1) {
			if ((longAt((page + (BaseHeaderSize)) + (i << 2))) == GIV(nilObj)) {
				GIV(classTableIndex) = (majorIndex << 10) + i;
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(page)));
				if (isOldObject(page)) {

					/* most stores into young objects */

					if (((aBehavior & 3) == 0)
					 && ((((usqInt) aBehavior)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(page))) >> 29) & 1) != 0)) {
							remember(page);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(page, (longAt(page)) | (1 << 29));
						}
					}
				}
				longAtput((page + (BaseHeaderSize)) + (i << 2), aBehavior);
				/* begin setHashBitsOf:to: */
				flag("endianness");
				assert(((GIV(classTableIndex) >= 0) && (GIV(classTableIndex) <= (identityHashHalfWordMask()))));
				longAtput(aBehavior + 4, ((((longAt(aBehavior + 4)) | 0x3FFFFF) - 0x3FFFFF)) + GIV(classTableIndex));
				assert((classAtIndex(rawHashBitsOf(aBehavior))) == aBehavior);
				scanClassPostBecomeeffects(aBehavior, BecamePointerObjectFlag + BecameCompiledMethodFlag);
				ensureAdequateClassTableBitmap();
				return 0;
			}
		}
		majorIndex = ((((majorIndex + 1) & 0x3FFFFF) < 1) ? 1 : ((majorIndex + 1) & 0x3FFFFF));
		if (majorIndex == initialMajorIndex) {

			/* wrapped; table full */

			return PrimErrLimitExceeded;
		}
	}
}

static sqInt
ephemeronFormat(void)
{
	return 5;
}


/*	Compact all of memory above firstFreeChunk using exact-fit, assuming free
	space is sorted and that as many of the the highest objects as will fit
	are recorded in highestObjects. Don't move pinned objects.
	Note that we don't actually move; we merely copy and forward. Eliminating
	forwarders will be done in a final pass. Leave the objects that don't fit
	exactly (the misfits), and hence aren't moved, in highestObjects. */

static void
exactFitCompact(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong b;
    sqInt bytesToMove;
    sqInt child;
    sqInt child1;
    sqInt child2;
    usqLong childBytes;
    usqLong childBytes1;
    usqLong childBytes2;
    sqInt f;
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt fieldIndex2;
    sqInt first;
    sqInt freeObj;
    sqInt freeObj1;
    sqInt freeObj2;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt initialPtr;
    usqInt misfits;
    usqInt newMisfitsPosition;
    sqInt next;
    sqInt next1;
    sqInt next2;
    sqInt nfits;
    sqInt nHighest;
    sqInt nMisses;
    sqInt nmiss;
    sqInt node;
    sqInt node1;
    sqInt node2;
    usqInt numSlots;
    sqInt o;
    usqInt oldLimit;
    sqInt prev;
    sqInt prev1;
    sqInt prev2;
    usqInt ptr;
    usqInt savedLimit;
    sqInt startOfObj;
    sqInt startOfObj1;
    sqInt startOfObj2;

	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (GIV(totalFreeOldSpace) == 0) {
		return;
	}
	if (((GIV(highestObjects).last)) < ((GIV(highestObjects).start))) {
		return;
	}
	nfits = (nmiss = 0);
	misfits = ((GIV(highestObjects).last)) + (wordSize());
	do {
		GIV(statCompactPassCount) += 1;
		/* begin from:reverseDo: */
		initialPtr = misfits - (wordSize());
		if (((GIV(highestObjects).last)) >= ((GIV(highestObjects).start))) {
			ptr = initialPtr;
			if (((GIV(highestObjects).first)) <= ((GIV(highestObjects).last))) {

				/* enum in first to last range, last to first */

				if (ptr >= ((GIV(highestObjects).first))) {
					while(1) {
						if (!((((usqInt) (longAt(ptr)))) > (((usqInt) GIV(firstFreeChunk))))) {
							(GIV(highestObjects).first = misfits);
							print("exactFitCompact fits: ");
							printNum(nfits);
							print(" misfits: ");
							printNum(nmiss);
							/* begin cr */
							printf("\n");
							return;
						}
						if (!((((longAt(longAt(ptr))) & 0x3FFFFF) == 8)
							 || (((((usqInt) (longAt(longAt(ptr)))) >> 30) & 1) != 0))) {
							b = bytesInObject(longAt(ptr));
							/* begin allocateOldSpaceChunkOfExactlyBytes:suchThat: */
							index = ((sqInt) b >> 3);
							if (index < 32) {
								if (GIV(freeListsMask) & (1 << index)) {
									if (((node = GIV(freeLists)[index])) == 0) {
										GIV(freeListsMask) -= 1 << index;
									}
									else {
										prev = 0;
										while (node != 0) {
											assert(node == (startOfObject(node)));
											assert(isValidFreeObject(node));
											next = longAt((node + (BaseHeaderSize)) + (0 << 2));
											if (node < (longAt(ptr))) {
												if (prev == 0) {
													GIV(freeLists)[index] = next;
												}
												else {
													/* begin storePointer:ofFreeChunk:withValue: */
													assert(isFreeObject(prev));
													assert((next == 0)
													 || (isFreeObject(next)));
													longAtput((prev + (BaseHeaderSize)) + (0 << 2), next);
												}
												GIV(totalFreeOldSpace) -= b;
												f = node;
												goto l7;
											}
											prev = node;
											node = next;
										}
									}
								}
								f = null;
								goto l7;
							}
							node = 0;
							child = GIV(freeLists)[0];
							while (child != 0) {
								assert(isValidFreeObject(child));
								childBytes = bytesInObject(child);
								if (childBytes == b) {

									/* size match; try to remove from list at node first. */

									node = child;
									while (1) {
										prev = node;
										node = longAt((node + (BaseHeaderSize)) + (0 << 2));
										if (!(node != 0)) break;
										if (node < (longAt(ptr))) {
											assert(isValidFreeObject(node));
											/* begin storePointer:ofFreeChunk:withValue: */
											assert(isFreeObject(prev));
											assert(((longAt((node + (BaseHeaderSize)) + (0 << 2))) == 0)
											 || (isFreeObject(longAt((node + (BaseHeaderSize)) + (0 << 2)))));
											longAtput((prev + (BaseHeaderSize)) + (0 << 2), longAt((node + (BaseHeaderSize)) + (0 << 2)));
											GIV(totalFreeOldSpace) -= b;
											f = ((rawNumSlotsOf(node)) == 0xFF
												? node - (BaseHeaderSize)
												: node);
											goto l7;
										}
									}
									if (!(child < (longAt(ptr)))) {
										f = null;
										goto l7;
									}
									next = longAt((child + (BaseHeaderSize)) + (0 << 2));
									if (next == 0) {

										/* no list; remove the interior node */

										unlinkSolitaryFreeTreeNode(child);
									}
									else {

										/* list; replace node with it */

										inFreeTreeReplacewith(child, next);
									}
									GIV(totalFreeOldSpace) -= b;
									f = ((rawNumSlotsOf(child)) == 0xFF
										? child - (BaseHeaderSize)
										: child);
									goto l7;
								}
								else {

									/* no size match; walk down the tree */

									/* begin fetchPointer:ofFreeChunk: */
									fieldIndex = (childBytes < b
										? 4
										: 3);
									child = longAt((child + (BaseHeaderSize)) + (fieldIndex << 2));
								}
							}
							f = null;
						l7:	/* end allocateOldSpaceChunkOfExactlyBytes:suchThat: */;
							if (f == null) {
								nmiss += 1;
								misfits -= wordSize();
								if (misfits < ((GIV(highestObjects).start))) {
									misfits = ((GIV(highestObjects).limit)) - (wordSize());
								}
								longAtput(misfits, longAt(ptr));
							}
							else {
								nfits += 1;
								/* begin copyAndForward:withBytes:toFreeChunk: */
								startOfObj = ((rawNumSlotsOf(longAt(ptr))) == 0xFF
									? (longAt(ptr)) - (BaseHeaderSize)
									: longAt(ptr));
								memcpy(((void *)f), ((void *)startOfObj), b);

								/* leave it to followRememberedForwarders to remember... */
								/* (self isRemembered: objOop) ifTrue:
								   [scavenger remember: freeObj]. */

								freeObj = f + ((longAt(ptr)) - startOfObj);
								/* begin forward:to: */
								/* begin setFormatOf:to: */
								assert(((7 >= 0) && (7 <= (formatMask()))));
								flag("endianness");
								longAtput(longAt(ptr), ((longAt(longAt(ptr))) & (~(0x1F << 24))) + (7 << 24));
								/* begin setClassIndexOf:to: */
								assert(((8 >= 0) && (8 <= (classIndexMask()))));
								flag("endianness");
								longAtput(longAt(ptr), ((longAt(longAt(ptr))) & (~0x3FFFFF)) + 8);
								/* begin storePointer:ofForwarder:withValue: */
								assert(isForwarded(longAt(ptr)));
								assert(!(isOopForwarded(freeObj)));
								if (isOldObject(longAt(ptr))) {

									/* most stores into young objects */

									if (((freeObj & 3) == 0)
									 && ((((usqInt) freeObj)) < (((usqInt) GIV(newSpaceLimit))))) {
										/* begin possibleRootStoreInto: */
										if (!(((((usqInt) (longAt(longAt(ptr)))) >> 29) & 1) != 0)) {
											remember(longAt(ptr));
											/* begin setIsRememberedOf:to: */
											flag("endianness");
											longAtput(longAt(ptr), (longAt(longAt(ptr))) | (1 << 29));
										}
									}
								}
								longAtput(((longAt(ptr)) + (BaseHeaderSize)) + (0 << 2), freeObj);
								if (f == GIV(firstFreeChunk)) {
									/* begin objectStartingAt: */
									/* begin rawNumSlotsOf: */
									flag("endianness");
									numSlots = ((usqInt) (((usqInt)(longAt(f + 4))))) >> 24;
									GIV(firstFreeChunk) = (numSlots == 0xFF
										? f + (BaseHeaderSize)
										: f);
								}
							}
						}

						if (((ptr -= wordSize())) < ((GIV(highestObjects).first))) {
							null;
							goto l1;
						}
					}
				}
			}
			else {

				/* enum in start to last range, last to start */

				if (ptr <= ((GIV(highestObjects).last))) {
					while (ptr >= ((GIV(highestObjects).start))) {
						if (!((((usqInt) (longAt(ptr)))) > (((usqInt) GIV(firstFreeChunk))))) {
							(GIV(highestObjects).first = misfits);
							print("exactFitCompact fits: ");
							printNum(nfits);
							print(" misfits: ");
							printNum(nmiss);
							/* begin cr */
							printf("\n");
							return;
						}
						if (!((((longAt(longAt(ptr))) & 0x3FFFFF) == 8)
							 || (((((usqInt) (longAt(longAt(ptr)))) >> 30) & 1) != 0))) {
							b = bytesInObject(longAt(ptr));
							/* begin allocateOldSpaceChunkOfExactlyBytes:suchThat: */
							index1 = ((sqInt) b >> 3);
							if (index1 < 32) {
								if (GIV(freeListsMask) & (1 << index1)) {
									if (((node1 = GIV(freeLists)[index1])) == 0) {
										GIV(freeListsMask) -= 1 << index1;
									}
									else {
										prev1 = 0;
										while (node1 != 0) {
											assert(node1 == (startOfObject(node1)));
											assert(isValidFreeObject(node1));
											next1 = longAt((node1 + (BaseHeaderSize)) + (0 << 2));
											if (node1 < (longAt(ptr))) {
												if (prev1 == 0) {
													GIV(freeLists)[index1] = next1;
												}
												else {
													/* begin storePointer:ofFreeChunk:withValue: */
													assert(isFreeObject(prev1));
													assert((next1 == 0)
													 || (isFreeObject(next1)));
													longAtput((prev1 + (BaseHeaderSize)) + (0 << 2), next1);
												}
												GIV(totalFreeOldSpace) -= b;
												f = node1;
												goto l8;
											}
											prev1 = node1;
											node1 = next1;
										}
									}
								}
								f = null;
								goto l8;
							}
							node1 = 0;
							child1 = GIV(freeLists)[0];
							while (child1 != 0) {
								assert(isValidFreeObject(child1));
								childBytes1 = bytesInObject(child1);
								if (childBytes1 == b) {

									/* size match; try to remove from list at node first. */

									node1 = child1;
									while (1) {
										prev1 = node1;
										node1 = longAt((node1 + (BaseHeaderSize)) + (0 << 2));
										if (!(node1 != 0)) break;
										if (node1 < (longAt(ptr))) {
											assert(isValidFreeObject(node1));
											/* begin storePointer:ofFreeChunk:withValue: */
											assert(isFreeObject(prev1));
											assert(((longAt((node1 + (BaseHeaderSize)) + (0 << 2))) == 0)
											 || (isFreeObject(longAt((node1 + (BaseHeaderSize)) + (0 << 2)))));
											longAtput((prev1 + (BaseHeaderSize)) + (0 << 2), longAt((node1 + (BaseHeaderSize)) + (0 << 2)));
											GIV(totalFreeOldSpace) -= b;
											f = ((rawNumSlotsOf(node1)) == 0xFF
												? node1 - (BaseHeaderSize)
												: node1);
											goto l8;
										}
									}
									if (!(child1 < (longAt(ptr)))) {
										f = null;
										goto l8;
									}
									next1 = longAt((child1 + (BaseHeaderSize)) + (0 << 2));
									if (next1 == 0) {

										/* no list; remove the interior node */

										unlinkSolitaryFreeTreeNode(child1);
									}
									else {

										/* list; replace node with it */

										inFreeTreeReplacewith(child1, next1);
									}
									GIV(totalFreeOldSpace) -= b;
									f = ((rawNumSlotsOf(child1)) == 0xFF
										? child1 - (BaseHeaderSize)
										: child1);
									goto l8;
								}
								else {

									/* no size match; walk down the tree */

									/* begin fetchPointer:ofFreeChunk: */
									fieldIndex1 = (childBytes1 < b
										? 4
										: 3);
									child1 = longAt((child1 + (BaseHeaderSize)) + (fieldIndex1 << 2));
								}
							}
							f = null;
						l8:	/* end allocateOldSpaceChunkOfExactlyBytes:suchThat: */;
							if (f == null) {
								nmiss += 1;
								misfits -= wordSize();
								if (misfits < ((GIV(highestObjects).start))) {
									misfits = ((GIV(highestObjects).limit)) - (wordSize());
								}
								longAtput(misfits, longAt(ptr));
							}
							else {
								nfits += 1;
								/* begin copyAndForward:withBytes:toFreeChunk: */
								startOfObj1 = ((rawNumSlotsOf(longAt(ptr))) == 0xFF
									? (longAt(ptr)) - (BaseHeaderSize)
									: longAt(ptr));
								memcpy(((void *)f), ((void *)startOfObj1), b);

								/* leave it to followRememberedForwarders to remember... */
								/* (self isRemembered: objOop) ifTrue:
								   [scavenger remember: freeObj]. */

								freeObj1 = f + ((longAt(ptr)) - startOfObj1);
								/* begin forward:to: */
								/* begin setFormatOf:to: */
								assert(((7 >= 0) && (7 <= (formatMask()))));
								flag("endianness");
								longAtput(longAt(ptr), ((longAt(longAt(ptr))) & (~(0x1F << 24))) + (7 << 24));
								/* begin setClassIndexOf:to: */
								assert(((8 >= 0) && (8 <= (classIndexMask()))));
								flag("endianness");
								longAtput(longAt(ptr), ((longAt(longAt(ptr))) & (~0x3FFFFF)) + 8);
								/* begin storePointer:ofForwarder:withValue: */
								assert(isForwarded(longAt(ptr)));
								assert(!(isOopForwarded(freeObj1)));
								if (isOldObject(longAt(ptr))) {

									/* most stores into young objects */

									if (((freeObj1 & 3) == 0)
									 && ((((usqInt) freeObj1)) < (((usqInt) GIV(newSpaceLimit))))) {
										/* begin possibleRootStoreInto: */
										if (!(((((usqInt) (longAt(longAt(ptr)))) >> 29) & 1) != 0)) {
											remember(longAt(ptr));
											/* begin setIsRememberedOf:to: */
											flag("endianness");
											longAtput(longAt(ptr), (longAt(longAt(ptr))) | (1 << 29));
										}
									}
								}
								longAtput(((longAt(ptr)) + (BaseHeaderSize)) + (0 << 2), freeObj1);
								if (f == GIV(firstFreeChunk)) {
									/* begin objectStartingAt: */
									/* begin rawNumSlotsOf: */
									flag("endianness");
									numSlots = ((usqInt) (((usqInt)(longAt(f + 4))))) >> 24;
									GIV(firstFreeChunk) = (numSlots == 0xFF
										? f + (BaseHeaderSize)
										: f);
								}
							}
						}

						ptr -= wordSize();
					}
					ptr = (GIV(highestObjects).limit);
				}
				while (ptr >= ((GIV(highestObjects).first))) {
					if (!((((usqInt) (longAt(ptr)))) > (((usqInt) GIV(firstFreeChunk))))) {
						(GIV(highestObjects).first = misfits);
						print("exactFitCompact fits: ");
						printNum(nfits);
						print(" misfits: ");
						printNum(nmiss);
						/* begin cr */
						printf("\n");
						return;
					}
					if (!((((longAt(longAt(ptr))) & 0x3FFFFF) == 8)
						 || (((((usqInt) (longAt(longAt(ptr)))) >> 30) & 1) != 0))) {
						b = bytesInObject(longAt(ptr));
						/* begin allocateOldSpaceChunkOfExactlyBytes:suchThat: */
						index2 = ((sqInt) b >> 3);
						if (index2 < 32) {
							if (GIV(freeListsMask) & (1 << index2)) {
								if (((node2 = GIV(freeLists)[index2])) == 0) {
									GIV(freeListsMask) -= 1 << index2;
								}
								else {
									prev2 = 0;
									while (node2 != 0) {
										assert(node2 == (startOfObject(node2)));
										assert(isValidFreeObject(node2));
										next2 = longAt((node2 + (BaseHeaderSize)) + (0 << 2));
										if (node2 < (longAt(ptr))) {
											if (prev2 == 0) {
												GIV(freeLists)[index2] = next2;
											}
											else {
												/* begin storePointer:ofFreeChunk:withValue: */
												assert(isFreeObject(prev2));
												assert((next2 == 0)
												 || (isFreeObject(next2)));
												longAtput((prev2 + (BaseHeaderSize)) + (0 << 2), next2);
											}
											GIV(totalFreeOldSpace) -= b;
											f = node2;
											goto l9;
										}
										prev2 = node2;
										node2 = next2;
									}
								}
							}
							f = null;
							goto l9;
						}
						node2 = 0;
						child2 = GIV(freeLists)[0];
						while (child2 != 0) {
							assert(isValidFreeObject(child2));
							childBytes2 = bytesInObject(child2);
							if (childBytes2 == b) {

								/* size match; try to remove from list at node first. */

								node2 = child2;
								while (1) {
									prev2 = node2;
									node2 = longAt((node2 + (BaseHeaderSize)) + (0 << 2));
									if (!(node2 != 0)) break;
									if (node2 < (longAt(ptr))) {
										assert(isValidFreeObject(node2));
										/* begin storePointer:ofFreeChunk:withValue: */
										assert(isFreeObject(prev2));
										assert(((longAt((node2 + (BaseHeaderSize)) + (0 << 2))) == 0)
										 || (isFreeObject(longAt((node2 + (BaseHeaderSize)) + (0 << 2)))));
										longAtput((prev2 + (BaseHeaderSize)) + (0 << 2), longAt((node2 + (BaseHeaderSize)) + (0 << 2)));
										GIV(totalFreeOldSpace) -= b;
										f = ((rawNumSlotsOf(node2)) == 0xFF
											? node2 - (BaseHeaderSize)
											: node2);
										goto l9;
									}
								}
								if (!(child2 < (longAt(ptr)))) {
									f = null;
									goto l9;
								}
								next2 = longAt((child2 + (BaseHeaderSize)) + (0 << 2));
								if (next2 == 0) {

									/* no list; remove the interior node */

									unlinkSolitaryFreeTreeNode(child2);
								}
								else {

									/* list; replace node with it */

									inFreeTreeReplacewith(child2, next2);
								}
								GIV(totalFreeOldSpace) -= b;
								f = ((rawNumSlotsOf(child2)) == 0xFF
									? child2 - (BaseHeaderSize)
									: child2);
								goto l9;
							}
							else {

								/* no size match; walk down the tree */

								/* begin fetchPointer:ofFreeChunk: */
								fieldIndex2 = (childBytes2 < b
									? 4
									: 3);
								child2 = longAt((child2 + (BaseHeaderSize)) + (fieldIndex2 << 2));
							}
						}
						f = null;
					l9:	/* end allocateOldSpaceChunkOfExactlyBytes:suchThat: */;
						if (f == null) {
							nmiss += 1;
							misfits -= wordSize();
							if (misfits < ((GIV(highestObjects).start))) {
								misfits = ((GIV(highestObjects).limit)) - (wordSize());
							}
							longAtput(misfits, longAt(ptr));
						}
						else {
							nfits += 1;
							/* begin copyAndForward:withBytes:toFreeChunk: */
							startOfObj2 = ((rawNumSlotsOf(longAt(ptr))) == 0xFF
								? (longAt(ptr)) - (BaseHeaderSize)
								: longAt(ptr));
							memcpy(((void *)f), ((void *)startOfObj2), b);

							/* leave it to followRememberedForwarders to remember... */
							/* (self isRemembered: objOop) ifTrue:
							   [scavenger remember: freeObj]. */

							freeObj2 = f + ((longAt(ptr)) - startOfObj2);
							/* begin forward:to: */
							/* begin setFormatOf:to: */
							assert(((7 >= 0) && (7 <= (formatMask()))));
							flag("endianness");
							longAtput(longAt(ptr), ((longAt(longAt(ptr))) & (~(0x1F << 24))) + (7 << 24));
							/* begin setClassIndexOf:to: */
							assert(((8 >= 0) && (8 <= (classIndexMask()))));
							flag("endianness");
							longAtput(longAt(ptr), ((longAt(longAt(ptr))) & (~0x3FFFFF)) + 8);
							/* begin storePointer:ofForwarder:withValue: */
							assert(isForwarded(longAt(ptr)));
							assert(!(isOopForwarded(freeObj2)));
							if (isOldObject(longAt(ptr))) {

								/* most stores into young objects */

								if (((freeObj2 & 3) == 0)
								 && ((((usqInt) freeObj2)) < (((usqInt) GIV(newSpaceLimit))))) {
									/* begin possibleRootStoreInto: */
									if (!(((((usqInt) (longAt(longAt(ptr)))) >> 29) & 1) != 0)) {
										remember(longAt(ptr));
										/* begin setIsRememberedOf:to: */
										flag("endianness");
										longAtput(longAt(ptr), (longAt(longAt(ptr))) | (1 << 29));
									}
								}
							}
							longAtput(((longAt(ptr)) + (BaseHeaderSize)) + (0 << 2), freeObj2);
							if (f == GIV(firstFreeChunk)) {
								/* begin objectStartingAt: */
								/* begin rawNumSlotsOf: */
								flag("endianness");
								numSlots = ((usqInt) (((usqInt)(longAt(f + 4))))) >> 24;
								GIV(firstFreeChunk) = (numSlots == 0xFF
									? f + (BaseHeaderSize)
									: f);
							}
						}
					}

					ptr -= wordSize();
				}
			}
		}
		null;
	l1:	/* end from:reverseDo: */;
		/* begin checkFreeSpace */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		first = longAt((GIV(highestObjects).first));
		assert(oopisGreaterThan(first, GIV(firstFreeChunk)));
		nHighest = usedSize(&GIV(highestObjects));
		(GIV(highestObjects).first = misfits);
		nMisses = usedSize(&GIV(highestObjects));
		if (nMisses > (((sqInt) nHighest >> 1))) {
			print("exactFitCompact fits: ");
			printNum(nfits);
			print(" misfits: ");
			printNum(nmiss);
			/* begin cr */
			printf("\n");
			return;
		}
		/* begin moveMisfitsToTopOfHighestObjects: */
		oldLimit = (GIV(highestObjects).limit);
		if (misfits == (((GIV(highestObjects).last)) + (wordSize()))) {
			savedLimit = oldLimit;
			goto l2;
		}
		if (oopisLessThanOrEqualTo(misfits, (GIV(highestObjects).last))) {
			bytesToMove = (((GIV(highestObjects).last)) + (wordSize())) - misfits;
			memmove(((void *)(((GIV(highestObjects).limit)) - bytesToMove)), ((void *)misfits), bytesToMove);
			(GIV(highestObjects).limit = misfits - (wordSize()));
			savedLimit = oldLimit;
			goto l2;
		}
		bytesToMove = ((GIV(highestObjects).last)) - ((GIV(highestObjects).start));
		memmove(((void *)(misfits - bytesToMove)), ((void *)misfits), oldLimit - misfits);
		(GIV(highestObjects).limit = misfits - bytesToMove);
		memmove(((void *)(oldLimit - bytesToMove)), ((void *)((GIV(highestObjects).start))), bytesToMove);
		savedLimit = oldLimit;
	l2:	/* end moveMisfitsToTopOfHighestObjects: */;
		fillHighestObjectsWithMovableObjectsFromupTo(GIV(firstFreeChunk), first);
		/* begin moveMisfitsInHighestObjectsBack: */
		if (savedLimit == ((GIV(highestObjects).limit))) {
			misfits = (GIV(highestObjects).last);
			goto l3;
		}
		if ((((GIV(highestObjects).first)) == ((GIV(highestObjects).start)))
		 && (((GIV(highestObjects).last)) < ((GIV(highestObjects).limit)))) {
			newMisfitsPosition = (GIV(highestObjects).limit);
			memmove(((void *)newMisfitsPosition), ((void *)(((GIV(highestObjects).last)) + (wordSize()))), savedLimit - newMisfitsPosition);
			(GIV(highestObjects).limit = savedLimit);
			misfits = newMisfitsPosition;
			goto l3;
		}
		error("shouldBeImplemented");
		misfits = newMisfitsPosition;
	l3:	/* end moveMisfitsInHighestObjectsBack: */;
	} while((usedSize(&GIV(highestObjects))) > 0);
}

static sqInt
existInstancesInNewSpaceOf(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevPrevObj;

	/* begin rawHashBitsOf: */
	flag("endianness");
	classIndex = (longAt(classObj + 4)) & 0x3FFFFF;
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((longAt(objOop1)) & 0x3FFFFF) == classIndex) {
			return 1;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((longAt(objOop1)) & 0x3FFFFF) == classIndex) {
			return 1;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	return 0;
}


/*	Bits have been set in the classTableBitmap corresponding to
	used classes. Any class in the class table that does not have a
	bit set has no instances with that class index. However, becomeForward:
	can create duplicate entries, and these duplicate entries
	a) won't have a bit set on load (because there are no forwarders on load),
	b) wont match their identityHash.
	So expunge duplicates by eliminating unmarked entries that don't occur at
	their identityHash. */

static void
expungeDuplicateClasses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt byteIndex;
    sqInt classIndex;
    sqInt classOrNil;
    sqInt classTablePage;
    sqInt i;
    sqInt majorBitIndex;
    sqInt majorBitIndexLimiT;
    sqInt minorBitIndex;

	for (i = 1; i < GIV(numClassTablePages); i += 1) {

		/* optimize scan by only scanning bitmap in regions that have pages. */

		classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (i << 2));
		if (classTablePage != GIV(nilObj)) {
			for (majorBitIndex = (i << 10), majorBitIndexLimiT = ((i << 10) + ((1 << 10) - 1)); majorBitIndex <= majorBitIndexLimiT; majorBitIndex += 8) {

				/* optimize scan by scanning a byte of indices (8 indices) at a time */

				byteIndex = ((sqInt) majorBitIndex >> 3);
				byte = GIV(classTableBitmap)[byteIndex];
				if (byte != 0xFF) {
					for (minorBitIndex = 0; minorBitIndex <= 7; minorBitIndex += 1) {
						if ((byte & (1 << minorBitIndex)) == 0) {
							classIndex = majorBitIndex + minorBitIndex;
							classOrNil = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
							assert((classAtIndex(classIndex)) == classOrNil);
							if ((classOrNil != GIV(nilObj))
							 && ((rawHashBitsOf(classOrNil)) != classIndex)) {
								/* begin storePointerUnchecked:ofObject:withValue: */
								assert(!(isForwarded(classTablePage)));
								longAtput((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2), GIV(nilObj));
								assert((classAtIndex(rawHashBitsOf(classOrNil))) == classOrNil);
							}
						}
					}
				}
			}
		}
	}
}


/*	Divorce a single frame and its context. If it is not the top frame of a
	stack this means splitting its stack. */

static void
externalDivorceFrameandContext(char *theFP, sqInt ctxt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt callerCtx;
    char *callerFP;
    char *callerFP1;
    sqInt callerIP;
    char *callerSP;
    char *frameAbove;
    sqInt index;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt onCurrent;
    sqInt theIP;
    StackPage *thePage;
    char *theSP;
    char *theSP1;
    sqInt valuePointer;


	/* stackPage needs to have current head pointers to avoid confusion. */

	assert((GIV(stackPage) == 0)
	 || (GIV(stackPage) == (mostRecentlyUsedPage())));
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	if (!((onCurrent = thePage == GIV(stackPage)))) {
		markStackPageNextMostRecentlyUsed(thePage);
	}
	theSP = findSPOfon(theFP, thePage);
	updateStateOfSpouseContextForFrameWithSP(theFP, theSP);
	/* begin ensureCallerContext: */
	/* begin frameCallerFP: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */

		callerCtx = longAt(theFP + FoxCallerContext);
		goto l2;
	}
	/* begin ensureFrameIsMarried:SP: */
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP1 = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
	if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP1)));
		callerCtx = longAt(callerFP1 + FoxThisContext);
		goto l2;
	}
	callerCtx = marryFrameSP(callerFP1, theSP1);
l2:	/* end ensureCallerContext: */;
	if (((frameAbove = findFrameAboveinPage(theFP, thePage))) == 0) {

		/* If we're divorcing the top frame we can simply peel it off. */

		theIP = longAt((thePage->headSP));
	}
	else {

		/* othewise move all frames above to a new stack and then peel the frame off. */

		/* begin newStackPage */
		lruOrFree = ((mostRecentlyUsedPage())->nextPage);
		if (isFree(lruOrFree)) {
			newPage = lruOrFree;
			goto l1;
		}
		divorceFramesIn(lruOrFree);
		newPage = lruOrFree;
	l1:	/* end newStackPage */;
		theIP = oopForPointer(frameCallerSavedIP(frameAbove));
		frameAbove = moveFramesInthroughtoPage(thePage, frameAbove, newPage);
		if (onCurrent) {
			/* begin setStackPageAndLimit: */
			assert(newPage != 0);
			GIV(stackPage) = newPage;
			if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
				GIV(stackLimit) = (GIV(stackPage)->stackLimit);
			}
			markStackPageMostRecentlyUsed(newPage);
			GIV(framePointer) = (GIV(stackPage)->headFP);
			GIV(stackPointer) = (GIV(stackPage)->headSP);
		}
		else {
			markStackPageMostRecentlyUsed(newPage);
		}
		assert((frameCallerContext(frameAbove)) == ctxt);
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	/* begin contextInstructionPointer:frame: */
	assert(validInstructionPointerinFrame(theIP, theFP));
	valuePointer = (((((theIP - (longAt(theFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
	assert(!(isForwarded(ctxt)));
	longAtput((ctxt + (BaseHeaderSize)) + (InstructionPointerIndex << 2), valuePointer);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(ctxt)));
	if (isOldObject(ctxt)) {

		/* most stores into young objects */

		if (((callerCtx & 3) == 0)
		 && ((((usqInt) callerCtx)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(ctxt))) >> 29) & 1) != 0)) {
				remember(ctxt);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(ctxt, (longAt(ctxt)) | (1 << 29));
			}
		}
	}
	longAtput((ctxt + (BaseHeaderSize)) + (SenderIndex << 2), callerCtx);
	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* theFP is a base frame; it is now alone; free the entire page */

		/* begin freeStackPage: */
		freeStackPageNoAssert(thePage);
		assert(pageListIsWellFormed());
	}
	else {
		callerIP = oopForPointer(frameCallerSavedIP(theFP));
		callerSP = (frameCallerSP(theFP)) - BytesPerWord;
		longAtput(callerSP, callerIP);
		/* begin setHeadFP:andSP:inPage: */
		assert(callerSP < callerFP);
		assert((callerSP < ((thePage->baseAddress)))
		 && (callerSP > (((thePage->realStackLimit)) - LargeContextSize)));
		assert((callerFP < ((thePage->baseAddress)))
		 && (callerFP > (((thePage->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(thePage->headFP = callerFP);
		(thePage->headSP = callerSP);
	}
}


/*	Ensure aFramePtr is a base frame. Then we can assign its sender.
	Answer the possibly moved location of the frame. */

static char *
externalEnsureIsBaseFrame(char *aFramePtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt onCurrent;
    char *theFP;
    StackPage *thePage;

	if ((longAt(aFramePtr + FoxSavedFP)) == 0) {
		return aFramePtr;
	}
	theFP = aFramePtr;
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));

	/* Storing the frame's sender with its caller's context
	   has the side effect of making theFP a base frame. */

	onCurrent = thePage == GIV(stackPage);
	theFP = storeSenderOfFramewithValue(theFP, ensureCallerContext(theFP));
	if (onCurrent) {
		assert(GIV(stackPage) != thePage);
		GIV(framePointer) = (GIV(stackPage)->headFP);
		GIV(stackPointer) = (GIV(stackPage)->headSP);
	}
	else {
		markStackPageMostRecentlyUsed(GIV(stackPage));
	}
	assert(pageListIsWellFormed());
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	return theFP;
}


/*	Fetch an instance variable from a maybe married context.
	If the context is still married compute the value of the
	relevant inst var from the spouse frame's state. */

static sqInt
externalInstVarofContext(sqInt offset, sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *callerFP1;
    char *fp;
    sqInt index;
    char *spouseFP;
    char *theFPAbove;
    sqInt theIP;
    StackPage *thePage;
    char *theSP;
    sqInt value;

	assert(isContext(aContext));
	if (!((offset < MethodIndex)
		 && (((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)))) {
		return longAt((aContext + (BaseHeaderSize)) + (offset << 2));
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (isWidowedContext(aContext)) {
		return longAt((aContext + (BaseHeaderSize)) + (offset << 2));
	}
	/* begin frameOfMarriedContext: */
	value = longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	spouseFP = pointerForOop(value - 1);
	if (offset == SenderIndex) {
		/* begin ensureCallerContext: */
		/* begin frameCallerFP: */
		callerFP1 = pointerForOop(longAt(spouseFP + FoxSavedFP));
		if (callerFP1 == 0) {

			/* base frame, context in saved ip slot (or base of stack in Cog) */

			return longAt(spouseFP + FoxCallerContext);
		}
		/* begin ensureFrameIsMarried:SP: */
		/* begin frameCallerStackPointer: */
		assert(!(isBaseFrame(spouseFP)));
		theSP = (spouseFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((spouseFP + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
		if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(callerFP1)));
			return longAt(callerFP1 + FoxThisContext);
		}
		return marryFrameSP(callerFP1, theSP);
	}
	if (offset == StackPointerIndex) {
		assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(aContext)));
		return (((stackPointerIndexForFrame(spouseFP)) << 1) | 1);
	}
	if (offset == InstructionPointerIndex) {
		if (spouseFP == GIV(framePointer)) {
			theIP = oopForPointer(GIV(instructionPointer));
		}
		else {
			/* begin stackPageFor: */
			/* begin stackPageAt: */
			index = pageIndexForstackMemorybytesPerPage(spouseFP, GIV(stackMemory), GIV(bytesPerPage));
			thePage = stackPageAtpages(index, GIV(pages));
			/* begin findFrameAbove:inPage: */
			fp = (thePage->headFP);
			if (fp == spouseFP) {
				theFPAbove = 0;
				goto l1;
			}
			while (((callerFP = frameCallerFP(fp))) != 0) {
				if (callerFP == spouseFP) {
					theFPAbove = fp;
					goto l1;
				}
				fp = callerFP;
			}
			error("did not find theFP in stack page");
			theFPAbove = 0;
		l1:	/* end findFrameAbove:inPage: */;
			theIP = (theFPAbove == 0
				? longAt((thePage->headSP))
				: oopForPointer(frameCallerSavedIP(theFPAbove)));
		}
		/* begin contextInstructionPointer:frame: */
		assert(validInstructionPointerinFrame(theIP, spouseFP));
		return (((((theIP - (longAt(spouseFP + FoxMethod))) - BaseHeaderSize) + 2) << 1) | 1);
	}
	error("bad index");
	return 0;
}


/*	Invoke a quick primitive.
	Called under the assumption that primFunctionPtr has been preloaded */

static sqInt
externalQuickPrimitiveResponse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt localPrimIndex;
    sqInt oop;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;

	assert(isPrimitiveFunctionPointerAnIndex());
	localPrimIndex = ((sqInt) primitiveFunctionPointer);
	assert((localPrimIndex > 0xFF)
	 && (localPrimIndex < 520));
	if (localPrimIndex >= 264) {
		/* begin pop:thenPush: */
		oop = longAt(((longAt(GIV(stackPointer))) + (BaseHeaderSize)) + ((localPrimIndex - 264) << 2));
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
		return 1;
	}
	if (localPrimIndex == 256) {
		return 1;
	}
	if (localPrimIndex == 257) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return 1;
	}
	if (localPrimIndex == 258) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp2;
		return 1;
	}
	if (localPrimIndex == 259) {
		/* begin pop:thenPush: */
		longAtput((sp3 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp3;
		return 1;
	}
	/* begin pop:thenPush: */
	longAtput((sp4 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (((localPrimIndex - 261) << 1) | 1));
	GIV(stackPointer) = sp4;
	return 1;
}


/*	See initializeStack:numSlots:pageSize:stackLimitOffset:stackPageHeadroom:
	``Because stack pages grow down...'' */

static sqInt
extraStackBytes(void)
{
	return BytesPerWord;
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

sqInt
failed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}


/*	not inlined for breakpoint value... */

static void
failUnbalancedPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(primFailCode) = PrimErrBadNumArgs;
}

sqInt
falseObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(falseObj);
}


/*	Fetch the instance variable at the given index of the given object. Return
	the address of first indexable field of resulting array object, or fail if
	the instance variable does not contain an indexable bytes or words object.
 */
/*	Note: May be called by translated primitive code. */

void *
fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOop;

	arrayOop = longAt((objectPointer + (BaseHeaderSize)) + (fieldIndex << 2));
	/* begin arrayValueOf: */
	if (((arrayOop & 3) == 0)
	 && (((((usqInt) (longAt(arrayOop))) >> 24) & 0x1F) > 5)) {
		return ((void *) (pointerForOop(arrayOop + BaseHeaderSize)));
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return null;
}

sqInt
fetchByteofObject(sqInt byteIndex, sqInt objOop)
{
	return byteAt((objOop + (BaseHeaderSize)) + byteIndex);
}

static sqInt
fetchClassOfNonImm(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;

	classIndex = (longAt(objOop)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		return objOop;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	return longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
}

sqInt
fetchClassOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt tagBits;

	if (((tagBits = oop & 3)) != 0) {
		return longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(oop)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		return oop;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		return null;
	}
	return longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
}


/*	Fetch the instance variable at the given index of the given object. Return
	the C double precision floating point value of that instance variable, or
	fail if it is not a Float.
 */
/*	Note: May be called by translated primitive code. */

double
fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt floatOop;
    sqInt isFloat;
    double result;

	floatOop = longAt((objectPointer + (BaseHeaderSize)) + (fieldIndex << 2));
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((floatOop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(floatOop)));
	ccIndex = (longAt(floatOop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(floatOop + (BaseHeaderSize), result);
		return result;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	Note: May be called by translated primitive code. */

sqInt
fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt intOop;

	intOop = longAt((objectPointer + (BaseHeaderSize)) + (fieldIndex << 2));
	/* begin checkedIntegerValueOf: */
	if ((intOop & 1)) {
		return (intOop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	index by 32-bit units, and return a 32-bit value. Intended to replace
	fetchWord:ofObject: 
 */

sqInt
fetchLong32ofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + (BaseHeaderSize)) + (fieldIndex << 2));
}

static sqInt
fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + (BaseHeaderSize)) + (fieldIndex << 2));
}

sqInt
fetchPointerofObject(sqInt fieldIndex, sqInt objOop)
{
	return longAt((objOop + (BaseHeaderSize)) + (fieldIndex << 2));
}


/*	Return the stackPointer of a Context or BlockContext.
	Does not deal with married contexts. Use only for debug
	printing or object tracing functions. To obtain an accurate
	stack pointer use stackPointerForMaybeMarriedContext: */

static sqInt
fetchStackPointerOf(sqInt aContext)
{
    sqInt sp;

	sp = longAt((aContext + (BaseHeaderSize)) + (StackPointerIndex << 2));
	if (!((sp & 1))) {
		return 0;
	}
	assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(aContext)));
	return (sp >> 1);
}


/*	Refill highestObjects with movable objects up to, but not including
	limitObj. c.f. the loop in
	freeUnmarkedObjectsNilUnmarkedWeaklingSlotsAndSortAndCoalesceFreeSpace. 
 */

static void
fillHighestObjectsWithMovableObjectsFromupTo(sqInt startObj, sqInt limitObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstFree;
    sqInt highestObjectsWraps;
    usqInt lastHighest;
    sqInt o;
    sqInt objOop;
    sqInt prevObj;
    sqInt prevPrevObj;

	/* begin resetAsEmpty */
	(GIV(highestObjects).first) = (GIV(highestObjects).start);
	(GIV(highestObjects).last) = ((GIV(highestObjects).start)) - (wordSize());
	GIV(highestObjects);
	lastHighest = (GIV(highestObjects).last);
	highestObjectsWraps = (firstFree = 0);
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj = (prevObj = null);
	objOop = startObj;
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!((((usqInt) objOop)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop)) != 0);
		if ((((usqInt) objOop)) >= (((usqInt) limitObj))) {
			(GIV(highestObjects).last = lastHighest);
			if ((firstFree != 0)
			 && (!(((longAt(GIV(firstFreeChunk))) & 0x3FFFFF) == 0))) {
				GIV(firstFreeChunk) = firstFree;
			}
			return;
		}
		if (((longAt(objOop)) & 0x3FFFFF) == 0) {
			if (firstFree == 0) {
				firstFree = objOop;
			}
		}
		else {
			if (!((((longAt(objOop)) & 0x3FFFFF) == 8)
				 || (((((usqInt) (longAt(objOop))) >> 30) & 1) != 0))) {

				/* conceptually...: */

				
				/* but we inline so we can use the local lastHighest */

				if (((lastHighest += wordSize())) >= ((GIV(highestObjects).limit))) {
					highestObjectsWraps += 1;
					lastHighest = (GIV(highestObjects).start);
				}
				longAtput(lastHighest, objOop);

			}
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = objectAfterlimit(objOop, GIV(endOfMemory));
	}
	
	
	(GIV(highestObjects).last = lastHighest);
	if ((firstFree != 0)
	 && (!(((longAt(GIV(firstFreeChunk))) & 0x3FFFFF) == 0))) {
		GIV(firstFreeChunk) = firstFree;
	}
}

static sqInt
findClassContainingMethodstartingAt(sqInt meth, sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    usqInt classDictSize;
    sqInt currClass;
    sqInt i;
    sqInt methodArray;
    usqInt numSlots;

	currClass = classObj;
	do {
		assert(!(isForwarded(currClass)));
		classDict = longAt((currClass + (BaseHeaderSize)) + (MethodDictionaryIndex << 2));
		assert(!(isForwarded(classDict)));
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(classDict)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots = ((usqInt) (((usqInt)(longAt(classDict + 4))))) >> 24;
		classDictSize = (numSlots == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(classDict - (BaseHeaderSize)))
			: numSlots);
		methodArray = longAt((classDict + (BaseHeaderSize)) + (MethodArrayIndex << 2));
		assert(!(isForwarded(methodArray)));
		i = 0;
		while (i < (classDictSize - SelectorStart)) {
			if (meth == (longAt((methodArray + (BaseHeaderSize)) + (i << 2)))) {
				return currClass;
			}
			i += 1;
		}
		currClass = longAt((currClass + (BaseHeaderSize)) + (SuperclassIndex << 2));
	} while(!(currClass == GIV(nilObj)));
	return currClass;
}

sqInt
findClassOfMethodforReceiver(sqInt meth, sqInt rcvr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt rclass;
    sqInt tagBits;

	if ((((rcvr & 3) != 0)
 || (addressCouldBeObj(rcvr)))
	 && (!(((rcvr & 3) == 0)
 && (((longAt(rcvr)) & 0x3FFFFF) == 8)))) {
		/* begin fetchClassOf: */
		if (((tagBits = rcvr & 3)) != 0) {
			rclass = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
			goto l1;
		}
		/* begin fetchClassOfNonImm: */
		classIndex = (longAt(rcvr)) & 0x3FFFFF;
		if (classIndex == 0x1F) {
			rclass = rcvr;
			goto l1;
		}
		assert(classIndex >= (arrayClassIndexPun()));
		/* begin classAtIndex: */
		assert((classIndex <= (tagMask()))
		 || (classIndex >= (arrayClassIndexPun())));
		classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
		if (classTablePage == GIV(nilObj)) {
			rclass = null;
			goto l1;
		}
		rclass = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
	l1:	/* end fetchClassOf: */;
		if (addressCouldBeClassObj(rclass)) {
			rclass = findClassContainingMethodstartingAt(meth, rclass);
			if (rclass != GIV(nilObj)) {
				return rclass;
			}
		}
	}
	if (!((addressCouldBeObj(meth))
		 && (((((usqInt) (longAt(meth))) >> 24) & 0x1F) >= 24))) {
		return GIV(nilObj);
	}
	return findClassContainingMethodstartingAt(meth, methodClassOf(meth));
}


/*	Answer the frame above theFP (adjacent frame nearest head end).
	If theFP is the head frame answer 0. */

static char *
findFrameAboveinPage(char *theFP, StackPage *thePage)
{
    char *callerFP;
    char *fp;

	fp = (thePage->headFP);
	if (fp == theFP) {
		return 0;
	}
	while (((callerFP = frameCallerFP(fp))) != 0) {
		if (callerFP == theFP) {
			return fp;
		}
		fp = callerFP;
	}
	error("did not find theFP in stack page");
	return 0;
}

static sqInt
findHomeForContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;

	if (!(((aContext & 3) == 0)
		 && (((longAt(aContext)) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
		return null;
	}
	closureOrNil = longAt((aContext + (BaseHeaderSize)) + (ClosureIndex << 2));
	if (closureOrNil == GIV(nilObj)) {
		return aContext;
	}
	if ((fetchClassOf(closureOrNil)) != (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassBlockClosure << 2)))) {
		return null;
	}
	return findHomeForContext(longAt((closureOrNil + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2)));
}


/*	Answer, but do not remove, the largest free chunk in the free lists. */

static sqInt
findLargestFreeChunk(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt childNode;
    sqInt treeNode;

	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		return null;
	}
	while (1) {
		assert(isValidFreeObject(treeNode));
		childNode = longAt((treeNode + (BaseHeaderSize)) + (4 << 2));
		if (!(childNode != 0)) break;
		treeNode = childNode;
	}
	return treeNode;
}


/*	See findUnwindThroughContext:. Alas this is mutually recursive with
	findMethodWithPrimitive:FromFP:SP:ThroughContext: instead of iterative.
	We're doing the simplest thing that could possibly work. Niceties can
	wait.  */

static sqInt
findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt primBits;
    sqInt theContext;
    sqInt theMethod;

	assert((senderContext == (nilObject()))
	 || (isContext(senderContext)));
	assert((homeContext == (nilObject()))
	 || (isContext(homeContext)));
	theContext = senderContext;
	while (1) {
		if (theContext == GIV(nilObj)) {
			return theContext;
		}
		if (((longAt((theContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) break;
		if (theContext == homeContext) {
			return 0;
		}
		if ((longAt((theContext + (BaseHeaderSize)) + (ClosureIndex << 2))) == GIV(nilObj)) {
			theMethod = longAt((theContext + (BaseHeaderSize)) + (MethodIndex << 2));
			if ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? ((longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
				? ((firstBytecode = (theMethod + ((LiteralStart + ((((usqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
					(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
				: 0)
		: ((primBits = ((usqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#else /* MULTIPLEBYTECODESETS */
	((primBits = ((usqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#endif /* MULTIPLEBYTECODESETS */
	) == primitive) {
				return theContext;
			}
		}
		theContext = longAt((theContext + (BaseHeaderSize)) + (SenderIndex << 2));
	}
	if (isWidowedContext(theContext)) {
		return GIV(nilObj);
	}
	return findMethodWithPrimitiveFromFPUpToContext(primitive, frameOfMarriedContext(theContext), homeContext);
}


/*	See findUnwindThroughContext:. Alas this is mutually recursive with
	findMethodWithPrimitive:FromContext:ThroughContext: instead of iterative.
	We're doing the simplest thing that could possibly work. Niceties can
	wait.  */

static sqInt
findMethodWithPrimitiveFromFPUpToContext(sqInt primitive, char *startFP, sqInt homeContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt primBits;
    sqInt senderContext;
    char *theFP;
    char *theFPAbove;
    sqInt theMethod;
    char *theSP;

	theFP = startFP;
	theFPAbove = startFP;
	do {
		if (((byteAt((theFP + FoxFrameFlags) + 2)) != 0)
		 && (homeContext == (longAt(theFP + FoxThisContext)))) {
			return 0;
		}
		if (!((byteAt((theFP + FoxFrameFlags) + 3)) != 0)) {
			theMethod = longAt(theFP + FoxMethod);
			if ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? ((longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
				? ((firstBytecode = (theMethod + ((LiteralStart + ((((usqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
					(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
				: 0)
		: ((primBits = ((usqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#else /* MULTIPLEBYTECODESETS */
	((primBits = ((usqInt) (longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#endif /* MULTIPLEBYTECODESETS */
	) == primitive) {
				if (theFP == theFPAbove) {
					theSP = findSPOfon(theFP, stackPageFor(theFP));
				}
				else {
					/* begin frameCallerStackPointer: */
					assert(!(isBaseFrame(theFPAbove)));
					theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFPAbove + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(theFP)));
					return longAt(theFP + FoxThisContext);
				}
				return marryFrameSP(theFP, theSP);
			}
		}
		theFPAbove = theFP;
		/* begin frameCallerFP: */
		theFP = pointerForOop(longAt(theFP + FoxSavedFP));
	} while(theFP != 0);
	senderContext = longAt(theFPAbove + FoxCallerContext);
	if (!(((senderContext & 3) == 0)
		 && (((longAt(senderContext)) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
		return GIV(nilObj);
	}
	return findMethodWithPrimitiveFromContextUpToContext(primitive, senderContext, homeContext);
}


/*	Find the compiled method to be run when the current 
	messageSelector is sent to the given class, setting the values 
	of 'newMethod' and 'primitiveIndex'. */

static sqInt
findNewMethodInClassTag(sqInt classTagArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classTablePage;
    sqInt classTag;
    sqInt hash;
    sqInt hash1;
    sqInt ok;
    sqInt probe;
    sqInt probe1;

	/* begin lookupInMethodCacheSel:classTag: */

	/* shift drops two low-order zeros from addresses */

	hash1 = GIV(messageSelector) ^ classTagArg;

	/* first probe */

	probe1 = hash1 & MethodCacheMask;
	if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
	 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == classTagArg)) {
		GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
		ok = 1;
		goto l2;
	}

	/* second probe */

	probe1 = (((usqInt) hash1) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
	 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == classTagArg)) {
		GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
		ok = 1;
		goto l2;
	}
	probe1 = (((usqInt) hash1) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
	 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == classTagArg)) {
		GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
		ok = 1;
		goto l2;
	}
	ok = 0;
l2:	/* end lookupInMethodCacheSel:classTag: */;
	if (!ok) {

		/* entry was not found in the cache; look it up the hard way */

		classTag = classTagArg;
		if ((((GIV(messageSelector) & 3) == 0)
 && (((longAt(GIV(messageSelector))) & 0x3FFFFF) == 8))
		 || (classTag == 8)) {
			if (((GIV(messageSelector) & 3) == 0)
			 && (((longAt(GIV(messageSelector))) & 0x3FFFFF) == 8)) {
				GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
			}
			if (classTag == 8) {
				classTag = handleForwardedSendFaultForTag(classTag);
			}
			/* begin lookupInMethodCacheSel:classTag: */

			/* shift drops two low-order zeros from addresses */

			hash = GIV(messageSelector) ^ classTag;

			/* first probe */

			probe = hash & MethodCacheMask;
			if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
			 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
				GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
				primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
				ok = 1;
				goto l1;
			}

			/* second probe */

			probe = (((usqInt) hash) >> 1) & MethodCacheMask;
			if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
			 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
				GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
				primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
				ok = 1;
				goto l1;
			}
			probe = (((usqInt) hash) >> 2) & MethodCacheMask;
			if (((GIV(methodCache)[probe + MethodCacheSelector]) == GIV(messageSelector))
			 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
				GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
				primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
				ok = 1;
				goto l1;
			}
			ok = 0;
		l1:	/* end lookupInMethodCacheSel:classTag: */;
			if (ok) {
				return null;
			}
		}
		/* begin classAtIndex: */
		assert((classTag <= (tagMask()))
		 || (classTag >= (arrayClassIndexPun())));
		classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classTag) >> 10) << 2));
		if (classTablePage == GIV(nilObj)) {
			class = null;
			goto l3;
		}
		class = longAt((classTablePage + (BaseHeaderSize)) + ((classTag & ((1 << 10) - 1)) << 2));
	l3:	/* end classAtIndex: */;
		lookupMethodInClass(class);
		addNewMethodToCache(class);
	}
}

sqInt
findSelectorOfMethod(sqInt methArg)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classDict;
    usqInt classDictSize;
    sqInt classObj;
    sqInt i;
    sqInt meth;
    sqInt methodArray;
    usqInt numSlots;
    sqInt referent;

	if (!(addressCouldBeObj(methArg))) {
		return GIV(nilObj);
	}
	if (((longAt(methArg)) & 0x3FFFFF) == 8) {
		/* begin followForwarded: */
		assert(isForwarded(methArg));
		referent = longAt((methArg + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		meth = referent;
	}
	else {
		meth = methArg;
	}
	if (!(((meth & 3) == 0)
		 && (((((usqInt) (longAt(meth))) >> 24) & 0x1F) >= 24))) {
		return GIV(nilObj);
	}
	classObj = methodClassOf(meth);
	if (addressCouldBeClassObj(classObj)) {
		classDict = longAt((classObj + (BaseHeaderSize)) + (MethodDictionaryIndex << 2));
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(classDict)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots = ((usqInt) (((usqInt)(longAt(classDict + 4))))) >> 24;
		classDictSize = (numSlots == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(classDict - (BaseHeaderSize)))
			: numSlots);
		methodArray = longAt((classDict + (BaseHeaderSize)) + (MethodArrayIndex << 2));
		i = 0;
		while (i < (classDictSize - SelectorStart)) {
			if (meth == (longAt((methodArray + (BaseHeaderSize)) + (i << 2)))) {
				return longAt((classDict + (BaseHeaderSize)) + ((i + SelectorStart) << 2));
			}
			i += 1;
		}
	}
	return GIV(nilObj);
}


/*	Search for the stack pointer for theFP. This points to the hottest item on
	the frame's stack.
	DO NOT CALL THIS WITH theFP == localFP OR theFP == framePointer! */

static char *
findSPOfon(char *theFP, StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    char *startFrame;
    char *theSP;
    char *theSP1;

	/* begin findSPOrNilOf:on:startingFrom: */
	startFrame = (thePage->headFP);
	assert(!(isFree(thePage)));
	aFrame = startFrame;
	theSP1 = (thePage->headSP);
	if (aFrame == theFP) {
		if (theSP1 >= aFrame) {

			/* If the SP is invalid return the pointer to the receiver field. */

			/* begin frameReceiverOffset: */
			theSP = aFrame + FoxReceiver;
			goto l1;
		}
		theSP = (thePage == GIV(stackPage)
			? theSP1
			: theSP1 + BytesPerWord);
		goto l1;
	}
	while (1) {
		/* begin frameCallerSP: */
		assert(!(isBaseFrame(aFrame)));
		theSP1 = (aFrame + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((aFrame + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
		/* begin frameCallerFP: */
		aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
		if (!(aFrame != 0)) break;
		if (theFP == aFrame) {
			theSP = theSP1;
			goto l1;
		}
	}
	theSP = null;
l1:	/* end findSPOrNilOf:on:startingFrom: */;
	if (theSP != null) {
		return theSP;
	}
	error("did not find theFP in stack page");
	return 0;
}


/*	Print the oops of all string-like things that start with the same
	characters as aCString
 */

void
findStringBeginningWith(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt cssz;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	cssz = strlen(aCString);
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 16)
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> 24) & 0x1F)) >= cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1);
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			printNum(lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> 24) & 0x1F));
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			printOopShort(objOop1);
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 16)
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> 24) & 0x1F)) >= cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1);
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			printNum(lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> 24) & 0x1F));
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			printOopShort(objOop1);
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if ((((((usqInt) (longAt(objOop11))) >> 24) & 0x1F) >= 16)
			 && (((lengthOfformat(objOop11, (((usqInt) (longAt(objOop11))) >> 24) & 0x1F)) >= cssz)
			 && ((strncmp(aCString, pointerForOop(objOop11 + BaseHeaderSize), cssz)) == 0))) {
				printHex(objOop11);
				/* begin space */
				/* begin printChar: */
				putchar(' ');
				printNum(lengthOfformat(objOop11, (((usqInt) (longAt(objOop11))) >> 24) & 0x1F));
				/* begin space */
				/* begin printChar: */
				putchar(' ');
				printOopShort(objOop11);
				/* begin cr */
				printf("\n");
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
}


/*	Print the oops of all string-like things that have the same characters as
	aCString 
 */

void
findString(char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt cssz;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	cssz = strlen(aCString);
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 16)
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> 24) & 0x1F)) == cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1);
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			printOopShort(objOop1);
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 16)
		 && (((lengthOfformat(objOop1, (((usqInt) (longAt(objOop1))) >> 24) & 0x1F)) == cssz)
		 && ((strncmp(aCString, pointerForOop(objOop1 + BaseHeaderSize), cssz)) == 0))) {
			printHex(objOop1);
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			printOopShort(objOop1);
			/* begin cr */
			printf("\n");
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if ((((((usqInt) (longAt(objOop11))) >> 24) & 0x1F) >= 16)
			 && (((lengthOfformat(objOop11, (((usqInt) (longAt(objOop11))) >> 24) & 0x1F)) == cssz)
			 && ((strncmp(aCString, pointerForOop(objOop11 + BaseHeaderSize), cssz)) == 0))) {
				printHex(objOop11);
				/* begin space */
				/* begin printChar: */
				putchar(' ');
				printOopShort(objOop11);
				/* begin cr */
				printf("\n");
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
}

static sqInt
firstAccessibleObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt savedTenuringThreshold;

	assert(GIV(nilObj) == GIV(oldSpaceStart));
	/* begin flushNewSpace */
	savedTenuringThreshold = GIV(tenureThreshold);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = GIV(newSpaceLimit);
	scavengingGCTenuringIf(TenureByAge);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize()) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace()).start)));
	assert(GIV(freeStart) == (((eden()).start)));
	return GIV(nilObj);
}

sqInt
firstByteFormat(void)
{
	return 16;
}

sqInt
firstCompiledMethodFormat(void)
{
	return 24;
}

static sqInt
firstCorpse(sqInt headOfCorpseList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (headOfCorpseList << 3) + GIV(newSpaceStart);
}


/*	Compact all of memory above firstFreeChunk using first-fit, assuming free
	space is sorted and that as many of the the highest objects as will fit
	are recorded in highestObjects. Don't move pinned objects.
	Note that we don't actually move; we merely copy and forward. Eliminating
	forwarders will be done in a final pass. */

static void
firstFitCompact(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt acceptedChunk;
    sqInt acceptedNode;
    usqLong b;
    sqInt child;
    usqLong childBytes;
    sqInt f;
    sqInt first;
    sqInt freeObj;
    sqInt index;
    sqInt initialIndex;
    sqInt next;
    sqInt nhits;
    sqInt nmisses;
    sqInt node;
    usqInt numSlots;
    sqInt o;
    sqInt prev;
    usqInt ptr;
    sqInt startOfObj;

	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	if (GIV(totalFreeOldSpace) == 0) {
		return;
	}
	if (((GIV(highestObjects).last)) < ((GIV(highestObjects).start))) {
		return;
	}
	nhits = (nmisses = 0);
	do {
		GIV(statCompactPassCount) += 1;
		/* begin reverseDo: */
		if (((GIV(highestObjects).last)) >= ((GIV(highestObjects).start))) {
			ptr = (GIV(highestObjects).last);
			while(1) {
				assert((((GIV(highestObjects).first)) <= ((GIV(highestObjects).last))
					? (((GIV(highestObjects).first)) <= ptr)
						 && (ptr <= ((GIV(highestObjects).last)))
					: ((((GIV(highestObjects).start)) <= ptr)
 && (ptr <= ((GIV(highestObjects).last))))
						 || ((((GIV(highestObjects).first)) <= ptr)
						 && (ptr <= ((GIV(highestObjects).limit))))));
				if ((((usqInt) (longAt(ptr)))) <= (((usqInt) GIV(firstFreeChunk)))) {
					print("firstFitCompact fits: ");
					printNum(nhits);
					print(" misfits: ");
					printNum(nmisses);
					/* begin cr */
					printf("\n");
					return;
				}
				if (!((((longAt(longAt(ptr))) & 0x3FFFFF) == 8)
					 || (((((usqInt) (longAt(longAt(ptr)))) >> 30) & 1) != 0))) {
					b = bytesInObject(longAt(ptr));
					/* begin allocateOldSpaceChunkOfBytes:suchThat: */
					assert(((GIV(lastSubdividedFreeChunk) = 0)) == 0);

					/* be optimistic (& don't wait for the write) */

					GIV(totalFreeOldSpace) -= b;
					initialIndex = ((sqInt) b >> 3);
					if ((initialIndex < 32)
					 && ((1 << initialIndex) <= GIV(freeListsMask))) {
						if (GIV(freeListsMask) & (1 << initialIndex)) {
							if (((node = GIV(freeLists)[initialIndex])) == 0) {
								GIV(freeListsMask) -= 1 << initialIndex;
							}
							else {
								prev = 0;
								while (node != 0) {
									assert(node == (startOfObject(node)));
									assert(isValidFreeObject(node));
									next = longAt((node + (BaseHeaderSize)) + (0 << 2));
									if (node < (longAt(ptr))) {
										if (prev == 0) {
											GIV(freeLists)[initialIndex] = next;
										}
										else {
											/* begin storePointer:ofFreeChunk:withValue: */
											assert(isFreeObject(prev));
											assert((next == 0)
											 || (isFreeObject(next)));
											longAtput((prev + (BaseHeaderSize)) + (0 << 2), next);
										}
										f = node;
										goto l3;
									}
									prev = node;
									node = next;
								}
							}
						}
						index = initialIndex;
						while ((((index += initialIndex)) < 32)
						 && ((1 << index) <= GIV(freeListsMask))) {
							if (GIV(freeListsMask) & (1 << index)) {
								if (((node = GIV(freeLists)[index])) == 0) {
									GIV(freeListsMask) -= 1 << index;
								}
								else {
									prev = 0;
									while (node != 0) {
										assert(node == (startOfObject(node)));
										assert(isValidFreeObject(node));
										next = longAt((node + (BaseHeaderSize)) + (0 << 2));
										if (node < (longAt(ptr))) {
											if (prev == 0) {
												GIV(freeLists)[index] = next;
											}
											else {
												/* begin storePointer:ofFreeChunk:withValue: */
												assert(isFreeObject(prev));
												assert((next == 0)
												 || (isFreeObject(next)));
												longAtput((prev + (BaseHeaderSize)) + (0 << 2), next);
											}
											freeChunkWithBytesat((index * 8) - b, (((rawNumSlotsOf(node)) == 0xFF
	? node - (BaseHeaderSize)
	: node)) + b);
											f = node;
											goto l3;
										}
										prev = node;
										node = next;
									}
								}
							}
						}
						index = initialIndex + 1;
						while ((((index += 1)) < 32)
						 && ((1 << index) <= GIV(freeListsMask))) {
							if (GIV(freeListsMask) & (1 << index)) {
								if (((node = GIV(freeLists)[index])) == 0) {
									GIV(freeListsMask) -= 1 << index;
								}
								else {
									prev = 0;
									while (node != 0) {
										assert(node == (startOfObject(node)));
										assert(isValidFreeObject(node));
										next = longAt((node + (BaseHeaderSize)) + (0 << 2));
										if (node < (longAt(ptr))) {
											if (prev == 0) {
												GIV(freeLists)[index] = next;
											}
											else {
												/* begin storePointer:ofFreeChunk:withValue: */
												assert(isFreeObject(prev));
												assert((next == 0)
												 || (isFreeObject(next)));
												longAtput((prev + (BaseHeaderSize)) + (0 << 2), next);
											}
											freeChunkWithBytesat((index * 8) - b, (((rawNumSlotsOf(node)) == 0xFF
	? node - (BaseHeaderSize)
	: node)) + b);
											f = node;
											goto l3;
										}
										prev = node;
										node = next;
									}
								}
							}
						}
					}
					child = GIV(freeLists)[0];
					node = (acceptedChunk = (acceptedNode = 0));
					while (child != 0) {
						assert(isValidFreeObject(child));
						childBytes = bytesInObject(child);
						if (childBytes == b) {

							/* size match; try to remove from list at node. */

							node = child;
							while (1) {
								prev = node;
								node = longAt((node + (BaseHeaderSize)) + (0 << 2));
								if (!(node != 0)) break;
								if (node < (longAt(ptr))) {
									assert(isValidFreeObject(node));
									/* begin storePointer:ofFreeChunk:withValue: */
									assert(isFreeObject(prev));
									assert(((longAt((node + (BaseHeaderSize)) + (0 << 2))) == 0)
									 || (isFreeObject(longAt((node + (BaseHeaderSize)) + (0 << 2)))));
									longAtput((prev + (BaseHeaderSize)) + (0 << 2), longAt((node + (BaseHeaderSize)) + (0 << 2)));
									f = ((rawNumSlotsOf(node)) == 0xFF
										? node - (BaseHeaderSize)
										: node);
									goto l3;
								}
							}
							if (child < (longAt(ptr))) {
								next = longAt((child + (BaseHeaderSize)) + (0 << 2));
								if (next == 0) {

									/* no list; remove the interior node */

									unlinkSolitaryFreeTreeNode(child);
								}
								else {

									/* list; replace node with it */

									inFreeTreeReplacewith(child, next);
								}
								f = ((rawNumSlotsOf(child)) == 0xFF
									? child - (BaseHeaderSize)
									: child);
								goto l3;
							}
						}
						if (child != 0) {

							/* Note that because the minimum free size is 16 bytes (2 * allocationUnit), to
							   leave room for the forwarding pointer/next free link, we can only break chunks
							   that are at least 16 bytes larger, hence reject chunks < 2 * allocationUnit larger. */

							if (childBytes <= (b + 8)) {

								/* node too small; walk down the larger size of the tree */

								child = longAt((child + (BaseHeaderSize)) + (4 << 2));
							}
							else {
								flag("we can do better here; preferentially choosing the lowest node. That would be a form of best-fit since we are trying to compact down");
								if (acceptedNode == 0) {

									/* first search the list. */

									acceptedChunk = child;
									do {
										acceptedChunk = longAt((acceptedChunk + (BaseHeaderSize)) + (0 << 2));
										if ((acceptedChunk != 0)
										 && (acceptedChunk < (longAt(ptr)))) {
											acceptedNode = child;
										}
									} while((acceptedChunk != 0)
 && (acceptedNode == 0));
									if ((acceptedNode == 0)
									 && (child < (longAt(ptr)))) {
										acceptedNode = child;
									}
								}
								child = longAt((child + (BaseHeaderSize)) + (3 << 2));
							}
						}
					}
					if (acceptedNode != 0) {
						if (acceptedChunk != 0) {
							assert((bytesInObject(acceptedChunk)) >= (b + (allocationUnit())));
							while (1) {
								next = longAt((acceptedNode + (BaseHeaderSize)) + (0 << 2));
								if (!(next != acceptedChunk)) break;
								acceptedNode = next;
							}
							/* begin storePointer:ofFreeChunk:withValue: */
							assert(isFreeObject(acceptedNode));
							assert(((longAt((acceptedChunk + (BaseHeaderSize)) + (0 << 2))) == 0)
							 || (isFreeObject(longAt((acceptedChunk + (BaseHeaderSize)) + (0 << 2)))));
							longAtput((acceptedNode + (BaseHeaderSize)) + (0 << 2), longAt((acceptedChunk + (BaseHeaderSize)) + (0 << 2)));
							freeChunkWithBytesat((bytesInObject(acceptedChunk)) - b, (((rawNumSlotsOf(acceptedChunk)) == 0xFF
	? acceptedChunk - (BaseHeaderSize)
	: acceptedChunk)) + b);
							f = ((rawNumSlotsOf(acceptedChunk)) == 0xFF
								? acceptedChunk - (BaseHeaderSize)
								: acceptedChunk);
							goto l3;
						}
						next = longAt((acceptedNode + (BaseHeaderSize)) + (0 << 2));
						if (next == 0) {

							/* no list; remove the interior node */

							unlinkSolitaryFreeTreeNode(acceptedNode);
						}
						else {

							/* list; replace node with it */

							inFreeTreeReplacewith(acceptedNode, next);
						}
						assert((bytesInObject(acceptedNode)) >= (b + (allocationUnit())));
						freeChunkWithBytesat((bytesInObject(acceptedNode)) - b, (((rawNumSlotsOf(acceptedNode)) == 0xFF
	? acceptedNode - (BaseHeaderSize)
	: acceptedNode)) + b);
						f = ((rawNumSlotsOf(acceptedNode)) == 0xFF
							? acceptedNode - (BaseHeaderSize)
							: acceptedNode);
						goto l3;
					}

					/* optimism was unfounded */

					GIV(totalFreeOldSpace) += b;
					f = null;
				l3:	/* end allocateOldSpaceChunkOfBytes:suchThat: */;
					if (f == null) {
						nmisses += 1;
					}
					else {
						nhits += 1;
						/* begin copyAndForward:withBytes:toFreeChunk: */
						startOfObj = ((rawNumSlotsOf(longAt(ptr))) == 0xFF
							? (longAt(ptr)) - (BaseHeaderSize)
							: longAt(ptr));
						memcpy(((void *)f), ((void *)startOfObj), b);

						/* leave it to followRememberedForwarders to remember... */
						/* (self isRemembered: objOop) ifTrue:
						   [scavenger remember: freeObj]. */

						freeObj = f + ((longAt(ptr)) - startOfObj);
						/* begin forward:to: */
						/* begin setFormatOf:to: */
						assert(((7 >= 0) && (7 <= (formatMask()))));
						flag("endianness");
						longAtput(longAt(ptr), ((longAt(longAt(ptr))) & (~(0x1F << 24))) + (7 << 24));
						/* begin setClassIndexOf:to: */
						assert(((8 >= 0) && (8 <= (classIndexMask()))));
						flag("endianness");
						longAtput(longAt(ptr), ((longAt(longAt(ptr))) & (~0x3FFFFF)) + 8);
						/* begin storePointer:ofForwarder:withValue: */
						assert(isForwarded(longAt(ptr)));
						assert(!(isOopForwarded(freeObj)));
						if (isOldObject(longAt(ptr))) {

							/* most stores into young objects */

							if (((freeObj & 3) == 0)
							 && ((((usqInt) freeObj)) < (((usqInt) GIV(newSpaceLimit))))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(longAt(ptr)))) >> 29) & 1) != 0)) {
									remember(longAt(ptr));
									/* begin setIsRememberedOf:to: */
									flag("endianness");
									longAtput(longAt(ptr), (longAt(longAt(ptr))) | (1 << 29));
								}
							}
						}
						longAtput(((longAt(ptr)) + (BaseHeaderSize)) + (0 << 2), freeObj);
						if (f == GIV(firstFreeChunk)) {
							/* begin objectStartingAt: */
							/* begin rawNumSlotsOf: */
							flag("endianness");
							numSlots = ((usqInt) (((usqInt)(longAt(f + 4))))) >> 24;
							GIV(firstFreeChunk) = (numSlots == 0xFF
								? f + (BaseHeaderSize)
								: f);
						}
						assert((GIV(lastSubdividedFreeChunk) == 0)
						 || ((addressAfter(objectStartingAt(f))) == GIV(lastSubdividedFreeChunk)));
					}
				}

				if (ptr == ((GIV(highestObjects).first))) {
					null;
					goto l1;
				}
				if (((ptr -= wordSize())) < ((GIV(highestObjects).start))) {
					ptr = (GIV(highestObjects).limit);
				}
			}
		}
		null;
	l1:	/* end reverseDo: */;
		/* begin checkFreeSpace */
		assert(bitsSetInFreeSpaceMaskForAllFreeLists());
		assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
		first = longAt((GIV(highestObjects).first));
		assert(oopisGreaterThan(first, GIV(firstFreeChunk)));
		fillHighestObjectsWithMovableObjectsFromupTo(GIV(firstFreeChunk), first);
	} while((usedSize(&GIV(highestObjects))) > 0);
	print("firstFitCompact fits: ");
	printNum(nhits);
	print(" misfits: ");
	printNum(nmisses);
	/* begin cr */
	printf("\n");
}


/*	for the message send breakpoint; selectors can be immediates. */

static void *
firstFixedFieldOfMaybeImmediate(sqInt oop)
{
	return ((oop & 3) != 0
		? ((void *)oop)
		: (/* begin firstFixedField: */
			pointerForOop(oop + (BaseHeaderSize))));
}

void *
firstFixedField(sqInt objOop)
{
	return pointerForOop(objOop + (BaseHeaderSize));
}


/*	NOTE: overridden in various simulator subclasses to add coercion to
	CArray, so please duplicate any changes.
	There are only two important cases, both for objects with named inst vars,
	i.e. formats 2,3 & 5.
	The first indexable field for formats 2 & 5 is the slot count (by
	convention, even though that's off the end
	of the object). For 3 we must go to the class. */

void *
firstIndexableField(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt classPointer;
    sqInt classTablePage;
    sqInt fmt;

	fmt = (((usqInt) (longAt(objOop))) >> 24) & 0x1F;
	if (fmt <= 5) {

		/* pointer; may need to delve into the class format word */

		if (((fmt >= 3) && (fmt <= 4))) {
			/* begin formatOfClass: */
			/* begin fetchClassOfNonImm: */
			classIndex = (longAt(objOop)) & 0x3FFFFF;
			if (classIndex == 0x1F) {
				classPointer = objOop;
				goto l1;
			}
			assert(classIndex >= (arrayClassIndexPun()));
			/* begin classAtIndex: */
			assert((classIndex <= (tagMask()))
			 || (classIndex >= (arrayClassIndexPun())));
			classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
			if (classTablePage == GIV(nilObj)) {
				classPointer = null;
				goto l1;
			}
			classPointer = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
		l1:	/* end fetchClassOfNonImm: */;
			classFormat = ((longAt((classPointer + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1);
			return pointerForOop((objOop + (BaseHeaderSize)) + ((classFormat & ((1 << 16) - 1)) << (wordSize())));
		}
		return pointerForOop((objOop + (BaseHeaderSize)) + ((numSlotsOf(objOop)) << (wordSize())));
	}
	assert(fmt < (firstCompiledMethodFormat()));
	return pointerForOop(objOop + (BaseHeaderSize));
}

sqInt
firstLongFormat(void)
{
	return 10;
}

sqInt
firstShortFormat(void)
{
	return 12;
}

sqInt
fixedFieldsFieldWidth(void)
{
	return 16;
}

sqInt
fixedFieldsOfClassFormatMask(void)
{
	return (1 << 16) - 1;
}

static sqInt
fixedFieldsOfClassFormat(sqInt classFormat)
{
	return classFormat & ((1 << 16) - 1);
}

static sqInt
fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;

	if ((fmt > 5)
	 || (fmt == 2)) {
		return 0;
	}
	if (fmt < 2) {
		return wordLength;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(objOop)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = objOop;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l1;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l1:	/* end fetchClassOfNonImm: */;
	return (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
}


/*	Private helper for followField:ofObject: to avoid code duplication for
	rare case.
 */

static sqInt
fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt referent;

	assert(isOopForwarded(initialValue));
	/* begin followForwarded: */
	assert(isForwarded(objOop));
	referent = longAt((objOop + (BaseHeaderSize)) + (0 << 2));
	while (((referent & 3) == 0)
	 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
		referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
	}
	objOop = referent;
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(anObject)));
	if (isOldObject(anObject)) {

		/* most stores into young objects */

		if (((objOop & 3) == 0)
		 && ((((usqInt) objOop)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(anObject))) >> 29) & 1) != 0)) {
				remember(anObject);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(anObject, (longAt(anObject)) | (1 << 29));
			}
		}
	}
	longAtput((anObject + (BaseHeaderSize)) + (fieldIndex << 2), objOop);
	return objOop;
}


/*	Like #stackFloatValue: but access method arguments left-to-right */

double
floatArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt isFloat;
    sqInt oop;
    double result;

	oop = methodArg(index);
	if (oop == 0) {
		return 0.0;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		return result;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}

sqInt
floatObjectOf(double aFloat)
{
    sqInt newFloatObj;
    sqInt numSlots;

	/* begin eeInstantiateClassIndex:format:numSlots: */
	numSlots = 8 / (wordSize());
	assert((numSlots >= 0)
	 && (ClassFloatCompactIndex != 0));
	assert((10) == (instSpecOfClass(knownClassAtIndex(ClassFloatCompactIndex))));
	newFloatObj = allocateNewSpaceSlotsformatclassIndex(numSlots, 10, ClassFloatCompactIndex);
	storeFloatAtfrom(newFloatObj + (BaseHeaderSize), aFloat);
	return newFloatObj;
}


/*	Answer the C double precision floating point value of the argument,
	or fail if it is not a Float, and answer 0.
	Note: May be called by translated primitive code. */

double
floatValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt isFloat;
    double result;

	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		return result;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	methodObj is a CompiledMethod containing an external primitive. Flush the
	function address and session ID of the CM
 */

static sqInt
flushExternalPrimitiveOf(sqInt methodObj)
{
    sqInt lit;

	if (!((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) > 0)) {
		return null;
	}
	lit = longAt((methodObj + (BaseHeaderSize)) + ((0 + LiteralStart) << 2));
	if (!((((lit & 3) == 0)
 && (((((usqInt) (longAt(lit))) >> 24) & 0x1F) == 2))
		 && ((lengthOfformat(lit, (((usqInt) (longAt(lit))) >> 24) & 0x1F)) == 4))) {
		return null;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + (BaseHeaderSize)) + (2 << 2), ConstZero);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + (BaseHeaderSize)) + (3 << 2), ConstZero);
}


/*	Make sure the oop at fieldIndex in anObject is not forwarded (follow the
	forwarder there-in if so). Answer the (possibly followed) oop at
	fieldIndex.  */

static sqInt
followFieldofObject(sqInt fieldIndex, sqInt anObject)
{
    sqInt objOop;

	objOop = longAt((anObject + (BaseHeaderSize)) + (fieldIndex << 2));
	if (((objOop & 3) == 0)
	 && (((longAt(objOop)) & 0x3FFFFF) == 8)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(fieldIndex, anObject, objOop);
	}
	return objOop;
}


/*	follow pointers in the current stack frame up to theSP. */

static void
followForwardedFrameContentsstackPointer(char *theFP, char *theSP)
{
    sqInt oop;
    char *ptr;

	for (ptr = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord))); ptr <= ((theFP + FoxCallerSavedIP) + BytesPerWord); ptr += BytesPerWord) {
		oop = longAt(ptr);
		if (((oop & 3) == 0)
		 && (((longAt(oop)) & 0x3FFFFF) == 8)) {
			longAtput(ptr, followForwarded(oop));
		}
	}
	for (ptr = theSP; ptr <= (frameReceiverOffset(theFP)); ptr += BytesPerWord) {
		oop = longAt(ptr);
		if (((oop & 3) == 0)
		 && (((longAt(oop)) & 0x3FFFFF) == 8)) {
			longAtput(ptr, followForwarded(oop));
		}
	}
	assert(!(isForwarded(frameMethod(theFP))));
	if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
		assert(!(isForwarded(frameContext(theFP))));
	}
}


/*	Post-compact, follow forwarders in an obj stack. */

static sqInt
followForwardedInObjStackatIndex(sqInt objStack, sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt firstPage;
    sqInt index;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    sqInt stackOrNil;

	if (objStack == GIV(nilObj)) {
		return objStack;
	}
	stackOrNil = objStack;
	if (((longAt(stackOrNil)) & 0x3FFFFF) == 8) {
		/* begin followForwarded: */
		assert(isForwarded(stackOrNil));
		referent = longAt((stackOrNil + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		stackOrNil = referent;
		/* begin updateRootOfObjStackAt:with: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if (isOldObject(GIV(hiddenRootsObj))) {

			/* most stores into young objects */

			if (((stackOrNil & 3) == 0)
			 && ((((usqInt) stackOrNil)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> 29) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(hiddenRootsObj), (longAt(GIV(hiddenRootsObj))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (objStackRootIndex << 2), stackOrNil);
		
		switch (objStackRootIndex) {
		case MarkStackRootIndex:
			GIV(markStack) = stackOrNil;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = stackOrNil;
			break;
		case EphemeronQueueRootIndex:
			GIV(ephemeronQueue) = stackOrNil;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		stackOrNil;
	}
	firstPage = stackOrNil;
	do {
		assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
		assert((fetchPointerofObject(ObjStackMyx, stackOrNil)) == objStackRootIndex);

		/* follow forwarded fields including ObjStackNextx and leave field containing the next link. */

		index = (longAt((stackOrNil + (BaseHeaderSize)) + (ObjStackTopx << 2))) + ObjStackNextx;
		do {
			field = longAt((stackOrNil + (BaseHeaderSize)) + (index << 2));
			if ((field != 0)
			 && (((field & 3) == 0)
			 && (((longAt(field)) & 0x3FFFFF) == 8))) {
				/* begin followForwarded: */
				assert(isForwarded(field));
				referent1 = longAt((field + (BaseHeaderSize)) + (0 << 2));
				while (((referent1 & 3) == 0)
				 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
					referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
				}
				field = referent1;
				/* begin storePointer:ofObjStack:withValue: */
				assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
				null;
				longAtput((stackOrNil + (BaseHeaderSize)) + (index << 2), field);
			}
		} while(((index -= 1)) > ObjStackFreex);
		assert(field == (fetchPointerofObject(ObjStackNextx, stackOrNil)));
	} while(((stackOrNil = field)) != 0);
	while (1) {
		stackOrNil = longAt((firstPage + (BaseHeaderSize)) + (ObjStackFreex << 2));
		if (!(stackOrNil != 0)) break;
		if (((longAt(stackOrNil)) & 0x3FFFFF) == 8) {
			/* begin followForwarded: */
			assert(isForwarded(stackOrNil));
			referent2 = longAt((stackOrNil + (BaseHeaderSize)) + (0 << 2));
			while (((referent2 & 3) == 0)
			 && (((longAt(referent2)) & 0x3FFFFF) == 8)) {
				referent2 = longAt((referent2 + (BaseHeaderSize)) + (0 << 2));
			}
			stackOrNil = referent2;
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(firstPage)) == (wordIndexableFormat()));
			null;
			longAtput((firstPage + (BaseHeaderSize)) + (ObjStackFreex << 2), stackOrNil);
		}
		firstPage = stackOrNil;
	}
	assert(isValidObjStackAt(objStackRootIndex));
}


/*	follow pointers in the object to depth.
	How to avoid cyclic structures?? A temproary mark bit? */

static void
followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt oop;
    sqInt referent;

	assert((isPointers(objOop))
	 || (isOopCompiledMethod(objOop)));
	for (i = 0, iLimiT = ((numPointerSlotsOf(objOop)) - 1); i <= iLimiT; i += 1) {
		oop = longAt((objOop + (BaseHeaderSize)) + (i << 2));
		if (((oop & 3) == 0)
		 && (((longAt(oop)) & 0x3FFFFF) == 8)) {
			/* begin followForwarded: */
			assert(isForwarded(oop));
			referent = longAt((oop + (BaseHeaderSize)) + (0 << 2));
			while (((referent & 3) == 0)
			 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
				referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
			}
			oop = referent;
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(objOop)));
			if (isOldObject(objOop)) {

				/* most stores into young objects */

				if (((oop & 3) == 0)
				 && ((((usqInt) oop)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(objOop))) >> 29) & 1) != 0)) {
						remember(objOop);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(objOop, (longAt(objOop)) | (1 << 29));
					}
				}
			}
			longAtput((objOop + (BaseHeaderSize)) + (i << 2), oop);
		}
		if (depth > 0) {
			followForwardedObjectFieldstoDepth(objOop, depth - 1);
		}
	}
}


/*	Follow a forwarding pointer. Alas we cannot prevent forwarders to
	forwarders being created by lazy become. Consider the following example by
	Igor Stasenko:
	array := { a. b. c }.
	- array at: 1 points to &a. array at: 2 points to &b. array at: 3 points
	to &c Ó
	a becomeForward: b
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	b becomeForward: c.
	- array at: 1 still points to &a. array at: 2 still points to &b. array
	at: 3 still points to &c
	- when accessing array first one has to follow a forwarding chain:
	&a -> &b -> c */

static sqInt
followForwarded(sqInt objOop)
{
    sqInt referent;

	assert(isForwarded(objOop));
	referent = longAt((objOop + (BaseHeaderSize)) + (0 << 2));
	while (((referent & 3) == 0)
	 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
		referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
	}
	return referent;
}


/*	Spur's become: is lazy, turning the becommed object into a forwarding
	object to the other.
	The read-barrier is minimised by arranging that forwarding pointers will
	fail a method cache
	probe, since notionally objects' internals are accessed only via sending
	messages to them,
	the exception is primitives that access the internals of the non-receiver
	argument(s). To avoid a read barrier on bytecode, literal and inst var
	fetch we scan the receivers and
	methods in the stack zone and follow any forwarded ones. This is of course
	way cheaper
	than scanning all of memory as in the old become. */

static void
followForwardingPointersInStackZone(sqInt theBecomeEffectsFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt delta;
    sqInt i;
    sqInt newOop;
    sqInt oop;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;
    char *theFP;
    sqInt theIP;
    usqInt theIPPtr;
    StackPage *thePage;
    char *theSP;

	if (theBecomeEffectsFlags & BecameCompiledMethodFlag) {
		if (((longAt(GIV(method))) & 0x3FFFFF) == 8) {
			theIPPtr = GIV(instructionPointer) - GIV(method);
			/* begin followForwarded: */
			assert(isForwarded(GIV(method)));
			referent = longAt((GIV(method) + (BaseHeaderSize)) + (0 << 2));
			while (((referent & 3) == 0)
			 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
				referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
			}
			GIV(method) = ((sqInt) referent);
			GIV(instructionPointer) = GIV(method) + theIPPtr;
		}
		if (((longAt(GIV(newMethod))) & 0x3FFFFF) == 8) {
			/* begin followForwarded: */
			assert(isForwarded(GIV(newMethod)));
			referent1 = longAt((GIV(newMethod) + (BaseHeaderSize)) + (0 << 2));
			while (((referent1 & 3) == 0)
			 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
				referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
			}
			GIV(newMethod) = ((sqInt) referent1);
		}
	}
	assert(GIV(stackPage) != 0);
	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */

			theFP = (thePage->headFP);
			if (thePage == GIV(stackPage)) {
				theIPPtr = 0;
			}
			else {
				theIPPtr = ((usqInt)theSP);
				theSP += BytesPerWord;
			}
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, ((void *)theIPPtr))));
				oop = longAt(theFP + FoxReceiver);
				if (((oop & 3) == 0)
				 && (((longAt(oop)) & 0x3FFFFF) == 8)) {
					longAtput(theFP + FoxReceiver, followForwarded(oop));
				}

				/* reuse theIP; its just an offset here */

				theIP = ((usqInt)(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord))));
				oop = longAt(theIP);
				if (((oop & 3) == 0)
				 && (((longAt(oop)) & 0x3FFFFF) == 8)) {
					longAtput(theIP, followForwarded(oop));
				}
				if (((byteAt((theFP + FoxFrameFlags) + 2)) != 0)
				 && (((longAt(longAt(theFP + FoxThisContext))) & 0x3FFFFF) == 8)) {
					longAtput(theFP + FoxThisContext, followForwarded(longAt(theFP + FoxThisContext)));
				}
				oop = longAt(theFP + FoxMethod);
				if (((longAt(oop)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(oop));
					referent2 = longAt((oop + (BaseHeaderSize)) + (0 << 2));
					while (((referent2 & 3) == 0)
					 && (((longAt(referent2)) & 0x3FFFFF) == 8)) {
						referent2 = longAt((referent2 + (BaseHeaderSize)) + (0 << 2));
					}
					newOop = referent2;
					if (theIPPtr != 0) {
						assert((longAt(theIPPtr)) > (frameMethod(theFP)));
						delta = newOop - oop;
						longAtput(theIPPtr, (longAt(theIPPtr)) + delta);
					}
					longAtput(theFP + FoxMethod, (oop = newOop));
				}
				followNecessaryForwardingInMethod(oop);
				if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
				theIPPtr = ((usqInt)(theFP + FoxCallerSavedIP));
				theFP = callerFP;
			}
		}
	}
}


/*	To avoid any chance of a forwarded object during super sends we follow the
	methodClassAssociation. The forwarded object send fault only copes with
	normal sends to instances. */

static void
followNecessaryForwardingInMethod(sqInt methodObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt assoc;
    sqInt classObj;
    sqInt fieldIndex;
    sqInt offset;
    sqInt referent;
    sqInt referent1;

	/* begin actuallyFollowNecessaryForwardingInMethod: */
	/* begin literal:ofMethod: */
	offset = (
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) - 1;
	assoc = longAt((methodObj + (BaseHeaderSize)) + ((offset + LiteralStart) << 2));
	if (((longAt(assoc)) & 0x3FFFFF) == 8) {
		/* begin followForwarded: */
		assert(isForwarded(assoc));
		referent = longAt((assoc + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		assoc = referent;
		/* begin setMethodClassAssociationOf:to: */
		/* begin storePointer:ofObject:withValue: */
		fieldIndex = ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((methodObj + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) - 1;
		assert(!(isForwarded(methodObj)));
		if (isOldObject(methodObj)) {

			/* most stores into young objects */

			if (((assoc & 3) == 0)
			 && ((((usqInt) assoc)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(methodObj))) >> 29) & 1) != 0)) {
					remember(methodObj);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(methodObj, (longAt(methodObj)) | (1 << 29));
				}
			}
		}
		longAtput((methodObj + (BaseHeaderSize)) + (fieldIndex << 2), assoc);
	}
	classObj = longAt((assoc + (BaseHeaderSize)) + (ValueIndex << 2));
	if (((longAt(classObj)) & 0x3FFFFF) == 8) {
		/* begin followForwarded: */
		assert(isForwarded(assoc));
		referent1 = longAt((assoc + (BaseHeaderSize)) + (0 << 2));
		while (((referent1 & 3) == 0)
		 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
			referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
		}
		classObj = referent1;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(assoc)));
		if (isOldObject(assoc)) {

			/* most stores into young objects */

			if (((classObj & 3) == 0)
			 && ((((usqInt) classObj)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(assoc))) >> 29) & 1) != 0)) {
					remember(assoc);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(assoc, (longAt(assoc)) | (1 << 29));
				}
			}
		}
		longAtput((assoc + (BaseHeaderSize)) + (ValueIndex << 2), classObj);
	}

}


/*	Force an interrupt check ASAP.
	Must set the stack page's limit before stackLimit to avoid
	a race condition if this is called from an interrupt handler. */

sqInt
forceInterruptCheck(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*iccFunc)();
    StackPage *thePage;


	/* Do _not_ set stackLimit until the stack system has been initialized.
	   stackLimit is the initialization flag for the stack system. */

	if (GIV(stackLimit) == 0) {
		return null;
	}
	thePage = GIV(stackPage);
	if ((thePage != null)
	 && (thePage != 0)) {
		(thePage->stackLimit = ((char *) (((usqInt) -1))));
	}
	GIV(stackLimit) = ((char *) (((usqInt) -1)));
	sqLowLevelMFence();
	if (((iccFunc = interruptCheckChain)) != null) {
		iccFunc();
	}
	GIV(statForceInterruptCheck) += 1;
}


/*	Force an interrupt check ASAP. This version is the
	entry-point to forceInterruptCheck for the heartbeat
	timer to allow for repeatable debugging. */

void
forceInterruptCheckFromHeartbeat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!suppressHeartbeatFlag) {
		/* begin checkForLongRunningPrimitive */
		if (GIV(longRunningPrimitiveCheckSemaphore) == null) {
			null;
			goto l1;
		}
		if ((GIV(longRunningPrimitiveStartUsecs) > 0)
		 && ((GIV(longRunningPrimitiveCheckMethod) == GIV(newMethod))
		 && (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)))) {
			GIV(longRunningPrimitiveStopUsecs) = ioUTCMicroseconds();
			assert(GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs));
			null;
			goto l1;
		}
		if (GIV(longRunningPrimitiveStopUsecs) == 0) {
			GIV(longRunningPrimitiveCheckSequenceNumber) = GIV(statCheckForEvents);
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
			GIV(longRunningPrimitiveStartUsecs) = ioUTCMicroseconds();
			sqLowLevelMFence();
		}
	l1:	/* end checkForLongRunningPrimitive */;
		forceInterruptCheck();
	}
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6,7,8 unused
	9 (?) 64-bit indexable
	10 - 11 32-bit indexable
	12 - 15 16-bit indexable
	16 - 23 byte indexable
	24 - 31 compiled method */

sqInt
formatMask(void)
{
	return 0x1F;
}

sqInt
formatOfClass(sqInt classPointer)
{
	return ((longAt((classPointer + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1);
}


/*	0 = 0 sized objects (UndefinedObject True False et al)
	1 = non-indexable objects with inst vars (Point et al)
	2 = indexable objects with no inst vars (Array et al)
	3 = indexable objects with inst vars (MethodContext AdditionalMethodState
	et al)
	4 = weak indexable objects with inst vars (WeakArray et al)
	5 = weak non-indexable objects with inst vars (ephemerons) (Ephemeron)
	6 unused, reserved for exotic pointer objects?
	7 Forwarded Object, 1st field is pointer, rest of fields are ignored
	8 unused, reserved for exotic non-pointer objects?
	9 (?) 64-bit indexable
	10 - 11 32-bit indexable	(11 unused in 32 bits)
	12 - 15 16-bit indexable	(14 & 15 unused in 32-bits)
	16 - 23 byte indexable		(20-23 unused in 32-bits)
	24 - 31 compiled method	(28-21 unused in 32-bits) */

static sqInt
formatOf(sqInt objOop)
{
	return (((usqInt) (longAt(objOop))) >> 24) & 0x1F;
}

sqInt
formatShift(void)
{
	return 24;
}


/*	A special format used by the GC to follow only the first pointer. */

static sqInt
forwardedFormat(void)
{
	return 7;
}

static sqInt
frameCallerContext(char *theFP)
{
	return longAt(theFP + FoxCallerContext);
}

static char *
frameCallerFP(char *theFP)
{
	return pointerForOop(longAt(theFP + FoxSavedFP));
}

static char *
frameCallerSavedIP(char *theFP)
{
	return pointerForOop(longAt(theFP + FoxCallerSavedIP));
}


/*	Answer the SP of the caller provided theFP is not a base frame.
	This points to the hottest item on the caller frame's stack. */

static char *
frameCallerSP(char *theFP)
{
	assert(!(isBaseFrame(theFP)));
	return (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
}

static sqInt
frameContext(char *theFP)
{
	return longAt(theFP + FoxThisContext);
}


/*	See encodeFrameFieldHasContext:numArgs: */

static sqInt
frameHasContext(char *theFP)
{
	return (byteAt((theFP + FoxFrameFlags) + 2)) != 0;
}


/*	<Integer> */

static sqInt
frameIsBlockActivation(char *theFP)
{
	return (byteAt((theFP + FoxFrameFlags) + 3)) != 0;
}

static sqInt
frameMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}


/*	See encodeFrameFieldHasContext:numArgs: */

static sqInt
frameNumArgs(char *theFP)
{
	return byteAt((theFP + FoxFrameFlags) + 1);
}

static char *
frameOfMarriedContext(sqInt aContext)
{
    sqInt value;

	value = longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	return pointerForOop(value - 1);
}

static char *
frameReceiverOffset(char *theFP)
{
	return theFP + FoxReceiver;
}

static sqInt
frameReceiver(char *theFP)
{
	return longAt(theFP + FoxReceiver);
}


/*	for linking objecs on each free list */

static sqInt
freeChunkNextIndex(void)
{
	return 0;
}


/*	for organizing the tree of large free chunks. */

static sqInt
freeChunkParentIndex(void)
{
	return 2;
}

static sqInt
freeChunkWithBytesat(sqInt bytes, sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeChunk;
    sqInt index;
    sqInt numSlots;

	assert(((GIV(lastSubdividedFreeChunk) = address)) != 0);
	/* begin initFreeChunkWithBytes:at: */
	assert(((bytes % (allocationUnit())) == 0)
	 && (bytes >= ((BaseHeaderSize) + (wordSize()))));
	flag("endianness");
	if (bytes >= ((0xFF << 2) + (BaseHeaderSize))) {
		numSlots = ((usqInt) ((bytes - (BaseHeaderSize)) - (BaseHeaderSize))) >> 2;
		longAtput(address, numSlots);
		longAtput(address + 4, 0xFF << 24);
		longAtput(address + 8, 0);
		longAtput(address + 12, 0xFF << 24);
		freeChunk = address + 8;
		goto l2;
	}
	numSlots = ((usqInt) (bytes - (BaseHeaderSize))) >> 2;
	assert(numSlots < (numSlotsMask()));
	longAtput(address, 0);
	longAtput(address + 4, numSlots << 24);
	freeChunk = address;
l2:	/* end initFreeChunkWithBytes:at: */;
	assert(isInMemory(addressAfter(freeChunk)));
	/* begin addToFreeList:bytes: */
	assert(isFreeObject(freeChunk));
	assert(bytes == (bytesInObject(freeChunk)));
	index = ((sqInt) bytes >> 3);
	if (index < 32) {
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(freeChunk));
		assert(((GIV(freeLists)[index]) == 0)
		 || (isFreeObject(GIV(freeLists)[index])));
		longAtput((freeChunk + (BaseHeaderSize)) + (0 << 2), GIV(freeLists)[index]);
		GIV(freeLists)[index] = freeChunk;
		GIV(freeListsMask) = GIV(freeListsMask) | (1 << index);
		0;
		goto l1;
	}
	addToFreeTreebytes(freeChunk, bytes);
l1:	/* end addToFreeList:bytes: */;
	assert(freeChunk == (objectStartingAt(address)));
	return freeChunk;
}

static sqInt
freeListsObj(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert((firstIndexableField(objectAfter(GIV(trueObj)))) == GIV(freeLists));
	return objectAfter(GIV(trueObj));
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static sqInt
freeStackPageNoAssert(StackPage *aPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return null;
	}
	prev = (aPage->prevPage);
	if (isFree(prev)) {
		return null;
	}
	(prev->nextPage = (aPage->nextPage));
	(((aPage->nextPage))->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
}


/*	Free any untraced stack pages. */

static void
freeUntracedStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    StackPage *thePage;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if ((!(isFree(thePage)))
		 && (((thePage->trace)) == StackPageUnreached)) {
			assert(noMarkedContextsOnPage(thePage));
			/* begin freeStackPage: */
			freeStackPageNoAssert(thePage);
			assert(pageListIsWellFormed());
		}
		assert(((thePage->trace = StackPageTraceInvalid)) != 0);
	}
}


/*	Repaint the entire smalltalk screen, ignoring the affected rectangle. Used
	in some platform's code when the Smalltalk window is brought to the front
	or uncovered.
 */

sqInt
fullDisplayUpdate(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt displayObj;
    sqInt h;
    sqInt w;

	displayObj = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheDisplay << 2));
	if ((((displayObj & 3) == 0)
 && (((((usqInt) (longAt(displayObj))) >> 24) & 0x1F) <= 5))
	 && ((lengthOfformat(displayObj, (((usqInt) (longAt(displayObj))) >> 24) & 0x1F)) >= 4)) {
		w = fetchIntegerofObject(1, displayObj);
		h = fetchIntegerofObject(2, displayObj);
		displayBitsOfLeftTopRightBottom(displayObj, 0, 0, w, h);
		ioForceDisplayUpdate();
	}
	return null;
}


/*	Perform a full lazy compacting GC. Answer the size of the largest free
	chunk. 
 */

usqLong
fullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aLimit;
    usqLong bytes;
    sqInt bytes1;
    sqInt childNode;
    sqInt freeSizeNow;
    usqInt header1NumSlots;
    usqInt header2NumSlots;
    usqInt headerNumSlots;
    sqInt here;
    sqInt highestObjectsWraps;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i12;
    sqInt i2;
    sqInt i21;
    sqInt i3;
    sqInt i4;
    sqInt i5;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt iLimiT2;
    sqInt index;
    sqInt index1;
    sqInt largestFree;
    usqInt lastHighest;
    sqInt lastLargeFree;
    sqInt limit;
    sqInt newNumSlots;
    sqInt next;
    sqInt next1;
    sqInt node;
    sqInt o;
    sqInt obj;
    sqInt obj2slots;
    sqInt objOop;
    sqInt oop;
    sqInt oop1;
    sqInt prev;
    sqInt prevObj;
    sqInt prevPrevObj;
    usqInt rawNumSlots;
    usqInt rawNumSlotsAfter;
    sqInt sizeOfUnusedEden;
    sqInt sortedFreeChunks;
    sqInt statCoalesces = 0;
    sqInt sweepIndex;
    StackPage *thePage;
    sqInt total;
    sqInt treeNode;

	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	GIV(statMarkCount) = 0;
	/* begin preGCAction: */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}

	/* begin globalGarbageCollect */
	/* begin runLeakCheckerForFullGC: */
	runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(1, 0);
	/* return self */
	assert(validObjStacks());
	/* begin markObjects */
	/* begin ensureAllMarkBitsAreZero */
	flag("need to implement the inc GC first...");
	assert(allObjectsUnmarked());
	ensureAdequateClassTableBitmap();
	/* begin initializeUnscannedEphemerons */
	/* begin findLargestFreeChunk */
	treeNode = GIV(freeLists)[0];
	if (treeNode == 0) {
		largestFree = null;
		goto l2;
	}
	while (1) {
		assert(isValidFreeObject(treeNode));
		childNode = longAt((treeNode + (BaseHeaderSize)) + (4 << 2));
		if (!(childNode != 0)) break;
		treeNode = childNode;
	}
	largestFree = treeNode;
l2:	/* end findLargestFreeChunk */;
	sizeOfUnusedEden = (((eden()).limit)) - GIV(freeStart);
	if ((largestFree != null)
	 && ((numSlotsOfAny(largestFree)) > (sizeOfUnusedEden / (wordSize())))) {
		(GIV(unscannedEphemerons).start = largestFree + (BaseHeaderSize));
		(GIV(unscannedEphemerons).limit = addressAfter(largestFree));
	}
	else {
		(GIV(unscannedEphemerons).start = GIV(freeStart));
		(GIV(unscannedEphemerons).limit = ((eden()).limit));
	}
	(GIV(unscannedEphemerons).top = (GIV(unscannedEphemerons).start));
	/* begin initializeMarkStack */
	ensureRoomOnObjStackAt(MarkStackRootIndex);
	/* begin initializeWeaklingStack */
	ensureRoomOnObjStackAt(WeaklingStackRootIndex);
	/* begin markAccessibleObjects */
	assert(validClassTableRootPages());
	assert(allBridgesMarked());
	null;

	/* This must come first to enable stack page reclamation.  It clears
	   the trace flags on stack pages and so must preceed any marking.
	   Otherwise it will clear the trace flags of reached pages. */

	GIV(marking) = 1;
	/* begin initStackPageGC */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (i2 = 0; i2 < GIV(numStackPages); i2 += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i2, GIV(pages));
		(thePage->trace = StackPageUnreached);
	}
	/* begin markAndTraceHiddenRoots */
	markAndTraceObjStackandContents(GIV(markStack), 0);
	markAndTraceObjStackandContents(GIV(weaklingStack), 0);
	markAndTraceObjStackandContents(GIV(ephemeronQueue), 1);
	setIsMarkedOfto(freeListsObj(), 1);
	if (((((usqInt) (longAt(GIV(classTableFirstPage)))) >> 24) & 0x1F) == 4) {
		markAndTrace(GIV(hiddenRootsObj));
		goto l1;
	}
	setIsMarkedOfto(GIV(hiddenRootsObj), 1);
	markAndTrace(GIV(classTableFirstPage));
	for (i4 = 1; i4 < GIV(numClassTablePages); i4 += 1) {
		setIsMarkedOfto(longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (i4 << 2)), 1);
	}
l1:	/* end markAndTraceHiddenRoots */;
	/* begin markAndTraceExtraRoots */
	assert(GIV(remapBufferCount) == 0);
	for (i11 = 1; i11 <= GIV(extraRootCount); i11 += 1) {
		oop = (GIV(extraRoots)[i11])[0];
		if (!(((oop & 3) != 0)
			 || (((longAt(oop)) & 0x3FFFFF) == 0))) {
			markAndTrace(oop);
		}
	}
	assert(validClassTableRootPages());
	/* begin markAndTraceInterpreterOops: */
	markAndTraceStackPages(1);
	/* begin markAndTraceTraceLog */
	/* begin markAndTracePrimTraceLog */
	markAndTrace(GIV(specialObjectsOop));
	if (!((GIV(newMethod) & 3) != 0)) {
		markAndTrace(GIV(newMethod));
	}
	/* begin traceProfileState */
	markAndTrace(GIV(profileProcess));
	markAndTrace(GIV(profileMethod));
	markAndTrace(GIV(profileSemaphore));
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveCheckMethod) != null)
	 && (GIV(longRunningPrimitiveCheckSequenceNumber) != GIV(statCheckForEvents))) {
		markAndTrace(GIV(longRunningPrimitiveCheckMethod));
	}
	if (GIV(longRunningPrimitiveCheckSemaphore) != null) {
		markAndTrace(GIV(longRunningPrimitiveCheckSemaphore));
	}
	if (!(GIV(tempOop) == 0)) {
		markAndTrace(GIV(tempOop));
	}
	for (i3 = 1, iLimiT = GIV(remapBufferCount); i3 <= iLimiT; i3 += 1) {
		oop1 = GIV(remapBuffer)[i3];
		if (!((oop1 & 1))) {
			markAndTrace(oop1);
		}
	}
	for (i3 = 1; i3 <= GIV(jmpDepth); i3 += 1) {
		oop1 = GIV(suspendedCallbacks)[i3];
		if (!((oop1 & 1))) {
			markAndTrace(oop1);
		}
		oop1 = GIV(suspendedMethods)[i3];
		if (!((oop1 & 1))) {
			markAndTrace(oop1);
		}
	}
	assert(validObjStacks());
	markWeaklingsAndMarkAndFireEphemerons();
	assert(validObjStacks());
	GIV(marking) = 0;
	expungeDuplicateClasses();
	nilUnmarkedWeaklingSlots();
	/* begin freeUnmarkedObjectsAndSortAndCoalesceFreeSpace */
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	/* begin forgetUnmarkedRememberedObjects */
	index = 0;
	while (index < GIV(rememberedSetSize)) {
		obj = GIV(rememberedSet)[index];
		if (isMarked(obj)) {
			index += 1;
		}
		else {

			/* unmarked; remove by overwriting with last element. */

			/* begin setIsRememberedOf:to: */
			flag("endianness");
			longAtput(obj, (longAt(obj)) & (~(1 << 29)));
			GIV(rememberedSetSize) -= 1;
			GIV(rememberedSet)[index] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
		}
	}
	assert(GIV(rememberedSetSize) >= 0);
	/* begin prepareForGlobalSweep */
	sweepIndex = 0;
	for (i5 = 0; i5 < GIV(numSegments); i5 += 1) {
		((GIV(segments)[i5]).containsPinned = 0);
	}
	/* begin resetFreeListHeads */
	for (i12 = 0, iLimiT2 = (32 - 1); i12 <= iLimiT2; i12 += 1) {
		GIV(freeLists)[i12] = 0;
	}
	/* begin initializeStart:limit: */
	aLimit = ((eden()).limit);
	(GIV(highestObjects).start = GIV(freeStart));
	(GIV(highestObjects).limit = aLimit);
	(GIV(highestObjects).first = GIV(freeStart));
	(GIV(highestObjects).last = GIV(freeStart) - (wordSize()));
	GIV(highestObjects);

	/* a.k.a. freeStart - wordSize */

	lastHighest = ((GIV(highestObjects).start)) - (wordSize());
	highestObjectsWraps = 0;
	assert(((((GIV(highestObjects).limit)) - ((GIV(highestObjects).start))) / (wordSize())) >= 1024);

	/* Note that if we were truly striving for performance we could split the scan into
	   two phases, one up to the first free object and one after, which would remove
	   the need to test firstFreeChunk when filling highestObjects. */

	GIV(firstFreeChunk) = (sortedFreeChunks = (lastLargeFree = 0));
	/* begin allOldSpaceEntitiesForCoalescingDo: */
	prevPrevObj = (prevObj = null);
	objOop = GIV(nilObj);
	while (1) {
		assert((objOop % (allocationUnit())) == 0);
		if (!((((usqInt) objOop)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop)) != 0);
		/* begin rawNumSlotsOf: */
		flag("endianness");
		rawNumSlots = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
		if (isMarked(objOop)) {

			/* forwarders should have been followed in markAndTrace: */

			assert(!(isForwarded(objOop)));
			setIsMarkedOfto(objOop, 0);
			if (((((usqInt) (longAt(objOop))) >> 30) & 1) != 0) {
				/* begin notePinned: */
				assert(isPinned(objOop));
				if (((longAt(objOop)) & 0x3FFFFF) == 3) {
					setIsMarkedOfto(objOop, 1);
				}
				else {
					while (((((GIV(segments)[sweepIndex]).segSize)) + (((GIV(segments)[sweepIndex]).segStart))) < objOop) {
						sweepIndex += 1;
					}
					((GIV(segments)[sweepIndex]).containsPinned = 1);
				}
			}
			if (GIV(firstFreeChunk) != 0) {

				/* conceptually...: */

				
				/* but we inline so we can use the local lastHighest */

				if (((lastHighest += wordSize())) >= ((GIV(highestObjects).limit))) {
					highestObjectsWraps += 1;
					lastHighest = (GIV(highestObjects).start);
				}
				longAtput(lastHighest, objOop);

			}
		}
		else {

			/* unmarked; two cases, an unreachable object or a free chunk. */

			assert(!(isRemembered(objOop)));
			here = objOop;
			limit = GIV(endOfMemory) - (2 * (BaseHeaderSize));
			next = objectAfterlimit(here, limit);
			while (!((next == limit)
			 || (isMarked(next)))) {

				/* coalescing; rare case */

				assert(!(isRemembered(objOop)));
				statCoalesces += 1;
				/* begin coalesce:and: */
				/* begin rawNumSlotsOf: */
				flag("endianness");
				header1NumSlots = ((usqInt) (((usqInt)(longAt(here + 4))))) >> 24;
				/* begin rawNumSlotsOf: */
				flag("endianness");
				header2NumSlots = ((usqInt) (((usqInt)(longAt(next + 4))))) >> 24;
				obj2slots = (header2NumSlots == 0xFF
					? (longAt(next - (BaseHeaderSize))) + ((2 * (BaseHeaderSize)) / (wordSize()))
					: ((header2NumSlots == 0
	? 1
	: header2NumSlots)) + ((BaseHeaderSize) / (wordSize())));
				obj2slots += obj2slots & 1;
				assert((obj2slots * (wordSize())) == (bytesInObject(next)));
				if (header1NumSlots == 0xFF) {
					longAtput(here - (BaseHeaderSize), obj2slots + (longAt(here - (BaseHeaderSize))));
					here = here;
					goto l4;
				}
				header1NumSlots = (header1NumSlots == 0
					? 2
					: header1NumSlots + (header1NumSlots & 1));
				assert(((header1NumSlots * (wordSize())) + (BaseHeaderSize)) == (bytesInObject(here)));

				/* if obj1 still only requires a single header things are simple... */

				newNumSlots = obj2slots + header1NumSlots;
				if (newNumSlots < 0xFF) {
					byteAtput(here + (((sqInt) 56 >> 3)), newNumSlots);
					here = here;
					goto l4;
				}
				newNumSlots -= (BaseHeaderSize) / (wordSize());
				longAtput(here + (BaseHeaderSize), longAt(here));
				longAtput((here + 4) + (BaseHeaderSize), (longAt(here + 4)) | (0xFF << 24));
				longAtput(here, newNumSlots);
				longAtput(here + 4, 0xFF << 24);
				here += BaseHeaderSize;
			l4:	/* end coalesce:and: */;
				next = objectAfterlimit(here, limit);
			}
			if (GIV(firstFreeChunk) == 0) {
				GIV(firstFreeChunk) = here;
			}
			if ((((sqInt) (bytesInObject(here)) >> 3)) >= 32) {
				/* begin setFree: */
				long32Atput(here, 0);
				if (lastLargeFree == 0) {
					sortedFreeChunks = (lastLargeFree = here);
				}
				else {
					/* begin storePointer:ofFreeChunk:withValue: */
					assert(isFreeObject(lastLargeFree));
					assert((here == 0)
					 || (isFreeObject(here)));
					longAtput((lastLargeFree + (BaseHeaderSize)) + (1 << 2), here);
				}
				lastLargeFree = here;
			}
			else {
				/* begin freeSmallObject: */
				/* begin rawNumSlotsOf: */
				flag("endianness");
				headerNumSlots = ((usqInt) (((usqInt)(longAt(here + 4))))) >> 24;
				if (headerNumSlots == 0) {
					/* begin setRawNumSlotsOf:to: */
					flag("endian");
					byteAtput(here + 7, 1);
					index1 = ((sqInt) ((BaseHeaderSize) + 8) >> 3);
				}
				else {
					bytes = bytesInObject(here);
					index1 = ((sqInt) bytes >> 3);
					assert(index1 < (numFreeLists()));
				}
				/* begin setFree: */
				long32Atput(here, 0);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(here));
				assert(((GIV(freeLists)[index1]) == 0)
				 || (isFreeObject(GIV(freeLists)[index1])));
				longAtput((here + (BaseHeaderSize)) + (0 << 2), GIV(freeLists)[index1]);
				GIV(freeLists)[index1] = here;
			}
		}

		/* begin rawNumSlotsOf: */
		flag("endianness");
		rawNumSlotsAfter = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
		if ((rawNumSlotsAfter != rawNumSlots)
		 && (rawNumSlotsAfter == 0xFF)) {
			objOop += BaseHeaderSize;
			assert((objectAfterlimit(prevObj, GIV(endOfMemory))) == objOop);
		}
		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = objectAfterlimit(objOop, GIV(endOfMemory));
	}
	
	
	(GIV(highestObjects).last = lastHighest);
	if (highestObjectsWraps != 0) {
		(GIV(highestObjects).first = ((lastHighest + (wordSize())) >= ((GIV(highestObjects).limit))
			? (GIV(highestObjects).start)
			: lastHighest + (wordSize())));
	}
	if (lastLargeFree != 0) {
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(lastLargeFree));
		assert((0 == 0)
		 || (isFreeObject(0)));
		longAtput((lastLargeFree + (BaseHeaderSize)) + (1 << 2), 0);
	}
	/* begin reverseSmallListHeads */
	total = 0;
	GIV(freeListsMask) = 0;
	for (i21 = 1, iLimiT1 = (32 - 1); i21 <= iLimiT1; i21 += 1) {
		bytes1 = i21 * 8;
		node = GIV(freeLists)[i21];
		if (node != 0) {
			assert((bytesInObject(node)) == bytes1);
			GIV(freeListsMask) += 1 << i21;
			prev = 0;
			while (node != 0) {
				next1 = longAt((node + (BaseHeaderSize)) + (0 << 2));
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(node));
				assert((prev == 0)
				 || (isFreeObject(prev)));
				longAtput((node + (BaseHeaderSize)) + (0 << 2), prev);
				prev = node;
				node = next1;
				total += bytes1;
			}
			GIV(freeLists)[i21] = prev;
		}
	}
	GIV(totalFreeOldSpace) = total;
	GIV(totalFreeOldSpace) += rebuildFreeTreeFrom(sortedFreeChunks);
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	
	runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(1, 1);
	/* begin compact */
	exactFitCompact();
	if ((usedSize(&GIV(highestObjects))) > 0) {
		firstFitCompact();
	}
	eliminateAndFreeForwarders();
	assert(validObjStacks());
	assert(allObjectsUnmarked());
	/* begin runLeakCheckerForFullGC: */
	runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(1, 0);
	/* return self */
	/* begin postGCAction: */
	
	/* but *not* become and *not* scavenge */

	freeSizeNow = GIV(totalFreeOldSpace);
	if ((freeSizeNow > GIV(shrinkThreshold))
	 && (freeSizeNow > GIV(growHeadroom))) {

		/* Attempt to shrink memory after successfully reclaiming lots of memory */

		/* begin shrinkObjectMemory: */
		print("shrinkObjectMemory: shouldBeImplemented");
		/* begin cr */
		printf("\n");
	}

	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	GIV(statFullGCs) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	GIV(statFullGCUsecs) += GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	return ((GIV(freeLists)[0]) != 0
		? bytesInObject(findLargestFreeChunk())
		: 0);
}


/*	Find an actual function pointer for this primitiveIndex. This is an
	opportunity to specialise the prim for the relevant class (format for
	example). Default for now is simply the entry in the base primitiveTable. */

void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void)

{
	return (primIdx > MaxPrimitiveIndex
		? 0
		: primitiveTable[primIdx]);
}


/*	currentBytecode will be private to the main dispatch loop in the generated
	code. This method allows the currentBytecode to be retrieved from global
	variables. 
 */

sqInt
getCurrentBytecode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return byteAt(GIV(instructionPointer));
}

sqInt
getFullScreenFlag(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(fullScreenFlag);
}

sqInt
getInterruptKeycode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptKeycode);
}

sqInt
getInterruptPending(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(interruptPending);
}


/*	Answer the next word read from aFile, byte-swapped according to the
	swapFlag. 
 */

static sqInt
getLongFromFileswap(sqImageFile  aFile, sqInt swapFlag)
{
    sqInt w;

	w = 0;
	sqImageFileRead(&w, sizeof(w), 1, aFile);
	if (swapFlag) {
		return ((((((usqInt) w >> 24)) & Byte0Mask) + ((((usqInt) w >> 8)) & Byte1Mask)) + ((((usqInt) w << 8)) & Byte2Mask)) + ((((usqInt) w << 24)) & Byte3Mask);
	}
	else {
		return w;
	}
}

usqLong
getNextWakeupUsecs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nextWakeupUsecs);
}

sqInt
getSavedWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(savedWindowSize);
}


/*	Answer the next half-word read from aFile, byte-swapped according to the
	swapFlag. 
 */

static sqInt
getShortFromFileswap(sqImageFile aFile, sqInt swapFlag)
{
    sqInt w;

	w = 0;
	sqImageFileRead(&w, sizeof(unsigned short), 1, aFile);
	return (swapFlag
		? (((usqInt) w >> 8)) + (((usqInt) (w & 0xFF) << 8))
		: w);
}


/*	For Alien FFI */

sqInt *
getStackPointer(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((sqInt *) GIV(stackPointer));
}


/*	return the global session ID value */

sqInt
getThisSessionID(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(globalSessionID);
}

static sqInt
goodContextSize(sqInt oop)
{
    usqInt numSlots;
    usqInt numSlots1;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(oop - (BaseHeaderSize)))
		: numSlots1);
	return (numSlots == SmallContextSlots)
	 || (numSlots == LargeContextSlots);
}


/*	Attempt to grow memory by at least minAmmount.
	Answer the size of the new segment, or nil if the attempt failed. */

static usqInt
growOldSpaceByAtLeast(sqInt minAmmount)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ammount;
    SpurSegmentInfo *segInfo;


	/* statGrowMemory counts attempts, not successes. */


	/* we need to include overhead for a new object header plus the segment bridge. */

	GIV(statGrowMemory) += 1;

	/* round up to the nearest power of two. */

	ammount = minAmmount + (((BaseHeaderSize) * 2) + (2 * (BaseHeaderSize)));

	/* and grow by at least growHeadroom. */

	ammount = 1 << (highBit(ammount - 1));
	ammount = ((ammount < GIV(growHeadroom)) ? GIV(growHeadroom) : ammount);
	return ((segInfo = addSegmentOfSize(ammount)),
	(!(segInfo == null)
			? (/* begin assimilateNewSegment: */
				((((segInfo->segSize)) + ((segInfo->segStart))) >= GIV(endOfMemory)
						? (GIV(freeOldSpaceStart) = (GIV(endOfMemory) = (((segInfo->segSize)) + ((segInfo->segStart))) - (2 * (BaseHeaderSize))))
						: 0),
				/* begin checkFreeSpace */
				assert(bitsSetInFreeSpaceMaskForAllFreeLists()),
				assert(GIV(totalFreeOldSpace) == (totalFreeListBytes())),
				(segInfo->segSize))
			: 0));
}


/*	Handle a send fault that is due to a send using a forwarded selector.
	Unforward the selector and follow the current method and special
	selectors array to unforward the source of the forwarded selector. */

static sqInt
handleForwardedSelectorFaultFor(sqInt selectorOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;

	assert(isOopForwarded(selectorOop));
	/* begin followForwardedFieldsInCurrentMethod */
	followForwardedObjectFieldstoDepth(GIV(method), 0);
	followForwardedObjectFieldstoDepth(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2)), 0);
	/* begin followForwarded: */
	assert(isForwarded(selectorOop));
	referent = longAt((selectorOop + (BaseHeaderSize)) + (0 << 2));
	while (((referent & 3) == 0)
	 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
		referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
	}
	return referent;
}


/*	Handle a send fault that may be due to a send to a forwarded object.
	Unforward the receiver on the stack and answer its actual class. */

static sqInt
handleForwardedSendFaultForTag(sqInt classTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt referent;
    sqInt tagBits;

	assert(isForwardedClassTag(classTag));

	/* should *not* be a super send, so the receiver should be forwarded. */

	rcvr = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	assert(isOopForwarded(rcvr));
	/* begin followForwarded: */
	assert(isForwarded(rcvr));
	referent = longAt((rcvr + (BaseHeaderSize)) + (0 << 2));
	while (((referent & 3) == 0)
	 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
		referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
	}
	rcvr = referent;
	longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), rcvr);
	followForwardedFrameContentsstackPointer(GIV(framePointer), GIV(stackPointer) + ((GIV(argumentCount) + 1) * BytesPerWord));
	if ((((longAt(GIV(framePointer) + FoxReceiver)) & 3) == 0)
	 && (((((usqInt) (longAt(longAt(GIV(framePointer) + FoxReceiver)))) >> 24) & 0x1F) <= 5)) {
		followForwardedObjectFieldstoDepth(longAt(GIV(framePointer) + FoxReceiver), 0);
	}
	/* begin fetchClassTagOf: */
	if (((tagBits = rcvr & 3)) != 0) {
		return ((tagBits & 1) != 0
			? 1
			: tagBits);
	}
	return (longAt(rcvr)) & 0x3FFFFF;
}


/*	Handle a special send fault that may be due to a special selector
	send accessing a forwarded object.
	Unforward the object on the stack and in inst vars and answer its target. */

static sqInt
handleSpecialSelectorSendFaultForfpsp(sqInt obj, char *theFP, char *theSP)
{
    sqInt referent;

	assert(isOopForwarded(obj));
	followForwardedFrameContentsstackPointer(theFP, theSP);
	if ((((longAt(theFP + FoxReceiver)) & 3) == 0)
	 && (((((usqInt) (longAt(longAt(theFP + FoxReceiver)))) >> 24) & 0x1F) <= 5)) {
		followForwardedObjectFieldstoDepth(longAt(theFP + FoxReceiver), 0);
	}
	/* begin followForwarded: */
	assert(isForwarded(obj));
	referent = longAt((obj + (BaseHeaderSize)) + (0 << 2));
	while (((referent & 3) == 0)
	 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
		referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
	}
	return referent;
}


/*	Check for stack overflow, moving frames to another stack if so. */

static void
handleStackOverflow(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *callerFP1;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt overflowCount;
    char *overflowLimitAddress;
    char *theFP;
    char *theSP;


	/* After checkForInterrupts another event check may have been forced, setting both
	   stackLimit and stackPage stackLimit to all ones.  So here we must check against
	   the real stackLimit, not the effective stackLimit. */

	if (!(GIV(stackPointer) < ((GIV(stackPage)->realStackLimit)))) {
		return;
	}
	/* begin maybeTraceStackOverflow */

	/* The stack has overflowed this page.  If the system is executing some recursive algorithm,
	   e.g. fibonacci, then the system could thrash overflowing the stack if the call soon returns
	   back to the current page.  To avoid thrashing, since overflow is quite slow, we can move
	   more than one frame.  The idea is to record which page has overflowed, and the first
	   time it overflows move one frame, the second time two frames, and so on.  We move no
	   more frames than would leave the page half occupied. */

	GIV(statStackOverflow) += 1;
	theFP = GIV(framePointer);
	if (GIV(stackPage) == GIV(overflowedPage)) {
		overflowLimitAddress = ((GIV(stackPage)->baseAddress)) - GIV(overflowLimit);
		overflowCount = (GIV(extraFramesToMoveOnOverflow) += 1);
		while ((((overflowCount -= 1)) >= 0)
		 && ((((callerFP = frameCallerFP(theFP))) < overflowLimitAddress)
		 && (!((longAt(callerFP + FoxSavedFP)) == 0)))) {
			theFP = callerFP;
		}
	}
	else {
		GIV(overflowedPage) = GIV(stackPage);
		GIV(extraFramesToMoveOnOverflow) = 0;
	}
	/* begin ensureCallerContext: */
	/* begin frameCallerFP: */
	callerFP1 = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP1 == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */

		longAt(theFP + FoxCallerContext);
		goto l2;
	}
	/* begin ensureFrameIsMarried:SP: */
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
	if ((byteAt((callerFP1 + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP1)));
		longAt(callerFP1 + FoxThisContext);
		goto l2;
	}
	marryFrameSP(callerFP1, theSP);
l2:	/* end ensureCallerContext: */;
	/* begin newStackPage */
	lruOrFree = ((mostRecentlyUsedPage())->nextPage);
	if (isFree(lruOrFree)) {
		newPage = lruOrFree;
		goto l1;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
l1:	/* end newStackPage */;
	moveFramesInthroughtoPage(GIV(stackPage), theFP, newPage);
	/* begin setStackPageAndLimit: */
	assert(newPage != 0);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	
	/* To overflow the stack this must be a new frame, but in Cog base frames are married. */

	assert(!(frameHasContext(GIV(framePointer))));
	assert(validInstructionPointerinMethodframePointer(GIV(instructionPointer), GIV(method), GIV(framePointer)));

}


/*	The stackPointer is below the stackLimit. This is either because of a
	stack overflow or the setting of stackLimit to indicate a possible
	interrupt. Check for interrupts and stackOverflow and deal with each
	appropriately. Answer if a context switch occurred. */

static sqInt
handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt switched;


	/* If the stackLimit differs from the realStackLimit then the stackLimit
	   has been set to indicate an event or interrupt that needs servicing. */

	if (GIV(stackLimit) == ((GIV(stackPage)->realStackLimit))) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		switched = 0;
	}
	else {
		switched = checkForEventsMayContextSwitch(mayContextSwitch);
	}
	handleStackOverflow();
	return switched;
}

static sqInt
hasYoungReferents(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt oop;

	for (i = 0, iLimiT = ((numPointerSlotsOf(objOop)) - 1); i <= iLimiT; i += 1) {
		oop = longAt((objOop + (BaseHeaderSize)) + (i << 2));
		if (((oop & 3) == 0)
		 && ((((usqInt) oop)) < (((usqInt) GIV(newSpaceLimit))))) {
			return 1;
		}
	}
	return 0;
}


/*	The header format in LSB is
	MSB:	| 8: numSlots		| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isMarked,?})
	| 22: identityHash	| (on a word boundary)
	| 3 bits				|	(msb <-> lsb = {isGrey,isPinned,isRemembered}
	| 5: format			| (on a byte boundary)
	| 2 bits				|	(msb,lsb = {isImmutable,?})
	| 22: classIndex		| (on a word boundary) : LSB
	The remaining bits (7) are used for
	isImmutable	(bit 23)
	isRemembered	(bit 29)
	isPinned		(bit 30)
	isGrey			(bit 31)
	isMarked		(bit 55)
	leaving 2 unused bits, each next to a 22-bit field, allowing those fields
	to be
	expanded to 23 bits.. The three bit field { isGrey, isPinned, isRemembered
	} is for bits that are never set in young objects. This allows the
	remembered table to be pruned when full by using these bits as a reference
	count of
	newSpace objects from the remembered table. Objects with a high count
	should be tenured to prune the remembered table. */

usqLong
headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex)
{
	return (((((usqLong) numSlots)) << 56) + (formatField << 24)) + classIndex;
}


/*	A negative header selects the alternate bytecode set. */

sqInt
headerIndicatesAlternateBytecodeSet(sqInt methodHeader)
{
	return (((sqInt) methodHeader)) < 0;
}

static sqInt
headerOf(sqInt methodPointer)
{
	return longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2));
}


/*	Answer the number of extra root slots in the root of the hidden root
	object. 
 */

static sqInt
hiddenRootSlots(void)
{
	return 8;
}


/*	This is a C implementation needed by ioSetMaxExtSemTableSize
	and e.g. stackPageByteSize. */

sqInt
highBit(usqInt anUnsignedValue)
{
    sqInt bitNo;
    usqInt shifted;


	/* so it shows up in senders... */

	shifted = anUnsignedValue;
	bitNo = 0;
	
#  if BytesPerWord > 4
	if (!(shifted < (1LL << 32))) {
		shifted = ((usqInt) shifted) >> 32;
		bitNo += 32;
	}

#  endif /* BytesPerWord > 4 */

	if (!(shifted < (1 << 16))) {
		shifted = ((usqInt) shifted) >> 16;
		bitNo += 16;
	}
	if (!(shifted < (1 << 8))) {
		shifted = ((usqInt) shifted) >> 8;
		bitNo += 8;
	}
	if (!(shifted < (1 << 4))) {
		shifted = ((usqInt) shifted) >> 4;
		bitNo += 4;
	}
	if (!(shifted < (1 << 2))) {
		shifted = ((usqInt) shifted) >> 2;
		bitNo += 2;
	}
	if (!(shifted < (1 << 1))) {
		shifted = ((usqInt) shifted) >> 1;
		bitNo += 1;
	}
	return bitNo + shifted;
}

sqInt
identityHashHalfWordMask(void)
{
	return 0x3FFFFF;
}

static usqInt
iframeMethod(char *theFP)
{
	return longAt(theFP + FoxMethod);
}


/*	This is for low-level error reporting. If either of the C stack pointers
	are pointing into the stack zone then write them back to framePointer
	and/or stackPointer so that the stack backtrace will be up to date. Write
	their original values through savedFPP & savedSPP if non-null.
	This is a noop in the stack VM since the C stack pointers are always
	elsewhere (e.g., in some C function running the interpreter). */

void
ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP)
{
}


/*	Return a magic constant that changes when the image format changes.
	Since the image reading code uses this to detect byte ordering, one
	must avoid version numbers that are invariant under byte reversal. */

static sqInt
imageFormatVersion(void)
{
    sqInt isSpurFlag;

	isSpurFlag = 16;
	return (6505) + isSpurFlag;
}


/*	when asked, newSpace should be empty. */

static sqInt
imageSizeToWrite(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt total;

	assert(newSpaceIsEmpty());
	/* begin totalBytesInSegments */
	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		total += ((GIV(segments)[i]).segSize);
	}
	return total;
}


/*	Answer whether an ephemeron is inactive (has a marked key) or,
	if active, failed to fit on the unscanned ephemerons stack. */

static sqInt
inactiveOrFailedToDeferScan(sqInt anEphemeron)
{
    sqInt key;

	assert(isEphemeron(anEphemeron));
	if ((isImmediate((key = keyOfEphemeron(anEphemeron))))
	 || (isMarked(key))) {
		return 1;
	}
	return !(pushOnUnscannedEphemeronsStack(anEphemeron));
}


/*	Return the equivalent of 
	aClass includesBehavior: aSuperclass.
	Note: written for efficiency and better inlining (only 1 temp) */

sqInt
includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt theClass;

	if (aSuperclass == GIV(nilObj)) {
		return 0;
	}
	theClass = aClass;
	while (1) {
		if (theClass == aSuperclass) {
			return 1;
		}
		if (!(theClass != GIV(nilObj))) break;
		theClass = longAt((theClass + (BaseHeaderSize)) + (SuperclassIndex << 2));
	}
	return 0;
}

void
incrementalGC(void)
{
	error("shouldNotImplement");
}

sqInt
indexablePointersFormat(void)
{
	return 3;
}


/*	Part of reorderReversedTreeList:. Switch treeNode with newNode in
	the tree, but do nothing to the list linked through freeChunkNextIndex. */
/*	copy parent, smaller, larger */

static void
inFreeTreeReplacewith(sqInt treeNode, sqInt newNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt i;
    sqInt iLimiT;
    sqInt relative;

	for (i = 2, iLimiT = 4; i <= iLimiT; i += 1) {
		relative = longAt((treeNode + (BaseHeaderSize)) + (i << 2));
		if (i == 2) {
			if (relative == 0) {

				/* update root to point to newNode */

				assert((GIV(freeLists)[0]) == treeNode);
				GIV(freeLists)[0] = newNode;
			}
			else {

				/* replace link from parent to treeNode with link to newNode. */

				/* begin storePointer:ofFreeChunk:withValue: */
				fieldIndex = (treeNode == (longAt((relative + (BaseHeaderSize)) + (3 << 2)))
					? 3
					: 4);
				assert(isFreeObject(relative));
				assert((newNode == 0)
				 || (isFreeObject(newNode)));
				longAtput((relative + (BaseHeaderSize)) + (fieldIndex << 2), newNode);
			}
		}
		else {
			if (relative != 0) {
				assert((fetchPointerofObject(freeChunkParentIndex(), relative)) == treeNode);
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(relative));
				assert((newNode == 0)
				 || (isFreeObject(newNode)));
				longAtput((relative + (BaseHeaderSize)) + (2 << 2), newNode);
			}
		}
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(newNode));
		assert((relative == 0)
		 || (isFreeObject(relative)));
		longAtput((newNode + (BaseHeaderSize)) + (i << 2), relative);
		/* begin storePointer:ofFreeChunk:withValue: */
		assert(isFreeObject(treeNode));
		assert((0 == 0)
		 || (isFreeObject(0)));
		longAtput((treeNode + (BaseHeaderSize)) + (i << 2), 0);
	}
}

static sqInt
initialInstanceOf(sqInt classObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin rawHashBitsOf: */
	flag("endianness");
	classIndex = (longAt(classObj + 4)) & 0x3FFFFF;
	if (classIndex == 0) {
		return null;
	}
	/* begin flushNewSpaceInstancesOf: */
	/* begin rawHashBitsOf: */
	flag("endianness");
	classIndex1 = (longAt(classObj + 4)) & 0x3FFFFF;
	if (classIndex1 == 0) {

		/* no instances; nothing to do */

		goto l1;
	}
	/* begin tenuringClassIndex: */
	GIV(tenuringClassIndex) = classIndex1;
	scavengingGCTenuringIf(TenureByClass);
	assert(!(existInstancesInNewSpaceOf(classObj)));
l1:	/* end flushNewSpaceInstancesOf: */;
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (classIndex == ((longAt(objOop1)) & 0x3FFFFF)) {
			return objOop1;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (classIndex == ((longAt(objOop1)) & 0x3FFFFF)) {
			return objOop1;
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (classIndex == ((longAt(objOop11)) & 0x3FFFFF)) {
				return objOop11;
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
	return null;
}


/*	Initialize object memory variables at startup time. Assume endOfMemory is
	initially set (by the image-reading code) to the end of the last object in
	the image. Initialization redefines endOfMemory to be the end of the
	object allocation area based on the total available memory, but reserving
	some space for forwarding blocks.
 */
/*	Assume: image reader initializes the following variables:
	memory
	memoryLimit
	specialObjectsOop
	lastHash
	 */
/*	Catch mis-initializations leading to bad translations to C */

static void
initializeObjectMemory(sqInt bytesToShift)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurNewSpaceSpace *aNewSpace;
    sqInt bit;
    sqInt bit1;
    sqInt classTableRoot;
    sqInt field;
    sqInt fieldAddr;
    sqInt fieldOop;
    sqInt firstObj;
    sqInt freeChunk;
    sqInt freeListObj;
    usqLong freeOldStart;
    sqInt hiddenRoots;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt iLimiT;
    sqInt index;
    sqInt indexLimiT;
    usqLong limit;
    sqInt majorIndex;
    sqInt majorIndex1;
    sqInt nilObjPreSwizzle;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt obj;
    sqInt p;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert(BaseHeaderSize == (BaseHeaderSize));
	initSegmentBridgeWithBytesat(2 * (BaseHeaderSize), GIV(endOfMemory) - (2 * (BaseHeaderSize)));

	adjustSegmentSwizzlesBy(bytesToShift);
	/* begin adjustAllOopsBy: */
	/* begin countNumClassPagesPreSwizzle: */
	/* begin objectStartingAt: */
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots2 = ((usqInt) (((usqInt)(longAt(GIV(oldSpaceStart) + 4))))) >> 24;
	firstObj = (numSlots2 == 0xFF
		? GIV(oldSpaceStart) + (BaseHeaderSize)
		: GIV(oldSpaceStart));
	classTableRoot = objectAfterlimit(objectAfterlimit(objectAfterlimit(objectAfterlimit(firstObj, GIV(endOfMemory)), GIV(endOfMemory)), GIV(endOfMemory)), GIV(endOfMemory));
	nilObjPreSwizzle = GIV(oldSpaceStart) - bytesToShift;
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classTableRoot)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots11 = ((usqInt) (((usqInt)(longAt(classTableRoot + 4))))) >> 24;
	GIV(numClassTablePages) = ((usqInt) ((numSlots11 == 0xFF
	? (/* begin rawOverflowSlotsOf: */
		flag("endianness"),
		longAt(classTableRoot - (BaseHeaderSize)))
	: numSlots11)));
	assert(GIV(numClassTablePages) == ((classTableRootSlots()) + (hiddenRootSlots())));
	for (i3 = 2; i3 < GIV(numClassTablePages); i3 += 1) {
		if ((longAt((classTableRoot + (BaseHeaderSize)) + (i3 << 2))) == nilObjPreSwizzle) {
			GIV(numClassTablePages) = i3;
			goto l2;
		}
	}
l2:	/* end countNumClassPagesPreSwizzle: */;
	ensureAdequateClassTableBitmap();
	if ((bytesToShift != 0)
	 || ((numSegments()) > 1)) {
		assert(newSpaceIsEmpty());
		/* begin objectStartingAt: */
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots = ((usqInt) (((usqInt)(longAt(GIV(oldSpaceStart) + 4))))) >> 24;
		obj = (numSlots == 0xFF
			? GIV(oldSpaceStart) + (BaseHeaderSize)
			: GIV(oldSpaceStart));
		while ((((usqInt) obj)) < (((usqInt) GIV(endOfMemory)))) {
			if (((longAt(obj)) & 0x3FFFFF) == 0) {
				/* begin swizzleFieldsOfFreeChunk: */
				field = longAt((obj + (BaseHeaderSize)) + (0 << 2));
				if (field != 0) {
					/* begin storePointerNoAssert:ofFreeChunk:withValue: */
					valuePointer = swizzleObj(field);
					longAtput((obj + (BaseHeaderSize)) + (0 << 2), valuePointer);
				}
				if ((((sqInt) (bytesInObject(obj)) >> 3)) >= 32) {
					for (index = 2, indexLimiT = 4; index <= indexLimiT; index += 1) {
						field = longAt((obj + (BaseHeaderSize)) + (index << 2));
						if (field != 0) {
							/* begin storePointerNoAssert:ofFreeChunk:withValue: */
							valuePointer1 = swizzleObj(field);
							longAtput((obj + (BaseHeaderSize)) + (index << 2), valuePointer1);
						}
					}
				}
			}
			else {
				/* begin inClassTableBitmapSet: */
				assert((((longAt(obj)) & 0x3FFFFF) >= 0)
				 && (((longAt(obj)) & 0x3FFFFF) <= (classIndexMask())));
				majorIndex = ((sqInt) ((longAt(obj)) & 0x3FFFFF) >> 3);
				bit = 1 << (((longAt(obj)) & 0x3FFFFF) & (BitsPerByte - 1));
				GIV(classTableBitmap)[majorIndex] = ((GIV(classTableBitmap)[majorIndex]) | bit);
				/* begin swizzleFieldsOfObject: */
				fieldAddr = obj + (lastPointerOfWhileSwizzling(obj));
				while ((((usqInt) fieldAddr)) >= (((usqInt) (obj + (BaseHeaderSize))))) {
					fieldOop = longAt(fieldAddr);
					if ((fieldOop & 3) == 0) {
						longAtput(fieldAddr, swizzleObj(fieldOop));
					}
					fieldAddr -= BytesPerOop;
				}
			}
			obj = objectAfter(obj);
		}
	}
	else {
		assert(newSpaceIsEmpty());
		/* begin objectStartingAt: */
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots1 = ((usqInt) (((usqInt)(longAt(GIV(oldSpaceStart) + 4))))) >> 24;
		obj = (numSlots1 == 0xFF
			? GIV(oldSpaceStart) + (BaseHeaderSize)
			: GIV(oldSpaceStart));
		while ((((usqInt) obj)) < (((usqInt) GIV(endOfMemory)))) {
			if (!(((longAt(obj)) & 0x3FFFFF) == 0)) {
				/* begin inClassTableBitmapSet: */
				assert((((longAt(obj)) & 0x3FFFFF) >= 0)
				 && (((longAt(obj)) & 0x3FFFFF) <= (classIndexMask())));
				majorIndex1 = ((sqInt) ((longAt(obj)) & 0x3FFFFF) >> 3);
				bit1 = 1 << (((longAt(obj)) & 0x3FFFFF) & (BitsPerByte - 1));
				GIV(classTableBitmap)[majorIndex1] = ((GIV(classTableBitmap)[majorIndex1]) | bit1);
			}
			obj = objectAfter(obj);
		}
	}

	/* heavily used special objects */

	GIV(specialObjectsOop) = swizzleObj(GIV(specialObjectsOop));
	GIV(nilObj) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (NilObject << 2));
	GIV(falseObj) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (FalseObject << 2));

	/* In Cog we insist that nil, true & false are next to each other (Cogit generates tighter
	   conditional branch code as a result).  In addition, Spur places the free lists and
	   class table root page immediately following them. */

	GIV(trueObj) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TrueObject << 2));
	assert(GIV(nilObj) == GIV(oldSpaceStart));
	assert(GIV(falseObj) == (objectAfter(GIV(nilObj))));
	assert(GIV(trueObj) == (objectAfter(GIV(falseObj))));
	freeListObj = objectAfter(GIV(trueObj));
	/* begin reInitializeClassTablePostLoad: */
	hiddenRoots = objectAfter(freeListObj);
	/* begin hiddenRootsObj: */
	GIV(hiddenRootsObj) = hiddenRoots;
	assert(validClassTableRootPages());
	GIV(classTableFirstPage) = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (0 << 2));
	assert(((numSlotsOf(GIV(classTableFirstPage))) - 1) == (classTableMinorIndexMask()));
	GIV(numClassTablePages) = 1 << (22 - 10);
	for (i = 2; i < GIV(numClassTablePages); i += 1) {
		if ((longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (i << 2))) == GIV(nilObj)) {
			GIV(numClassTablePages) = i;
			GIV(classTableIndex) = ((((GIV(numClassTablePages) - 1) < 1) ? 1 : (GIV(numClassTablePages) - 1))) << 10;
			goto l1;
		}
	}
	GIV(classTableIndex) = 1 << 10;
l1:	/* end hiddenRootsObj: */;
	expungeDuplicateClasses();
	GIV(markStack) = swizzleObjStackAt(MarkStackRootIndex);
	GIV(weaklingStack) = swizzleObjStackAt(WeaklingStackRootIndex);
	GIV(ephemeronQueue) = swizzleObjStackAt(EphemeronQueueRootIndex);
	/* begin initializeFreeSpacePostLoad: */
	assert((numSlotsOf(freeListObj)) == (numFreeLists()));
	assert((formatOf(freeListObj)) == (firstLongFormat()));
	GIV(freeLists) = firstIndexableField(freeListObj);
	GIV(freeListsMask) = 0;
	for (i1 = 0, iLimiT = (32 - 1); i1 <= iLimiT; i1 += 1) {
		if ((GIV(freeLists)[i1]) != 0) {
			GIV(freeListsMask) = GIV(freeListsMask) | (1 << i1);
			GIV(freeLists)[i1] = (swizzleObj(GIV(freeLists)[i1]));
		}
	}
	collapseSegmentsPostSwizzle();
	/* begin computeFreeSpacePostSwizzle */
	GIV(totalFreeOldSpace) = totalFreeListBytes();
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	/* begin initializeNewSpaceVariables */
	GIV(freeStart) = ((eden()).start);
	GIV(pastSpaceStart) = ((pastSpace()).start);
	GIV(scavengeThreshold) = ((((eden()).limit)) - (((sqInt) (((GIV(eden).limit)) - ((GIV(eden).start))) >> 6))) - (interpreterAllocationReserveBytes());
	GIV(newSpaceStart) = (((((pastSpace()).start)) < (((futureSpace()).start))) ? (((pastSpace()).start)) : (((futureSpace()).start)));
	assert(GIV(newSpaceStart) < (((eden()).start)));
	/* begin initSpaceForAllocationCheck: */
	aNewSpace = (&(eden()));
	if (!(GIV(memory) == null)) {
		for (p = ((aNewSpace->start)); p < ((aNewSpace->limit)); p += (wordSize())) {
			longAtput(p, p);
		}

	}

	/* begin initializeOldSpaceFirstFree: */
	limit = GIV(endOfMemory) - (2 * (BaseHeaderSize));
	if (limit > GIV(freeOldSpaceStart)) {
		GIV(totalFreeOldSpace) += limit - GIV(freeOldSpaceStart);
		freeOldStart = GIV(freeOldSpaceStart);
		
		if (freeOldStart < limit) {
			freeChunk = freeChunkWithBytesat(limit - freeOldStart, freeOldStart);
			assert((addressAfter(freeChunk)) == limit);
		}
	}
	GIV(freeOldSpaceStart) = GIV(endOfMemory);
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	/* begin checkSegments */
	assert(GIV(numSegments) >= 1);
	for (i2 = 0; i2 < GIV(numSegments); i2 += 1) {
		assert(addressCouldBeObj(((GIV(segments)[i2]).segStart)));
		assert(isValidSegmentBridge(bridgeAt(i2)));
	}
	assert((segLimit(&GIV(segments)[GIV(numSegments) - 1])) == (endOfMemory()));

	/* headroom when growing */

	GIV(growHeadroom) = (16 * 1024) * 1024;
	GIV(shrinkThreshold) = (32 * 1024) * 1024;
}


/*	Initialize the stack pages. For testing I want stack addresses to be
	disjoint from
	normal memory addresses so stack addresses are negative. The first address
	is -pageSize bytes. So for example if there are 1024 bytes per page and 3
	pages then the pages are organized as
	
	byte address: -1024 <-> -2047 | -2048 <-> -3071 | -3072 <-> -4096 |
	page 3			page 2			page 1
	mem index: 769 <-> 513 | 512 <-> 257 | 256 <-> 1 |
	
	The byte address is the external address corresponding to a real address
	in the VM.
	mem index is the index in the memory Array holding the stack, an index
	internal to
	the stack pages. The first stack page allocated will be the last page in
	the array of pages
	at the highest effective address. Its base address be -1024 and grow down
	towards -2047. */
/*	The lFoo's are to get around the foo->variable scheme in the C call to
	allocStackPages below.
 */

static sqInt
initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    char * highestAddress;
    sqInt i;
    sqInt index;
    sqInt lowestAddress;
    sqInt memIndex;
    StackPage *page;
    char *pageStructBase;
    void *pointer;
    sqInt structStackPageSize;
    sqInt theIndex;

	

	/* For initialization in the C code. */

	GIV(stackMemory) = theStackPages;
	
	structStackPageSize = sizeof(InterpreterStackPage);
	GIV(bytesPerPage) = slotsPerPage * BytesPerWord;

	/* Because stack pages grow down baseAddress is at the top of a stack page and so to avoid
	   subtracting BytesPerWord from baseAddress and lastAddress in the init loop below we simply
	   push the stackPage array up one word to avoid the overlap.  This word is extraStackBytes. */

	GIV(numPages) = stackSlots / (slotsPerPage + (((sqInt) structStackPageSize >> 2)));
	pageStructBase = (theStackPages + (GIV(numPages) * GIV(bytesPerPage))) + BytesPerWord;

	/* Simulation only.  Since addresses are negative the offset is positive.  To make all
	   stack addresses negative we make the offset a page more than it needs to be so the
	   address of the last slot in memory (the highest address in the stack, or its start) is
	   - pageByteSize
	   and the address of the first slot (the lowest address, or its end) is
	   - pageByteSize * (numPages + 1) */

	GIV(pages) = (StackPage *)pageStructBase;
	
	assert((((stackPageByteSize()) - (stackLimitBytes())) - (stackLimitOffset())) >= (stackPageHeadroom()));
	for (index = 0; index < GIV(numPages); index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		(page->lastAddress = (char *)theStackPages + (index * GIV(bytesPerPage)));
		(page->baseAddress = ((page->lastAddress)) + GIV(bytesPerPage));
		(page->stackLimit = ((page->baseAddress)) - (((512 < (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord)) - 0)) ? 512 : (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord)) - 0))));
		(page->realStackLimit = (page->stackLimit));
		(page->baseFP = 0);
		(page->nextPage = stackPageAt((index == (GIV(numPages) - 1)
			? 0
			: index + 1)));
		(page->prevPage = stackPageAt((index == 0
			? GIV(numPages) - 1
			: index - 1)));
	}
	
	/* begin stackPageAt: */
	page = stackPageAtpages(0, GIV(pages));
	GIV(overflowLimit) = ((((page->baseAddress)) - ((page->realStackLimit))) * 3) / 5;
	for (index = 0; index < GIV(numPages); index += 1) {
		/* begin stackPageAt: */
		page = stackPageAtpages(index, GIV(pages));
		assert((pageIndexFor((page->baseAddress))) == index);
		assert((pageIndexFor(((page->baseAddress)) - ((slotsPerPage - 1) * BytesPerWord))) == index);
		assert((stackPageFor((page->baseAddress))) == page);
		assert((stackPageFor((page->stackLimit))) == page);
		
		/* begin initializePageTraceToInvalid: */
		(page->trace = StackPageTraceInvalid);
	}
	/* begin stackPageAt: */
	GIV(mostRecentlyUsedPage) = stackPageAtpages(0, GIV(pages));
	page = GIV(mostRecentlyUsedPage);
	count = 0;
	do {
		count += 1;
		/* begin pageIndexFor: */
		pointer = (page->baseAddress);
		theIndex = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
		assert((stackPageAt(theIndex)) == page);
		assert((pageIndexFor((page->baseAddress))) == theIndex);
		assert((pageIndexFor((page->stackLimit))) == theIndex);
		assert((pageIndexFor(((page->lastAddress)) + BytesPerWord)) == theIndex);
	} while(((page = (page->nextPage))) != GIV(mostRecentlyUsedPage));
	assert(count == GIV(numPages));
	assert(pageListIsWellFormed());
}

sqInt
initialPCForHeadermethod(sqInt methodHeader, sqInt theMethod)
{
	return (theMethod + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize);
}


/*	must have room for a double header */

static void
initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address)
{
    sqInt numSlots;

	assert(((numBytes % (allocationUnit())) == 0)
	 && (numBytes >= ((BaseHeaderSize) + (BaseHeaderSize))));
	numSlots = ((usqInt) ((numBytes - (BaseHeaderSize)) - (BaseHeaderSize))) >> 2;
	flag("endianness");
	if (numSlots == 0) {

		/* short bridge for adjacent segments */

		longAtput(address, ((1 << 30) + (10 << 24)) + 3);
		longAtput(address + 4, 1 << 23);
	}
	else {

		/* long bridge */

		longAtput(address, numSlots);
		longAtput(address + 4, 0xFF << 24);
		longAtput(address + 8, ((1 << 30) + (10 << 24)) + 3);
		longAtput(address + 12, (0xFF << 24) + (1 << 23));
	}
}


/*	Answer the number of slots in a class. For example the instanceSizeOf: 
	ClassPoint is 2, for the x & y slots. The instance size of non-pointer
	classes is 0. */

sqInt
instanceSizeOf(sqInt classObj)
{
	assert(addressCouldBeClassObj(classObj));
	return (((longAt((classObj + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
}

sqInt
instantiateClassindexableSize(sqInt classObj, sqInt nElements)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt fillValue;
    sqInt instSpec;
    sqInt newHash;
    sqInt newObj;
    sqInt newObj1;
    sqInt numBytes;
    sqInt numSlots;
    sqInt p;

	classFormat = ((longAt((classObj + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1);
	instSpec = (((usqInt) classFormat) >> 16) & 0x1F;
	fillValue = 0;
	
	switch (instSpec) {
	case 2:
		numSlots = nElements;
		fillValue = GIV(nilObj);
		break;
	case 3:
	case 4:
		numSlots = (classFormat & ((1 << 16) - 1)) + nElements;
		fillValue = GIV(nilObj);
		break;
	case 9:
		numSlots = nElements * 2;
		break;
	case 10:
		numSlots = nElements;
		break;
	case 12:
		numSlots = ((sqInt) (nElements + 1) >> 1);
		instSpec += nElements & 1;
		break;
	case 16:
	case 24:
		numSlots = ((sqInt) (nElements + 3) >> 2);
		instSpec += (4 - nElements) & 3;
		break;
	default:
		
		/* some Squeak images include funky fixed subclasses of abstract variable
		   superclasses. e.g. DirectoryEntry as a subclass of ArrayedCollection.
		   Allow fixed classes to be instantiated here iff nElements = 0. */

		if ((nElements != 0)
		 || (instSpec >= 9)) {
			return null;
		}
		numSlots = classFormat & ((1 << 16) - 1);

	}
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj));
	if (((newHash = rawHashBitsOf(classObj))) == 0) {
		if (((err = enterIntoClassTable(classObj))) != 0) {
			classIndex = -err;
			goto l1;
		}
		/* begin rawHashBitsOf: */
		flag("endianness");
		newHash = (longAt(classObj + 4)) & 0x3FFFFF;
		assert((classAtIndex(newHash)) == classObj);
	}
	classIndex = newHash;
l1:	/* end ensureBehaviorHash: */;
	if (classIndex < 0) {
		GIV(primFailCode) = -classIndex;
		return null;
	}
	if (numSlots > ((1 << 16) - 1)) {
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, ((numSlots == 0
	? 8
	: (numSlots + (numSlots & 1)) << 2)) + ((numSlots >= 0xFF
	? (BaseHeaderSize) + (BaseHeaderSize)
	: BaseHeaderSize)), instSpec, classIndex);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= 0xFF) {
			newObj1 = GIV(freeStart) + (BaseHeaderSize);

			/* double header */
			/* roundTo allocationUnit */

			numBytes = ((BaseHeaderSize) + (BaseHeaderSize)) + ((numSlots + (numSlots & 1)) * 4);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = (BaseHeaderSize) + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * 4));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
			goto l2;
		}
		if (numSlots >= 0xFF) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */

			flag("endianness");
			longAtput(GIV(freeStart), numSlots);
			longAtput(GIV(freeStart) + 4, 0xFF << 24);
			longLongAtput(newObj1, (((((usqLong) 0xFF)) << 56) + (instSpec << 24)) + classIndex);
		}
		else {
			longLongAtput(newObj1, (((((usqLong) numSlots)) << 56) + (instSpec << 24)) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l2:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + (BaseHeaderSize)) + (numSlots * (bytesPerOop()))) - 1, addressAfter(newObj)));
		for (p = (newObj + (BaseHeaderSize)); p < ((newObj + (BaseHeaderSize)) + (numSlots * (wordSize()))); p += 8) {
			longAtput(p, fillValue);
			longAtput(p + 4, fillValue);
		}
	}
	return newObj;
}


/*	This is the same as the field stored in every object header */

static sqInt
instSpecOfClass(sqInt classPointer)
{
	return (((usqInt) (((longAt((classPointer + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F;
}


/*	Like #stackIntegerValue: but access method arguments left-to-right */

sqInt
integerArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0;
	}
	/* begin checkedIntegerValueOf: */
	if ((oop & 1)) {
		return (oop >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Convert the integer value, assumed to be in SmallInteger range, into a
	tagged SmallInteger object.
	In C, use a shift and an add to set the tag bit.
	In Smalltalk we have to work harder because the simulator works with
	strictly positive bit patterns. */

sqInt
integerObjectOf(sqInt value)
{
	return (value << 1) + 1;
}


/*	Translator produces 'oop >> 1' */

sqInt
integerValueOf(sqInt oop)
{
	return ((((usqInt) oop >> 31)) == 1
		? (((((usqInt) oop >> 1)) & 0x3FFFFFFF) - 0x3FFFFFFF) - 1
		: ((usqInt) oop >> 1));
}


/*	At a rough approximation we may need to allocate up to a couple
	of page's worth of contexts when switching stack pages, assigning
	to senders, etc. But the snapshot primitive voids all stack pages.
	So a safe margin is the size of a large context times the maximum
	number of frames per page times the number of pages. */

static sqInt
interpreterAllocationReserveBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt maxFramesPerPage;
    sqInt maxUsedBytesPerPage;

	maxUsedBytesPerPage = 512 + ((FrameSlots + 64) * BytesPerWord);
	maxFramesPerPage = (((sqInt) maxUsedBytesPerPage >> 2)) / FrameSlots;
	return ((maxFramesPerPage * LargeContextSlots) * BytesPerOop) * GIV(numStackPages);
}


/*	the vm has to convert aFilenameString via any canonicalization and
	char-mapping and put the result in aCharBuffer.
	Note the resolveAliases flag - this is an awful artefact of OSX and Apples
	demented alias handling. When opening a file, the flag must be true, when
	closing or renaming it must be false. Sigh.
 */

void
ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean)
{
	sqGetFilenameFromString(aCharBuffer, aFilenameString, filenameLength, aBoolean);
}


/*	Answer true if this is an indexable object with pointer elements, e.g., an
	array 
 */

sqInt
isArray(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) == 2);
}


/*	A base frame (first frame in a stack page) is so marked by having a null
	saved fp.
 */

static sqInt
isBaseFrame(char *theFP)
{
	return (longAt(theFP + FoxSavedFP)) == 0;
}


/*	Answer true if the argument contains indexable bytes. See comment in
	formatOf: 
 */
/*	Note: Includes CompiledMethods. */

sqInt
isBytes(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16);
}

sqInt
isCharacterObject(sqInt oop)
{
	return (oop & 3) == 2;
}

sqInt
isCharacterValue(sqInt anInteger)
{
	return (anInteger >= 0)
	 && (anInteger < (pow(2,30)));
}


/*	Answer whether the argument object is of compiled method format */

sqInt
isCompiledMethod(sqInt objOop)
{
	return ((((usqInt) (longAt(objOop))) >> 24) & 0x1F) >= 24;
}

static sqInt
isContextHeader(sqInt aHeader)
{
	return (aHeader & 0x3FFFFF) == ClassMethodContextCompactIndex;
}

static sqInt
isContextNonImm(sqInt oop)
{
	return ((longAt(oop)) & 0x3FFFFF) == ClassMethodContextCompactIndex;
}

static sqInt
isContext(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (((longAt(oop)) & 0x3FFFFF) == ClassMethodContextCompactIndex);
}


/*	Answer if objOop should be included in an allObjects...Do: enumeration.
	Non-objects should be excluded; these are bridges and free chunks. */

static sqInt
isEnumerableObjectNoAssert(sqInt objOop)
{
	return ((longAt(objOop)) & 0x3FFFFF) >= 8;
}


/*	Answer if objOop should be included in an allObjects...Do: enumeration.
	Non-objects should be excluded; these are bridges and free chunks. */

static sqInt
isEnumerableObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;

	classIndex = (longAt(objOop)) & 0x3FFFFF;
	assert(((longLongAt(objOop)) != 0)
	 && (classIndex < (GIV(numClassTablePages) * (classTablePageSize()))));
	return classIndex >= 8;
}

static sqInt
isEphemeron(sqInt objOop)
{
	assert(isNonImmediate(objOop));
	return ((((usqInt) (longAt(objOop))) >> 24) & 0x1F) == 5;
}

sqInt
isFloatObject(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (ClassFloatCompactIndex == ((longAt(oop)) & 0x3FFFFF));
}

static sqInt
isForwardedClassTag(sqInt classIndex)
{
	return classIndex == 8;
}

sqInt
isForwardedObjectClassIndexPun(void)
{
	return 8;
}

sqInt
isForwarded(sqInt objOop)
{
	return ((longAt(objOop)) & 0x3FFFFF) == 8;
}

static sqInt
isFree(StackPage * self_in_isFree)
{
	return ((self_in_isFree->baseFP)) == 0;
}

static sqInt
isFreeObject(sqInt objOop)
{
	return ((longAt(objOop)) & 0x3FFFFF) == 0;
}

sqInt
isImmediate(sqInt oop)
{
	return (oop & 3) != 0;
}

sqInt
isIndexable(sqInt objOop)
{
    sqInt fmt;

	fmt = (((usqInt) (longAt(objOop))) >> 24) & 0x1F;
	return (fmt >= 2)
	 && ((fmt <= 4)
	 || (fmt >= 9));
}

static sqInt
isInEden(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt baseOop;

	/* begin oop:isGreaterThanOrEqualTo:andLessThan: */
	baseOop = ((eden()).start);
	return ((((usqInt) objOop)) >= (((usqInt) baseOop)))
	 && ((((usqInt) objOop)) < (((usqInt) GIV(freeStart))));
}

static sqInt
isInFutureSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt baseOop;

	/* begin oop:isGreaterThanOrEqualTo:andLessThan: */
	baseOop = ((futureSpace()).start);
	return ((((usqInt) address)) >= (((usqInt) baseOop)))
	 && ((((usqInt) address)) < (((usqInt) GIV(futureSurvivorStart))));
}


/*	Answer if the given address is in ST object memory. */

sqInt
isInMemory(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((((usqInt) address)) < (((usqInt) GIV(newSpaceLimit))))
 && ((((usqInt) address)) >= (((usqInt) GIV(newSpaceStart)))))
	 || (isInSegments(address));
}

static sqInt
isInNewSpace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((((usqInt) objOop)) < (((usqInt) GIV(newSpaceLimit))))
	 && ((((usqInt) objOop)) >= (((usqInt) GIV(newSpaceStart))));
}

static sqInt
isInOldSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((((usqInt) address)) >= (((usqInt) GIV(oldSpaceStart))))
	 && ((((usqInt) address)) < (((usqInt) GIV(endOfMemory))));
}

static sqInt
isInPastSpace(sqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt baseOop;

	/* begin oop:isGreaterThanOrEqualTo:andLessThan: */
	baseOop = ((pastSpace()).start);
	return ((((usqInt) address)) >= (((usqInt) baseOop)))
	 && ((((usqInt) address)) < (((usqInt) GIV(pastSpaceStart))));
}

static sqInt
isInRememberedSet(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(rememberedSetSize); i += 1) {
		if ((GIV(rememberedSet)[i]) == objOop) {
			return 1;
		}
	}
	return 0;
}

static sqInt
isInSegments(usqInt address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numSegments); i += 1) {
		if (address < (((GIV(segments)[i]).segStart))) {
			return 0;
		}
		if (address < ((((GIV(segments)[i]).segSize)) + (((GIV(segments)[i]).segStart)))) {
			return 1;
		}
	}
	return 0;
}

sqInt
isIntegerObject(sqInt oop)
{
	return (oop & 1) != 0;
}


/*	Answer if the given value can be represented as a Smalltalk integer value.
	In C, use a shift and XOR to set the sign bit if and only if the top two
	bits of the given
	value are the same, then test the sign bit. Note that the top two bits are
	equal for
	exactly those integers in the range that can be represented in 31-bits or
	63-bits. 
 */

sqInt
isIntegerValue(sqInt intValue)
{
	return (intValue ^ (intValue << 1)) >= 0;
}


/*	Answer if the argument, which can be any object, is a live context. */

static sqInt
isLiveContext(sqInt oop)
{
	if (!(((oop & 3) == 0)
		 && (((longAt(oop)) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
		return 0;
	}
	if (((longAt((oop + (BaseHeaderSize)) + (SenderIndex << 2))) & 3) == 0) {
		return ((longAt((oop + (BaseHeaderSize)) + (InstructionPointerIndex << 2))) & 1);
	}
	return !(isWidowedContext(oop));
}


/*	For compatibility with CoInterpreter. Needed to avoid
	slowPrimitiveResponse failing within ceSend:to:numArgs: et al with an
	unbalanced stack. */

static sqInt
isMachineCodeFrame(char *theFP)
{
	return 0;
}

sqInt
isMarked(sqInt objOop)
{
	flag("endianness");
	return ((((usqInt) (longAt(objOop + 4))) >> 23) & 1) != 0;
}

static sqInt
isMarriedOrWidowedContext(sqInt aContext)
{
	return ((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1);
}


/*	Answer true if integer object is negative.
	Fail if object pointed by oop i not an integer. */

static sqInt
isNegativeIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt ok;
    sqInt smallInt;

	if ((oop & 1)) {
		smallInt = (oop >> 1);
		return smallInt < 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex));
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & 0x3FFFFF;
	ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
	goto l2;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargeNegativeInteger << 2))) == (classAtIndex(ccIndex1));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		return 1;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}

sqInt
isNonImmediate(sqInt oop)
{
	return (oop & 3) == 0;
}


/*	Answer if obj is old. Require that obj is non-immediate. */

sqInt
isOldObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return (((usqInt) objOop)) >= (((usqInt) GIV(oldSpaceStart)));
}


/*	Answer whether the oop is an object of compiled method format */

sqInt
isOopCompiledMethod(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 24);
}

sqInt
isOopForwarded(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (((longAt(oop)) & 0x3FFFFF) == 8);
}

sqInt
isOopImmutable(sqInt oop)
{
	return ((oop & 3) != 0)
	 || (((((usqInt) (longAt(oop))) >> 23) & 1) != 0);
}

sqInt
isOopMutable(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (!(((((usqInt) (longAt(oop))) >> 23) & 1) != 0));
}

sqInt
isPinned(sqInt objOop)
{
	return ((((usqInt) (longAt(objOop))) >> 30) & 1) != 0;
}


/*	Answer if the argument has only fields that can hold oops. See comment in
	formatOf: 
 */

sqInt
isPointers(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 5);
}


/*	We save slots in the method cache by using the primitiveFunctionPointer
	to hold either a function pointer or the index of a quick primitive. Since
	quick primitive indices are small they can't be confused with function
	addresses. */

static sqInt
isPrimitiveFunctionPointerAnIndex(void)
{
	return (((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex;
}

sqInt
isQuickPrimitiveIndex(sqInt anInteger)
{
	return ((anInteger >= 256) && (anInteger <= 519));
}


/*	Reading the sender, instructionPointer and stackPointer inst vars of a
	context must take
	account of potentially married contexts and fetch the state from the
	frame. method,
	closureOrNil and receiver can safely be fetched from the context without
	checking. 
 */

sqInt
isReadMediatedContextInstVarIndex(sqInt index)
{
	return index <= StackPointerIndex;
}


/*	Answer if obj is young. This for compatibility with SqueakV3 where
	the GC makes all objects young during full GC. Spur doesn't do so. */

sqInt
isReallyYoungObject(sqInt obj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin isYoungObject: */
	assert(isNonImmediate(obj));
	return (((usqInt) obj)) < (((usqInt) GIV(newSpaceLimit)));
}


/*	Answer if oop is young. */

sqInt
isReallyYoung(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (isYoungObject(oop));
}

static sqInt
isRemembered(sqInt objOop)
{
	return ((((usqInt) (longAt(objOop))) >> 29) & 1) != 0;
}


/*	Answer whether the oop has survived a scavenge. This is equivalent to
	| target |
	(manager isImmediate: oop) ifTrue:
	[^true].
	target := (manager isForwarded: oop)
	ifTrue: [manager followForwarded: oop]
	ifFalse: [oop].
	^((manager isInEden: target)
	or: [(manager isInPastSpace: target)]) not */

static sqInt
isScavengeSurvivor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt target;

	if ((oop & 3) != 0) {
		return 1;
	}
	if (((longAt(oop)) & 0x3FFFFF) == 8) {
		/* begin followForwarded: */
		assert(isForwarded(oop));
		referent = longAt((oop + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		target = referent;
	}
	else {
		target = oop;
	}
	return (!(((target & 3) == 0)
 && (isYoungObject(target))))
	 || (oopisGreaterThanOrEqualToandLessThan(target, ((futureSpace()).start), GIV(futureSurvivorStart)));
}


/*	Maybe this should be in SpurSegmentManager only */

static sqInt
isSegmentBridge(sqInt objOop)
{
	return ((longAt(objOop)) & 0x3FFFFF) == 3;
}

static sqInt
isSingleContext(sqInt aContext)
{
	return ((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 3) == 0;
}

static sqInt
isValidFreeObject(sqInt objOop)
{
    sqInt chunk;

	return (addressCouldBeObj(objOop))
	 && ((((longAt(objOop)) & 0x3FFFFF) == 0)
	 && ((isInMemory(addressAfter(objOop)))
	 && (((((chunk = longAt((objOop + (BaseHeaderSize)) + (0 << 2)))) == 0)
 || (((longAt(chunk)) & 0x3FFFFF) == 0))
	 && (((((sqInt) (bytesInObject(objOop)) >> 3)) < 32)
	 || (((((chunk = longAt((objOop + (BaseHeaderSize)) + (2 << 2)))) == 0)
 || (((longAt(chunk)) & 0x3FFFFF) == 0))
	 && (((((chunk = longAt((objOop + (BaseHeaderSize)) + (3 << 2)))) == 0)
 || (((longAt(chunk)) & 0x3FFFFF) == 0))
	 && ((((chunk = longAt((objOop + (BaseHeaderSize)) + (4 << 2)))) == 0)
	 || (((longAt(chunk)) & 0x3FFFFF) == 0))))))));
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

static sqInt
isValidObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stackOrNil;

	stackOrNil = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (objStackRootIndex << 2));
	return (stackOrNil == GIV(nilObj))
	 || (isValidObjStackPagemyIndexfirstPage(stackOrNil, objStackRootIndex, 1));
}


/*	Just check the page itself. */

static sqInt
isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(((longAt(objStackPage)) & 0x3FFFFF) == 18)) {
		GIV(objStackInvalidBecause) = "wrong class index";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(((((usqInt) (longAt(objStackPage))) >> 24) & 0x1F) == 10)) {
		GIV(objStackInvalidBecause) = "wrong format";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!((numSlotsOfAny(objStackPage)) == ObjStackPageSlots)) {
		GIV(objStackInvalidBecause) = "wrong num slots";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (!(myx == (longAt((objStackPage + (BaseHeaderSize)) + (ObjStackMyx << 2))))) {
		GIV(objStackInvalidBecause) = "wrong myx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	if (GIV(marking)
	 && (!(isMarked(objStackPage)))) {
		GIV(objStackInvalidBecause) = "marking but page is unmarked";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return 1;
}


/*	Answer if the obj stack at stackRootIndex is valid. */

static sqInt
isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeOrNextPage;
    sqInt index;
    char *ns;
    sqInt page;

	if (!(isValidObjStackPagemyIndex(objStackPage, myx))) {
		return 0;
	}
	freeOrNextPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackFreex << 2));
	while (freeOrNextPage != 0) {
		if (!isFirstPage) {
			GIV(objStackInvalidBecause) = "free page on other than first page";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (freeOrNextPage == (longAt((objStackPage + (BaseHeaderSize)) + (ObjStackNextx << 2)))) {
			GIV(objStackInvalidBecause) = "free page = next page";
			GIV(invalidObjStackPage) = freeOrNextPage;
			return 0;
		}
		if (!(isValidObjStackPagemyIndex(freeOrNextPage, myx))) {
			ns = malloc(((strlen(GIV(objStackInvalidBecause))) + (strlen(", on next page"))) + 2);
			strcpy(ns, GIV(objStackInvalidBecause));
			GIV(objStackInvalidBecause) = strcat(ns, ", on next page");

			return 0;
		}
		page = longAt((freeOrNextPage + (BaseHeaderSize)) + (ObjStackFreex << 2));
		if ((page == freeOrNextPage)
		 || (page == objStackPage)) {
			GIV(objStackInvalidBecause) = "circularity in free page list";
			GIV(invalidObjStackPage) = page;
			return 0;
		}
		freeOrNextPage = page;
	}
	if (isFirstPage) {
		if (!(((myx >= (1 << (22 - 10))) && (myx <= (((1 << (22 - 10)) + 8) - 1))))) {
			GIV(objStackInvalidBecause) = "myx out of range";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
		if (!((longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (myx << 2))) == objStackPage)) {
			GIV(objStackInvalidBecause) = "firstPage is not root";
			GIV(invalidObjStackPage) = objStackPage;
			return 0;
		}
	}
	index = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackTopx << 2));
	if (!(((index >= 0) && (index <= ObjStackLimit)))) {
		GIV(objStackInvalidBecause) = "bad topx";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	freeOrNextPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackNextx << 2));
	if (freeOrNextPage == 0) {
		return 1;
	}
	if (freeOrNextPage == objStackPage) {
		GIV(objStackInvalidBecause) = "circularity in objStack page list";
		GIV(invalidObjStackPage) = objStackPage;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(freeOrNextPage, myx, 0);
}


/*	Answer if the obj stack at objStackRootIndex is valid. */

static sqInt
isValidObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((addressCouldBeObj(objStack))
		 && ((numSlotsOfAny(objStack)) == ObjStackPageSlots))) {
		GIV(objStackInvalidBecause) = "first page not obj or wrong size";
		GIV(invalidObjStackPage) = objStack;
		return 0;
	}
	return isValidObjStackPagemyIndexfirstPage(objStack, longAt((objStack + (BaseHeaderSize)) + (ObjStackMyx << 2)), 1);
}


/*	bridges bridge the gaps between segments. They are the last object in each
	segment. 
 */

static sqInt
isValidSegmentBridge(sqInt objOop)
{
	return (addressCouldBeObj(objOop - (BaseHeaderSize)))
	 && ((((longAt(objOop)) & 0x3FFFFF) == 3)
	 && (((rawNumSlotsOf(objOop)) == 0xFF)
	 || ((numSlotsOfAny(objOop)) == 0)));
}

static sqInt
isWeakNonImm(sqInt objOop)
{
	return ((((usqInt) (longAt(objOop))) >> 24) & 0x1F) == 4;
}


/*	Answer if the argument has only weak fields that can hold oops. See
	comment in formatOf:
 */

sqInt
isWeak(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) == 4);
}


/*	See if the argument is married to a live frame or not.
	If it is not, turn it into a bereaved single context. */

static sqInt
isWidowedContext(sqInt aOnceMarriedContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt frameCtxt;
    sqInt index;
    sqInt referent;
    char *shouldBeFrameCallerField;
    char *theFrame;
    StackPage *thePage;
    sqInt value;

	assert((isContext(aOnceMarriedContext))
	 && (isMarriedOrWidowedContext(aOnceMarriedContext)));
	/* begin frameOfMarriedContext: */
	value = longAt((aOnceMarriedContext + (BaseHeaderSize)) + (SenderIndex << 2));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	theFrame = pointerForOop(value - 1);
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	if (!((isFree(thePage))
		 || (theFrame < ((thePage->headFP))))) {

		/* The frame pointer is within the bounds of a live page.
		   Now check if it matches a frame. */

		/* begin withoutSmallIntegerTags: */
		assert(((longAt((aOnceMarriedContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2))) & 1));
		shouldBeFrameCallerField = pointerForOop((longAt((aOnceMarriedContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2))) - 1);
		if (((frameCallerFP(theFrame)) == shouldBeFrameCallerField)
		 && ((byteAt((theFrame + FoxFrameFlags) + 2)) != 0)) {
			frameCtxt = longAt(theFrame + FoxThisContext);
			if (((longAt(frameCtxt)) & 0x3FFFFF) == 8) {
				/* begin followForwarded: */
				assert(isForwarded(frameCtxt));
				referent = longAt((frameCtxt + (BaseHeaderSize)) + (0 << 2));
				while (((referent & 3) == 0)
				 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
					referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
				}
				frameCtxt = referent;
				/* begin setFrameContext:to: */
				longAtput(theFrame + FoxThisContext, frameCtxt);
			}
			if (frameCtxt == aOnceMarriedContext) {

				/* It is still married! */

				return 0;
			}
		}
	}
	/* begin markContextAsDead: */
	assert(isContext(aOnceMarriedContext));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(aOnceMarriedContext)));
	longAtput((aOnceMarriedContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
	return 1;
}

sqInt
isWordsOrBytes(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) > 5);
}


/*	Answer if the argument contains only indexable words (no oops). See
	comment in formatOf:
 */

sqInt
isWords(sqInt oop)
{
	return ((oop & 3) == 0)
	 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) == 10);
}


/*	Wrining any inst vars of a context must take account of potentially
	married contexts
	and set the state in the frame. Inst vars in subclasses don't need
	mediation; subclasses
	can't marry. */

sqInt
isWriteMediatedContextInstVarIndex(sqInt index)
{
	return index <= ReceiverIndex;
}


/*	Answer if obj is young. Require that obj is non-immediate. */

sqInt
isYoungObject(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isNonImmediate(objOop));
	return (((usqInt) objOop)) < (((usqInt) GIV(newSpaceLimit)));
}


/*	Answer if oop is young. */

sqInt
isYoung(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((oop & 3) == 0)
	 && ((((usqInt) oop)) < (((usqInt) GIV(newSpaceLimit))));
}


/*	Answer if oop is an instance of the given class. If the class has a
	(non-zero) compactClassIndex use that to speed up the check. N.B. Inlining
	should result in classOop not being accessed if oop's compact class index
	and compactClassIndex are non-zero. */

static sqInt
isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex)
{
    sqInt ccIndex;

	if ((oop & 3) != 0) {
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	if (compactClassIndex != 0) {
		return compactClassIndex == ccIndex;
	}
	return classOop == (classAtIndex(ccIndex));
}


/*	Support for external primitives. */

sqInt
isKindOfClass(sqInt oop, sqInt aClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt oopClass;
    sqInt tagBits;

	/* begin fetchClassOf: */
	if (((tagBits = oop & 3)) != 0) {
		oopClass = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
		goto l1;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(oop)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		oopClass = oop;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		oopClass = null;
		goto l1;
	}
	oopClass = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l1:	/* end fetchClassOf: */;
	while (!(oopClass == GIV(nilObj))) {
		if (oopClass == aClass) {
			return 1;
		}
		oopClass = longAt((oopClass + (BaseHeaderSize)) + (SuperclassIndex << 2));
	}
	return 0;
}


/*	Support for external primitives. */

sqInt
isKindOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt oopClass;
    sqInt tagBits;

	/* begin fetchClassOf: */
	if (((tagBits = oop & 3)) != 0) {
		oopClass = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
		goto l1;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(oop)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		oopClass = oop;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		oopClass = null;
		goto l1;
	}
	oopClass = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l1:	/* end fetchClassOf: */;
	while (!(oopClass == GIV(nilObj))) {
		if (classNameOfIs(oopClass, className)) {
			return 1;
		}
		oopClass = longAt((oopClass + (BaseHeaderSize)) + (SuperclassIndex << 2));
	}
	return 0;
}


/*	Support for external primitives */

sqInt
isMemberOf(sqInt oop, char *className)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt oopClass;
    sqInt tagBits;

	/* begin fetchClassOf: */
	if (((tagBits = oop & 3)) != 0) {
		oopClass = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
		goto l1;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(oop)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		oopClass = oop;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		oopClass = null;
		goto l1;
	}
	oopClass = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l1:	/* end fetchClassOf: */;
	return classNameOfIs(oopClass, className);
}

static sqInt
isonWeaklingList(sqInt oop, sqInt listHead)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt corpse;
    sqInt listOffset;

	corpse = (listHead << 3) + GIV(newSpaceStart);
	while (corpse != null) {
		if (oop == (followForwarded(corpse))) {
			return 1;
		}
		/* begin nextCorpseOrNil: */
		assert(isYoung(corpse));
		listOffset = ((rawHashBitsOf(corpse)) << 5) + ((((usqInt) (longAt(corpse))) >> 24) & 0x1F);
		corpse = (listOffset != 0
			? (listOffset << 3) + GIV(newSpaceStart)
			: 0);
	}
	return 0;
}


/*	Answer the object the ephemeron guards. This is its first element. */

static sqInt
keyOfEphemeron(sqInt objOop)
{
	assert((isNonImmediate(objOop))
	 && (isEphemeron(objOop)));
	return longAt((objOop + (BaseHeaderSize)) + (0 << 2));
}

static sqInt
knownClassAtIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(((classIndex >= 1) && (classIndex <= (classTablePageSize()))));
	return longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (classIndex << 2));
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects.
	Does not examine the stack pointer of contexts to be sure to swizzle
	the nils that fill contexts on snapshot.
	It is invariant that on image load no object contains a forwarding
	pointer, and the image contains no forwarders (see class comment). */

sqInt
lastPointerOfWhileSwizzling(sqInt objOop)
{
    sqInt fmt;
    sqInt numLiterals;

	fmt = (((usqInt) (longAt(objOop))) >> 24) & 0x1F;
	assert(fmt != (forwardedFormat()));
	if (fmt <= 5) {
		return (((numSlotsOf(objOop)) - 1) * BytesPerOop) + (BaseHeaderSize);
	}
	if (fmt < 24) {
		return 0;
	}
	numLiterals = 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? (((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
				: (((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#  else /* MULTIPLEBYTECODESETS */
		(((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#  endif /* MULTIPLEBYTECODESETS */
		;
	return (((numLiterals + LiteralStart) - 1) * BytesPerOop) + (BaseHeaderSize);
}


/*	Answer the byte offset of the last pointer field of the given object.
	Works with CompiledMethods, as well as ordinary objects. */

sqInt
lastPointerOf(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt numLiterals;
    sqInt sp;

	fmt = (((usqInt) (longAt(objOop))) >> 24) & 0x1F;
	assert(fmt != (forwardedFormat()));
	if (fmt <= 5) {
		if ((fmt == 3)
		 && (((longAt(objOop)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */

			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + (BaseHeaderSize)) + (StackPointerIndex << 2));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			return (CtxtTempFrameStart + contextSize) * BytesPerOop;
		}
		return (((numSlotsOf(objOop)) - 1) * BytesPerOop) + (BaseHeaderSize);
	}
	if (fmt < 24) {
		return 0;
	}
	numLiterals = 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? (((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
				: (((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#  else /* MULTIPLEBYTECODESETS */
		(((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#  endif /* MULTIPLEBYTECODESETS */
		;
	return (((numLiterals + LiteralStart) - 1) * BytesPerOop) + (BaseHeaderSize);
}

sqInt
leakCheckBecome(void)
{
	return (checkForLeaks & 4) != 0;
}

sqInt
leakCheckFullGC(void)
{
	return (checkForLeaks & 1) != 0;
}

sqInt
leakCheckIncrementalGC(void)
{
	return (checkForLeaks & 8) != 0;
}

sqInt
leakCheckNewSpaceGC(void)
{
	return (checkForLeaks & 2) != 0;
}


/*	for the message send breakpoint; selectors can be immediates. */

static sqInt
lengthOfMaybeImmediate(sqInt oop)
{
    usqInt numSlots;
    usqInt numSlots1;

	if ((oop & 3) != 0) {
		return 0;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(oop - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 9) {
		return numSlots;
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		return (numSlots << 2) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 7);
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 12) {
		return (numSlots << (2 - 1)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 3);
	}
	return (numSlots << (2 - 2)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 1);
}

static sqInt
lengthOfNameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots2 = ((usqInt) (((usqInt)(longAt(classOop + 4))))) >> 24;
	numSlots = (numSlots2 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(classOop - (BaseHeaderSize)))
		: numSlots2);
	if (numSlots == GIV(metaclassNumSlots)) {
		return lengthOfNameOfClass(longAt((classOop + (BaseHeaderSize)) + (GIV(thisClassIndex) << 2)));
	}
	if (numSlots <= GIV(classNameIndex)) {
		return 0;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2)))) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots3 = ((usqInt) (((usqInt)(longAt((longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2))) + 4))))) >> 24;
	numSlots1 = (numSlots3 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt((longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2))) - (BaseHeaderSize)))
		: numSlots3);
	if (((((usqInt) (longAt(longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2))))) >> 24) & 0x1F) <= 9) {
		return numSlots1;
	}
	if (((((usqInt) (longAt(longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2))))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		return (numSlots1 << 2) - (((((usqInt) (longAt(longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2))))) >> 24) & 0x1F) & 7);
	}
	if (((((usqInt) (longAt(longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2))))) >> 24) & 0x1F) >= 12) {
		return (numSlots1 << (2 - 1)) - (((((usqInt) (longAt(longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2))))) >> 24) & 0x1F) & 3);
	}
	return (numSlots1 << (2 - 2)) - (((((usqInt) (longAt(longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2))))) >> 24) & 0x1F) & 1);
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes) should
	be subtracted from the result. */

sqInt
lengthOf(sqInt objOop)
{
    usqInt numSlots;
    usqInt numSlots1;

	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(objOop - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) <= 9) {
		return numSlots;
	}
	if (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		return (numSlots << 2) - (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) & 7);
	}
	if (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) >= 12) {
		return (numSlots << (2 - 1)) - (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) & 3);
	}
	return (numSlots << (2 - 2)) - (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) & 1);
}


/*	Answer the number of indexable units in the given object.
	For a CompiledMethod, the size of the method header (in bytes)
	should be subtracted from the result of this method. */

static sqInt
lengthOfformat(sqInt objOop, sqInt fmt)
{
    usqInt numSlots;
    usqInt numSlots1;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(objOop - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		return numSlots;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		return (numSlots << 2) - (fmt & 7);
	}
	if (fmt >= 12) {
		return (numSlots << (2 - 1)) - (fmt & 3);
	}
	return (numSlots << (2 - 2)) - (fmt & 1);
}

sqInt
literalCountOfHeader(sqInt headerPointer)
{
	return 
#  if MULTIPLEBYTECODESETS
		((((sqInt) headerPointer)) < 0
				? (((usqInt) headerPointer) >> 1) & 0xFFFF
				: (((usqInt) headerPointer) >> 10) & 0xFF)
#  else /* MULTIPLEBYTECODESETS */
		(((usqInt) headerPointer) >> 10) & 0xFF
#  endif /* MULTIPLEBYTECODESETS */
		;
}

sqInt
literalCountOf(sqInt methodPointer)
{
	return 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
				: (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#  else /* MULTIPLEBYTECODESETS */
		(((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#  endif /* MULTIPLEBYTECODESETS */
		;
}

sqInt
literalofMethod(sqInt offset, sqInt methodPointer)
{
	return longAt((methodPointer + (BaseHeaderSize)) + ((offset + LiteralStart) << 2));
}


/*	This entry point needs to be implemented for the interpreter proxy.
	Since BitBlt is now a plugin we need to look up
	BitBltPlugin:=loadBitBltFrom and call it. This entire mechanism should
	eventually go away and be
	replaced with a dynamic lookup from BitBltPlugin itself but for backward
	compatibility this stub is provided
 */

sqInt
loadBitBltFrom(sqInt bb)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void *fn;

	fn = ioLoadFunctionFrom("loadBitBltFrom", "BitBltPlugin");
	if (fn == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return ((sqInt (*)(sqInt))fn)(bb);
}

void
loadInitialContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;

	null;
	/* begin runLeakCheckerForFullGC: */
	runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(1, 0);
	/* return self */
	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
	activeContext = longAt((activeProc + (BaseHeaderSize)) + (SuspendedContextIndex << 2));
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
}

void
longPrintOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aByte;
    sqInt aByte1;
    sqInt aByte2;
    sqInt aByte3;
    sqInt aByte4;
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt column;
    sqInt fieldOop;
    sqInt fmt;
    sqInt i;
    sqInt index;
    sqInt lastIndex;
    sqInt len;
    sqInt n;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt startIP;

	if (((oop & 3) != 0)
	 || ((!(addressCouldBeObj(oop)))
	 || (((oop & (8 - 1)) != 0)
	 || ((((longAt(oop)) & 0x3FFFFF) == 0)
	 || (((longAt(oop)) & 0x3FFFFF) == 8))))) {
		printOop(oop);
		return;
	}
	printHex(oop);
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(oop)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = oop;
		goto l3;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l4;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l4:	/* end classAtIndex: */;
l3:	/* end fetchClassOfNonImm: */;
	if (class == null) {
		print(" has a nil class!!");
	}
	else {
		print(": a(n) ");
		printNameOfClasscount(class, 5);
		print(" (");
		/* begin printHexnp: */
		printf("0x%x", (longAt(oop)) & 0x3FFFFF);
		print("=>");

		/* begin printHexnp: */
		printf("0x%x", class);
		print(")");
	}
	fmt = (((usqInt) (longAt(oop))) >> 24) & 0x1F;
	print(" format ");
	/* begin printHexnp: */
	printf("0x%x", fmt);
	if (fmt > 5) {
		print(" nbytes ");
		printNum(byteLengthOf(oop));
	}
	else {
		if ((fmt >= 2)
		 && ((fmt <= 4)
		 || (fmt >= 9))) {
			/* begin lengthOf:format: */
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
			/* begin rawNumSlotsOf: */
			flag("endianness");
			numSlots2 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
			numSlots = (numSlots2 == 0xFF
				? (/* begin rawOverflowSlotsOf: */
					flag("endianness"),
					longAt(oop - (BaseHeaderSize)))
				: numSlots2);
			if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 9) {
				len = numSlots;
				goto l1;
			}
			if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16) {

				/* bytes, including CompiledMethod */

				len = (numSlots << 2) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 7);
				goto l1;
			}
			if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 12) {
				len = (numSlots << (2 - 1)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 3);
				goto l1;
			}
			len = (numSlots << (2 - 2)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 1);
		l1:	/* end lengthOf:format: */;
			print(" size ");
			printNum(len - (fixedFieldsOfformatlength(oop, fmt, len)));
		}
	}
	/* begin printHeaderTypeOf: */
	print(((numSlotsOf(oop)) >= 0xFF
		? " hdr16 "
		: " hdr8 "));
	/* begin printChar: */
	aByte = (((((usqInt) (longAt(oop))) >> 23) & 1) != 0
		? 'i'
		: '.');
	putchar(aByte);
	/* begin printChar: */
	aByte1 = (((((usqInt) (longAt(oop))) >> 29) & 1) != 0
		? 'r'
		: '.');
	putchar(aByte1);
	/* begin printChar: */
	aByte2 = (((((usqInt) (longAt(oop))) >> 30) & 1) != 0
		? 'p'
		: '.');
	putchar(aByte2);
	/* begin printChar: */
	aByte3 = (isMarked(oop)
		? 'm'
		: '.');
	putchar(aByte3);
	/* begin printChar: */
	aByte4 = (((((usqInt) (longAt(oop))) >> 0x1F) & 1) != 0
		? 'g'
		: '.');
	putchar(aByte4);
	print(" hash ");
	/* begin printHexnp: */
	/* begin rawHashBitsOf: */
	flag("endianness");
	n = (longAt(oop + 4)) & 0x3FFFFF;
	printf("0x%x", n);
	/* begin cr */
	printf("\n");
	if (((fmt >= 16) && (fmt <= (24 - 1)))) {
		printStringOf(oop);
		/* begin cr */
		printf("\n");

		return;
	}
	if (((fmt >= 10) && (fmt <= (16 - 1)))) {
		return;
	}
	startIP = ((sqInt) (((lastPointerOf(oop)) + BytesPerOop) - (BaseHeaderSize)) >> 2);
	lastIndex = ((256 < startIP) ? 256 : startIP);
	if (lastIndex > 0) {
		for (i = 1; i <= lastIndex; i += 1) {
			fieldOop = longAt((oop + (BaseHeaderSize)) + ((i - 1) << 2));
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			printNum(i - 1);
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			printHex(fieldOop);
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			if ((i == 1)
			 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 24)) {
				/* begin printMethodHeaderOop: */
				printOopShort(fieldOop);
				/* return self */
			}
			else {
				printOopShort(fieldOop);
			}
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 24) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf:format: */
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots3 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
		numSlots1 = (numSlots3 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(oop - (BaseHeaderSize)))
			: numSlots3);
		if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 9) {
			lastIndex = numSlots1;
			goto l2;
		}
		if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16) {

			/* bytes, including CompiledMethod */

			lastIndex = (numSlots1 << 2) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 7);
			goto l2;
		}
		if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 12) {
			lastIndex = (numSlots1 << (2 - 1)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 3);
			goto l2;
		}
		lastIndex = (numSlots1 << (2 - 2)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 1);
	l2:	/* end lengthOf:format: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				printf("0x%08x: ", oop+BaseHeaderSize+index-1);
			}
			byte = byteAt((oop + (BaseHeaderSize)) + (index - 1));
			printf(" %02x/%-3d", byte,byte);
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				/* begin cr */
				printf("\n");
			}
		}
		if (!(column == 1)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > 64) {
			print("...");
			/* begin cr */
			printf("\n");
		}
	}
}


/*	Scan the heap long printing the oops of any and all objects that refer to
	anOop 
 */

void
longPrintReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt i;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prntObj;

	prntObj = 0;
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots2 = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots2 == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) <= 5)
		 || (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24)) {
			if (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24) {
				i = (
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart;
			}
			else {
				if (((longAt(objOop1)) & 0x3FFFFF) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(objOop1));
				}
				else {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objOop1)) > (isForwardedObjectClassIndexPun()));
					/* begin rawNumSlotsOf: */
					flag("endianness");
					numSlots = ((usqInt) (((usqInt)(longAt(objOop1 + 4))))) >> 24;
					i = ((usqInt) ((numSlots == 0xFF
	? (/* begin rawOverflowSlotsOf: */
		flag("endianness"),
		longAt(objOop1 - (BaseHeaderSize)))
	: numSlots)));
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + (BaseHeaderSize)) + (i << 2)))) {
					printHex(objOop1);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					prntObj = 1;
					i = 0;
				}
			}
			if (prntObj) {
				prntObj = 0;
				longPrintOop(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if ((((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) <= 5)
		 || (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24)) {
			if (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24) {
				i = (
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart;
			}
			else {
				if (((longAt(objOop1)) & 0x3FFFFF) == ClassMethodContextCompactIndex) {
					i = CtxtTempFrameStart + (fetchStackPointerOf(objOop1));
				}
				else {
					/* begin numSlotsOf: */
					flag("endianness");
					assert((classIndexOf(objOop1)) > (isForwardedObjectClassIndexPun()));
					/* begin rawNumSlotsOf: */
					flag("endianness");
					numSlots = ((usqInt) (((usqInt)(longAt(objOop1 + 4))))) >> 24;
					i = ((usqInt) ((numSlots == 0xFF
	? (/* begin rawOverflowSlotsOf: */
		flag("endianness"),
		longAt(objOop1 - (BaseHeaderSize)))
	: numSlots)));
				}
			}
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + (BaseHeaderSize)) + (i << 2)))) {
					printHex(objOop1);
					print(" @ ");
					printNum(i);
					/* begin cr */
					printf("\n");
					prntObj = 1;
					i = 0;
				}
			}
			if (prntObj) {
				prntObj = 0;
				longPrintOop(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if ((((((usqInt) (longAt(objOop11))) >> 24) & 0x1F) <= 5)
			 || (((((usqInt) (longAt(objOop11))) >> 24) & 0x1F) >= 24)) {
				if (((((usqInt) (longAt(objOop11))) >> 24) & 0x1F) >= 24) {
					i = (
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart;
				}
				else {
					if (((longAt(objOop11)) & 0x3FFFFF) == ClassMethodContextCompactIndex) {
						i = CtxtTempFrameStart + (fetchStackPointerOf(objOop11));
					}
					else {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(objOop11)) > (isForwardedObjectClassIndexPun()));
						/* begin rawNumSlotsOf: */
						flag("endianness");
						numSlots = ((usqInt) (((usqInt)(longAt(objOop11 + 4))))) >> 24;
						i = ((usqInt) ((numSlots == 0xFF
	? (/* begin rawOverflowSlotsOf: */
		flag("endianness"),
		longAt(objOop11 - (BaseHeaderSize)))
	: numSlots)));
					}
				}
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((objOop11 + (BaseHeaderSize)) + (i << 2)))) {
						printHex(objOop11);
						print(" @ ");
						printNum(i);
						/* begin cr */
						printf("\n");
						prntObj = 1;
						i = 0;
					}
				}
				if (prntObj) {
					prntObj = 0;
					longPrintOop(objOop11);
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
}


/*	Answer the relevant long store temp bytecode, which indicates it has a
	primitive error code.
 */
/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

sqInt
longStoreBytecodeForHeader(sqInt methodHeader)
{
	return 
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader)) < 0
				? 234
				: 129)
#  else /* MULTIPLEBYTECODESETS */
		129
#  endif /* MULTIPLEBYTECODESETS */
		;
}


/*	This method implements a simple method lookup cache. If an entry for the
	given selector and classTag is
	found in the cache, set the values of 'newMethod' and
	'primitiveFunctionPointer' and answer true. Otherwise,
	answer false. */
/*	About the re-probe scheme: The hash is the low bits of the XOR of two
	large addresses, minus their useless
	lowest two bits. If a probe doesn't get a hit, the hash is shifted right
	one bit to compute the next probe,
	introducing a new randomish bit. The cache is probed CacheProbeMax times
	before giving up.
 */
/*	WARNING: Since the hash computation is based on the object addresses of
	the class and selector, we must
	rehash or flush when compacting storage. We've chosen to flush, since that
	also saves the trouble of updating
	the addresses of the objects in the cache. */
/*	classTag is either a class object, if using NewObjectMemory, or a
	classIndex, if using SpurMemoryManager.
 */

static sqInt
lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt probe;


	/* shift drops two low-order zeros from addresses */

	hash = selector ^ classTag;

	/* first probe */

	probe = hash & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}

	/* second probe */

	probe = (((usqInt) hash) >> 1) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	probe = (((usqInt) hash) >> 2) & MethodCacheMask;
	if (((GIV(methodCache)[probe + MethodCacheSelector]) == selector)
	 && ((GIV(methodCache)[probe + MethodCacheClass]) == classTag)) {
		GIV(newMethod) = GIV(methodCache)[probe + MethodCacheMethod];
		primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe + MethodCachePrimFunction]));
		return 1;
	}
	return 0;
}

static sqInt
lookupMethodInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;
    sqInt found;
    sqInt hash;
    sqInt index;
    usqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt wrapAround;

	assert(addressCouldBeClassObj(class));
	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + (BaseHeaderSize)) + (MethodDictionaryIndex << 2));
		if (dictionary == GIV(nilObj)) {

			/* MethodDict pointer is nil (hopefully due a swapped out stub)
			   -- raise exception #cannotInterpret:. */

			createActualMessageTo(class);
			GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorCannotInterpret << 2));
			/* begin sendBreakpoint:receiver: */
			sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), null);
			return lookupMethodInClass(longAt((currentClass + (BaseHeaderSize)) + (SuperclassIndex << 2)));
		}
		/* begin lookupMethodInDictionary: */
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots = ((usqInt) (((usqInt)(longAt(dictionary + 4))))) >> 24;
		length = (numSlots == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(dictionary - (BaseHeaderSize)))
			: numSlots);

		/* Use linear search on small dictionaries; its cheaper.
		   Also the limit can be set to force linear search of all dictionaries, which supports the
		   booting of images that need rehashing (e.g. because a tracer has generated an image
		   with different hashes but hasn't rehashed it yet.) */

		mask = (length - SelectorStart) - 1;
		if (mask <= GIV(methodDictLinearSearchLimit)) {
			index = 0;
			while (index <= mask) {
				nextSelector = longAt((dictionary + (BaseHeaderSize)) + ((index + SelectorStart) << 2));
				if (nextSelector == GIV(messageSelector)) {
					methodArray = longAt((dictionary + (BaseHeaderSize)) + (MethodArrayIndex << 2));
					GIV(newMethod) = longAt((methodArray + (BaseHeaderSize)) + (index << 2));
					found = 1;
					goto l1;
				}
				index += 1;
			}
			found = 0;
			goto l1;
		}

		/* It is assumed that there are some nils in this dictionary, and search will
		   stop when one is encountered. However, if there are no nils, then wrapAround
		   will be detected the second time the loop gets to the end of the table. */

		index = SelectorStart + (mask & (((GIV(messageSelector) & 3) != 0
	? (GIV(messageSelector) >> 1)
	: (/* begin hashBitsOf: */
		/* begin rawHashBitsOf: */
		flag("endianness"),
		(hash = (longAt(GIV(messageSelector) + 4)) & 0x3FFFFF),
		(hash == 0
				? ((hash = (newObjectHash()) & 0x3FFFFF),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					longAtput(GIV(messageSelector) + 4, ((((longAt(GIV(messageSelector) + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash))
				: 0),
		hash))));
		wrapAround = 0;
		while (1) {
			nextSelector = longAt((dictionary + (BaseHeaderSize)) + (index << 2));
			if (nextSelector == GIV(nilObj)) {
				found = 0;
				goto l1;
			}
			if (nextSelector == GIV(messageSelector)) {
				methodArray = longAt((dictionary + (BaseHeaderSize)) + (MethodArrayIndex << 2));
				GIV(newMethod) = longAt((methodArray + (BaseHeaderSize)) + ((index - SelectorStart) << 2));
				found = 1;
				goto l1;
			}
			index += 1;
			if (index == length) {
				if (wrapAround) {
					found = 0;
					goto l1;
				}
				wrapAround = 1;
				index = SelectorStart;
			}
		}
		found = 0;
	l1:	/* end lookupMethodInDictionary: */;
		if (found) {
			return currentClass;
		}
		currentClass = longAt((currentClass + (BaseHeaderSize)) + (SuperclassIndex << 2));
	}
	if (GIV(messageSelector) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorDoesNotUnderstand << 2)))) {
		error("Recursive not understood error encountered");
	}
	createActualMessageTo(class);
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorDoesNotUnderstand << 2));
	sendBreakpointreceiver(GIV(messageSelector) + BaseHeaderSize, lengthOfformat(GIV(messageSelector), (((usqInt) (longAt(GIV(messageSelector)))) >> 24) & 0x1F), null);
	return lookupMethodInClass(class);
}


/*	This method lookup tolerates integers as Dictionary keys to support
	execution of images in which Symbols have been compacted out. */

static sqInt
lookupMethodInDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt index;
    usqInt length;
    sqInt mask;
    sqInt methodArray;
    sqInt nextSelector;
    usqInt numSlots;
    sqInt wrapAround;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(dictionary + 4))))) >> 24;
	length = (numSlots == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(dictionary - (BaseHeaderSize)))
		: numSlots);

	/* Use linear search on small dictionaries; its cheaper.
	   Also the limit can be set to force linear search of all dictionaries, which supports the
	   booting of images that need rehashing (e.g. because a tracer has generated an image
	   with different hashes but hasn't rehashed it yet.) */

	mask = (length - SelectorStart) - 1;
	if (mask <= GIV(methodDictLinearSearchLimit)) {
		index = 0;
		while (index <= mask) {
			nextSelector = longAt((dictionary + (BaseHeaderSize)) + ((index + SelectorStart) << 2));
			if (nextSelector == GIV(messageSelector)) {
				methodArray = longAt((dictionary + (BaseHeaderSize)) + (MethodArrayIndex << 2));
				GIV(newMethod) = longAt((methodArray + (BaseHeaderSize)) + (index << 2));
				return 1;
			}
			index += 1;
		}
		return 0;
	}

	/* It is assumed that there are some nils in this dictionary, and search will
	   stop when one is encountered. However, if there are no nils, then wrapAround
	   will be detected the second time the loop gets to the end of the table. */

	index = SelectorStart + (mask & (((GIV(messageSelector) & 3) != 0
	? (GIV(messageSelector) >> 1)
	: (/* begin hashBitsOf: */
		/* begin rawHashBitsOf: */
		flag("endianness"),
		(hash = (longAt(GIV(messageSelector) + 4)) & 0x3FFFFF),
		(hash == 0
				? ((hash = (newObjectHash()) & 0x3FFFFF),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					longAtput(GIV(messageSelector) + 4, ((((longAt(GIV(messageSelector) + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash))
				: 0),
		hash))));
	wrapAround = 0;
	while (1) {
		nextSelector = longAt((dictionary + (BaseHeaderSize)) + (index << 2));
		if (nextSelector == GIV(nilObj)) {
			return 0;
		}
		if (nextSelector == GIV(messageSelector)) {
			methodArray = longAt((dictionary + (BaseHeaderSize)) + (MethodArrayIndex << 2));
			GIV(newMethod) = longAt((methodArray + (BaseHeaderSize)) + ((index - SelectorStart) << 2));
			return 1;
		}
		index += 1;
		if (index == length) {
			if (wrapAround) {
				return 0;
			}
			wrapAround = 1;
			index = SelectorStart;
		}
	}
	return 0;
}


/*	Lookup messageSelector in class. Answer 0 on success. Answer the splObj:
	index for the error selector to use on failure rather than performing MNU
	processing etc. */

static sqInt
lookupMethodNoMNUEtcInClass(sqInt class)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentClass;
    sqInt dictionary;

	currentClass = class;
	while (currentClass != GIV(nilObj)) {
		dictionary = longAt((currentClass + (BaseHeaderSize)) + (MethodDictionaryIndex << 2));
		if (dictionary == GIV(nilObj)) {
			GIV(lkupClass) = longAt((currentClass + (BaseHeaderSize)) + (SuperclassIndex << 2));
			return SelectorCannotInterpret;
		}
		if (lookupMethodInDictionary(dictionary)) {
			addNewMethodToCache(class);
			return 0;
		}
		currentClass = longAt((currentClass + (BaseHeaderSize)) + (SuperclassIndex << 2));
	}
	GIV(lkupClass) = class;
	return SelectorDoesNotUnderstand;
}


/*	Return a Large Integer object for the given integer magnitude and sign */

static sqInt
magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt highWord;
    sqInt i;
    sqInt intValue;
    sqInt isSmall;
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt smallVal;
    sqInt sz;

	isSmall = (isNegative
		? magnitude <= 0x40000000
		: magnitude < 0x40000000);
	if (isSmall) {
		smallVal = ((sqInt) magnitude);
		if (isNegative) {
			smallVal = 0 - smallVal;
		}
		return ((smallVal << 1) | 1);
	}
	largeClass = (isNegative
		? (/* begin knownClassAtIndex: */
			assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize())))),
			longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (ClassLargeNegativeIntegerCompactIndex << 2)))
		: (/* begin knownClassAtIndex: */
			assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize())))),
			longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (ClassLargePositiveIntegerCompactIndex << 2))));
	highWord = magnitude >> 32;
	if (highWord == 0) {
		sz = 4;
	}
	else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
	}
	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	for (i = 0; i < sz; i += 1) {
		intValue = (magnitude >> (i * 8)) & 0xFF;
		byteAtput((newLargeInteger + (BaseHeaderSize)) + i, intValue);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a eight-byte
	LargeInteger. 
 */

static usqLong
magnitude64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt i;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt ok;
    sqInt smallIntValue;
    sqInt sz;
    usqLong value;

	if ((oop & 1)) {
		smallIntValue = (oop >> 1);
		if (smallIntValue < 0) {
			smallIntValue = 0 - smallIntValue;
		}
		return ((usqLong) smallIntValue);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex1));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & 0x3FFFFF;
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

		ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargeNegativeInteger << 2))) == (classAtIndex(ccIndex));
	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(oop - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 9) {
		sz = numSlots;
		goto l3;
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		sz = (numSlots << 2) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 7);
		goto l3;
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 12) {
		sz = (numSlots << (2 - 1)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 3);
		goto l3;
	}
	sz = (numSlots << (2 - 2)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 1);
l3:	/* end lengthOf:format: */;
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	value = 0;
	for (i = 0; i < sz; i += 1) {
		value += (((sqLong) (byteAt((oop + (BaseHeaderSize)) + i)))) << (i * 8);
	}
	return value;
}


/*	<Integer> */
/*	Marry aContext with the base frame of a new stack page. Build the base
	frame to reflect the context's state. Answer the new page. */

static StackPage *
makeBaseFrameFor(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt header;
    sqInt i;
    StackPage *lruOrFree;
    sqInt maybeClosure;
    sqInt numArgs;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oop;
    sqInt oop1;
    StackPage *page;
    char *pointer;
    sqInt rcvr;
    sqInt stackPtrIndex;
    sqInt theIP;
    sqInt theMethod;
    char *value;
    sqInt valuePointer;
    sqInt valuePointer1;

	assert(isSingleContext(aContext));
	assert(goodContextSize(aContext));
	/* begin newStackPage */
	lruOrFree = ((mostRecentlyUsedPage())->nextPage);
	if (isFree(lruOrFree)) {
		page = lruOrFree;
		goto l1;
	}
	divorceFramesIn(lruOrFree);
	page = lruOrFree;
l1:	/* end newStackPage */;
	pointer = (page->baseAddress);
	theIP = longAt((aContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2));
	/* begin followNonImmediateField:ofObject: */
	objOop = longAt((aContext + (BaseHeaderSize)) + (MethodIndex << 2));
	assert(isNonImmediate(objOop));
	if (((longAt(objOop)) & 0x3FFFFF) == 8) {
		objOop = fixFollowedFieldofObjectwithInitialValue(MethodIndex, aContext, objOop);
	}
	theMethod = objOop;
	followNecessaryForwardingInMethod(theMethod);
	if (!((theIP & 1))) {
		error("context is not resumable");
	}
	theIP = (theIP >> 1);
	/* begin followField:ofObject: */
	objOop1 = longAt((aContext + (BaseHeaderSize)) + (ReceiverIndex << 2));
	if (((objOop1 & 3) == 0)
	 && (((longAt(objOop1)) & 0x3FFFFF) == 8)) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, aContext, objOop1);
	}
	rcvr = objOop1;
	/* begin followField:ofObject: */
	objOop2 = longAt((aContext + (BaseHeaderSize)) + (ClosureIndex << 2));
	if (((objOop2 & 3) == 0)
	 && (((longAt(objOop2)) & 0x3FFFFF) == 8)) {
		objOop2 = fixFollowedFieldofObjectwithInitialValue(ClosureIndex, aContext, objOop2);
	}
	maybeClosure = objOop2;
	if (maybeClosure != GIV(nilObj)) {
		/* begin quickFetchInteger:ofObject: */
		oop = longAt((maybeClosure + (BaseHeaderSize)) + (ClosureNumArgsIndex << 2));
		assert((oop & 1));
		numArgs = (oop >> 1);
		longAtput(pointer, maybeClosure);
	}
	else {
		header = longAt((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2));
		numArgs = (((usqInt) header) >> 25) & 15;
		
#    if MULTIPLEBYTECODESETS

		/* If this is a synthetic context its IP could be pointing at the CallPrimitive opcode.  If so, skip it. */

		if (((((sqInt) theIP)) > 0)
		 && ((((((sqInt) header)) < 0
		? header & (65536 << SmallIntegerShift)
		: (header & 536871934) != 0))
		 && (theIP == (1 + (lastPointerOf(theMethod)))))) {
			theIP += ((((sqInt) header)) < 0
								? 3
								: 0);
		}

#    endif /* MULTIPLEBYTECODESETS */

		longAtput(pointer, rcvr);
	}
	for (i = 1; i <= numArgs; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + (BaseHeaderSize)) + ((ReceiverIndex + i) << 2)));
	}
	longAtput((pointer -= BytesPerWord), longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2)));
	longAtput((pointer -= BytesPerWord), 0);
	(page->baseFP = pointer);
	(page->headFP = pointer);
	longAtput((pointer -= BytesPerWord), theMethod);
	longAtput((pointer -= BytesPerWord), ((1 + (numArgs << 8)) + (1 << 16)) + ((maybeClosure != GIV(nilObj)
	? 1 << 24
	: 0)));
	assert(frameHasContext((page->baseFP)));
	assert((frameNumArgs((page->baseFP))) == numArgs);
	longAtput((pointer -= BytesPerWord), aContext);
	longAtput((pointer -= BytesPerWord), rcvr);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aContext + (BaseHeaderSize)) + (StackPointerIndex << 2));
	assert((oop1 & 1));
	stackPtrIndex = (oop1 >> 1);
	assert((ReceiverIndex + stackPtrIndex) < (lengthOf(aContext)));
	for (i = (numArgs + 1); i <= stackPtrIndex; i += 1) {
		longAtput((pointer -= BytesPerWord), longAt((aContext + (BaseHeaderSize)) + ((ReceiverIndex + i) << 2)));
	}
	/* begin iframeInstructionPointerForIndex:method: */
	assert(((theIP >= (((LiteralStart + (literalCountOf(theMethod))) * BytesPerOop) + 1)) && (theIP <= (lengthOf(theMethod)))));
	theIP = ((theMethod + theIP) + (BaseHeaderSize)) - 2;
	longAtput((pointer -= BytesPerWord), theIP);
	(page->headSP = pointer);
	assert(contexthasValidInversePCMappingOfin(aContext, theIP, (page->baseFP)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	/* begin withSmallIntegerTags: */
	value = (page->baseFP);
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer = (oopForPointer(value)) + 1;
	assert(!(isForwarded(aContext)));
	longAtput((aContext + (BaseHeaderSize)) + (SenderIndex << 2), valuePointer);
	/* begin storePointerUnchecked:ofObject:withValue: */
	/* begin withSmallIntegerTags: */
	assert(((oopForPointer(0)) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer(0)) + 1;
	assert(!(isForwarded(aContext)));
	longAtput((aContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2), valuePointer1);
	assert(((fetchPointerofObject(SenderIndex, aContext)) & 1));
	assert((frameOfMarriedContext(aContext)) == ((page->baseFP)));
	assert(validStackPageBaseFrame(page));
	return page;
}


/*	make a Point xValue@yValue.
	We know both will be integers so no value nor root checking is needed */

sqInt
makePointwithxValueyValue(sqInt xValue, sqInt yValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt err;
    sqInt newHash;
    sqInt pointResult;

	/* begin eeInstantiateSmallClass:numSlots: */
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
	if (((newHash = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
		if (((err = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
			classIndex = -err;
			goto l1;
		}
		/* begin rawHashBitsOf: */
		flag("endianness");
		newHash = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
		assert((classAtIndex(newHash)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
	}
	classIndex = newHash;
l1:	/* end ensureBehaviorHash: */;
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert(((YIndex + 1) >= 0)
	 && (classIndex != 0));
	assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex))));
	pointResult = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + (BaseHeaderSize)) + (XIndex << 2), ((xValue << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + (BaseHeaderSize)) + (YIndex << 2), ((yValue << 1) | 1));
	return pointResult;
}


/*	Map all oops in the interpreter's state to their new values 
	during garbage collection or a become: operation. */
/*	Assume: All traced variables contain valid oops. */

static void
mapInterpreterOops(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt oop;

	mapStackPages();
	/* begin mapMachineCode */
	/* begin mapTraceLogs */
	/* begin mapVMRegisters */
	if ((((longAt(GIV(method))) & 0x3FFFFF) == 8)
	 || (isYoungObject(GIV(method)))) {

		/* *rel to method */

		GIV(instructionPointer) -= GIV(method);
		GIV(method) = remapObj(GIV(method));
		GIV(instructionPointer) += GIV(method);
	}
	if (((GIV(newMethod) & 3) == 0)
	 && ((((longAt(GIV(newMethod))) & 0x3FFFFF) == 8)
	 || (isYoungObject(GIV(newMethod))))) {

		/* maybe oop due to object-as-method */

		GIV(newMethod) = remapObj(GIV(newMethod));
	}
	/* begin mapProfileState */
	if ((((longAt(GIV(profileProcess))) & 0x3FFFFF) == 8)
	 || (isYoungObject(GIV(profileProcess)))) {
		GIV(profileProcess) = remapObj(GIV(profileProcess));
	}
	if ((((longAt(GIV(profileMethod))) & 0x3FFFFF) == 8)
	 || (isYoungObject(GIV(profileMethod)))) {
		GIV(profileMethod) = remapObj(GIV(profileProcess));
	}
	if ((((longAt(GIV(profileSemaphore))) & 0x3FFFFF) == 8)
	 || (isYoungObject(GIV(profileSemaphore)))) {
		GIV(profileSemaphore) = remapObj(GIV(profileSemaphore));
	}
	sqLowLevelMFence();
	if (!(GIV(longRunningPrimitiveCheckMethod) == null)) {
		if (GIV(longRunningPrimitiveCheckSequenceNumber) == GIV(statCheckForEvents)) {
			GIV(longRunningPrimitiveCheckMethod) = GIV(newMethod);
		}
		else {
			if ((((longAt(GIV(longRunningPrimitiveCheckMethod))) & 0x3FFFFF) == 8)
			 || (isYoungObject(GIV(longRunningPrimitiveCheckMethod)))) {
				GIV(longRunningPrimitiveCheckMethod) = remapObj(GIV(longRunningPrimitiveCheckMethod));
			}
		}
		sqLowLevelMFence();
	}
	if (!(GIV(longRunningPrimitiveCheckSemaphore) == null)) {
		if ((((longAt(GIV(longRunningPrimitiveCheckSemaphore))) & 0x3FFFFF) == 8)
		 || (isYoungObject(GIV(longRunningPrimitiveCheckSemaphore)))) {
			GIV(longRunningPrimitiveCheckSemaphore) = remapObj(GIV(longRunningPrimitiveCheckSemaphore));
		}
	}
	/* begin remapCallbackState */
	for (i = 1; i <= GIV(jmpDepth); i += 1) {
		oop = GIV(suspendedCallbacks)[i];
		if (((oop & 3) == 0)
		 && ((((longAt(oop)) & 0x3FFFFF) == 8)
		 || (isYoungObject(oop)))) {
			GIV(suspendedCallbacks)[i] = (remapObj(oop));
		}
		oop = GIV(suspendedMethods)[i];
		if ((((longAt(oop)) & 0x3FFFFF) == 8)
		 || (isYoungObject(oop))) {
			GIV(suspendedMethods)[i] = (remapObj(oop));
		}
	}
	if ((GIV(tempOop) != 0)
	 && (((GIV(tempOop) & 3) == 0)
	 && ((((longAt(GIV(tempOop))) & 0x3FFFFF) == 8)
	 || (isYoungObject(GIV(tempOop)))))) {
		GIV(tempOop) = remapObj(GIV(tempOop));
	}
}

static void
mapStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt i;
    sqInt oop;
    char *theFP;
    sqInt theIP;
    char *theIPPtr;
    StackPage *thePage;
    char *theSP;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i, GIV(pages));
		if (!(((thePage->baseFP)) == 0)) {
			theSP = (thePage->headSP);

			/* Skip the instruction pointer on top of stack of inactive pages. */

			theFP = (thePage->headFP);
			if (thePage == GIV(stackPage)) {
				theIPPtr = 0;
			}
			else {
				theIPPtr = theSP;
				theSP += BytesPerWord;
			}
			while (1) {
				assert(addressIsInPage(thePage, theFP));
				assert(addressIsInPage(thePage, theSP));
				assert((theIPPtr == 0)
				 || (addressIsInPage(thePage, theIPPtr)));
				while (theSP <= (theFP + FoxReceiver)) {
					oop = longAt(theSP);
					if (((oop & 3) == 0)
					 && ((((longAt(oop)) & 0x3FFFFF) == 8)
					 || (isYoungObject(oop)))) {
						longAtput(theSP, remapObj(oop));
					}
					theSP += BytesPerWord;
				}
				if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
					if ((((longAt(longAt(theFP + FoxThisContext))) & 0x3FFFFF) == 8)
					 || (isYoungObject(longAt(theFP + FoxThisContext)))) {
						longAtput(theFP + FoxThisContext, remapObj(longAt(theFP + FoxThisContext)));
					}
					assert((isMarriedOrWidowedContext(frameContext(theFP)))
					 && ((frameOfMarriedContext(frameContext(theFP))) == theFP));
				}
				if ((((longAt(longAt(theFP + FoxMethod))) & 0x3FFFFF) == 8)
				 || (isYoungObject(longAt(theFP + FoxMethod)))) {
					if (theIPPtr != 0) {
						assert((longAt(theIPPtr)) > (frameMethod(theFP)));
						theIP = (longAt(theIPPtr)) - (longAt(theFP + FoxMethod));
					}
					longAtput(theFP + FoxMethod, remapObj(longAt(theFP + FoxMethod)));
					if (theIPPtr != 0) {
						longAtput(theIPPtr, theIP + (longAt(theFP + FoxMethod)));
					}
				}
				if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
				theSP = ((theIPPtr = theFP + FoxCallerSavedIP)) + BytesPerWord;
				theFP = callerFP;
			}

			/* a.k.a. FoxCallerSavedIP */

			theSP = theFP + FoxCallerContext;
			while (theSP <= ((thePage->baseAddress))) {
				oop = longAt(theSP);
				if (((oop & 3) == 0)
				 && ((((longAt(oop)) & 0x3FFFFF) == 8)
				 || (isYoungObject(oop)))) {
					longAtput(theSP, remapObj(oop));
				}
				theSP += BytesPerWord;
			}
		}
	}
}


/*	Mark the argument, and answer if its fields should be scanned now.
	Immediate objects don't need to be marked.
	Already marked objects have already been processed.
	Pure bits objects don't need scanning, although their class does.
	Weak objects should be pushed on the weakling stack.
	Anything else need scanning. */

static sqInt
markAndShouldScan(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt format;

	if ((objOop & 3) != 0) {
		return 0;
	}
	assert(!(isForwarded(objOop)));
	if (isMarked(objOop)) {
		return 0;
	}
	setIsMarkedOfto(objOop, 1);
	format = (((usqInt) (longAt(objOop))) >> 24) & 0x1F;
	if ((format >= 9)
	 && (format < 24)) {

		/* avoid pushing non-pointer objects on the markStack */

		markAndTraceClassOf(objOop);
		return 0;
	}
	if (format == 4) {

		/* push weaklings on the weakling stack to scan later */

		pushonObjStack(objOop, GIV(weaklingStack));
		return 0;
	}
	return 1;
}


/*	Ensure the class of the argument is marked, pushing it on the markStack if
	not already marked.
	Also set the relevant bit in the classTableBitmap so that duplicate
	entries can be eliminated.
	Note that this is recursive, but the metaclass chain should terminate
	quickly. 
 */

static void
markAndTraceClassOf(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bit;
    sqInt classIndex;
    sqInt classObj;
    sqInt classTablePage;
    sqInt majorIndex;

	classIndex = (longAt(objOop)) & 0x3FFFFF;
	/* begin inClassTableBitmapSet: */
	assert((classIndex >= 0)
	 && (classIndex <= (classIndexMask())));
	majorIndex = ((sqInt) classIndex >> 3);
	bit = 1 << (classIndex & (BitsPerByte - 1));
	GIV(classTableBitmap)[majorIndex] = ((GIV(classTableBitmap)[majorIndex]) | bit);
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		classObj = null;
		goto l1;
	}
	classObj = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l1:	/* end classAtIndex: */;
	if (!(isMarked(classObj))) {
		setIsMarkedOfto(classObj, 1);
		markAndTraceClassOf(classObj);
		pushonObjStack(classObj, GIV(markStack));
	}
}


/*	An obj stack is a stack of objects stored in a hidden root slot, such
	as the markStack or the ephemeronQueue. It is a linked list of
	segments, with the hot end at the head of the list. It is a word object.
	The stack pointer is in ObjStackTopx and 0 means empty. */

static void
markAndTraceObjStackandContents(sqInt stackOrNil, sqInt markAndTraceContents)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt index;

	if (stackOrNil == GIV(nilObj)) {
		return;
	}
	setIsMarkedOfto(stackOrNil, 1);
	assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
	field = longAt((stackOrNil + (BaseHeaderSize)) + (ObjStackNextx << 2));
	if (field != 0) {
		markAndTraceObjStackandContents(field, markAndTraceContents);
	}
	field = stackOrNil;
	while (1) {
		field = longAt((field + (BaseHeaderSize)) + (ObjStackFreex << 2));
		if (!(field != 0)) break;
		setIsMarkedOfto(field, 1);
	}
	if (!markAndTraceContents) {
		return;
	}
	index = (longAt((stackOrNil + (BaseHeaderSize)) + (ObjStackTopx << 2))) + ObjStackNextx;
	while (index >= ObjStackFixedSlots) {
		field = longAt((stackOrNil + (BaseHeaderSize)) + (index << 2));
		if (!((field & 3) != 0)) {
			markAndTrace(field);
		}
		index -= 1;
	}
}


/*	GC of pages. Throwing away all stack pages on full GC is simple but
	dangerous because it causes us to allocate lots of contexts immediately
	before a GC.
	Reclaiming pages whose top context is not referenced is poor because it
	would take N incrementalGCs to reclaim N unused pages. Only the page whose
	top context is not referred to by the bottom context of any other page
	would be
	reclaimed. Not until the next GC would the page whose top contect is the
	previously reclaimed page's base frame's bottom context be reclaimed.
	
	Better is to not mark stack pages until their contexts are encountered. We
	can eagerly trace the active page and the page reachable from its bottom
	context if any, and so on. Other pages can be marked when we encounter a
	married context. */

static sqInt
markAndTraceStackPages(sqInt fullGCFlag)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt i;
    sqInt i1;
    sqInt index;
    void *pointer;
    char *theFP;
    StackPage *thePage;
    StackPage *thePage1;
    sqInt value;

	
	if (!fullGCFlag) {
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if (!(isFree(thePage))) {
				markAndTraceStackPage(thePage);
			}
		}
		return null;
	}
	if (GIV(stackPage) == 0) {
		return null;
	}
	thePage = GIV(stackPage);
	do {
		markAndTraceStackPage(thePage);
		/* begin frameCallerContext: */
		theFP = (thePage->baseFP);
		context = longAt(theFP + FoxCallerContext);
		if ((((context & 3) == 0)
 && (((longAt(context)) & 0x3FFFFF) == ClassMethodContextCompactIndex))
		 && ((((longAt((context + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && ((((longAt((context + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(context)))))) {
			/* begin stackPageFor: */
			/* begin frameOfMarriedContext: */
			value = longAt((context + (BaseHeaderSize)) + (SenderIndex << 2));
			/* begin withoutSmallIntegerTags: */
			assert((value & 1));
			pointer = ((char *) (pointerForOop(value - 1)));
			/* begin stackPageAt: */
			index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
			thePage = stackPageAtpages(index, GIV(pages));
			assert(!(isFree(thePage)));
		}
	} while(((thePage->trace)) < StackPageTraced);
}

static void
markAndTraceStackPage(StackPage *thePage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *frameRcvrOffset;
    sqInt oop;
    char *theFP;
    char *theSP;

	assert(!(isFree(thePage)));
	assert(((thePage->trace)) != StackPageTraced);
	(thePage->trace = StackPageTraced);
	theSP = (thePage->headSP);

	/* Skip the instruction pointer on top of stack of inactive pages. */

	theFP = (thePage->headFP);
	if (!(thePage == GIV(stackPage))) {
		theSP += BytesPerWord;
	}
	while (1) {
		/* begin frameReceiverOffset: */
		frameRcvrOffset = theFP + FoxReceiver;
		while (theSP <= frameRcvrOffset) {
			oop = longAt(theSP);
			if (!((oop & 3) != 0)) {
				markAndTrace(oop);
			}
			theSP += BytesPerWord;
		}
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			markAndTrace(longAt(theFP + FoxThisContext));
		}
		markAndTrace(longAt(theFP + FoxMethod));
		if (!(((callerFP = frameCallerFP(theFP))) != 0)) break;
		theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
		theFP = callerFP;
	}

	/* caller ip is frameCallerContext in a base frame */

	theSP = theFP + FoxCallerSavedIP;
	while (theSP <= ((thePage->baseAddress))) {
		oop = longAt(theSP);
		if (!((oop & 3) != 0)) {
			markAndTrace(oop);
		}
		theSP += BytesPerWord;
	}
}


/*	Trace any untraced pages */

static void
markAndTraceUntracedReachableStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt foundToBeTracedPage;
    sqInt i;
    StackPage *thePage;

	do {
		foundToBeTracedPage = 0;
		for (i = 0; i < GIV(numStackPages); i += 1) {
			/* begin stackPageAt: */
			thePage = stackPageAtpages(i, GIV(pages));
			if ((!(isFree(thePage)))
			 && (((thePage->trace)) == StackPageReachedButUntraced)) {
				foundToBeTracedPage = 1;
				markAndTraceStackPage(thePage);
			}
		}
	} while(foundToBeTracedPage);
}


/*	Mark the argument, and all objects reachable from it, and any remaining
	objects on the mark stack. Follow forwarding pointers in the scan. */

void
markAndTrace(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt contextSize;
    sqInt field;
    sqInt fmt;
    sqInt index;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt numStrongSlots;
    sqInt objOop1;
    sqInt objToScan;
    sqInt referent;
    sqInt referent1;
    sqInt sp;

	if (!(markAndShouldScan(objOop))) {
		return;
	}
	assert(!(isForwarded(objOop)));

	/* To avoid overflowing the mark stack when we encounter large objects, we
	   push the obj, then its numStrongSlots, and then index the object from the stack. */

	objToScan = objOop;
	do {
		if (((objToScan & 3) != 0)
		 || (((numStrongSlots = numStrongSlotsOfephemeronInactiveIf(objToScan, inactiveOrFailedToDeferScan)),
		numStrongSlots > 16))) {

			/* scanning a large object. scan until hitting an unmarked object, then switch to it, if any. */

			if ((objToScan & 3) != 0) {
				index = (objToScan >> 1);
				objToScan = topOfObjStack(GIV(markStack));
			}
			else {
				index = numStrongSlots;
				markAndTraceClassOf(objToScan);
			}
			while (index > 0) {
				index -= 1;
				field = longAt((objToScan + (BaseHeaderSize)) + (index << 2));
				if (((field & 3) == 0)
				 && (((longAt(field)) & 0x3FFFFF) == 8)) {
					/* begin followForwarded: */
					assert(isForwarded(field));
					referent = longAt((field + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					field = referent;
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objToScan)));
					longAtput((objToScan + (BaseHeaderSize)) + (index << 2), field);
				}
				if (markAndShouldScan(field)) {
					if (index > 0) {
						if ((topOfObjStack(GIV(markStack))) != objToScan) {
							pushonObjStack(objToScan, GIV(markStack));
						}
						pushonObjStack(((index << 1) | 1), GIV(markStack));
					}
					objToScan = field;
					index = -1;
				}
			}
			if (index >= 0) {

				/* if loop terminated without finding an unmarked referent, switch to top of stack. */

				objToScan = popObjStack(GIV(markStack));
				if (objToScan == objOop) {
					objToScan = popObjStack(GIV(markStack));
				}
			}
		}
		else {

			/* scanning a small object. scan, marking, pushing unmarked referents, then switch to the top of the stack. */

			index = numStrongSlots;
			markAndTraceClassOf(objToScan);
			while (index > 0) {
				index -= 1;
				field = longAt((objToScan + (BaseHeaderSize)) + (index << 2));
				if (((field & 3) == 0)
				 && (((longAt(field)) & 0x3FFFFF) == 8)) {
					/* begin followForwarded: */
					assert(isForwarded(field));
					referent1 = longAt((field + (BaseHeaderSize)) + (0 << 2));
					while (((referent1 & 3) == 0)
					 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
						referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
					}
					field = referent1;
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objToScan)));
					longAtput((objToScan + (BaseHeaderSize)) + (index << 2), field);
				}
				if (markAndShouldScan(field)) {
					pushonObjStack(field, GIV(markStack));
					/* begin numStrongSlotsOf:ephemeronInactiveIf: */
					fmt = (((usqInt) (longAt(field))) >> 24) & 0x1F;
					if (fmt <= 5) {
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(field)) > (isForwardedObjectClassIndexPun()));
						/* begin rawNumSlotsOf: */
						flag("endianness");
						numSlots1 = ((usqInt) (((usqInt)(longAt(field + 4))))) >> 24;
						numSlots = (numSlots1 == 0xFF
							? (/* begin rawOverflowSlotsOf: */
								flag("endianness"),
								longAt(field - (BaseHeaderSize)))
							: numSlots1);
						if (fmt <= 2) {
							numStrongSlots = numSlots;
							goto l3;
						}
						if (fmt == 3) {
							if (((longAt(field)) & 0x3FFFFF) == ClassMethodContextCompactIndex) {
								setTraceFlagOnContextsFramesPageIfNeeded(field);
								/* begin fetchStackPointerOf: */
								sp = longAt((field + (BaseHeaderSize)) + (StackPointerIndex << 2));
								if (!((sp & 1))) {
									contextSize = 0;
									goto l1;
								}
								assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(field)));
								contextSize = (sp >> 1);
							l1:	/* end fetchStackPointerOf: */;
								numStrongSlots = CtxtTempFrameStart + contextSize;
								goto l3;
							}
							numStrongSlots = numSlots;
							goto l3;
						}
						if (fmt == 4) {
							/* begin fixedFieldsOfClass: */
							/* begin fetchClassOfNonImm: */
							classIndex = (longAt(field)) & 0x3FFFFF;
							if (classIndex == 0x1F) {
								objOop1 = field;
								goto l2;
							}
							assert(classIndex >= (arrayClassIndexPun()));
							/* begin classAtIndex: */
							assert((classIndex <= (tagMask()))
							 || (classIndex >= (arrayClassIndexPun())));
							classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
							if (classTablePage == GIV(nilObj)) {
								objOop1 = null;
								goto l2;
							}
							objOop1 = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
						l2:	/* end fetchClassOfNonImm: */;
							numStrongSlots = (((longAt((objOop1 + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
							goto l3;
						}
						assert(fmt == (ephemeronFormat()));
						numStrongSlots = ((inactiveOrFailedToDeferScan == null)
						 || (inactiveOrFailedToDeferScan((keyOfEphemeron(field))))
							? numSlots
							: 0);
						goto l3;
					}
					if (fmt == 7) {
						numStrongSlots = 1;
						goto l3;
					}
					if (fmt < 24) {
						numStrongSlots = 0;
						goto l3;
					}
					numLiterals = 
#          if MULTIPLEBYTECODESETS
						((((sqInt) (longAt((field + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
												? (((usqInt) (longAt((field + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
												: (((usqInt) (longAt((field + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#          else /* MULTIPLEBYTECODESETS */
						(((usqInt) (longAt((field + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#          endif /* MULTIPLEBYTECODESETS */
						;
					numStrongSlots = numLiterals + LiteralStart;
				l3:	/* end numStrongSlotsOf:ephemeronInactiveIf: */;
					if (numStrongSlots > 16) {
						pushonObjStack(((numStrongSlots << 1) | 1), GIV(markStack));
					}
				}
			}
			objToScan = popObjStack(GIV(markStack));
		}
	} while(objToScan != null);
}


/*	Go through the unscanned ephemerons, marking the inactive ones, and
	removing them from the unscanned ephemerons. Answer if any inactive
	ones were found. We cannot fire the ephemerons until all are found to
	be active since scan-marking an inactive ephemeron later in the set may
	render a previously-observed active ephemeron as inactive. */

static sqInt
markInactiveEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeron;
    sqInt foundInactive;
    sqInt key;
    sqInt objOop;
    usqInt ptr;

	foundInactive = 0;
	ptr = (GIV(unscannedEphemerons).start);
	while (ptr < ((GIV(unscannedEphemerons).top))) {
		/* begin keyOfEphemeron: */
		objOop = (ephemeron = longAt(ptr));
		assert((isNonImmediate(objOop))
		 && (isEphemeron(objOop)));
		key = longAt((objOop + (BaseHeaderSize)) + (0 << 2));
		if (((key & 3) != 0)
		 || (isMarked(key))) {

			/* Now remove the inactive ephemeron from the set, and scan-mark it.
			   Scan-marking it may add more ephemerons to the set. */

			foundInactive = 1;
			(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) - (wordSize()));
			if (((GIV(unscannedEphemerons).top)) > ptr) {
				longAtput(ptr, longAt((GIV(unscannedEphemerons).top)));
			}
			markAndTrace(ephemeron);
		}
		else {
			ptr += wordSize();
		}
	}
	return foundInactive;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static sqInt
markStackPageMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return null;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed());
		return null;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static sqInt
markStackPageNextMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return null;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->prevPage))->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed());
}


/*	After the initial scan-mark is complete ephemerons can be processed.
	Weaklings have accumulated on the weaklingStack, but more may be
	uncovered during ephemeron processing. So trace the strong slots
	of the weaklings, and as ephemerons are processed ensure any newly
	reached weaklings are also traced. */

static void
markWeaklingsAndMarkAndFireEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeron;
    sqInt field;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt key;
    sqInt numOnThisPage;
    sqInt numToEnumerate;
    sqInt numToEnumerateOnThisPage;
    sqInt numTracedWeaklings;
    sqInt objOop;
    sqInt objStackPage;
    sqInt p;
    sqInt pLimiT;
    sqInt ptr;
    sqInt size;
    sqInt topIndex;
    sqInt weakling;

	numTracedWeaklings = 0;
	while(1) {
		markAndTraceUntracedReachableStackPages();
		/* begin objStack:from:do: */
		size = longAt((GIV(weaklingStack) + (BaseHeaderSize)) + (ObjStackTopx << 2));
		objStackPage = longAt((GIV(weaklingStack) + (BaseHeaderSize)) + (ObjStackNextx << 2));
		while (objStackPage != 0) {
			size += ObjStackLimit;
			assert((fetchPointerofObject(ObjStackTopx, objStackPage)) == ObjStackLimit);
			objStackPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackNextx << 2));
		}
		numToEnumerate = size - numTracedWeaklings;
		objStackPage = GIV(weaklingStack);
		while (numToEnumerate > 0) {
			numOnThisPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackTopx << 2));
			numToEnumerateOnThisPage = ((numToEnumerate < numOnThisPage) ? numToEnumerate : numOnThisPage);
			topIndex = (numOnThisPage + ObjStackFixedSlots) - 1;
			for (i1 = topIndex; i1 >= ((topIndex - numToEnumerateOnThisPage) + 1); i1 += -1) {
				markAndTraceClassOf(longAt((objStackPage + (BaseHeaderSize)) + (i1 << 2)));
				for (i = 0, iLimiT = ((numStrongSlotsOfephemeronInactiveIf(longAt((objStackPage + (BaseHeaderSize)) + (i1 << 2)), null)) - 1); i <= iLimiT; i += 1) {
					field = longAt(((longAt((objStackPage + (BaseHeaderSize)) + (i1 << 2))) + (BaseHeaderSize)) + (i << 2));
					if (!(((field & 3) != 0)
						 || (isMarked(field)))) {
						markAndTrace(field);
					}
				}

			}
			numToEnumerate -= numToEnumerateOnThisPage;
			objStackPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackNextx << 2));
		}
		numTracedWeaklings = size;
		if (((GIV(unscannedEphemerons).top)) == ((GIV(unscannedEphemerons).start))) {
			markAndTraceUntracedReachableStackPages();
			freeUntracedStackPages();
			return;
		}
		if (!(markInactiveEphemerons())) {
			/* begin fireAllUnscannedEphemerons */
			assert(!(noUnscannedEphemerons()));
			assert(allUnscannedEphemeronsAreActive());
			for (p = ((GIV(unscannedEphemerons).start)), pLimiT = (((GIV(unscannedEphemerons).top)) - (wordSize())); p <= pLimiT; p += 1) {
				/* begin queueEphemeron: */
				assert((isNonImmediate(longAt(p)))
				 && ((formatOf(longAt(p))) == (ephemeronFormat())));
				pushonObjStack(longAt(p), GIV(ephemeronQueue));
			}
			forceInterruptCheck();
		}
		/* begin markAllUnscannedEphemerons */
		assert(!(noUnscannedEphemerons()));
		assert(allUnscannedEphemeronsAreActive());
		ptr = ((GIV(unscannedEphemerons).top)) - (wordSize());
		while (ptr >= ((GIV(unscannedEphemerons).start))) {
			/* begin keyOfEphemeron: */
			objOop = (ephemeron = longAt(ptr));
			assert((isNonImmediate(objOop))
			 && (isEphemeron(objOop)));
			key = longAt((objOop + (BaseHeaderSize)) + (0 << 2));
			markAndTrace(key);
			markAndTrace(ephemeron);
			(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) - (wordSize()));
			if (ptr < ((GIV(unscannedEphemerons).top))) {

				/* not the last entry; remove it by overwriting it with the last
				   ephemeron (which must have been newly added by markAndTrace:). */

				longAtput(ptr, longAt((GIV(unscannedEphemerons).top)));
			}
			ptr -= wordSize();
		}
	}
}


/*	This is a helper for primitiveObjectPointsTo so it *does not* check the
	frameContext field because that is an implicit self-reference not present
	in the state .
 */

static sqInt
marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    char *rcvrOffset;
    char *theFP;
    StackPage *thePage;
    char *theSP;
    sqInt value;

	/* begin frameOfMarriedContext: */
	value = longAt((spouseContext + (BaseHeaderSize)) + (SenderIndex << 2));
	/* begin withoutSmallIntegerTags: */
	assert((value & 1));
	theFP = pointerForOop(value - 1);
	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer) + (stackDeltaForCurrentFrame * BytesPerWord);
	}
	else {
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		theSP = findSPOfon(theFP, thePage);
	}
	if ((anOop & 1)) {

		/* Check stack and instruction pointer fields. */

		if ((anOop == (((((((usqInt) ((theFP + FoxReceiver) - theSP)) >> ShiftForWord) + (byteAt((theFP + FoxFrameFlags) + 1))) << 1) | 1)))
		 || (anOop == (externalInstVarofContext(InstructionPointerIndex, spouseContext)))) {
			return 1;
		}
	}
	else {

		/* Check method and sender fields, avoiding unnecessarily reifying sender context. */

		if (anOop == (longAt(theFP + FoxMethod))) {
			return 1;
		}
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			if (anOop == (longAt(theFP + FoxCallerContext))) {
				return 1;
			}
		}
		else {
			if ((frameHasContext(frameCallerFP(theFP)))
			 && (anOop == (frameContext(frameCallerFP(theFP))))) {
				return 1;
			}
		}
	}
	/* begin frameReceiverOffset: */
	rcvrOffset = theFP + FoxReceiver;
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	theSP = (theFP + FoxCallerSavedIP) + BytesPerWord;
	rcvrOffset = theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord));
	while (theSP <= rcvrOffset) {
		if (anOop == (longAt(theSP))) {
			return 1;
		}
		theSP += BytesPerWord;
	}
	return 0;
}


/*	Establish aContext at the base of a new stackPage, make the stackPage the
	active one and set-up the interreter registers. This is used to boot the
	system and bring it back after a snapshot. */

static void
marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aMethodObj;
    StackPage *newPage;
    char *theFP;
    sqInt top;

	assert(GIV(stackPage) == 0);
	newPage = makeBaseFrameFor(aContext);
	/* begin setStackPageAndLimit: */
	assert(newPage != 0);
	GIV(stackPage) = newPage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(newPage);
	GIV(framePointer) = (GIV(stackPage)->headFP);
	GIV(stackPointer) = (GIV(stackPage)->headSP);
	/* begin setMethod: */
	/* begin iframeMethod: */
	theFP = (GIV(stackPage)->headFP);
	aMethodObj = ((usqInt) (longAt(theFP + FoxMethod)));
	GIV(method) = aMethodObj;
	assert(isOopCompiledMethod(GIV(method)));
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) (longAt((GIV(method) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
}


/*	Marry an unmarried frame. This means creating a spouse context
	initialized with a subset of the frame's state (state through the last
	argument) that references the frame. */

static sqInt
marryFrameSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt closureOrNil;
    sqInt frameNumArgs;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numSlots;
    sqInt numStack;
    sqInt numTemps;
    sqInt theContext;
    char *value;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer2;

	/* begin marryFrame:SP:copyTemps: */
	assert(!(frameHasContext(theFP)));
	assert(addressCouldBeOop(longAt(theSP)));

	/* Decide how much of the stack to preserve in widowed contexts.  Preserving too much
	   state will potentially hold onto garbage.  Holding onto too little may mean that a dead
	   context isn't informative enough in a debugging situation.  If copyTemps is false (as it
	   is in the default closure implementation) compromise, retaining only the arguments with
	   no temporaries.  Note that we still set the stack pointer to its current value, but stack
	   contents other than the arguments are nil. */

	methodHeader = longAt(((longAt(theFP + FoxMethod)) + (BaseHeaderSize)) + (HeaderIndex << 2));
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	numStack = (((usqInt) ((theFP + FoxReceiver) - theSP)) >> ShiftForWord) + (byteAt((theFP + FoxFrameFlags) + 1));
	closureOrNil = ((byteAt((theFP + FoxFrameFlags) + 3)) != 0
		? longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord)))
		: GIV(nilObj));
	numSlots = ((methodHeader & LargeContextBit) != 0
		? LargeContextSlots
		: SmallContextSlots);
	theContext = allocateNewSpaceSlotsformatclassIndex(numSlots, 3, ClassMethodContextCompactIndex);
	assert((numStack + ReceiverIndex) <= numSlots);
	/* begin storePointerUnchecked:ofObject:withValue: */
	/* begin withSmallIntegerTags: */
	assert(((oopForPointer(theFP)) & (BytesPerWord - 1)) == 0);
	valuePointer1 = (oopForPointer(theFP)) + 1;
	assert(!(isForwarded(theContext)));
	longAtput((theContext + (BaseHeaderSize)) + (SenderIndex << 2), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	/* begin withSmallIntegerTags: */
	/* begin frameCallerFP: */
	value = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	valuePointer2 = (oopForPointer(value)) + 1;
	assert(!(isForwarded(theContext)));
	longAtput((theContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2), valuePointer2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + (BaseHeaderSize)) + (StackPointerIndex << 2), ((numStack << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + (BaseHeaderSize)) + (MethodIndex << 2), longAt(theFP + FoxMethod));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + (BaseHeaderSize)) + (ClosureIndex << 2), closureOrNil);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + (BaseHeaderSize)) + (ReceiverIndex << 2), longAt(theFP + FoxReceiver));
	for (i = 1; i <= numArgs; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		longAtput((theContext + (BaseHeaderSize)) + ((ReceiverIndex + i) << 2), longAt((theFP + FoxCallerSavedIP) + (((numArgs - i) + 1) * BytesPerWord)));
	}
	
	for (i = (numArgs + 1); i <= numStack; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		longAtput((theContext + (BaseHeaderSize)) + ((ReceiverIndex + i) << 2), GIV(nilObj));
	}
	/* begin setFrameContext:to: */
	longAtput(theFP + FoxThisContext, theContext);
	/* begin setFrameHasContext: */
	byteAtput((theFP + FoxFrameFlags) + 2, 1);
	assert(frameHasContext(theFP));
	assert((frameOfMarriedContext(theContext)) == theFP);
	assert((numStack + ReceiverIndex) < (lengthOf(theContext)));
	return theContext;
}


/*	Answer one of the objects in the SpecialObjectsArray, if in range,
	otherwise answer nil.
 */

sqInt
maybeSplObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (index < (numSlotsOf(GIV(specialObjectsOop)))
		? longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (index << 2))
		: 0);
}

sqInt
methodArgumentCount(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(argumentCount);
}


/*	Like #stackValue: but access method arguments left-to-right */

sqInt
methodArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((index > GIV(argumentCount)) + 1) {
		fprintf(stderr,"[VM]: Attempt to access method args beyond range\n");
		printCallStack();
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return longAt(GIV(stackPointer) + ((GIV(argumentCount) - index) * BytesPerWord));
}

sqInt
methodClassAssociationOf(sqInt methodPointer)
{
    sqInt offset;

	/* begin literal:ofMethod: */
	offset = (
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) - 1;
	return longAt((methodPointer + (BaseHeaderSize)) + ((offset + LiteralStart) << 2));
}

static sqInt
methodClassOf(sqInt methodPointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt literal;
    sqInt offset;
    sqInt offset1;

	return 
#  if NewspeakVM
		(/* begin literal:ofMethod: */
			(offset = (
		#if MULTIPLEBYTECODESETS
			((((sqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
				: (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
		#else /* MULTIPLEBYTECODESETS */
			(((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
		#endif /* MULTIPLEBYTECODESETS */
			) - 1),
			(literal = longAt((methodPointer + (BaseHeaderSize)) + ((offset + LiteralStart) << 2))),
			assert(!(isForwarded(literal))),
			(literal == GIV(nilObj)
					? literal
					: longAt((literal + (BaseHeaderSize)) + (ValueIndex << 2))))
#  else /* NewspeakVM */
		(/* begin literal:ofMethod: */
			(offset1 = (
		#if MULTIPLEBYTECODESETS
			((((sqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
				: (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
		#else /* MULTIPLEBYTECODESETS */
			(((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
		#endif /* MULTIPLEBYTECODESETS */
			) - 1),
			(literal = longAt((methodPointer + (BaseHeaderSize)) + ((offset1 + LiteralStart) << 2))),
			assert(!(isForwarded(literal))),
			longAt((literal + (BaseHeaderSize)) + (ValueIndex << 2)))
#  endif /* NewspeakVM */
		;
}

sqInt
methodPrimitiveIndex(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt primBits;

	if (!((addressCouldBeObj(GIV(newMethod)))
		 && (((((usqInt) (longAt(GIV(newMethod)))) >> 24) & 0x1F) >= 24))) {
		return -1;
	}
	return 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? ((longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
						? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + ((((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
							(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
						: 0)
				: ((primBits = ((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
					(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#  else /* MULTIPLEBYTECODESETS */
		((primBits = ((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#  endif /* MULTIPLEBYTECODESETS */
		;
}


/*	Sets the return value for a method. In the CoInterpreter we replace the
	cumbersome primResult machinery. */

sqInt
methodReturnValue(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
	return 0;
}


/*	A negative header selects the alternate bytecode set. */

sqInt
methodUsesAlternateBytecodeSet(sqInt aMethodObj)
{
	return (((sqInt) (longAt((aMethodObj + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0;
}


/*	The module with the given name was just unloaded. 
	Make sure we have no dangling references. */

EXPORT(void)
moduleUnloaded(char *aModuleName)
{
	if ((strcmp(aModuleName, "SurfacePlugin")) == 0) {

		/* Surface plugin went away. Should never happen. But  then, who knows */

		showSurfaceFn = 0;
	}
}


/*	Move frames from the hot end of oldPage through to theFP to newPage.
	This has the effect of making theFP a base frame which can be stored into.
	Answer theFP's new location. */

static char *
moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage)
{
    char *callerFP;
    sqInt callerIP;
    sqInt delta;
    char *fpInNewPage;
    char *newFP;
    char *newSP;
    char *offsetCallerFP;
    char *source;
    sqInt stackedReceiverOffset;
    sqInt theContext;
    char *theFP1;
    sqInt valuePointer;
    sqInt valuePointer1;

	newSP = ((newPage->baseAddress)) + BytesPerWord;

	/* First move the data.  We will fix up frame pointers later. */

	stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord);
	for (source = (theFP + stackedReceiverOffset); source >= ((oldPage->headSP)); source += (-BytesPerWord)) {
		newSP -= BytesPerWord;
		longAtput(newSP, longAt(source));
	}
	delta = newSP - ((oldPage->headSP));
	newFP = ((newPage->baseAddress)) - stackedReceiverOffset;
	/* begin setHeadFP:andSP:inPage: */
	theFP1 = ((oldPage->headFP)) + delta;
	assert(newSP < theFP1);
	assert((newSP < ((newPage->baseAddress)))
	 && (newSP > (((newPage->realStackLimit)) - LargeContextSize)));
	assert((theFP1 < ((newPage->baseAddress)))
	 && (theFP1 > (((newPage->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(newPage->headFP = theFP1);
	(newPage->headSP = newSP);
	(newPage->baseFP = newFP);
	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	assert(!(isBaseFrame(theFP)));
	assert(frameHasContext(callerFP));
	callerIP = oopForPointer(frameCallerSavedIP(theFP));
	longAtput(theFP + stackedReceiverOffset, callerIP);
	assert((callerFP < ((oldPage->baseAddress)))
	 && (callerFP > (((oldPage->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(oldPage->headFP = callerFP);
	(oldPage->headSP = theFP + stackedReceiverOffset);
	longAtput(newFP + FoxCallerContext, longAt(callerFP + FoxThisContext));
	longAtput(newFP + FoxSavedFP, 0);
	fpInNewPage = (newPage->headFP);
	do {
		/* begin frameCallerFP: */
		offsetCallerFP = pointerForOop(longAt(fpInNewPage + FoxSavedFP));
		if (offsetCallerFP != 0) {
			offsetCallerFP += delta;
		}
		longAtput(fpInNewPage + FoxSavedFP, oopForPointer(offsetCallerFP));
		if ((byteAt((fpInNewPage + FoxFrameFlags) + 2)) != 0) {
			theContext = longAt(fpInNewPage + FoxThisContext);
			/* begin storePointerUnchecked:ofObject:withValue: */
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(fpInNewPage)) & (BytesPerWord - 1)) == 0);
			valuePointer = (oopForPointer(fpInNewPage)) + 1;
			assert(!(isForwarded(theContext)));
			longAtput((theContext + (BaseHeaderSize)) + (SenderIndex << 2), valuePointer);
			/* begin storePointerUnchecked:ofObject:withValue: */
			/* begin withSmallIntegerTags: */
			assert(((oopForPointer(offsetCallerFP)) & (BytesPerWord - 1)) == 0);
			valuePointer1 = (oopForPointer(offsetCallerFP)) + 1;
			assert(!(isForwarded(theContext)));
			longAtput((theContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2), valuePointer1);
		}
		fpInNewPage = offsetCallerFP;
	} while(fpInNewPage != 0);
	return newFP;
}


/*	Brain-damaged nameOfClass: for C VM. Does *not* answer Foo class for
	metaclasses. Use e.g. classIsMeta: to avoid being fooled. */

static char *
nameOfClass(sqInt classOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt numSlots1;

	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(classOop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(classOop - (BaseHeaderSize)))
		: numSlots1);
	if (numSlots == GIV(metaclassNumSlots)) {
		return nameOfClass(longAt((classOop + (BaseHeaderSize)) + (GIV(thisClassIndex) << 2)));
	}
	if (numSlots <= GIV(classNameIndex)) {
		return "bad class";
	}
	return firstIndexableField(longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2)));
}


/*	Use simple algorithm by D.H. Lehmer from 1951, for now. */

static sqInt
newObjectHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT

	/* 7 raisedTo: 5 */
	/* (2 raisedTo: 31) - 1 */

	GIV(lastHash) = (GIV(lastHash) * 16807) % 2147483645;
	assert(GIV(lastHash) != 0);
	return GIV(lastHash);
}

static sqInt
newSpaceIsEmpty(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(freeStart) == (((eden()).start)))
	 && (GIV(pastSpaceStart) == (((pastSpace()).start)));
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static StackPage *
newStackPage(void)
{
    StackPage *lruOrFree;

	lruOrFree = ((mostRecentlyUsedPage())->nextPage);
	if (isFree(lruOrFree)) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree);
	return lruOrFree;
}

sqInt
nilObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(nilObj);
}


/*	Nil the unmarked slots in the weaklings on the
	weakling stack, finalizing those that lost references.
	Finally, empty the weaklingStack. */

static void
nilUnmarkedWeaklingSlots(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt nextNextPage;
    sqInt nextPage;
    sqInt numOnThisPage;
    sqInt numToEnumerate;
    sqInt numToEnumerateOnThisPage;
    sqInt objStackPage;
    sqInt size;
    sqInt topIndex;
    sqInt weakling;

	/* begin objStack:from:do: */
	size = longAt((GIV(weaklingStack) + (BaseHeaderSize)) + (ObjStackTopx << 2));
	objStackPage = longAt((GIV(weaklingStack) + (BaseHeaderSize)) + (ObjStackNextx << 2));
	while (objStackPage != 0) {
		size += ObjStackLimit;
		assert((fetchPointerofObject(ObjStackTopx, objStackPage)) == ObjStackLimit);
		objStackPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackNextx << 2));
	}
	numToEnumerate = size - 0;
	objStackPage = GIV(weaklingStack);
	while (numToEnumerate > 0) {
		numOnThisPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackTopx << 2));
		numToEnumerateOnThisPage = ((numToEnumerate < numOnThisPage) ? numToEnumerate : numOnThisPage);
		topIndex = (numOnThisPage + ObjStackFixedSlots) - 1;
		for (i = topIndex; i >= ((topIndex - numToEnumerateOnThisPage) + 1); i += -1) {
			if (nilUnmarkedWeaklingSlotsIn(longAt((objStackPage + (BaseHeaderSize)) + (i << 2)))) {
				/* begin signalFinalization: */
				forceInterruptCheck();
				GIV(pendingFinalizationSignals) += 1;
			}

		}
		numToEnumerate -= numToEnumerateOnThisPage;
		objStackPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackNextx << 2));
	}
	size;
	/* begin emptyObjStack: */
	assert(isValidObjStack(GIV(weaklingStack)));
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(GIV(weaklingStack))));
	if (isOldObject(GIV(weaklingStack))) {

		/* most stores into young objects */

		if (((0 & 3) == 0)
		 && ((((usqInt) 0)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(GIV(weaklingStack)))) >> 29) & 1) != 0)) {
				remember(GIV(weaklingStack));
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(GIV(weaklingStack), (longAt(GIV(weaklingStack))) | (1 << 29));
			}
		}
	}
	longAtput((GIV(weaklingStack) + (BaseHeaderSize)) + (ObjStackTopx << 2), 0);
	nextPage = longAt((GIV(weaklingStack) + (BaseHeaderSize)) + (ObjStackNextx << 2));
	while (nextPage != 0) {
		nextNextPage = longAt((nextPage + (BaseHeaderSize)) + (ObjStackNextx << 2));
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		null;
		longAtput((nextPage + (BaseHeaderSize)) + (ObjStackFreex << 2), longAt((GIV(weaklingStack) + (BaseHeaderSize)) + (ObjStackFreex << 2)));
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		null;
		longAtput((nextPage + (BaseHeaderSize)) + (ObjStackNextx << 2), 0);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(GIV(weaklingStack))) == (wordIndexableFormat()));
		null;
		longAtput((GIV(weaklingStack) + (BaseHeaderSize)) + (ObjStackFreex << 2), nextPage);
		nextPage = nextNextPage;
	}
	/* begin storePointer:ofObjStack:withValue: */
	assert((formatOf(GIV(weaklingStack))) == (wordIndexableFormat()));
	null;
	longAtput((GIV(weaklingStack) + (BaseHeaderSize)) + (ObjStackNextx << 2), 0);
	assert(isValidObjStack(GIV(weaklingStack)));
}


/*	Nil the unmarked slots in aWeakling and
	answer if any unmarked slots were found. */

static sqInt
nilUnmarkedWeaklingSlotsIn(sqInt aWeakling)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt anyUnmarked;
    sqInt i;
    sqInt iLimiT;
    sqInt oop;

	anyUnmarked = 0;
	for (i = (numStrongSlotsOfephemeronInactiveIf(aWeakling, null)), iLimiT = ((numSlotsOf(aWeakling)) - 1); i <= iLimiT; i += 1) {
		oop = longAt((aWeakling + (BaseHeaderSize)) + (i << 2));
		if (!(((oop & 3) != 0)
			 || (isMarked(oop)))) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(aWeakling)));
			longAtput((aWeakling + (BaseHeaderSize)) + (i << 2), GIV(nilObj));
			anyUnmarked = 1;
		}
	}
	return anyUnmarked;
}


/*	Push an element on an objStack. Split from push:onObjStack: for testing. */

static sqInt
noCheckPushonObjStack(sqInt objOop, sqInt objStack)
{
    sqInt topx;

	assert(isValidObjStack(objStack));
	null;
	topx = longAt((objStack + (BaseHeaderSize)) + (ObjStackTopx << 2));
	if (topx >= ObjStackLimit) {
		noCheckPushonObjStack(objOop, ensureRoomOnObjStackAt(longAt((objStack + (BaseHeaderSize)) + (ObjStackMyx << 2))));
	}
	else {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		null;
		longAtput((objStack + (BaseHeaderSize)) + ((ObjStackFixedSlots + topx) << 2), objOop);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		null;
		longAtput((objStack + (BaseHeaderSize)) + (ObjStackTopx << 2), topx + 1);
	}
	return objOop;
}

static sqInt
noInlineTemporaryin(sqInt offset, char *theFP)
{
    sqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord))
		: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord)));
}

static sqInt
noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop)
{
    sqInt frameNumArgs;

	return (offset < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAtput((theFP + FoxCallerSavedIP) + ((frameNumArgs - offset) * BytesPerWord), valueOop)
		: longAtput(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - offset) * BytesPerWord), valueOop));
}


/*	Answer true if there are no marked contexts on thePage. */

static sqInt
noMarkedContextsOnPage(StackPage *thePage)
{
    char *theFP;

	assert(!(isFree(thePage)));
	theFP = (thePage->headFP);
	do {
		if ((byteAt((theFP + FoxFrameFlags) + 2)) != 0) {
			assert(isContext(frameContext(theFP)));
			if (isMarked(longAt(theFP + FoxThisContext))) {
				return 0;
			}
		}
	} while(((theFP = frameCallerFP(theFP))) != 0);
	return 1;
}

sqInt
nonIndexablePointerFormat(void)
{
	return 1;
}


/*	For assert checking only. */

static sqInt
noUnfiredEphemeronsAtEndOfRememberedSet(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt referrer;

	for (i = GIV(numRememberedEphemerons); i < GIV(rememberedSetSize); i += 1) {
		referrer = GIV(rememberedSet)[i];
		if (isEphemeron(referrer)) {
			if (!(isScavengeSurvivor(keyOfEphemeron(referrer)))) {
				return 0;
			}
		}
	}
	return 1;
}

static sqInt
noUnscannedEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(unscannedEphemerons).top)) == ((GIV(unscannedEphemerons).start));
}


/*	Answer the number of free lists. We use freeListsMask, a bitmap, to avoid
	reading empty list heads. This hsould fit in a machine word to end up in a
	register during free chunk allocation. */

static sqInt
numFreeLists(void)
{
	return 32;
}


/*	Answer the number of pointer fields in the given object.
	Works with CompiledMethods, as well as ordinary objects. */

sqInt
numPointerSlotsOf(sqInt objOop)
{
    sqInt contextSize;
    sqInt fmt;
    sqInt numLiterals;
    usqInt numSlots;
    sqInt sp;

	fmt = (((usqInt) (longAt(objOop))) >> 24) & 0x1F;
	if (fmt <= 5) {
		if ((fmt == 3)
		 && (((longAt(objOop)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

			/* contexts end at the stack pointer */

			/* begin fetchStackPointerOf: */
			sp = longAt((objOop + (BaseHeaderSize)) + (StackPointerIndex << 2));
			if (!((sp & 1))) {
				contextSize = 0;
				goto l1;
			}
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop)));
			contextSize = (sp >> 1);
		l1:	/* end fetchStackPointerOf: */;
			return CtxtTempFrameStart + contextSize;
		}
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
		return ((usqInt) ((numSlots == 0xFF
	? (/* begin rawOverflowSlotsOf: */
		flag("endianness"),
		longAt(objOop - (BaseHeaderSize)))
	: numSlots)));
	}
	if (fmt == 7) {
		return 1;
	}
	if (fmt < 24) {
		return 0;
	}
	numLiterals = 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? (((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
				: (((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#  else /* MULTIPLEBYTECODESETS */
		(((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#  endif /* MULTIPLEBYTECODESETS */
		;
	return numLiterals + LiteralStart;
}

sqInt
numSlotsHalfShift(void)
{
	return 24;
}


/*	8-bit slot count
	max 64-bit small obj size 254 * 8 = 2032 bytes
	max 32-bit small obj size 254 * 4 = 1016 bytes */

sqInt
numSlotsMask(void)
{
	return 0xFF;
}


/*	A private internal version of numSlotsOf: that is happy to be applied to
	free or forwarded objects.
 */

static usqInt
numSlotsOfAny(sqInt objOop)
{
    usqInt numSlots;

	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
	return (numSlots == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(objOop - (BaseHeaderSize)))
		: numSlots);
}

usqInt
numSlotsOf(sqInt objOop)
{
    usqInt numSlots;

	flag("endianness");
	assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
	return (numSlots == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(objOop - (BaseHeaderSize)))
		: numSlots);
}


/*	Answer the number of strong pointer fields in the given object.
	Works with CompiledMethods, as well as ordinary objects. */

sqInt
numStrongSlotsOfephemeronInactiveIf(sqInt objOop, int (*criterion)(sqInt key))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt contextSize;
    sqInt fmt;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop1;
    sqInt sp;

	fmt = (((usqInt) (longAt(objOop))) >> 24) & 0x1F;
	if (fmt <= 5) {
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(objOop)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots1 = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
		numSlots = (numSlots1 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(objOop - (BaseHeaderSize)))
			: numSlots1);
		if (fmt <= 2) {
			return numSlots;
		}
		if (fmt == 3) {
			if (((longAt(objOop)) & 0x3FFFFF) == ClassMethodContextCompactIndex) {
				setTraceFlagOnContextsFramesPageIfNeeded(objOop);
				/* begin fetchStackPointerOf: */
				sp = longAt((objOop + (BaseHeaderSize)) + (StackPointerIndex << 2));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l1;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop)));
				contextSize = (sp >> 1);
			l1:	/* end fetchStackPointerOf: */;
				return CtxtTempFrameStart + contextSize;
			}
			return numSlots;
		}
		if (fmt == 4) {
			/* begin fixedFieldsOfClass: */
			/* begin fetchClassOfNonImm: */
			classIndex = (longAt(objOop)) & 0x3FFFFF;
			if (classIndex == 0x1F) {
				objOop1 = objOop;
				goto l2;
			}
			assert(classIndex >= (arrayClassIndexPun()));
			/* begin classAtIndex: */
			assert((classIndex <= (tagMask()))
			 || (classIndex >= (arrayClassIndexPun())));
			classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
			if (classTablePage == GIV(nilObj)) {
				objOop1 = null;
				goto l2;
			}
			objOop1 = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
		l2:	/* end fetchClassOfNonImm: */;
			return (((longAt((objOop1 + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
		}
		assert(fmt == (ephemeronFormat()));
		return ((criterion == null)
		 || (criterion((keyOfEphemeron(objOop))))
			? numSlots
			: 0);
	}
	if (fmt == 7) {
		return 1;
	}
	if (fmt < 24) {
		return 0;
	}
	numLiterals = 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? (((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
				: (((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#  else /* MULTIPLEBYTECODESETS */
		(((usqInt) (longAt((objOop + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#  endif /* MULTIPLEBYTECODESETS */
		;
	return numLiterals + LiteralStart;
}

sqInt
numTagBits(void)
{
	return 2;
}


/*	Answer if objOop looks like a class object. WIth Spur be lenient if the
	object doesn't
	yet have a hash (i.e. is not yet in the classTable), and accept forwarding
	pointers. 
 */

static sqInt
objCouldBeClassObj(sqInt objOop)
{
    sqInt fieldOop;

	return (((((usqInt) (longAt(objOop))) >> 24) & 0x1F) <= 5)
	 && (((numSlotsOf(objOop)) >= (InstanceSpecificationIndex + 1))
	 && (((fieldOop = longAt((objOop + (BaseHeaderSize)) + (SuperclassIndex << 2))),
	((((fieldOop & 3) == 0)
 && (((((usqInt) (longAt(fieldOop))) >> 24) & 0x1F) <= 5))
 || (((rawHashBitsOf(objOop)) == 0)
 && ((((fieldOop & 3) == 0)
 && (((longAt(fieldOop)) & 0x3FFFFF) == 8))
 && (isPointers(followForwarded(fieldOop))))))
		 && (((fieldOop = longAt((objOop + (BaseHeaderSize)) + (MethodDictionaryIndex << 2))),
		((((fieldOop & 3) == 0)
 && (((((usqInt) (longAt(fieldOop))) >> 24) & 0x1F) <= 5))
 || (((rawHashBitsOf(objOop)) == 0)
 && ((((fieldOop & 3) == 0)
 && (((longAt(fieldOop)) & 0x3FFFFF) == 8))
 && (isPointers(followForwarded(fieldOop))))))
			 && (((longAt((objOop + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) & 1)))))));
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated slotSize. If the word following
	an object doesn't have a saturated size field it must be a single-header
	object. If the word following
	does have a saturated slotSize it must be the overflow size word. */

sqInt
objectAfter(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((((usqInt) objOop)) < (((usqInt) GIV(newSpaceLimit)))) {
		if (oopisGreaterThanOrEqualToandLessThan(objOop, ((eden()).start), GIV(freeStart))) {
			return objectAfterlimit(objOop, GIV(freeStart));
		}
		if (oopisGreaterThanOrEqualToandLessThan(objOop, ((pastSpace()).start), GIV(pastSpaceStart))) {
			return objectAfterlimit(objOop, GIV(pastSpaceStart));
		}
		return objectAfterlimit(objOop, GIV(futureSurvivorStart));
	}
	return objectAfterlimit(objOop, GIV(endOfMemory));
}


/*	Object parsing.
	1. all objects have at least a word following the header, for a forwarding
	pointer. 2. objects with an overflow size have a preceeing word with a
	saturated numSlots. If the word
	following an object doesn't have a saturated numSlots field it must be a
	single-header object.
	If the word following does have a saturated numSlots it must be the
	overflow size word. */

static sqInt
objectAfterlimit(sqInt objOop, sqInt limit)
{
    sqInt followingWord;
    sqInt followingWordAddress;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt slotBytes;

	/* begin addressAfter: */
	/* begin numSlotsOfAny: */
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(objOop - (BaseHeaderSize)))
		: numSlots1);
	slotBytes = (numSlots == 0
		? 8
		: (numSlots + (numSlots & 1)) << 2);
	followingWordAddress = (objOop + (BaseHeaderSize)) + slotBytes;
	if ((((usqInt) followingWordAddress)) >= (((usqInt) limit))) {
		return limit;
	}
	flag("endianness");
	followingWord = longAt(followingWordAddress + 4);
	return ((((usqInt) followingWord) >> 24) == 0xFF
		? followingWordAddress + (BaseHeaderSize)
		: followingWordAddress);
}


/*	Like #stackObjectValue: but access method arguments left-to-right */

sqInt
objectArg(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = methodArg(index);
	if (oop == 0) {
		return 0;
	}
	if ((oop & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}

sqInt
objectBefore(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt o;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt objOop3;
    sqInt prev;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	prev = null;
	if ((((usqInt) objOop)) < (((usqInt) GIV(newSpaceLimit)))) {
		/* begin allNewSpaceObjectsDo: */
		/* begin allNewSpaceEntitiesDo: */

		/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
		   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

		prevPrevObj = (prevObj = null);
		assert((bootstrapping())
		 || ((((pastSpace()).start)) < (((eden()).start))));
		/* begin objectStartingAt: */
		address = ((pastSpace()).start);
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
		objOop1 = (numSlots == 0xFF
			? address + (BaseHeaderSize)
			: address);
		limit = GIV(pastSpaceStart);
		while ((((usqInt) objOop1)) < (((usqInt) limit))) {
			assert(isEnumerableObjectNoAssert(objOop1));
			if ((((usqInt) objOop1)) >= (((usqInt) objOop))) {
				return prev;
			}
			prev = objOop1;


			prevPrevObj = prevObj;
			prevObj = objOop1;
			objOop1 = objectAfterlimit(objOop1, limit);
		}
		/* begin objectStartingAt: */
		address1 = ((eden()).start);
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
		objOop1 = (numSlots1 == 0xFF
			? address1 + (BaseHeaderSize)
			: address1);
		while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
			assert(isEnumerableObjectNoAssert(objOop1));
			if ((((usqInt) objOop1)) >= (((usqInt) objOop))) {
				return prev;
			}
			prev = objOop1;


			prevPrevObj = prevObj;
			prevObj = objOop1;
			objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
		}
		
		
		return prev;
	}
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if ((((usqInt) objOop11)) >= (((usqInt) objOop))) {
				return prev;
			}
			prev = objOop11;

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
	return prev;
}


/*	For enumerating objects find the header of the first object in a space.
	If the object starts with an overflow size field it will start at the next
	allocationUnit. c.f. numSlotsOf: */

static sqInt
objectStartingAt(sqInt address)
{
    usqInt numSlots;

	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	return (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
}


/*	This message is deprecated but supported for a while via a tweak to
	sqVirtualMachine.[ch] Use fetchLong32, fetchLong64 or fetchPointer instead
	for new code
 */

sqInt
obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop)
{
	return long32At((oop + (BaseHeaderSize)) + (fieldIndex << 2));
}


/*	Verify that the given oop is legitimate. Check address, header, and size
	but not class.
 */

static sqInt
okayOop(sqInt signedOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt fmt;
    usqInt oop;
    usqLong unusedBits;
    sqInt unusedBitsInYoungObjects;


	/* address and size checks */

	oop = ((usqInt) signedOop);
	if ((oop & 3) != 0) {
		return 1;
	}
	if (!(addressCouldBeObj(oop))) {
		error("oop is not a valid address");
		return 0;
	}
	if (!(oopisLessThanOrEqualTo(addressAfter(oop), GIV(endOfMemory)))) {
		error("oop size would make it extend beyond the end of memory");
		return 0;
	}
	if (!(((classIndex = (longAt(oop)) & 0x3FFFFF)) >= 16)) {
		error("oop is a free chunk, or bridge, not an object");
		return 0;
	}
	if (((rawNumSlotsOf(oop)) == 0xFF)
	 && ((rawNumSlotsOf(oop - (BaseHeaderSize))) != 0xFF)) {
		error("oop header has overflow header word, but overflow word does not have a saturated numSlots field");
		return 0;
	}
	fmt = (((usqInt) (longAt(oop))) >> 24) & 0x1F;
	if ((fmt == 6) || (fmt == 8)) {
		error("oop has an unknown format type");
		return 0;
	}
	if ((fmt == 7) != (classIndex == 8)) {
		error("oop has mis-matched format/classIndex fields; only one of them is the isForwarded value");
		return 0;
	}
	unusedBits = (1 << 22) || (1 << (22 + 32));
	if (((longLongAt(oop)) & unusedBits) != 0) {
		error("some unused header bits are set; should be zero");
		return 0;
	}
	unusedBitsInYoungObjects = ((1 << 0x1F) || (1 << 30)) || (1 << 29);
	if (((longAt(oop)) & unusedBitsInYoungObjects) != 0) {
		error("some header bits unused in young objects are set; should be zero");
		return 0;
	}
	return 1;
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

static sqInt
oopisGreaterThanOrEqualTo(sqInt anOop, sqInt otherOop)
{
	return (((usqInt) anOop)) >= (((usqInt) otherOop));
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

static sqInt
oopisGreaterThanOrEqualToandLessThanOrEqualTo(sqInt anOop, sqInt baseOop, sqInt limitOop)
{
	return ((((usqInt) anOop)) >= (((usqInt) baseOop)))
	 && ((((usqInt) anOop)) <= (((usqInt) limitOop)));
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

static sqInt
oopisGreaterThanOrEqualToandLessThan(sqInt anOop, sqInt baseOop, sqInt limitOop)
{
	return ((((usqInt) anOop)) >= (((usqInt) baseOop)))
	 && ((((usqInt) anOop)) < (((usqInt) limitOop)));
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

static sqInt
oopisGreaterThan(sqInt anOop, sqInt otherOop)
{
	return (((usqInt) anOop)) > (((usqInt) otherOop));
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

static sqInt
oopisLessThanOrEqualTo(sqInt anOop, sqInt otherOop)
{
	return (((usqInt) anOop)) <= (((usqInt) otherOop));
}


/*	Compare two oop values, treating them as object memory locations.
	Use #cCoerce:to: to ensure comparison of unsigned magnitudes. This
	method will be inlined during C translation. */

static sqInt
oopisLessThan(sqInt anOop, sqInt otherOop)
{
	return (((usqInt) anOop)) < (((usqInt) otherOop));
}


/*	<Integer> */
/*	Answer the page index for a pointer into stack memory, i.e. the index
	for the page the address is in. N.B. This is a zero-relative index. */

static sqInt
pageIndexFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

static sqInt
pageListIsWellFormed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numPages) * 2;
	while ((((page->baseFP)) == 0)
	 && ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit))) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit)) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(isFree(page)))) {
			if (!(asserta((stackPageFor((page->baseFP))) == page))) {
				ok = 0;
			}
			if (!(asserta((stackPageFor((page->headSP))) == page))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == GIV(numPages)))) {
		ok = 0;
	}
	return ok;
}

void
pinObject(sqInt objOop)
{
	error("shouldBeImplemented");
}

static sqInt
popObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt myx;
    sqInt nextPage;
    sqInt top;
    sqInt topx;

	assert(isValidObjStack(objStack));
	topx = longAt((objStack + (BaseHeaderSize)) + (ObjStackTopx << 2));
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		null;
		return null;
	}
	topx -= 1;
	top = longAt((objStack + (BaseHeaderSize)) + ((topx + ObjStackFixedSlots) << 2));
	null;
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(objStack)));
	if (isOldObject(objStack)) {

		/* most stores into young objects */

		if (((topx & 3) == 0)
		 && ((((usqInt) topx)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objStack))) >> 29) & 1) != 0)) {
				remember(objStack);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(objStack, (longAt(objStack)) | (1 << 29));
			}
		}
	}
	longAtput((objStack + (BaseHeaderSize)) + (ObjStackTopx << 2), topx);
	if ((topx == 0)
	 && (((nextPage = longAt((objStack + (BaseHeaderSize)) + (ObjStackNextx << 2)))) != 0)) {
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(nextPage)) == (wordIndexableFormat()));
		null;
		longAtput((nextPage + (BaseHeaderSize)) + (ObjStackFreex << 2), objStack);
		/* begin storePointer:ofObjStack:withValue: */
		assert((formatOf(objStack)) == (wordIndexableFormat()));
		null;
		longAtput((objStack + (BaseHeaderSize)) + (ObjStackNextx << 2), 0);
		myx = longAt((objStack + (BaseHeaderSize)) + (ObjStackMyx << 2));
		/* begin updateRootOfObjStackAt:with: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(hiddenRootsObj))));
		if (isOldObject(GIV(hiddenRootsObj))) {

			/* most stores into young objects */

			if (((nextPage & 3) == 0)
			 && ((((usqInt) nextPage)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(hiddenRootsObj)))) >> 29) & 1) != 0)) {
					remember(GIV(hiddenRootsObj));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(hiddenRootsObj), (longAt(GIV(hiddenRootsObj))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (myx << 2), nextPage);
		
		switch (myx) {
		case MarkStackRootIndex:
			GIV(markStack) = nextPage;
			break;
		case WeaklingStackRootIndex:
			GIV(weaklingStack) = nextPage;
			break;
		case EphemeronQueueRootIndex:
			GIV(ephemeronQueue) = nextPage;
			break;
		default:
			error("Case not found and no otherwise clause");
		}
		nextPage;
	}
	assert(isValidObjStack(objStack));
	return top;
}


/*	Pop and return the possibly remapped object from the remap buffer.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

sqInt
popRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	return oop;
}


/*	In the StackInterpreter stacks grow down. */

sqInt
popStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt top;

	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	return top;
}


/*	In the StackInterpreter stacks grow down. */

sqInt
pop(sqInt nItems)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(stackPointer) += nItems * BytesPerWord;
	return null;
}


/*	In the StackInterpreter stacks grow down. */

void
popthenPush(sqInt nItems, sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) + ((nItems - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Note - integerValue is interpreted as POSITIVE, eg, as the result of
	Bitmap>at:, or integer>bitAnd:.
 */

sqInt
positive32BitIntegerFor(sqInt integerValue)
{
    sqInt newLargeInteger;
    sqInt objFormat;

	if ((integerValue >= 0)
	 && ((integerValue ^ (integerValue << 1)) >= 0)) {
		return ((integerValue << 1) | 1);
	}
	/* begin eeInstantiateClassIndex:format:numSlots: */
	objFormat = 16 + (4 & ((wordSize()) - 1));
	assert((1 >= 0)
	 && (ClassLargePositiveIntegerCompactIndex != 0));
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
	newLargeInteger = allocateNewSpaceSlotsformatclassIndex(1, objFormat, ClassLargePositiveIntegerCompactIndex);
	byteAtput((newLargeInteger + (BaseHeaderSize)) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
	byteAtput((newLargeInteger + (BaseHeaderSize)) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
	byteAtput((newLargeInteger + (BaseHeaderSize)) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
	byteAtput((newLargeInteger + (BaseHeaderSize)) + 0, integerValue & 0xFF);
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargePositiveInteger. 
 */

sqInt
positive32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ok;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = 0;
		}
		return value;
	}
	else {
		if (1
		 && ((oop & 3) != 0)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex));
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!(ok
		 && ((lengthOfformat(oop, (((usqInt) (longAt(oop))) >> 24) & 0x1F)) == 4))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return (((byteAt((oop + (BaseHeaderSize)) + 0)) + ((byteAt((oop + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((oop + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((oop + (BaseHeaderSize)) + 3)) << 24);
}


/*	Note - integerValue is interpreted as POSITIVE, eg, as the result of
	Bitmap>at:, or integer>bitAnd:. */

sqInt
positive64BitIntegerFor(sqLong integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt highWord;
    sqInt i;
    sqInt newLargeInteger;
    sqInt sz;
    sqInt value;

	if ((sizeof(integerValue)) == 4) {
		return positive32BitIntegerFor(integerValue);
	}

	/* shift is coerced to usqInt otherwise */

	highWord = integerValue >> 32;
	if (highWord == 0) {
		return positive32BitIntegerFor(integerValue);
	}
	sz = 5;
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
	}
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
	}
	if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
		sz += 1;
	}
	newLargeInteger = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2)), sz);
	for (i = 0; i < sz; i += 1) {
		value = (integerValue >> (i * 8)) & 255;
		byteAtput((newLargeInteger + (BaseHeaderSize)) + i, value);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargePositiveInteger. 
 */

sqLong
positive64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt i;
    sqInt ok;
    sqInt sz;
    sqLong value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex));
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!(ok
		 && (((sz = lengthOfformat(oop, (((usqInt) (longAt(oop))) >> 24) & 0x1F))) <= (sizeof(sqLong))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	value = 0;
	for (i = 0; i < sz; i += 1) {
		value += (((sqLong) (byteAt((oop + (BaseHeaderSize)) + i)))) << (i * 8);
	}
	return value;
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */

unsigned long
positiveMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ok;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex));
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!(ok
		 && (((bs = lengthOfformat(oop, (((usqInt) (longAt(oop))) >> 24) & 0x1F))) <= (sizeof(unsigned long))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		return (((((((byteAt((oop + (BaseHeaderSize)) + 0)) + ((byteAt((oop + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((oop + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((oop + (BaseHeaderSize)) + 3)) << 24)) + ((byteAt((oop + (BaseHeaderSize)) + 4)) << 32)) + ((byteAt((oop + (BaseHeaderSize)) + 5)) << 40)) + ((byteAt((oop + (BaseHeaderSize)) + 6)) << 48)) + ((byteAt((oop + (BaseHeaderSize)) + 7)) << 56);
	}
	return (((byteAt((oop + (BaseHeaderSize)) + 0)) + ((byteAt((oop + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((oop + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((oop + (BaseHeaderSize)) + 3)) << 24);
}


/*	Scan the class table post-become (iff a pointer object or compiled method
	was becommed),
	or post-compact.
	Note that one-way become can cause duplications in the class table.
	When can these be eliminated? We use the classTableBitmap to mark
	classTable entries
	(not the classes themselves, since marking a class doesn't help in knowing
	if its index is used).
	On image load, and during incrememtal scan-mark and full GC, classIndices
	are marked.
	We can somehow avoid following classes from the classTable until after
	this mark phase. */

static void
postBecomeOrCompactScanClassTable(sqInt effectsFlags)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classOrNil;
    sqInt i;
    sqInt j;
    sqInt jLimiT;
    sqInt page;
    sqInt referent;

	assert(validClassTableRootPages());
	if (!(effectsFlags & (BecamePointerObjectFlag + BecameCompiledMethodFlag))) {
		return;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		page = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (i << 2));
		assert(!(isForwarded(page)));
		for (j = 0, jLimiT = ((numSlotsOf(page)) - 1); j <= jLimiT; j += 1) {
			classOrNil = longAt((page + (BaseHeaderSize)) + (j << 2));
			if (classOrNil != GIV(nilObj)) {
				if (((longAt(classOrNil)) & 0x3FFFFF) == 8) {
					/* begin followForwarded: */
					assert(isForwarded(classOrNil));
					referent = longAt((classOrNil + (BaseHeaderSize)) + (0 << 2));
					while (((referent & 3) == 0)
					 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
						referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
					}
					classOrNil = referent;
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(page)));
					if (isOldObject(page)) {

						/* most stores into young objects */

						if (((classOrNil & 3) == 0)
						 && ((((usqInt) classOrNil)) < (((usqInt) GIV(newSpaceLimit))))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(page))) >> 29) & 1) != 0)) {
								remember(page);
								/* begin setIsRememberedOf:to: */
								flag("endianness");
								longAtput(page, (longAt(page)) | (1 << 29));
							}
						}
					}
					longAtput((page + (BaseHeaderSize)) + (j << 2), classOrNil);
				}
				scanClassPostBecomeeffects(classOrNil, effectsFlags);
			}
		}
	}
}

static void
primitiveAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((integerResult ^ (integerResult << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveAddLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!(!GIV(primFailCode))) {
		return;
	}
	if (aIsNegative == bIsNegative) {

		/* Protect against overflow */

		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = bIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

static void
primitiveAdoptInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	err = changeClassOfto(arg, rcvr);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */

		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		null;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}

static void
primitiveArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		rcvr = result;
		goto l2;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = atan(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

static void
primitiveArrayBecome(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 1, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		null;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

static void
primitiveArrayBecomeOneWay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		null;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument whether
	to copy
	the receiver's identity hash over the argument's identity hash.
 */

static void
primitiveArrayBecomeOneWayCopyHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt copyHashFlag;
    sqInt ec;
    sqInt rcvr;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHashFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		copyHashFlag = 0;
		goto l1;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */

	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	copyHashFlag = null;
l1:	/* end booleanValueOf: */;
	arg = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, copyHashFlag);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		null;
	}
	else {
		GIV(primFailCode) = ec;
	}
}

static void
primitiveAsCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt characterCode;
    sqInt characterObject;
    sqInt objOop;
    sqInt reasonCode;
    char *sp;

	characterCode = longAt(GIV(stackPointer));
	if (!(((characterCode & 1))
		 && (((characterCode = (characterCode >> 1)),
		(characterCode >= 0)
			 && (characterCode < (pow(2,30))))))) {
		/* begin primitiveFailFor: */
		reasonCode = (GIV(argumentCount) == 0
			? PrimErrBadReceiver
			: PrimErrBadArgument);
		(GIV(primFailCode) = reasonCode);
		return;
	}
	characterObject = (CharacterTable == null
		? (characterCode << 2) + 2
		: (/* begin fetchPointer:ofObject: */
			/* begin characterTable */
			error("shouldNotImplement"),
			longAt((objOop + (BaseHeaderSize)) + (characterCode << 2))));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), characterObject);
	GIV(stackPointer) = sp;
}

static void
primitiveAsFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    double f;
    sqInt integerPointer;
    sqInt object;
    char *sp;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		arg = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = ((double) arg);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}

static void
primitiveAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;

	/* begin commonAt: */
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 3) != 0) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}

	/* No need to test for large positive integers here.  No object has 1g elements */

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	index = (index >> 1);
	/* begin stObject:at: */
	hdr = longLongAt(rcvr);
	fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l2;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l2;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l2:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = rcvr;
		goto l3;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l3;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l3:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l4:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3)
	 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l5;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + (BaseHeaderSize)) + (StackPointerIndex << 2));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l5;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 1);
	l5:	/* end stackPointerForMaybeMarriedContext: */;
		if (((((usqInt) index)) >= (((usqInt) 1)))
		 && (((((usqInt) index)) <= (((usqInt) stSize)))
		 && ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l6;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= 24
	? (((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1
	: 1)))
	 && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			result = longAt((rcvr + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2));
			goto l6;
		}
		if (fmt >= 16) {
			result = (((byteAt((rcvr + (BaseHeaderSize)) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l6;
		}
		result = positive32BitIntegerFor(long32At((rcvr + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2)));
		goto l6;
	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
l6:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		;
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAt: */;
}

static void
primitiveAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt class1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classTablePage;
    sqInt classTablePage1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt reasonCode1;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    sqInt sp2;
    sqInt sp3;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    sqInt value;
    sqInt value1;
    sqInt valueToStore;
    sqInt valueToStore1;

	/* begin commonAtPut: */
	value = longAt(GIV(stackPointer));
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((rcvr & 3) == 0)) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}

	/* No need to test for large positive integers here.  No object has 1g elements */

	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	index = (index >> 1);
	/* begin stObject:at:put: */
	hdr1 = longLongAt(rcvr);
	fmt1 = (((unsigned sqLong)hdr1) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots11 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots2 = (numSlots11 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots11);
	if (fmt1 <= 9) {
		totalLength1 = numSlots2;
		goto l8;
	}
	if (fmt1 >= 16) {

		/* bytes, including CompiledMethod */

		totalLength1 = (numSlots2 << 2) - (fmt1 & 7);
		goto l8;
	}
	if (fmt1 >= 12) {
		totalLength1 = (numSlots2 << (2 - 1)) - (fmt1 & 3);
		goto l8;
	}
	totalLength1 = (numSlots2 << (2 - 2)) - (fmt1 & 1);
l8:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt1 > 5)
	 || (fmt1 == 2)) {
		fixedFields1 = 0;
		goto l10;
	}
	if (fmt1 < 2) {
		fixedFields1 = totalLength1;
		goto l10;
	}
	/* begin fetchClassOfNonImm: */
	classIndex1 = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex1 == 0x1F) {
		class1 = rcvr;
		goto l9;
	}
	assert(classIndex1 >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex1 <= (tagMask()))
	 || (classIndex1 >= (arrayClassIndexPun())));
	classTablePage1 = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex1) >> 10) << 2));
	if (classTablePage1 == GIV(nilObj)) {
		class1 = null;
		goto l9;
	}
	class1 = longAt((classTablePage1 + (BaseHeaderSize)) + ((classIndex1 & ((1 << 10) - 1)) << 2));
l9:	/* end fetchClassOfNonImm: */;
	fixedFields1 = (((longAt((class1 + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l10:	/* end fixedFieldsOf:format:length: */;
	if ((fmt1 == 3)
	 && ((hdr1 & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp3 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp3 >> 1))) < (lengthOf(rcvr)));
			stSize1 = sp3;
			goto l7;
		}
		/* begin fetchStackPointerOf: */
		sp11 = longAt((rcvr + (BaseHeaderSize)) + (StackPointerIndex << 2));
		if (!((sp11 & 1))) {
			stSize1 = 0;
			goto l7;
		}
		assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(rcvr)));
		stSize1 = (sp11 >> 1);
	l7:	/* end stackPointerForMaybeMarriedContext: */;
		if (((((usqInt) index)) >= (((usqInt) 1)))
		 && (((((usqInt) index)) <= (((usqInt) stSize1)))
		 && ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr), value);
			goto l11;
		}
	}
	else {
		stSize1 = totalLength1 - fixedFields1;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= 24
	? (((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1
	: 1)))
	 && ((((usqInt) index)) <= (((usqInt) stSize1)))) {
		/* begin subscript:with:storing:format: */
		if (fmt1 <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */

				if (((value & 3) == 0)
				 && ((((usqInt) value)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
						remember(rcvr);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
					}
				}
			}
			longAtput((rcvr + (BaseHeaderSize)) + (((index + fixedFields1) - 1) << 2), value);
		}
		else {
			if (fmt1 >= 16) {
				if (!((value & 1))) {
					GIV(primFailCode) = PrimErrBadIndex;
				}
				valueToStore1 = (value >> 1);
				if (!((valueToStore1 >= 0)
					 && (valueToStore1 <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
				}
				if (!GIV(primFailCode)) {
					byteAtput((rcvr + (BaseHeaderSize)) + ((index + fixedFields1) - 1), valueToStore1);
				}
			}
			else {

				/* long-word type objects */

				valueToStore1 = positive32BitValueOf(value);
				if (!GIV(primFailCode)) {
					long32Atput((rcvr + (BaseHeaderSize)) + (((index + fixedFields1) - 1) << 2), valueToStore1);
				}
			}
		}
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode1 = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode1;
	}
	value;
l11:	/* end stObject:at:put: */;

	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAtPut: */;
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

static void
primitiveBeCursor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt i;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean10;
    sqInt successBoolean11;
    sqInt successBoolean12;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;
    sqInt successBoolean9;

	if (GIV(argumentCount) == 0) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}
	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin success: */
	successBoolean11 = (((cursorObj & 3) == 0)
 && (((((usqInt) (longAt(cursorObj))) >> 24) & 0x1F) <= 5))
	 && ((lengthOfformat(cursorObj, (((usqInt) (longAt(cursorObj))) >> 24) & 0x1F)) >= 5);
	if (!successBoolean11) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		bitsObj = longAt((cursorObj + (BaseHeaderSize)) + (0 << 2));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + (BaseHeaderSize)) + (4 << 2));
	}
	/* begin success: */
	successBoolean12 = (((offsetObj & 3) == 0)
 && (((((usqInt) (longAt(offsetObj))) >> 24) & 0x1F) <= 5))
	 && ((lengthOfformat(offsetObj, (((usqInt) (longAt(offsetObj))) >> 24) & 0x1F)) >= 2);
	if (!successBoolean12) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		if ((GIV(argumentCount) == 0)
		 && (depth == 32)) {

			/* Support arbitrary-sized 32 bit ARGB forms --bf 3/1/2007 23:51 */

			/* begin success: */
			successBoolean = (extentX > 0)
			 && (extentY > 0);
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean1 = (offsetX >= (extentX * -1))
			 && (offsetX <= 0);
			if (!successBoolean1) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean2 = (offsetY >= (extentY * -1))
			 && (offsetY <= 0);
			if (!successBoolean2) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean3 = (((bitsObj & 3) == 0)
 && (((((usqInt) (longAt(bitsObj))) >> 24) & 0x1F) == 10))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> 24) & 0x1F)) == (extentX * extentY));
			if (!successBoolean3) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
			
		}
		else {
			/* begin success: */
			successBoolean4 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean4) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean5 = (offsetX >= -16)
			 && (offsetX <= 0);
			if (!successBoolean5) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean6 = (offsetY >= -16)
			 && (offsetY <= 0);
			if (!successBoolean6) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean7 = (((bitsObj & 3) == 0)
 && (((((usqInt) (longAt(bitsObj))) >> 24) & 0x1F) == 10))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> 24) & 0x1F)) == 16);
			if (!successBoolean7) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + (BaseHeaderSize);
			
		}
	}
	if (GIV(argumentCount) == 1) {
		/* begin success: */
		successBoolean10 = (((maskObj & 3) == 0)
 && (((((usqInt) (longAt(maskObj))) >> 24) & 0x1F) <= 5))
		 && ((lengthOfformat(maskObj, (((usqInt) (longAt(maskObj))) >> 24) & 0x1F)) >= 5);
		if (!successBoolean10) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			bitsObj = longAt((maskObj + (BaseHeaderSize)) + (0 << 2));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (!GIV(primFailCode)) {
			/* begin success: */
			successBoolean8 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean8) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean9 = (((bitsObj & 3) == 0)
 && (((((usqInt) (longAt(bitsObj))) >> 24) & 0x1F) == 10))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> 24) & 0x1F)) == 16);
			if (!successBoolean9) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + (BaseHeaderSize);
		}
	}
	if (!GIV(primFailCode)) {
		if (GIV(argumentCount) == 0) {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

					return;
				}
			}
			else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		}
		else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		null;
	}
}


/*	Record the system Display object in the specialObjectsTable. */

static void
primitiveBeDisplay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt successBoolean;

	rcvr = longAt(GIV(stackPointer));
	/* begin success: */
	successBoolean = (((rcvr & 3) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) <= 5))
	 && ((lengthOfformat(rcvr, (((usqInt) (longAt(rcvr))) >> 24) & 0x1F)) >= 4);
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((rcvr & 3) == 0)
			 && ((((usqInt) rcvr)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheDisplay << 2), rcvr);
	}
}


/*	make the basic beep noise */

static void
primitiveBeep(void)
{
	ioBeep();
}

static void
primitiveBehaviorHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt err;
    sqInt hashOrError;
    sqInt newHash;
    char *sp;

	assert((isNonImmediate(stackTop()))
	 && (addressCouldBeClassObj(stackTop())));
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(longAt(GIV(stackPointer))));
	if (((newHash = rawHashBitsOf(longAt(GIV(stackPointer))))) == 0) {
		if (((err = enterIntoClassTable(longAt(GIV(stackPointer))))) != 0) {
			hashOrError = -err;
			goto l1;
		}
		/* begin rawHashBitsOf: */
		flag("endianness");
		newHash = (longAt((longAt(GIV(stackPointer))) + 4)) & 0x3FFFFF;
		assert((classAtIndex(newHash)) == (longAt(GIV(stackPointer))));
	}
	hashOrError = newHash;
l1:	/* end ensureBehaviorHash: */;
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((hashOrError << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		GIV(primFailCode) = -hashOrError;
	}
}

static void
primitiveBitAnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;
    sqInt top11;
    sqInt top2;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver & integerArgument);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(void)
primitiveBitAndLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!(!GIV(primFailCode))) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

static void
primitiveBitOr(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;
    sqInt top11;
    sqInt top2;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver | integerArgument);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(void)
primitiveBitOrLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!(!GIV(primFailCode))) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

static void
primitiveBitShift(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerReceiver;
    sqInt object;
    sqInt shifted;
    char *sp;
    sqInt top;
    sqInt top1;
    sqInt top2;

	/* begin popInteger */
	/* begin popStack */
	top2 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top2;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	integerReceiver = positive32BitValueOf(top);
	if (!GIV(primFailCode)) {
		if (integerArgument >= 0) {

			/* Left shift -- must fail if we lose bits beyond 32 */

			/* begin success: */
			if (!(integerArgument <= 0x1F)) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			shifted = integerReceiver << integerArgument;
			/* begin success: */
			if (!((((usqInt) shifted) >> integerArgument) == integerReceiver)) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
		else {

			/* Right shift -- OK to lose bits */

			/* begin success: */
			if (!(integerArgument >= -31)) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
		}
	}
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = positive32BitIntegerFor(shifted);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveBitShiftLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    sqInt integerPointer;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt shift;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		shift = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		shift = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	if (!(!GIV(primFailCode))) {
		return;
	}
	if (shift >= 0) {

		/* Protect against overflow */


		/* This is to avoid undue (usqInt) cast */

		result = 0xFFFFFFFFFFFFFFFFULL;
		if ((shift >= 64)
		 || (a > (result >> shift))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a << shift;
	}
	else {
		shift = 0 - shift;
		if (shift >= 64) {
			result = 0;
		}
		else {
			result = a >> shift;
		}
		if (aIsNegative
		 && ((result << shift) != a)) {
			result += 1;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

static void
primitiveBitXor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;
    sqInt top11;
    sqInt top2;

	/* begin popPos32BitInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top = top1;
	integerArgument = positive32BitValueOf(top);
	/* begin popPos32BitInteger */
	/* begin popStack */
	top11 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top2 = top11;
	integerReceiver = positive32BitValueOf(top2);
	if (!GIV(primFailCode)) {
		/* begin push: */
		object = positive32BitIntegerFor(integerReceiver ^ integerArgument);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive logical operations for large integers in 64 bit range */

EXPORT(void)
primitiveBitXorLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!(!GIV(primFailCode))) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Reports bytes available at this moment. For more meaningful 
	results, calls to this primitive should be preceeded by a full 
	or incremental garbage collection. */

static void
primitiveBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    sqInt integerVal;
    char *sp;
    char *sp1;

	if (GIV(argumentCount) == 0) {

		/* old behavior - just return the size of free memory */

		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((GIV(totalFreeOldSpace) << 1) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {

		/* new behaviour -including or excluding swap space depending on aBool */

		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushInteger: */
			integerVal = (((GIV(totalFreeOldSpace) + ((((eden()).limit)) - GIV(freeStart))) + ((((pastSpace()).limit)) - GIV(pastSpaceStart))) + ((((futureSpace()).limit)) - (((futureSpace()).limit)))) - (interpreterAllocationReserveBytes());
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerVal << 1) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */

static void
primitiveCalloutToFFI(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static void *function = (void *)-1;
    void (*primitiveCallout)(void);

	/* begin functionForPrimitiveCallout */
	;
	if ((((sqInt)function)) == -1) {
		function = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims");
	}
	primitiveCallout = ((void (*)(void)) (((void (*)(void)) function)));
	if (primitiveCallout == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		primitiveCallout();
	}
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that
	the format of the receiver matches the format of the argument's class.
	Fail if the
	receiver or argument are SmallIntegers, or the receiver is an instance of
	a compact
	class and the argument isn't, or when the argument's class is compact and
	the receiver
	isn't, or when the format of the receiver is different from the format of
	the argument's
	class, or when the arguments class is fixed and the receiver's size
	differs from the size
	that an instance of the argument's class should have. */

static void
primitiveChangeClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l2;
	}
	arg = oop;
l2:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l3;
	}
	rcvr = oop1;
l3:	/* end stackObjectValue: */;
	if (!(!GIV(primFailCode))) {
		return;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(arg)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		argClass = arg;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		argClass = null;
		goto l4;
	}
	argClass = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l4:	/* end classAtIndex: */;
l1:	/* end fetchClassOfNonImm: */;
	err = changeClassOfto(rcvr, argClass);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */

		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		null;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}

static void
primitiveCharacterValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt characterCode;
    sqInt characterObject;
    char *sp;

	characterObject = longAt(GIV(stackPointer));

	/* the Character must be the receiver for safety */

	characterCode = (CharacterTable == null
		? (((((usqInt) (((usqInt)characterObject))) >> 2) << 1) | 1)
		: longAt((characterObject + (BaseHeaderSize)) + (CharacterValueIndex << 2)));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), characterCode);
	GIV(stackPointer) = sp;
}

static void
primitiveClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt instance;
    sqInt oop;
    char *sp;
    sqInt tagBits;

	instance = longAt(GIV(stackPointer));
	/* begin pop:thenPush: */
	/* begin fetchClassOf: */
	if (((tagBits = instance & 3)) != 0) {
		oop = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
		goto l1;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(instance)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		oop = instance;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		oop = null;
		goto l1;
	}
	oop = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l1:	/* end fetchClassOf: */;
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Void the VM profile histograms. */

static void
primitiveClearVMProfile(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	null;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

static void
primitiveClipboardText(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt numBytes;
    sqInt s;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(((s & 3) == 0)
			 && (((((usqInt) (longAt(s))) >> 24) & 0x1F) >= 16))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		if (!GIV(primFailCode)) {
			/* begin byteLengthOf: */
			fmt = (((usqInt) (longAt(s))) >> 24) & 0x1F;
			numBytes = (numSlotsOf(s)) << 2;
			if (fmt <= 9) {
				sz = numBytes;
				goto l1;
			}
			if (fmt >= 16) {

				/* bytes, including CompiledMethod */

				sz = numBytes - (fmt & 7);
				goto l1;
			}
			if (fmt >= 12) {
				sz = numBytes - ((fmt & 3) << 1);
				goto l1;
			}
			sz = numBytes - ((fmt & 1) << 2);
		l1:	/* end byteLengthOf: */;
			clipboardWriteFromAt(sz, s + (BaseHeaderSize), 0);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			null;
		}
	}
	else {
		sz = clipboardSize();
		s = allocateBytesclassIndex(sz, ClassByteStringCompactIndex);
		if (!(s)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}

		clipboardReadIntoAt(sz, s + (BaseHeaderSize), 0);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Take a boolean which if true turns or keeps clock logging on. Answer an
	array supplying
	the size of the clock logs, the address of the usecs log, the index in it,
	the address of the
	msecs log, and the index into it. */

EXPORT(sqInt)
primitiveClockLogAddresses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt midx;
    void *msecs;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt result;
    sqInt runInNOut;
    char *sp;
    sqInt uidx;
    void *usecs;
    sqInt v1;
    sqInt v2;

	if (GIV(argumentCount) != 1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	runInNOut = (longAt(GIV(stackPointer) + (0 * BytesPerWord))) == GIV(trueObj);
	ioGetClockLogSizeUsecsIdxMsecsIdx((&runInNOut), (&usecs), (&uidx), (&msecs), (&midx));
	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassArray << 2)), 5);
	if (result == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(result));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = result;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(GIV(remapBuffer)[GIV(remapBufferCount)])));
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + (BaseHeaderSize)) + (0 << 2), ((runInNOut << 1) | 1));
	v1 = positive32BitIntegerFor(((usqInt)usecs));
	v2 = positive32BitIntegerFor(((usqInt)msecs));
	if (!(!GIV(primFailCode))) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		oop;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(GIV(remapBuffer)[GIV(remapBufferCount)])));
	if (isOldObject(GIV(remapBuffer)[GIV(remapBufferCount)])) {

		/* most stores into young objects */

		if (((v1 & 3) == 0)
		 && ((((usqInt) v1)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(GIV(remapBuffer)[GIV(remapBufferCount)]))) >> 29) & 1) != 0)) {
				remember(GIV(remapBuffer)[GIV(remapBufferCount)]);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(GIV(remapBuffer)[GIV(remapBufferCount)], (longAt(GIV(remapBuffer)[GIV(remapBufferCount)])) | (1 << 29));
			}
		}
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + (BaseHeaderSize)) + (1 << 2), v1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(GIV(remapBuffer)[GIV(remapBufferCount)])));
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + (BaseHeaderSize)) + (2 << 2), ((uidx << 1) | 1));
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(GIV(remapBuffer)[GIV(remapBufferCount)])));
	if (isOldObject(GIV(remapBuffer)[GIV(remapBufferCount)])) {

		/* most stores into young objects */

		if (((v2 & 3) == 0)
		 && ((((usqInt) v2)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(GIV(remapBuffer)[GIV(remapBufferCount)]))) >> 29) & 1) != 0)) {
				remember(GIV(remapBuffer)[GIV(remapBufferCount)]);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(GIV(remapBuffer)[GIV(remapBufferCount)], (longAt(GIV(remapBuffer)[GIV(remapBufferCount)])) | (1 << 29));
			}
		}
	}
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + (BaseHeaderSize)) + (3 << 2), v2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(GIV(remapBuffer)[GIV(remapBufferCount)])));
	longAtput(((GIV(remapBuffer)[GIV(remapBufferCount)]) + (BaseHeaderSize)) + (4 << 2), ((midx << 1) | 1));
	/* begin pop:thenPush: */
	/* begin popRemappableOop */
	oop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	oop1 = oop2;
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
	GIV(stackPointer) = sp;
}


/*	Return a shallow copy of the receiver.
	Special-case non-single contexts (because of context-to-stack mapping).
	Can't fail for contexts cuz of image context instantiation code (sigh). */

static void
primitiveClone(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt newCopy;
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer));
	if ((rcvr & 3) != 0) {
		newCopy = rcvr;
	}
	else {
		if (((longAt(rcvr)) & 0x3FFFFF) == ClassMethodContextCompactIndex) {
			newCopy = cloneContext(rcvr);
		}
		else {
			newCopy = clone(rcvr);
		}
		if (newCopy == 0) {
			(GIV(primFailCode) = PrimErrNoMemory);
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), newCopy);
	GIV(stackPointer) = sp;
}

static void
primitiveClosureCopyWithCopiedValues(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt context;
    sqInt copiedValues;
    sqInt err;
    sqInt i;
    sqInt initialIP;
    sqInt integerPointer;
    sqInt newClosure;
    sqInt newClosure1;
    sqInt newHash;
    sqInt numArgs;
    usqInt numCopied;
    usqInt numSlots;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		numArgs = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		numArgs = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin closureIn:numArgs:instructionPointer:copiedValues: */
	context = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	initialIP = (GIV(instructionPointer) + 2) - (GIV(method) + BaseHeaderSize);
	copiedValues = longAt(GIV(stackPointer));
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(copiedValues)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(copiedValues + 4))))) >> 24;
	numCopied = (numSlots == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(copiedValues - (BaseHeaderSize)))
		: numSlots);
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert(((ClosureFirstCopiedValueIndex + numCopied) >= 0)
	 && (ClassBlockClosureCompactIndex != 0));
	assert((3) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex))));
	newClosure1 = allocateNewSpaceSlotsformatclassIndex(ClosureFirstCopiedValueIndex + numCopied, 3, ClassBlockClosureCompactIndex);

	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newClosure1)));
	longAtput((newClosure1 + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2), context);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newClosure1)));
	longAtput((newClosure1 + (BaseHeaderSize)) + (ClosureStartPCIndex << 2), ((initialIP << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newClosure1)));
	longAtput((newClosure1 + (BaseHeaderSize)) + (ClosureNumArgsIndex << 2), ((numArgs << 1) | 1));
	for (i = 0; i < numCopied; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(newClosure1)));
		longAtput((newClosure1 + (BaseHeaderSize)) + ((i + ClosureFirstCopiedValueIndex) << 2), longAt((copiedValues + (BaseHeaderSize)) + (i << 2)));
	}
	newClosure = newClosure1;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), newClosure);
	GIV(stackPointer) = sp;
}

static void
primitiveClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt theMethod;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + (BaseHeaderSize)) + (ClosureNumArgsIndex << 2));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2));
	if (!(((outerContext & 3) == 0)
		 && (((longAt(outerContext)) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + (BaseHeaderSize)) + (MethodIndex << 2));
	if (!(((closureMethod & 3) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> 24) & 0x1F) >= 24))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	outerContext1 = longAt((blockClosure + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	theMethod = longAt((outerContext1 + (BaseHeaderSize)) + (MethodIndex << 2));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), theMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = ((1 + (numArgs << 8)) + (0)) + (1 << 24);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), longAt((outerContext1 + (BaseHeaderSize)) + (ReceiverIndex << 2)));
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + (BaseHeaderSize)) + ((i + ClosureFirstCopiedValueIndex) << 2)));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + (BaseHeaderSize)) + (ClosureStartPCIndex << 2));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = theMethod;
	assert(isOopCompiledMethod(GIV(method)));
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) (longAt((GIV(method) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

void
primitiveClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt theMethod;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + (BaseHeaderSize)) + (ClosureNumArgsIndex << 2));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2));
	if (!(((outerContext & 3) == 0)
		 && (((longAt(outerContext)) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + (BaseHeaderSize)) + (MethodIndex << 2));
	if (!(((closureMethod & 3) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> 24) & 0x1F) >= 24))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	outerContext1 = longAt((blockClosure + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	theMethod = longAt((outerContext1 + (BaseHeaderSize)) + (MethodIndex << 2));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), theMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = ((1 + (numArgs << 8)) + (0)) + (1 << 24);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), longAt((outerContext1 + (BaseHeaderSize)) + (ReceiverIndex << 2)));
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + (BaseHeaderSize)) + ((i + ClosureFirstCopiedValueIndex) << 2)));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + (BaseHeaderSize)) + (ClosureStartPCIndex << 2));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = theMethod;
	assert(isOopCompiledMethod(GIV(method)));
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) (longAt((GIV(method) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(0);
	}
}

static void
primitiveClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt index;
    sqInt numArgs;
    sqInt numCopied;
    usqInt numSlots;
    sqInt object;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt theMethod;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 3) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 24) & 0x1F) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(argumentArray + 4))))) >> 24;
	arraySize = (numSlots == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(argumentArray - (BaseHeaderSize)))
		: numSlots);
	if (!(roomToPushNArgs(arraySize))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + (BaseHeaderSize)) + (ClosureNumArgsIndex << 2));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2));
	if (!(((outerContext & 3) == 0)
		 && (((longAt(outerContext)) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + (BaseHeaderSize)) + (MethodIndex << 2));
	if (!(((closureMethod & 3) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> 24) & 0x1F) >= 24))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	top;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + (BaseHeaderSize)) + ((index - 1) << 2)));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	outerContext1 = longAt((blockClosure + (BaseHeaderSize)) + (ClosureOuterContextIndex << 2));
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	theMethod = longAt((outerContext1 + (BaseHeaderSize)) + (MethodIndex << 2));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), theMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = ((1 + (numArgs << 8)) + (0)) + (1 << 24);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), longAt((outerContext1 + (BaseHeaderSize)) + (ReceiverIndex << 2)));
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + (BaseHeaderSize)) + ((i + ClosureFirstCopiedValueIndex) << 2)));
		GIV(stackPointer) = sp7;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + (BaseHeaderSize)) + (ClosureStartPCIndex << 2));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = theMethod;
	assert(isOopCompiledMethod(GIV(method)));
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) (longAt((GIV(method) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	Primitive. Compare two byte-indexed objects for equality */

EXPORT(void)
primitiveCompareBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg1;
    sqInt arg2;
    sqInt i;
    sqInt len1;
    sqInt len2;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	arg1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((((arg1 & 3) == 0)
 && (((((usqInt) (longAt(arg1))) >> 24) & 0x1F) >= 16))
		 && (((arg2 & 3) == 0)
		 && (((((usqInt) (longAt(arg2))) >> 24) & 0x1F) >= 16)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (arg1 == arg2) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return;
	}
	len1 = byteSizeOf(arg1);
	len2 = byteSizeOf(arg2);
	if (!(len1 == len2)) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp1;
		return;
	}
	for (i = 0; i < len1; i += 1) {
		if (!((byteAt((arg1 + (BaseHeaderSize)) + i)) == (byteAt((arg2 + (BaseHeaderSize)) + i)))) {
			/* begin pop:thenPush: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
	GIV(stackPointer) = sp3;
}


/*	Fill the receiver, which must be an indexable bytes or words 
	objects, with the given integer value. */

static void
primitiveConstantFill(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end;
    sqInt fillValue;
    usqInt i;
    sqInt rcvr;
    sqInt rcvrIsBytes;
    sqInt successBoolean;
    sqInt successBoolean1;

	fillValue = positive32BitValueOf(longAt(GIV(stackPointer)));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin success: */
	successBoolean1 = ((rcvr & 3) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) > 5);
	if (!successBoolean1) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	rcvrIsBytes = ((rcvr & 3) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 16);
	if (rcvrIsBytes) {
		/* begin success: */
		successBoolean = (fillValue >= 0)
		 && (fillValue <= 0xFF);
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		end = rcvr + (((numSlotsOf(rcvr)) << 2) + (BaseHeaderSize));
		i = rcvr + BaseHeaderSize;
		if (rcvrIsBytes) {
			while (i < end) {
				byteAtput(i, fillValue);
				i += 1;
			}
		}
		else {
			while (i < end) {
				long32Atput(i, fillValue);
				i += 4;
			}
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		null;
	}
}


/*	Special version of primitiveAt for accessing contexts.
	Written to be varargs for use from mirror primitives. */

static void
primitiveContextAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt class;
    sqInt class1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classTablePage;
    sqInt classTablePage1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqInt frameNumArgs;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt reasonCode;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    char *sp2;
    char *sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    sqInt value;
    sqInt value1;

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	index = (index >> 1);

	/* Duplicating much of stObject:at:put: here allows stObject:at:put: to omit tests for contexts. */

	aContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	hdr = longLongAt(aContext);
	if (!((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */

		/* begin stObject:at: */
		hdr1 = longLongAt(aContext);
		fmt1 = (((unsigned sqLong)hdr1) >> 24) & 0x1F;
		/* begin lengthOf:format: */
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(aContext)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots11 = ((usqInt) (((usqInt)(longAt(aContext + 4))))) >> 24;
		numSlots2 = (numSlots11 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(aContext - (BaseHeaderSize)))
			: numSlots11);
		if (fmt1 <= 9) {
			totalLength1 = numSlots2;
			goto l7;
		}
		if (fmt1 >= 16) {

			/* bytes, including CompiledMethod */

			totalLength1 = (numSlots2 << 2) - (fmt1 & 7);
			goto l7;
		}
		if (fmt1 >= 12) {
			totalLength1 = (numSlots2 << (2 - 1)) - (fmt1 & 3);
			goto l7;
		}
		totalLength1 = (numSlots2 << (2 - 2)) - (fmt1 & 1);
	l7:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 > 5)
		 || (fmt1 == 2)) {
			fixedFields1 = 0;
			goto l9;
		}
		if (fmt1 < 2) {
			fixedFields1 = totalLength1;
			goto l9;
		}
		/* begin fetchClassOfNonImm: */
		classIndex1 = (longAt(aContext)) & 0x3FFFFF;
		if (classIndex1 == 0x1F) {
			class1 = aContext;
			goto l8;
		}
		assert(classIndex1 >= (arrayClassIndexPun()));
		/* begin classAtIndex: */
		assert((classIndex1 <= (tagMask()))
		 || (classIndex1 >= (arrayClassIndexPun())));
		classTablePage1 = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex1) >> 10) << 2));
		if (classTablePage1 == GIV(nilObj)) {
			class1 = null;
			goto l8;
		}
		class1 = longAt((classTablePage1 + (BaseHeaderSize)) + ((classIndex1 & ((1 << 10) - 1)) << 2));
	l8:	/* end fetchClassOfNonImm: */;
		fixedFields1 = (((longAt((class1 + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
	l9:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == 3)
		 && ((hdr1 & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if ((((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
			 && (!(isWidowedContext(aContext)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((sp4 >> 1))) < (lengthOf(aContext)));
				stSize1 = sp4;
				goto l6;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + (BaseHeaderSize)) + (StackPointerIndex << 2));
			if (!((sp11 & 1))) {
				stSize1 = 0;
				goto l6;
			}
			assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(aContext)));
			stSize1 = (sp11 >> 1);
		l6:	/* end stackPointerForMaybeMarriedContext: */;
			if (((((usqInt) index)) >= (((usqInt) 1)))
			 && (((((usqInt) index)) <= (((usqInt) stSize1)))
			 && ((((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
			 && (!(isWidowedContext(aContext)))))) {
				value = noInlineTemporaryin(index - 1, frameOfMarriedContext(aContext));
				goto l10;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= 24
	? (((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((aContext + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((aContext + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((aContext + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((aContext + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1
	: 1)))
		 && ((((usqInt) index)) <= (((usqInt) stSize1)))) {
			/* begin subscript:with:format: */
			if (fmt1 <= 5) {
				value = longAt((aContext + (BaseHeaderSize)) + (((index + fixedFields1) - 1) << 2));
				goto l10;
			}
			if (fmt1 >= 16) {
				value = (((byteAt((aContext + (BaseHeaderSize)) + ((index + fixedFields1) - 1))) << 1) | 1);
				goto l10;
			}
			value = positive32BitIntegerFor(long32At((aContext + (BaseHeaderSize)) + (((index + fixedFields1) - 1) << 2)));
			goto l10;
		}
		/* begin primitiveFailFor: */
		reasonCode = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
		value = 0;
	l10:	/* end stObject:at: */;
		(!GIV(primFailCode)
			? (/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value),
				(GIV(stackPointer) = sp))
			: 0);
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
		/* begin lengthOf:format: */
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(aContext)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots1 = ((usqInt) (((usqInt)(longAt(aContext + 4))))) >> 24;
		numSlots = (numSlots1 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(aContext - (BaseHeaderSize)))
			: numSlots1);
		if (fmt <= 9) {
			totalLength = numSlots;
			goto l1;
		}
		if (fmt >= 16) {

			/* bytes, including CompiledMethod */

			totalLength = (numSlots << 2) - (fmt & 7);
			goto l1;
		}
		if (fmt >= 12) {
			totalLength = (numSlots << (2 - 1)) - (fmt & 3);
			goto l1;
		}
		totalLength = (numSlots << (2 - 2)) - (fmt & 1);
	l1:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 5)
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l5;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l5;
		}
		/* begin fetchClassOfNonImm: */
		classIndex = (longAt(aContext)) & 0x3FFFFF;
		if (classIndex == 0x1F) {
			class = aContext;
			goto l4;
		}
		assert(classIndex >= (arrayClassIndexPun()));
		/* begin classAtIndex: */
		assert((classIndex <= (tagMask()))
		 || (classIndex >= (arrayClassIndexPun())));
		classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
		if (classTablePage == GIV(nilObj)) {
			class = null;
			goto l4;
		}
		class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
	l4:	/* end fetchClassOfNonImm: */;
		fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
	l5:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp1 = longAt((aContext + (BaseHeaderSize)) + (StackPointerIndex << 2));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(aContext)));
		stSize = (sp1 >> 1);
	l2:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			(GIV(primFailCode) = PrimErrBadIndex);
			return;
		}
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			value = longAt((aContext + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2));
			goto l3;
		}
		if (fmt >= 16) {
			value = (((byteAt((aContext + (BaseHeaderSize)) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l3;
		}
		value = positive32BitIntegerFor(long32At((aContext + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2)));
	l3:	/* end subscript:with:format: */;
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp2;
		return;
	}
	/* begin frameOfMarriedContext: */
	value1 = longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2));
	/* begin withoutSmallIntegerTags: */
	assert((value1 & 1));
	spouseFP = pointerForOop(value1 - 1);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	value = ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))
		? longAt((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord))
		: longAt(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord)));
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp3;
}


/*	Special version of primitiveAtPut for accessing contexts.
	Written to be varargs for use from mirror primitives. */

static void
primitiveContextAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContext;
    sqInt class;
    sqInt class1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classTablePage;
    sqInt classTablePage1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqInt frameNumArgs;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt reasonCode;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    char *sp2;
    char *sp3;
    sqInt sp4;
    char *spouseFP;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    sqInt value;
    sqInt value1;
    sqInt valueToStore;
    sqInt valueToStore1;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aContext = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((index & 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	hdr = longLongAt(aContext);
	index = (index >> 1);
	if (!((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

		/* might be an instance of a subclass */

		/* begin stObject:at:put: */
		hdr1 = longLongAt(aContext);
		fmt1 = (((unsigned sqLong)hdr1) >> 24) & 0x1F;
		/* begin lengthOf:format: */
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(aContext)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots11 = ((usqInt) (((usqInt)(longAt(aContext + 4))))) >> 24;
		numSlots2 = (numSlots11 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(aContext - (BaseHeaderSize)))
			: numSlots11);
		if (fmt1 <= 9) {
			totalLength1 = numSlots2;
			goto l6;
		}
		if (fmt1 >= 16) {

			/* bytes, including CompiledMethod */

			totalLength1 = (numSlots2 << 2) - (fmt1 & 7);
			goto l6;
		}
		if (fmt1 >= 12) {
			totalLength1 = (numSlots2 << (2 - 1)) - (fmt1 & 3);
			goto l6;
		}
		totalLength1 = (numSlots2 << (2 - 2)) - (fmt1 & 1);
	l6:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt1 > 5)
		 || (fmt1 == 2)) {
			fixedFields1 = 0;
			goto l8;
		}
		if (fmt1 < 2) {
			fixedFields1 = totalLength1;
			goto l8;
		}
		/* begin fetchClassOfNonImm: */
		classIndex1 = (longAt(aContext)) & 0x3FFFFF;
		if (classIndex1 == 0x1F) {
			class1 = aContext;
			goto l7;
		}
		assert(classIndex1 >= (arrayClassIndexPun()));
		/* begin classAtIndex: */
		assert((classIndex1 <= (tagMask()))
		 || (classIndex1 >= (arrayClassIndexPun())));
		classTablePage1 = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex1) >> 10) << 2));
		if (classTablePage1 == GIV(nilObj)) {
			class1 = null;
			goto l7;
		}
		class1 = longAt((classTablePage1 + (BaseHeaderSize)) + ((classIndex1 & ((1 << 10) - 1)) << 2));
	l7:	/* end fetchClassOfNonImm: */;
		fixedFields1 = (((longAt((class1 + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
	l8:	/* end fixedFieldsOf:format:length: */;
		if ((fmt1 == 3)
		 && ((hdr1 & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
			/* begin stackPointerForMaybeMarriedContext: */
			if ((((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
			 && (!(isWidowedContext(aContext)))) {
				sp4 = stackPointerIndexForFrame(frameOfMarriedContext(aContext));
				assert((ReceiverIndex + ((sp4 >> 1))) < (lengthOf(aContext)));
				stSize1 = sp4;
				goto l5;
			}
			/* begin fetchStackPointerOf: */
			sp11 = longAt((aContext + (BaseHeaderSize)) + (StackPointerIndex << 2));
			if (!((sp11 & 1))) {
				stSize1 = 0;
				goto l5;
			}
			assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(aContext)));
			stSize1 = (sp11 >> 1);
		l5:	/* end stackPointerForMaybeMarriedContext: */;
			if (((((usqInt) index)) >= (((usqInt) 1)))
			 && (((((usqInt) index)) <= (((usqInt) stSize1)))
			 && ((((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
			 && (!(isWidowedContext(aContext)))))) {
				noInlineTemporaryinput(index - 1, frameOfMarriedContext(aContext), value);
				goto l9;
			}
		}
		else {
			stSize1 = totalLength1 - fixedFields1;
		}
		if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= 24
	? (((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((aContext + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((aContext + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((aContext + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((aContext + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1
	: 1)))
		 && ((((usqInt) index)) <= (((usqInt) stSize1)))) {
			/* begin subscript:with:storing:format: */
			if (fmt1 <= 5) {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(aContext)));
				if (isOldObject(aContext)) {

					/* most stores into young objects */

					if (((value & 3) == 0)
					 && ((((usqInt) value)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(aContext))) >> 29) & 1) != 0)) {
							remember(aContext);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(aContext, (longAt(aContext)) | (1 << 29));
						}
					}
				}
				longAtput((aContext + (BaseHeaderSize)) + (((index + fixedFields1) - 1) << 2), value);
			}
			else {
				if (fmt1 >= 16) {
					if (!((value & 1))) {
						GIV(primFailCode) = PrimErrBadIndex;
					}
					valueToStore1 = (value >> 1);
					if (!((valueToStore1 >= 0)
						 && (valueToStore1 <= 0xFF))) {
						GIV(primFailCode) = PrimErrBadArgument;
					}
					if (!GIV(primFailCode)) {
						byteAtput((aContext + (BaseHeaderSize)) + ((index + fixedFields1) - 1), valueToStore1);
					}
				}
				else {

					/* long-word type objects */

					valueToStore1 = positive32BitValueOf(value);
					if (!GIV(primFailCode)) {
						long32Atput((aContext + (BaseHeaderSize)) + (((index + fixedFields1) - 1) << 2), valueToStore1);
					}
				}
			}
		}
		else {
			/* begin primitiveFailFor: */
			reasonCode = (fmt1 <= 1
				? PrimErrBadReceiver
				: PrimErrBadIndex);
			GIV(primFailCode) = reasonCode;
		}
		value;
	l9:	/* end stObject:at:put: */;
		(!GIV(primFailCode)
			? (/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value),
				(GIV(stackPointer) = sp))
			: 0);
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!((((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(aContext))))) {
		fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
		/* begin lengthOf:format: */
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(aContext)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots1 = ((usqInt) (((usqInt)(longAt(aContext + 4))))) >> 24;
		numSlots = (numSlots1 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(aContext - (BaseHeaderSize)))
			: numSlots1);
		if (fmt <= 9) {
			totalLength = numSlots;
			goto l1;
		}
		if (fmt >= 16) {

			/* bytes, including CompiledMethod */

			totalLength = (numSlots << 2) - (fmt & 7);
			goto l1;
		}
		if (fmt >= 12) {
			totalLength = (numSlots << (2 - 1)) - (fmt & 3);
			goto l1;
		}
		totalLength = (numSlots << (2 - 2)) - (fmt & 1);
	l1:	/* end lengthOf:format: */;
		/* begin fixedFieldsOf:format:length: */
		if ((fmt > 5)
		 || (fmt == 2)) {
			fixedFields = 0;
			goto l4;
		}
		if (fmt < 2) {
			fixedFields = totalLength;
			goto l4;
		}
		/* begin fetchClassOfNonImm: */
		classIndex = (longAt(aContext)) & 0x3FFFFF;
		if (classIndex == 0x1F) {
			class = aContext;
			goto l3;
		}
		assert(classIndex >= (arrayClassIndexPun()));
		/* begin classAtIndex: */
		assert((classIndex <= (tagMask()))
		 || (classIndex >= (arrayClassIndexPun())));
		classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
		if (classTablePage == GIV(nilObj)) {
			class = null;
			goto l3;
		}
		class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
	l3:	/* end fetchClassOfNonImm: */;
		fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
	l4:	/* end fixedFieldsOf:format:length: */;
		/* begin fetchStackPointerOf: */
		sp1 = longAt((aContext + (BaseHeaderSize)) + (StackPointerIndex << 2));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(aContext)));
		stSize = (sp1 >> 1);
	l2:	/* end fetchStackPointerOf: */;
		if (!(((index >= 1) && (index <= stSize)))) {
			(GIV(primFailCode) = PrimErrBadIndex);
			return;
		}
		/* begin subscript:with:storing:format: */
		if (fmt <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(aContext)));
			if (isOldObject(aContext)) {

				/* most stores into young objects */

				if (((value & 3) == 0)
				 && ((((usqInt) value)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(aContext))) >> 29) & 1) != 0)) {
						remember(aContext);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(aContext, (longAt(aContext)) | (1 << 29));
					}
				}
			}
			longAtput((aContext + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2), value);
		}
		else {
			if (fmt >= 16) {
				if (!((value & 1))) {
					GIV(primFailCode) = PrimErrBadIndex;
				}
				valueToStore = (value >> 1);
				if (!((valueToStore >= 0)
					 && (valueToStore <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
				}
				if (!GIV(primFailCode)) {
					byteAtput((aContext + (BaseHeaderSize)) + ((index + fixedFields) - 1), valueToStore);
				}
			}
			else {

				/* long-word type objects */

				valueToStore = positive32BitValueOf(value);
				if (!GIV(primFailCode)) {
					long32Atput((aContext + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2), valueToStore);
				}
			}
		}
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp2;
		return;
	}
	/* begin frameOfMarriedContext: */
	value1 = longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2));
	/* begin withoutSmallIntegerTags: */
	assert((value1 & 1));
	spouseFP = pointerForOop(value1 - 1);
	if (!(((index >= 1) && (index <= (stackPointerIndexForFrame(spouseFP)))))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((index - 1) < ((frameNumArgs = byteAt((spouseFP + FoxFrameFlags) + 1)))) {
		longAtput((spouseFP + FoxCallerSavedIP) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}
	else {
		longAtput(((spouseFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - (index - 1)) * BytesPerWord), value);
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp3;
}


/*	Special version of primitiveSize for accessing contexts.
	Written to be varargs for use from mirror primitives. */

static void
primitiveContextSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt sz;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	hdr = longLongAt(rcvr);
	fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l1;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l1;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = rcvr;
		goto l3;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l3;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l3:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l4:	/* end fixedFieldsOf:format:length: */;
	if ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			sz = sp2;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + (BaseHeaderSize)) + (StackPointerIndex << 2));
		if (!((sp1 & 1))) {
			sz = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		sz = (sp1 >> 1);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
	}
	else {
		sz = totalLength - fixedFields;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((sz << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Lift the veil from a context and answer an integer describing its interior
	state. Used for e.g. VM tests so they can verify they're testing what they
	think they're testing.
	0 implies a vanilla heap context.
	Bit 0 = is or was married to a frame
	Bit 1 = is still married to a frame
	Bit 2 = frame is executing machine code
	Bit 3 = has machine code pc (as opposed to nil or a bytecode pc)
	Bit 4 = method is currently compiled to machine code */

static void
primitiveContextXray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;
    sqInt flags;
    char *sp;

	context = longAt(GIV(stackPointer));
	if (((longAt((context + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
		if (checkIsStillMarriedContextcurrentFP(context, GIV(framePointer))) {
			flags = 3;
		}
		else {
			flags = 1;
		}
	}
	else {
		flags = 0;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((flags << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

static void
primitiveControlVMProfiling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    char *sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((onOffBar = longAt(GIV(stackPointer) + (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((bufferSize & 1))
			 && (((bufferSize = (bufferSize >> 1))) > 0))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), ((numSamples << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class.
	Fail if the receiver or argument are non-pointer objects.
	Fail if the receiver or argument are contexts (because of context-to-stack
	mapping). Fail if receiver and argument have different lengths (for
	indexable objects).
	 */

static void
primitiveCopyObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt i;
    sqInt length;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l2;
	}
	arg = oop;
l2:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l3;
	}
	rcvr = oop1;
l3:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	if (!(((rcvr & 3) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) <= 5))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((((longAt(rcvr)) & 0x3FFFFF) == ClassMethodContextCompactIndex)
	 || (((longAt(arg)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((fetchClassOfNonImm(rcvr)) == (fetchClassOfNonImm(arg)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) <= 9) {
		length = numSlots;
		goto l1;
	}
	if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		length = (numSlots << 2) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 7);
		goto l1;
	}
	if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 12) {
		length = (numSlots << (2 - 1)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 3);
		goto l1;
	}
	length = (numSlots << (2 - 2)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 1);
l1:	/* end lengthOf:format: */;
	if (!(length == (lengthOfformat(arg, (((usqInt) (longAt(arg))) >> 24) & 0x1F)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	for (i = 0; i < length; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(rcvr)));
		if (isOldObject(rcvr)) {

			/* most stores into young objects */

			if ((((longAt((arg + (BaseHeaderSize)) + (i << 2))) & 3) == 0)
			 && ((((usqInt) (longAt((arg + (BaseHeaderSize)) + (i << 2))))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
					remember(rcvr);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
				}
			}
		}
		longAtput((rcvr + (BaseHeaderSize)) + (i << 2), longAt((arg + (BaseHeaderSize)) + (i << 2)));
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
}


/*	Crash the VM by indirecting through a null pointer. If the sole argument
	is true crash in this thread, and if it is false crash in a new thread. If
	the argument is an integer use the method that implies.
	bit 0 = thread to crash in; 1 => this thread
	bit 1 = crash method; 0 => indirect through null pointer; 1 => call exit */

EXPORT(sqInt)
primitiveCrashVM(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt crashInThisThread;

	if (((longAt(GIV(stackPointer))) & 1)) {
		crashInThisThread = ((longAt(GIV(stackPointer))) >> 1);
	}
	else {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			crashInThisThread = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			crashInThisThread = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		crashInThisThread = null;
	l1:	/* end booleanValueOf: */;
	}
	if (GIV(primFailCode)
	 || (GIV(argumentCount) != 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	crashInThisOrAnotherThread(crashInThisThread);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
}


/*	Set or clear the flag that controls whether modifications of 
	the Display object are propagated to the underlying 
	platform's screen. */

static void
primitiveDeferDisplayUpdates(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt flag;

	flag = longAt(GIV(stackPointer));
	if (flag == GIV(trueObj)) {
		deferDisplayUpdates = 1;
	}
	else {
		if (flag == GIV(falseObj)) {
			deferDisplayUpdates = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		null;
	}
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

EXPORT(sqInt)
primitiveDisablePowerManager(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integer = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integer = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		null;
	}
}

static void
primitiveDiv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    char *sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((quotient ^ (quotient << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((quotient << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}

static void
primitiveDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerReceiver = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArgument = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!GIV(primFailCode)) {
			if (((integerReceiver / integerArgument) ^ ((integerReceiver / integerArgument) << 1)) >= 0) {
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((integerReceiver / integerArgument) << 1) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin success: */
				
				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}

			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveDivideLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!(!GIV(primFailCode))) {
		return;
	}
	if (!((b != 0)
		 && ((a % b) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveDivLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong rem;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		return;
	}
	result = a / b;
	if (!(a == 0)) {
		if (!(bIsNegative == aIsNegative)) {

			/* Round toward negative infinity */

			rem = a % b;
			if (!(rem == 0)) {

				/* This can not overflow, because b > 1, otherwise rem = 0 */

				result += 1;
			}
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Simulate an primitiveExternalCall invocation (e.g. for the Debugger). Do
	not cache anything.
	e.g. ContextPart>>tryNamedPrimitiveIn: aCompiledMethod for: aReceiver
	withArgs: arguments */

static void
primitiveDoNamedPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt argumentArray;
    usqInt arraySize;
    sqInt ccIndex;
    sqInt ctxtRcvr;
    sqInt firstBytecode;
    sqInt functionLength;
    sqInt functionName;
    sqInt index;
    sqInt isArray;
    sqInt methodArg;
    sqInt methodHeader;
    sqInt moduleLength;
    sqInt moduleName;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    usqInt numSlots4;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt oop3;
    sqInt oop4;
    sqInt oop5;
    sqInt oop6;
    sqInt oop7;
    sqInt primBits;
    sqInt primRcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt spec;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt top;
    sqInt top1;

	argumentArray = longAt(GIV(stackPointer));
	methodArg = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((argumentArray & 3) == 0)
 && (((((usqInt) (longAt(argumentArray))) >> 24) & 0x1F) == 2))
		 && (((methodArg & 3) == 0)
		 && (((((usqInt) (longAt(methodArg))) >> 24) & 0x1F) >= 24)))) {
		(GIV(primFailCode) = -2);
		return;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots3 = ((usqInt) (((usqInt)(longAt(argumentArray + 4))))) >> 24;
	arraySize = (numSlots3 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(argumentArray - (BaseHeaderSize)))
		: numSlots3);
	if (!(roomToPushNArgs(arraySize))) {
		(GIV(primFailCode) = -2);
		return;
	}
	methodHeader = longAt((methodArg + (BaseHeaderSize)) + (HeaderIndex << 2));
	if (!((
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) > 2)) {
		(GIV(primFailCode) = -3);
		return;
	}

	/* first literal */

	spec = longAt((methodArg + (BaseHeaderSize)) + (1 << 2));
	/* begin is:instanceOf:compactClassIndex: */
	if ((spec & 3) != 0) {
		isArray = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(spec)));
	ccIndex = (longAt(spec)) & 0x3FFFFF;
	isArray = ClassArrayCompactIndex == ccIndex;
	goto l2;

	isArray = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassArray << 2))) == (classAtIndex(ccIndex));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!(isArray
		 && (((lengthOfformat(spec, (((usqInt) (longAt(spec))) >> 24) & 0x1F)) == 4)
		 && ((
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (methodHeader & (65536 << SmallIntegerShift)
				? ((firstBytecode = (methodArg + ((LiteralStart + ((((usqInt) methodHeader) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
					(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
				: 0)
		: ((primBits = ((usqInt) methodHeader) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#else /* MULTIPLEBYTECODESETS */
	((primBits = ((usqInt) methodHeader) >> 1),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#endif /* MULTIPLEBYTECODESETS */
	) == 117)))) {
		(GIV(primFailCode) = -3);
		return;
	}
	if (!(((((usqInt) methodHeader) >> 25) & 15) == arraySize)) {
		(GIV(primFailCode) = -2);
		return;
	}
	moduleName = longAt((spec + (BaseHeaderSize)) + (0 << 2));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		/* begin success: */
		successBoolean = ((moduleName & 3) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) >= 16);
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		/* begin lengthOf:format: */
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(moduleName)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots2 = ((usqInt) (((usqInt)(longAt(moduleName + 4))))) >> 24;
		numSlots = (numSlots2 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(moduleName - (BaseHeaderSize)))
			: numSlots2);
		if (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) <= 9) {
			moduleLength = numSlots;
			goto l1;
		}
		if (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) >= 16) {

			/* bytes, including CompiledMethod */

			moduleLength = (numSlots << 2) - (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) & 7);
			goto l1;
		}
		if (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) >= 12) {
			moduleLength = (numSlots << (2 - 1)) - (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) & 3);
			goto l1;
		}
		moduleLength = (numSlots << (2 - 2)) - (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) & 1);
	l1:	/* end lengthOf:format: */;
		
	}
	functionName = longAt((spec + (BaseHeaderSize)) + (1 << 2));
	/* begin success: */
	successBoolean1 = ((functionName & 3) == 0)
	 && (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) >= 16);
	if (!successBoolean1) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(functionName)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots4 = ((usqInt) (((usqInt)(longAt(functionName + 4))))) >> 24;
	numSlots1 = (numSlots4 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(functionName - (BaseHeaderSize)))
		: numSlots4);
	if (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) <= 9) {
		functionLength = numSlots1;
		goto l3;
	}
	if (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		functionLength = (numSlots1 << 2) - (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) & 7);
		goto l3;
	}
	if (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) >= 12) {
		functionLength = (numSlots1 << (2 - 1)) - (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) & 3);
		goto l3;
	}
	functionLength = (numSlots1 << (2 - 2)) - (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) & 1);
l3:	/* end lengthOf:format: */;
	if (!(!GIV(primFailCode))) {
		(GIV(primFailCode) = -3);
		return;
	}
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (addr == 0) {
		(GIV(primFailCode) = -1);
		return;
	}
	/* begin pushRemappableOop: */
	oop = (argumentArray = popStack());
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin pushRemappableOop: */
	oop1 = (primRcvr = popStack());
	assert(addressCouldBeOop(oop1));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop1;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin pushRemappableOop: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop2 = top;
	assert(addressCouldBeOop(oop2));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop2;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin pushRemappableOop: */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop3 = top1;
	assert(addressCouldBeOop(oop3));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop3;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), primRcvr);
	GIV(stackPointer) = sp5;
	GIV(argumentCount) = arraySize;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + (BaseHeaderSize)) + ((index - 1) << 2)));
		GIV(stackPointer) = sp;
	}
	/* begin callExternalPrimitive: */
	dispatchFunctionPointer(addr);
	/* begin popRemappableOop */
	oop4 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	ctxtRcvr = oop4;
	/* begin popRemappableOop */
	oop5 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	methodArg = oop5;
	/* begin popRemappableOop */
	oop6 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	primRcvr = oop6;
	/* begin popRemappableOop */
	oop7 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	argumentArray = oop7;
	if (!(!GIV(primFailCode))) {

		/* If primitive failed, then restore state for failure code */

		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		null;
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ctxtRcvr);
		GIV(stackPointer) = sp1;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), methodArg);
		GIV(stackPointer) = sp2;
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), primRcvr);
		GIV(stackPointer) = sp3;
		/* begin push: */
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), argumentArray);
		GIV(stackPointer) = sp4;

		/* Hack.  A nil prim error code (primErrorCode = 1) is interpreted by the image
		   as meaning this primitive is not implemented.  So to pass back nil as an error
		   code we use -1 to indicate generic failure. */

		GIV(argumentCount) = 3;
		if (GIV(primFailCode) == 1) {
			GIV(primFailCode) = -1;
		}
	}
}

static void
primitiveDoPrimitiveWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt index;
    sqInt integerPointer;
    sqInt nArgs;
    usqInt numSlots;
    sqInt primIdx;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt successBoolean;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & 3) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 24) & 0x1F) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(argumentArray + 4))))) >> 24;
	arraySize = (numSlots == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(argumentArray - (BaseHeaderSize)))
		: numSlots);
	/* begin success: */
	successBoolean = roomToPushNArgs(arraySize);
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		primIdx = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		primIdx = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primIdx > MaxPrimitiveIndex
	? 0
	: primitiveTable[primIdx])));
	if (primitiveFunctionPointer == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	null;
	GIV(argumentCount) = arraySize;
	index = 1;
	while (index <= GIV(argumentCount)) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + (BaseHeaderSize)) + ((index - 1) << 2)));
		GIV(stackPointer) = sp;
		index += 1;
	}
	if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
		externalQuickPrimitiveResponse();
		return;
	}

	/* prim might alloc/gc */
	/* Run the primitive (sets primFailCode) */

	GIV(tempOop) = argumentArray;
	/* begin slowPrimitiveResponse */
	nArgs = GIV(argumentCount);
	savedStackPointer = GIV(stackPointer);
	savedFramePointer = GIV(framePointer);

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	dispatchFunctionPointer(primitiveFunctionPointer);
	if (FailImbalancedPrimitives
	 && ((!GIV(primFailCode))
	 && (GIV(framePointer) == savedFramePointer))) {

		/* Don't fail if primitive has done something radical, e.g. perform: */

		if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
			flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
			GIV(stackPointer) = savedStackPointer;
			failUnbalancedPrimitive();
		}
	}
	if (GIV(nextProfileTick) > 0) {
		checkProfileTick(GIV(newMethod));
	}
	!GIV(primFailCode);
	if (!(!GIV(primFailCode))) {

		/* If primitive failed, then restore state for failure code */

		/* begin pop: */
		GIV(stackPointer) += arraySize * BytesPerWord;
		null;
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ((primIdx << 1) | 1));
		GIV(stackPointer) = sp1;
		null;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(tempOop));
		GIV(stackPointer) = sp2;
		GIV(argumentCount) = 2;
	}
	GIV(tempOop) = 0;
}


/*	Attempt to enter a CriticalSection/Mutex. If not owned, set the owner to
	the current
	process and answer false. If owned by the current process answer true.
	Otherwise suspend the process. Answer if the receiver is owned by the
	current process.
	For simulation if there is an argument it is taken to be the effective
	activeProcess (see Process>>effectiveProcess). */

static void
primitiveEnterCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer));
		activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
	}

	/* CriticalSections are laid out like Semaphores */

	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + (BaseHeaderSize)) + (owningProcessIndex << 2));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		if (isOldObject(criticalSection)) {

			/* most stores into young objects */

			if (((activeProc & 3) == 0)
			 && ((((usqInt) activeProc)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(criticalSection))) >> 29) & 1) != 0)) {
					remember(criticalSection);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(criticalSection, (longAt(criticalSection)) | (1 << 29));
				}
			}
		}
		longAtput((criticalSection + (BaseHeaderSize)) + (owningProcessIndex << 2), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp2;
	addLastLinktoList(activeProc, criticalSection);
	transferTo(wakeHighestPriority());
}

static void
primitiveEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt result;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerArgument = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerReceiver = top1;
	/* begin compare31or32Bits:equal: */
	if (((integerReceiver & 1))
	 && ((integerArgument & 1))) {
		result = integerReceiver == integerArgument;
		goto l1;
	}
	result = (positive32BitValueOf(integerReceiver)) == (positive32BitValueOf(integerArgument));
l1:	/* end compare31or32Bits:equal: */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		/* begin push: */
		object = (result
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr == integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

sqInt
primitiveErrorTable(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
}


/*	With 0 args answers whether ioProcessEvents is enabled and being called.
	With 1 arg expects a boolean which will enable ioProcessEvents if true and
	disable it if false, answering its previous state. */

EXPORT(void)
primitiveEventProcessingControl(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt enabled;
    char *sp;
    char *sp1;

	enabled = inIOProcessEvents >= 0;
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			if (inIOProcessEvents < 0) {
				inIOProcessEvents = 0;
			}
		}
		else {
			if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
				inIOProcessEvents = -1;
			}
			else {
				GIV(primFailCode) = PrimErrBadArgument;
				return;
			}
		}
		/* begin pop:thenPushBool: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (enabled
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp1;
		return;
	}
	GIV(primFailCode) = PrimErrBadNumArgs;
}


/*	receiver, args, then method are on top of stack. Execute method against
	receiver and args.
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and
	hence primitiveFunctionPointer is stale. */

static void
primitiveExecuteMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt firstBytecode;
    sqInt i;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt table;
    sqInt top;

	methodArgument = longAt(GIV(stackPointer));
	if (!(((methodArgument & 3) == 0)
		 && (((((usqInt) (longAt(methodArgument))) >> 24) & 0x1F) >= 24))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (!((GIV(argumentCount) - 1) == ((((usqInt) (longAt((methodArgument + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 25) & 15))) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(newMethod) = ((sqInt) top);
	primitiveIndex = 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? ((longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
						? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + ((((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
							(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
						: 0)
				: ((primBits = ((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
					(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#  else /* MULTIPLEBYTECODESETS */
		((primBits = ((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#  endif /* MULTIPLEBYTECODESETS */
		;
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) -= 1;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			null;
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		if (FailImbalancedPrimitives
		 && ((!GIV(primFailCode))
		 && (GIV(framePointer) == savedFramePointer))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */

			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				GIV(stackPointer) = savedStackPointer;
				failUnbalancedPrimitive();
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			null;
			goto l1;
		}
	}
	/* begin activateNewMethod */
	/* begin justActivateNewMethod */
	methodHeader1 = longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2));
	numTemps = (((usqInt) methodHeader1) >> 19) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> 25) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((headerOf(GIV(method))) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) methodHeader1)) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	/* begin push: */
	object = ((1 + (numArgs << 8)) + (0)) + (0);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? (((usqInt) methodHeader1) >> 1) & 0xFFFF
		: (((usqInt) methodHeader1) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader1) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize)) - 1;
	if (
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader1)) < 0
				? methodHeader1 & (65536 << SmallIntegerShift)
				: (methodHeader1 & 536871934) != 0)
#  else /* MULTIPLEBYTECODESETS */
		(methodHeader1 & 536871934) != 0
#  endif /* MULTIPLEBYTECODESETS */
		) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 
#    if MULTIPLEBYTECODESETS
			((((sqInt) methodHeader1)) < 0
						? 3
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? 234
		: 129)
#else /* MULTIPLEBYTECODESETS */
	129
#endif /* MULTIPLEBYTECODESETS */
	)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
					if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
						errorCode = longAt((table + (BaseHeaderSize)) + ((GIV(primFailCode) - 1) << 2));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	receiver, argsArray, then method are on top of stack. Execute method
	against receiver and args. Allow for up to two extra arguments (e.g. for
	mirror primitives).
	Set primitiveFunctionPointer because no cache lookup has been done for the
	method, and hence primitiveFunctionPointer is stale. */

static void
primitiveExecuteMethodArgsArray(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argCnt;
    sqInt argumentArray;
    sqInt errorCode;
    sqInt firstBytecode;
    sqInt i;
    sqInt i1;
    sqInt methodArgument;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt primBits;
    sqInt primitiveIndex;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;

	methodArgument = longAt(GIV(stackPointer));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((methodArgument & 3) == 0)
 && (((((usqInt) (longAt(methodArgument))) >> 24) & 0x1F) >= 24))
		 && (((argumentArray & 3) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 24) & 0x1F) == 2)))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	argCnt = (((usqInt) (longAt((methodArgument + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 25) & 15;
	if (!(argCnt == (numSlotsOf(argumentArray)))) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	if (GIV(argumentCount) > 2) {

		/* CompiledMethod class>>receiver:withArguments:executeMethod:
		   SqueakObjectPrimitives class >> receiver:withArguments:apply:
		   VMMirror>>ifFail:object:with:executeMethod: et al */

		if (GIV(argumentCount) > 4) {
			(GIV(primFailCode) = PrimErrUnsupported);
			return;
		}
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), longAt(GIV(stackPointer) + (2 * BytesPerWord)));
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	null;
	for (i = 0; i < argCnt; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + (BaseHeaderSize)) + (i << 2)));
		GIV(stackPointer) = sp;
	}
	GIV(newMethod) = methodArgument;
	primitiveIndex = 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? ((longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
						? ((firstBytecode = (GIV(newMethod) + ((LiteralStart + ((((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
							(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
						: 0)
				: ((primBits = ((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
					(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#  else /* MULTIPLEBYTECODESETS */
		((primBits = ((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#  endif /* MULTIPLEBYTECODESETS */
		;
	/* begin functionPointerFor:inClass: */
	primitiveFunctionPointer = ((void (*)(void)) ((primitiveIndex > MaxPrimitiveIndex
	? 0
	: primitiveTable[primitiveIndex])));
	GIV(argumentCount) = argCnt;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			null;
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		if (FailImbalancedPrimitives
		 && ((!GIV(primFailCode))
		 && (GIV(framePointer) == savedFramePointer))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */

			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				GIV(stackPointer) = savedStackPointer;
				failUnbalancedPrimitive();
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			null;
			goto l1;
		}
	}
	/* begin activateNewMethod */
	/* begin justActivateNewMethod */
	methodHeader1 = longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2));
	numTemps = (((usqInt) methodHeader1) >> 19) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> 25) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((headerOf(GIV(method))) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) methodHeader1)) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	/* begin push: */
	object = ((1 + (numArgs << 8)) + (0)) + (0);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? (((usqInt) methodHeader1) >> 1) & 0xFFFF
		: (((usqInt) methodHeader1) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader1) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize)) - 1;
	if (
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader1)) < 0
				? methodHeader1 & (65536 << SmallIntegerShift)
				: (methodHeader1 & 536871934) != 0)
#  else /* MULTIPLEBYTECODESETS */
		(methodHeader1 & 536871934) != 0
#  endif /* MULTIPLEBYTECODESETS */
		) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 
#    if MULTIPLEBYTECODESETS
			((((sqInt) methodHeader1)) < 0
						? 3
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? 234
		: 129)
#else /* MULTIPLEBYTECODESETS */
	129
#endif /* MULTIPLEBYTECODESETS */
	)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
					if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
						errorCode = longAt((table + (BaseHeaderSize)) + ((GIV(primFailCode) - 1) << 2));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Exit the critical section.
	This may change the active process as a result. */

static void
primitiveExitCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;


	/* rcvr */

	criticalSection = longAt(GIV(stackPointer));

	/* CriticalSections are laid out like Semaphores */

	owningProcessIndex = ExcessSignalsIndex;
	if ((longAt((criticalSection + (BaseHeaderSize)) + (FirstLinkIndex << 2))) == GIV(nilObj)) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		longAtput((criticalSection + (BaseHeaderSize)) + (owningProcessIndex << 2), GIV(nilObj));
	}
	else {

		/* store check unnecessary because criticalSection referred to owningProcess
		   via its FirstLinkIndex slot before owningProcess was removed. */

		owningProcess = removeFirstLinkOfList(criticalSection);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		longAtput((criticalSection + (BaseHeaderSize)) + (owningProcessIndex << 2), owningProcess);
		resumepreemptedYieldingIf(owningProcess, GIV(preemptionYields));
	}
}

static void
primitiveExitToDebugger(void)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power. */

static void
primitiveExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		rcvr = result;
		goto l2;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = exp(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Exponent part of this float. */

static void
primitiveExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double frac;
    sqInt isFloat;
    sqInt oop;
    int pwr;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		rcvr = result;
		goto l2;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {

		/* rcvr = frac * 2^pwr, where frac is in [0.5..1.0) */

		frac = frexp(rcvr, &pwr);
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), (((pwr - 1) << 1) | 1));
		GIV(stackPointer) = sp;
		null;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Call an external primitive. External primitive methods first literals are
	an array of
	* The module name (String | Symbol) 
	* The function name (String | Symbol) 
	* The session ID (SmallInteger) [OBSOLETE] 
	* The function index (Integer) in the externalPrimitiveTable
	For fast interpreter dispatch in subsequent invocations the
	primitiveFunctionPointer in the method cache is rewritten, either to the
	function itself, or to zero if the external
	function is not found. This allows for fast responses as long as the
	method stays in
	the cache. The cache rewrite relies on lastMethodCacheProbeWrite which is
	set in
	addNewMethodToCache:. 
	Now that the VM flushes function addresses from its tables, the session ID
	is obsolete,
	but it is kept for backward compatibility. Also, a failed lookup is
	reported specially. If a
	method has been looked up and not been found, the function address is
	stored as -1
	(i.e., the SmallInteger -1 to distinguish from 16rFFFFFFFF which may be
	returned from
	lookup), and the primitive fails with PrimErrNotFound.
 */

static void
primitiveExternalCall(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    void (*addr)();
    sqInt functionLength;
    sqInt functionName;
    sqInt i;
    sqInt index;
    sqInt lit;
    sqInt moduleLength;
    sqInt moduleName;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;


	/* Fetch the first literal of the method */

	if (!((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) > 0)) {
		(GIV(primFailCode) = PrimErrBadMethod);
		return;
	}

	/* Check if it's an array of length 4 */

	lit = longAt((GIV(newMethod) + (BaseHeaderSize)) + ((0 + LiteralStart) << 2));
	if (!((((lit & 3) == 0)
 && (((((usqInt) (longAt(lit))) >> 24) & 0x1F) == 2))
		 && ((lengthOfformat(lit, (((usqInt) (longAt(lit))) >> 24) & 0x1F)) == 4))) {
		(GIV(primFailCode) = PrimErrBadMethod);
		return;
	}
	index = longAt((lit + (BaseHeaderSize)) + (3 << 2));
	if (!((index & 1))) {
		(GIV(primFailCode) = PrimErrBadMethod);
		return;
	}

	/* Check if we have already looked up the function and failed. */

	index = (index >> 1);
	if (index < 0) {

		/* Function address was not found in this session,
		   Void the primitive function. */

		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);
		(GIV(primFailCode) = PrimErrNotFound);
		return;
	}
	if ((index > 0)
	 && (index <= MaxExternalPrimitiveTableSize)) {
		addr = externalPrimitiveTable[index - 1];
		if (addr != 0) {
			rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);
			/* begin callExternalPrimitive: */
			dispatchFunctionPointer(addr);
			return;
		}
		(GIV(primFailCode) = PrimErrNamedInternal);
		return;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + (BaseHeaderSize)) + (2 << 2), ConstZero);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + (BaseHeaderSize)) + (3 << 2), ConstZero);
	moduleName = longAt((lit + (BaseHeaderSize)) + (0 << 2));
	if (moduleName == GIV(nilObj)) {
		moduleLength = 0;
	}
	else {
		if (!(((moduleName & 3) == 0)
			 && (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) >= 16))) {
			GIV(primFailCode) = PrimErrBadMethod;
		}
		/* begin lengthOf:format: */
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(moduleName)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots2 = ((usqInt) (((usqInt)(longAt(moduleName + 4))))) >> 24;
		numSlots = (numSlots2 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(moduleName - (BaseHeaderSize)))
			: numSlots2);
		if (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) <= 9) {
			moduleLength = numSlots;
			goto l1;
		}
		if (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) >= 16) {

			/* bytes, including CompiledMethod */

			moduleLength = (numSlots << 2) - (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) & 7);
			goto l1;
		}
		if (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) >= 12) {
			moduleLength = (numSlots << (2 - 1)) - (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) & 3);
			goto l1;
		}
		moduleLength = (numSlots << (2 - 2)) - (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) & 1);
	l1:	/* end lengthOf:format: */;
	}
	functionName = longAt((lit + (BaseHeaderSize)) + (1 << 2));
	if (!(((functionName & 3) == 0)
		 && (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) >= 16))) {
		GIV(primFailCode) = PrimErrBadMethod;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(functionName)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots3 = ((usqInt) (((usqInt)(longAt(functionName + 4))))) >> 24;
	numSlots1 = (numSlots3 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(functionName - (BaseHeaderSize)))
		: numSlots3);
	if (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) <= 9) {
		functionLength = numSlots1;
		goto l3;
	}
	if (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		functionLength = (numSlots1 << 2) - (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) & 7);
		goto l3;
	}
	if (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) >= 12) {
		functionLength = (numSlots1 << (2 - 1)) - (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) & 3);
		goto l3;
	}
	functionLength = (numSlots1 << (2 - 2)) - (((((usqInt) (longAt(functionName))) >> 24) & 0x1F) & 1);
l3:	/* end lengthOf:format: */;
	addr = ioLoadExternalFunctionOfLengthFromModuleOfLength(functionName + BaseHeaderSize, functionLength, moduleName + BaseHeaderSize, moduleLength);
	if (addr == 0) {
		index = -1;
	}
	else {

		/* add the function to the external primitive table */

		/* begin addToExternalPrimitiveTable: */
		for (i = GIV(externalPrimitiveTableFirstFreeIndex); i < MaxExternalPrimitiveTableSize; i += 1) {
			if ((externalPrimitiveTable[i]) == 0) {
				externalPrimitiveTable[i] = addr;
				index = (GIV(externalPrimitiveTableFirstFreeIndex) = i + 1);
				goto l2;
			}
		}
		index = 0;
	l2:	/* end addToExternalPrimitiveTable: */;
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(lit)));
	longAtput((lit + (BaseHeaderSize)) + (3 << 2), ((index << 1) | 1));
	if (index >= 0) {
		rewriteMethodCacheEntryForExternalPrimitiveToFunction(addr);
		/* begin callExternalPrimitive: */
		dispatchFunctionPointer(addr);
	}
	else {

		/* Otherwise void the primitive function and fail */

		rewriteMethodCacheEntryForExternalPrimitiveToFunction(0);
		(GIV(primFailCode) = PrimErrNotFound);
		return;
	}
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

sqInt
primitiveFailFor(sqInt reasonCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}

sqInt
primitiveFailureCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}


/*	Primitive. Search up the context stack for the next method context marked
	for exception handling starting at the receiver. Return nil if none found */

static void
primitiveFindHandlerContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt handlerOrNilOrZero;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(199, longAt(GIV(stackPointer)), GIV(nilObj));
	if (handlerOrNilOrZero == 0) {
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}


/*	Primitive. Search up the context stack for the next method context marked
	for unwind
	handling from the receiver up to but not including the argument. Return
	nil if none found.
 */

static void
primitiveFindNextUnwindContext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calleeContext;
    sqInt handlerOrNilOrZero;
    char *sp;
    sqInt startContext;
    sqInt stopContext;
    char *theFP;
    sqInt value;

	stopContext = longAt(GIV(stackPointer));
	calleeContext = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((stopContext == GIV(nilObj))
		 || (((stopContext & 3) == 0)
		 && (((longAt(stopContext)) & 0x3FFFFF) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((((longAt((calleeContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
	 && (!(isWidowedContext(calleeContext)))) {
		/* begin frameOfMarriedContext: */
		value = longAt((calleeContext + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		if ((longAt(theFP + FoxSavedFP)) == 0) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, longAt(theFP + FoxCallerContext), stopContext);
		}
		else {
			handlerOrNilOrZero = findMethodWithPrimitiveFromFPUpToContext(198, frameCallerFP(theFP), stopContext);
		}
	}
	else {
		startContext = longAt((calleeContext + (BaseHeaderSize)) + (SenderIndex << 2));
		if (((startContext & 3) == 0)
		 && (((longAt(startContext)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
			handlerOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, startContext, stopContext);
		}
		else {
			handlerOrNilOrZero = 0;
		}
	}
	if (handlerOrNilOrZero == 0) {
		handlerOrNilOrZero = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), handlerOrNilOrZero);
	GIV(stackPointer) = sp;
}

static void
primitiveFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatAdd:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(rcvrOop)));
	ccIndex = (longAt(rcvrOop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(argOop)));
	ccIndex1 = (longAt(argOop)) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto(argOop + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

static void
primitiveFloatAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    sqInt reasonCode;
    usqInt result;
    char *sp;
    char *sp1;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (index == ConstOne) {
		result = positive32BitIntegerFor(fetchLong32ofObject(1, rcvr));
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		result = positive32BitIntegerFor(fetchLong32ofObject(0, rcvr));
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

static void
primitiveFloatAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    sqInt reasonCode;
    char *sp;
    char *sp1;
    usqInt valueToStore;

	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	oopToStore = longAt(GIV(stackPointer));
	valueToStore = positive32BitValueOf(oopToStore);
	if (!(!GIV(primFailCode))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (index == ConstOne) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex = 1;
		long32Atput((rcvr + (BaseHeaderSize)) + (fieldIndex << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex1 = 0;
		long32Atput((rcvr + (BaseHeaderSize)) + (fieldIndex1 << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}

static void
primitiveFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatDivide:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(rcvrOop)));
	ccIndex = (longAt(rcvrOop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(argOop)));
	ccIndex1 = (longAt(argOop)) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto(argOop + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin success: */
	if (!(arg != 0.0)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer) + (1 * BytesPerWord)))));
	ccIndex = (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord)))) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer)))));
	ccIndex1 = (longAt(longAt(GIV(stackPointer)))) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer))) + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatGreaterOrEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer) + (1 * BytesPerWord)))));
	ccIndex = (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord)))) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer)))));
	ccIndex1 = (longAt(longAt(GIV(stackPointer)))) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer))) + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr >= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatGreater:thanArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer) + (1 * BytesPerWord)))));
	ccIndex = (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord)))) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer)))));
	ccIndex1 = (longAt(longAt(GIV(stackPointer)))) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer))) + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr > arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatLessOrEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer) + (1 * BytesPerWord)))));
	ccIndex = (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord)))) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer)))));
	ccIndex1 = (longAt(longAt(GIV(stackPointer)))) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer))) + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr <= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatLess:thanArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer) + (1 * BytesPerWord)))));
	ccIndex = (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord)))) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer)))));
	ccIndex1 = (longAt(longAt(GIV(stackPointer)))) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer))) + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr < arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatMultiply:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(rcvrOop)));
	ccIndex = (longAt(rcvrOop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(argOop)));
	ccIndex1 = (longAt(argOop)) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto(argOop + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr * arg));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatEqual:toArg: */
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 1)) {
		rcvr = ((double) (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer) + (1 * BytesPerWord)))));
	ccIndex = (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord)))) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer))) & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer)))));
	ccIndex1 = (longAt(longAt(GIV(stackPointer)))) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer))) + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (!aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatSubtract:fromArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((rcvrOop & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(rcvrOop)));
	ccIndex = (longAt(rcvrOop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + (BaseHeaderSize), result);
		rcvr = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l4:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if ((argOop & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(argOop)));
	ccIndex1 = (longAt(argOop)) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto(argOop + (BaseHeaderSize), result1);
		arg = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l6:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr - arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Clear the method lookup cache. This must be done after every programming
	change. 
 */

static void
primitiveFlushCache(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt i2;

	/* begin flushMethodCache */
	for (i2 = 1; i2 <= MethodCacheSize; i2 += 1) {
		GIV(methodCache)[i2] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin flushAtCache */
	for (i = 1; i <= AtCacheTotalSize; i += 1) {
		GIV(atCache)[i] = 0;
	}
}


/*	The receiver is a compiledMethod. Clear all entries in the method lookup
	cache that refer to this method, presumably because it has been redefined,
	overridden or removed.
 */

static void
primitiveFlushCacheByMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstBytecode;
    sqInt i;
    sqInt i1;
    sqInt oldMethod;
    sqInt primBits;
    sqInt primIdx;
    sqInt probe;

	oldMethod = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheMethod]) == oldMethod) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	primIdx = 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((oldMethod + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? ((longAt((oldMethod + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
						? ((firstBytecode = (oldMethod + ((LiteralStart + ((((usqInt) (longAt((oldMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
							(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
						: 0)
				: ((primBits = ((usqInt) (longAt((oldMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
					(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#  else /* MULTIPLEBYTECODESETS */
		((primBits = ((usqInt) (longAt((oldMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#  endif /* MULTIPLEBYTECODESETS */
		;
	if (primIdx == PrimitiveExternalCallIndex) {

		/* It's primitiveExternalCall */

		flushExternalPrimitiveOf(oldMethod);
	}
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
}


/*	The receiver is a message selector. Clear all entries in the method lookup
	cache with this selector, presumably because an associated method has been
	redefined.  */

static void
primitiveFlushCacheBySelector(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt i1;
    sqInt probe;
    sqInt selector;

	selector = longAt(GIV(stackPointer));
	probe = 0;
	for (i = 1; i <= MethodCacheEntries; i += 1) {
		if ((GIV(methodCache)[probe + MethodCacheSelector]) == selector) {
			GIV(methodCache)[probe + MethodCacheSelector] = 0;
		}
		probe += MethodCacheEntrySize;
	}
	if ((selector == (longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((16 * 2) << 2))))
	 || (selector == (longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((17 * 2) << 2))))) {
		/* begin flushAtCache */
		for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
			GIV(atCache)[i1] = 0;
		}
	}
}


/*	Primitive. Flush all the existing external primitives in the image thus
	forcing a reload on next invokation.
 */

static void
primitiveFlushExternalPrimitives(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt firstBytecode;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt primBits;
    sqInt primIdx;

	/* begin flushExternalPrimitives */
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & 0x3FFFFF) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24) {

				/* This is a compiled method */

				primIdx = 
#        if MULTIPLEBYTECODESETS
					((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
										? ((longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
												? ((firstBytecode = (objOop1 + ((LiteralStart + ((((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
													(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
												: 0)
										: ((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
											(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#        else /* MULTIPLEBYTECODESETS */
					((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
									(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#        endif /* MULTIPLEBYTECODESETS */
					;
				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */

					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & 0x3FFFFF) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24) {

				/* This is a compiled method */

				primIdx = 
#        if MULTIPLEBYTECODESETS
					((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
										? ((longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
												? ((firstBytecode = (objOop1 + ((LiteralStart + ((((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
													(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
												: 0)
										: ((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
											(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#        else /* MULTIPLEBYTECODESETS */
					((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
									(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#        endif /* MULTIPLEBYTECODESETS */
					;
				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */

					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (!(((longAt(objOop11)) & 0x3FFFFF) == 0)) {
				if (((((usqInt) (longAt(objOop11))) >> 24) & 0x1F) >= 24) {

					/* This is a compiled method */

					primIdx = 
#          if MULTIPLEBYTECODESETS
						((((sqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
												? ((longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
														? ((firstBytecode = (objOop11 + ((LiteralStart + ((((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
															(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
														: 0)
												: ((primBits = ((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
													(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#          else /* MULTIPLEBYTECODESETS */
						((primBits = ((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
											(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#          endif /* MULTIPLEBYTECODESETS */
						;
					if (primIdx == PrimitiveExternalCallIndex) {

						/* It's primitiveExternalCall */

						flushExternalPrimitiveOf(objOop11);
					}
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin flushAtCache */
	for (i2 = 1; i2 <= AtCacheTotalSize; i2 += 1) {
		GIV(atCache)[i2] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i3 = 0; i3 < MaxExternalPrimitiveTableSize; i3 += 1) {
		externalPrimitiveTable[i3] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
}


/*	On some platforms, this primitive forces enqueued display updates to be
	processed immediately. On others, it does nothing.
 */

static void
primitiveForceDisplayUpdate(void)
{
	ioForceDisplayUpdate();
}


/*	On platforms that support it, this primitive prints the receiver, assumed
	to be a Form, to the default printer.
 */

static void
primitiveFormPrint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsArray;
    sqInt bitsArraySize;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt depth;
    sqInt fmt;
    sqInt h;
    double  hScale;
    sqInt isFloat;
    sqInt isFloat1;
    sqInt landscapeFlag;
    sqInt numBytes;
    sqInt ok;
    sqInt pixelsPerWord;
    sqInt rcvr;
    double result;
    double result1;
    double  vScale;
    sqInt w;
    sqInt wordsPerLine;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		landscapeFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		landscapeFlag = 0;
		goto l1;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */

	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	landscapeFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 3) != 0) {
		isFloat = 0;
		goto l3;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer) + (1 * BytesPerWord)))));
	ccIndex = (longAt(longAt(GIV(stackPointer) + (1 * BytesPerWord)))) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l3;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l3:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + (BaseHeaderSize), result);
		vScale = result;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	vScale = 0.0;
l4:	/* end floatValueOf: */;
	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (2 * BytesPerWord))) & 3) != 0) {
		isFloat1 = 0;
		goto l5;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer) + (2 * BytesPerWord)))));
	ccIndex1 = (longAt(longAt(GIV(stackPointer) + (2 * BytesPerWord)))) & 0x3FFFFF;
	isFloat1 = ClassFloatCompactIndex == ccIndex1;
	goto l5;

	isFloat1 = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex1));
l5:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat1) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (2 * BytesPerWord))) + (BaseHeaderSize), result1);
		hScale = result1;
		goto l6;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	hScale = 0.0;
l6:	/* end floatValueOf: */;
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((rcvr & 1)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

	}
	if (!GIV(primFailCode)) {
		if (!((((rcvr & 3) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) <= 5))
			 && ((lengthOfformat(rcvr, (((usqInt) (longAt(rcvr))) >> 24) & 0x1F)) >= 4))) {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
	if (!GIV(primFailCode)) {
		bitsArray = longAt((rcvr + (BaseHeaderSize)) + (0 << 2));
		w = fetchIntegerofObject(1, rcvr);
		h = fetchIntegerofObject(2, rcvr);
		depth = fetchIntegerofObject(3, rcvr);
		if (!((w > 0)
			 && (h > 0))) {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if ((!((rcvr & 1)))
		 && (((bitsArray & 3) == 0)
		 && (((((usqInt) (longAt(bitsArray))) >> 24) & 0x1F) > 5))) {
			/* begin byteLengthOf: */
			fmt = (((usqInt) (longAt(bitsArray))) >> 24) & 0x1F;
			numBytes = (numSlotsOf(bitsArray)) << 2;
			if (fmt <= 9) {
				bitsArraySize = numBytes;
				goto l2;
			}
			if (fmt >= 16) {

				/* bytes, including CompiledMethod */

				bitsArraySize = numBytes - (fmt & 7);
				goto l2;
			}
			if (fmt >= 12) {
				bitsArraySize = numBytes - ((fmt & 3) << 1);
				goto l2;
			}
			bitsArraySize = numBytes - ((fmt & 1) << 2);
		l2:	/* end byteLengthOf: */;
			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
	if (!GIV(primFailCode)) {
		ok = ioFormPrint(bitsArray + 4, w, h, depth, hScale, vScale, landscapeFlag);

		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
		null;
	}
}

static void
primitiveFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double frac;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;
    double trunc;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		rcvr = result;
		goto l2;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		frac = modf(rcvr, &trunc);
		/* begin pushFloat: */
		/* begin push: */
		object = floatObjectOf(frac);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */
/*	Do a full garbage collection. In SqueakV3ObjectMemory, answer the number
	of bytes available (including swap space if dynamic memory management is
	supported). In Spur, answer the size of the largest free chunk. */

static void
primitiveFullGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    sqInt integerVal1;
    char *sp;
    char *sp1;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin pop:thenPushInteger: */
	integerVal = fullGC();
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((integerVal << 1) | 1));
	GIV(stackPointer) = sp;
	return;

	
	/* begin incrementalGC */
	error("shouldNotImplement");
	fullGC();
	/* begin pop:thenPushInteger: */
	integerVal1 = (((GIV(totalFreeOldSpace) + ((((eden()).limit)) - GIV(freeStart))) + ((((pastSpace()).limit)) - GIV(pastSpaceStart))) + ((((futureSpace()).limit)) - (((futureSpace()).limit)))) - (interpreterAllocationReserveBytes());
	longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((integerVal1 << 1) | 1));
	GIV(stackPointer) = sp1;
}


/*	Fetch the system attribute with the given integer ID. The 
	result is a string, which will be empty if the attribute is not 
	defined. */

static void
primitiveGetAttribute(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt attr;
    sqInt integerPointer;
    sqInt s;
    char *sp;
    sqInt sz;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		attr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		attr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		sz = attributeSize(attr);
	}
	if (!GIV(primFailCode)) {
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2)), sz);
		getAttributeIntoLength(attr, s + BaseHeaderSize, sz);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Answer the VM's current log directory */

EXPORT(sqInt)
primitiveGetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char*ptr;
    char *sp;
    sqInt stringOop;
    sqInt sz;

	ptr = ioGetLogDirectory();
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = strlen(ptr);
	stringOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2)), sz);
	for (i = 0; i < sz; i += 1) {
		byteAtput((stringOop + (BaseHeaderSize)) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	null;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), stringOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Return the next input event from the VM event queue. */

static void
primitiveGetNextEvent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    int evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    sqInt value;

	
	arg = longAt(GIV(stackPointer));
	if (!((((arg & 3) == 0)
 && (((((usqInt) (longAt(arg))) >> 24) & 0x1F) == 2))
		 && ((slotSizeOf(arg)) == 8))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (!(!GIV(primFailCode))) {
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if (((evtBuf[0]) ^ ((evtBuf[0]) << 1)) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(arg)));
		longAtput((arg + (BaseHeaderSize)) + (0 << 2), (((evtBuf[0]) << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	null;
	if (!(!GIV(primFailCode))) {
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((evtBuf[1]) & MillisecondClockMask) ^ (((evtBuf[1]) & MillisecondClockMask) << 1)) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(arg)));
		longAtput((arg + (BaseHeaderSize)) + (1 << 2), ((((evtBuf[1]) & MillisecondClockMask) << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	null;
	if (!(!GIV(primFailCode))) {
		return;
	}
	for (i = 2; i <= 7; i += 1) {
		value = evtBuf[i];
		if ((value ^ (value << 1)) >= 0) {
			/* begin storeInteger:ofObject:withValue: */
			if ((value ^ (value << 1)) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(arg)));
				longAtput((arg + (BaseHeaderSize)) + (i << 2), ((value << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			null;
		}
		else {
			value = positive32BitIntegerFor(value);
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(arg)));
			if (isOldObject(arg)) {

				/* most stores into young objects */

				if (((value & 3) == 0)
				 && ((((usqInt) value)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(arg))) >> 29) & 1) != 0)) {
						remember(arg);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(arg, (longAt(arg)) | (1 << 29));
					}
				}
			}
			longAtput((arg + (BaseHeaderSize)) + (i << 2), value);
		}
	}
	if (!(!GIV(primFailCode))) {
		return;
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
}


/*	Primitive. Answer the OS window's label */

EXPORT(sqInt)
primitiveGetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt labelOop;
    char*ptr;
    char *sp;
    sqInt sz;

	ptr = ioGetWindowLabel();
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = strlen(ptr);
	labelOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2)), sz);
	for (i = 0; i < sz; i += 1) {
		byteAtput((labelOop + (BaseHeaderSize)) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	null;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), labelOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the OS window's size (extent) */

EXPORT(sqInt)
primitiveGetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt err;
    sqInt h;
    sqInt newHash;
    sqInt object;
    sqInt pointResult;
    char *sp;
    sqInt w;

	w = ioGetWindowWidth();
	h = ioGetWindowHeight();
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	null;
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	/* begin eeInstantiateSmallClass:numSlots: */
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
	if (((newHash = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
		if (((err = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
			classIndex = -err;
			goto l1;
		}
		/* begin rawHashBitsOf: */
		flag("endianness");
		newHash = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
		assert((classAtIndex(newHash)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
	}
	classIndex = newHash;
l1:	/* end ensureBehaviorHash: */;
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert(((YIndex + 1) >= 0)
	 && (classIndex != 0));
	assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex))));
	pointResult = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + (BaseHeaderSize)) + (XIndex << 2), ((w << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + (BaseHeaderSize)) + (YIndex << 2), ((h << 1) | 1));
	object = pointResult;
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

static void
primitiveGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		/* begin push: */
		object = (integerReceiver >= integerArgument
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveGreaterOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr >= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		/* begin push: */
		object = (integerReceiver > integerArgument
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveGreaterThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr > integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveGrowMemoryByAtLeast(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ammount;
    usqInt segSize;
    char *sp;

	ammount = longAt(GIV(stackPointer));
	if (!((ammount & 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	segSize = growOldSpaceByAtLeast((ammount >> 1));
	if (segSize == null) {
		GIV(primFailCode) = PrimErrNoMemory;
	}
	else {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((segSize << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Answer the heartbeat frequency in beats per second. If the argument is
	true, reset the frequency measure. */

EXPORT(sqInt)
primitiveHeartbeatFrequency(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt reset;
    char *sp;

	reset = (GIV(argumentCount) == 1)
	 && ((longAt(GIV(stackPointer))) == GIV(trueObj));
	/* begin pop:thenPush: */
	oop = positive32BitIntegerFor(ioHeartbeatFrequency(reset));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the value of the high resolution clock if this system has any. The
	exact frequency of the high res clock is undefined specifically so that we
	can use processor dependent instructions (like RDTSC). The only use for
	the high res clock is for profiling where we can allocate time based on
	sub-msec resolution of the high res clock. If no high-resolution counter
	is available, the platform should return zero.
 */

EXPORT(sqInt)
primitiveHighResClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
	/* begin push: */
	object = positive64BitIntegerFor(ioHighResClock());
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

static void
primitiveIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    sqInt referent;
    sqInt referent1;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	if (((otherObject & 3) == 0)
	 && (((longAt(otherObject)) & 0x3FFFFF) == 8)) {
		assert(GIV(argumentCount) > 1);
		/* begin followForwarded: */
		assert(isForwarded(thisObject));
		referent = longAt((thisObject + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		otherObject = referent;
	}
	assert(!(isOopForwarded(otherObject)));
	if (((thisObject & 3) == 0)
	 && (((longAt(thisObject)) & 0x3FFFFF) == 8)) {
		/* begin followForwarded: */
		assert(isForwarded(thisObject));
		referent1 = longAt((thisObject + (BaseHeaderSize)) + (0 << 2));
		while (((referent1 & 3) == 0)
		 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
			referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
		}
		thisObject = referent1;
	}
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject == otherObject
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}

static void
primitiveIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt integerVal;
    char *sp;
    sqInt thisReceiver;

	thisReceiver = longAt(GIV(stackPointer));
	if ((thisReceiver & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPushInteger: */
		/* begin hashBitsOf: */
		/* begin rawHashBitsOf: */
		flag("endianness");
		hash = (longAt(thisReceiver + 4)) & 0x3FFFFF;
		if (hash == 0) {

			/* would like to assert
			   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
			   but instance-specific behaviors that are instances of themselves may
			   fail this test. */

			hash = (newObjectHash()) & 0x3FFFFF;
			/* begin setHashBitsOf:to: */
			flag("endianness");
			assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
			longAtput(thisReceiver + 4, ((((longAt(thisReceiver + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash);
		}
		integerVal = hash;
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((integerVal << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	When called with a single string argument, record the string as the
	current image file name. When called with zero arguments, return a string
	containing the current image file name.
 */

static void
primitiveImageName(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt okToRename;
    sqInt s;
    void *sCRIfn;
    char *sp;
    sqInt successBoolean;
    sqInt sz;

	if (GIV(argumentCount) == 1) {

		/* If the security plugin can be loaded, use it to check for rename permission.
		   If not, assume it's ok */

		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin");
		if (sCRIfn != 0) {
			okToRename = ((sqInt (*)(void))sCRIfn)();
			if (!okToRename) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		s = longAt(GIV(stackPointer));
		/* begin assertClassOf:is: */
		/* begin success: */
		successBoolean = ((longAt(s)) & 0x3FFFFF) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2))));
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			sz = stSizeOf(s);
			imageNamePutLength(s + BaseHeaderSize, sz);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			null;
		}
	}
	else {
		sz = imageNameSize();
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2)), sz);
		imageNameGetLength(s + BaseHeaderSize, sz);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		null;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), s);
		GIV(stackPointer) = sp;
	}
}


/*	Do a quick, incremental garbage collection and return the number of bytes
	immediately available.
	(Note: more space may be made available by doing a full garbage
	collection. 
 */

static void
primitiveIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin scavengingGC */
	scavengingGCTenuringIf(TenureByAge);

	/* begin pop:thenPushInteger: */
	integerVal = (((GIV(totalFreeOldSpace) + ((((eden()).limit)) - GIV(freeStart))) + ((((pastSpace()).limit)) - GIV(pastSpaceStart))) + ((((futureSpace()).limit)) - (((futureSpace()).limit)))) - (interpreterAllocationReserveBytes());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((integerVal << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Note: With the Squeak V0 format we now have 10 bits of primitive index,
	but they are in
	two places for temporary backward compatibility. The time to unpack is
	negligible, since the derived primitive function pointer is stored in the
	method cache. With the new
	format we assume a 3-byte CallPrimitive with a little-endian 16-bit
	primitive index. */

sqInt
primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader)
{
    sqInt firstBytecode;
    sqInt primBits;

	return 
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader)) < 0
				? (methodHeader & (65536 << SmallIntegerShift)
						? ((firstBytecode = (theMethod + ((LiteralStart + ((((usqInt) methodHeader) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
							(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
						: 0)
				: ((primBits = ((usqInt) methodHeader) >> 1),
					(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#  else /* MULTIPLEBYTECODESETS */
		((primBits = ((usqInt) methodHeader) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#  endif /* MULTIPLEBYTECODESETS */
		;
}

sqInt
primitiveIndexOf(sqInt methodPointer)
{
    sqInt firstBytecode;
    sqInt primBits;

	return 
#  if MULTIPLEBYTECODESETS
		((((sqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
				? ((longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
						? ((firstBytecode = (methodPointer + ((LiteralStart + ((((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
							(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
						: 0)
				: ((primBits = ((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
					(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#  else /* MULTIPLEBYTECODESETS */
		((primBits = ((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#  endif /* MULTIPLEBYTECODESETS */
		;
}


/*	Register the input semaphore. If the argument is not a 
	Semaphore, unregister the current input semaphore. */

static void
primitiveInputSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt top;

	arg = longAt(GIV(stackPointer));
	if ((arg & 1)) {

		/* If arg is integer, then use it as an index
		   into the external objects array and install it
		   as the new event semaphore */

		ioSetInputSemaphore((arg >> 1));
		if (!GIV(primFailCode)) {
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			null;
		}
		return;
	}
	if (TheInputSemaphore == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	arg = top;
	if (!((fetchClassOf(arg)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2))))) {
		arg = GIV(nilObj);
	}
	/* begin splObj:put: */
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(GIV(specialObjectsOop))));
	if (isOldObject(GIV(specialObjectsOop))) {

		/* most stores into young objects */

		if (((arg & 3) == 0)
		 && ((((usqInt) arg)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
				remember(GIV(specialObjectsOop));
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
			}
		}
	}
	longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheInputSemaphore << 2), arg);
}


/*	Return an integer indicating the reason for the most recent input
	interrupt. 
 */

static void
primitiveInputWord(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((0 << 1) | 1));
	GIV(stackPointer) = sp;
}

static void
primitiveInstVarAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt index;
    sqInt integerPointer;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt totalLength;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(!GIV(primFailCode))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	hdr = longLongAt(rcvr);
	fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l1;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l1;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l5;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l5;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = rcvr;
		goto l4;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l4;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l4:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l5:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((fmt == 3)
	 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		value = externalInstVarofContext(index - 1, rcvr);
	}
	else {
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			value = longAt((rcvr + (BaseHeaderSize)) + ((index - 1) << 2));
			goto l2;
		}
		if (fmt >= 16) {
			value = (((byteAt((rcvr + (BaseHeaderSize)) + (index - 1))) << 1) | 1);
			goto l2;
		}
		value = positive32BitIntegerFor(long32At((rcvr + (BaseHeaderSize)) + ((index - 1) << 2)));
	l2:	/* end subscript:with:format: */;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
	GIV(stackPointer) = sp;
}

static void
primitiveInstVarAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt index;
    sqInt index1;
    sqInt integerPointer;
    sqInt newValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt onCurrentPage;
    sqInt rcvr;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt totalLength;
    sqInt value;
    sqInt valueToStore;

	newValue = longAt(GIV(stackPointer));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(!GIV(primFailCode))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	hdr = longLongAt(rcvr);
	fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l1;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l1;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = rcvr;
		goto l3;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l3;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l3:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l4:	/* end fixedFieldsOf:format:length: */;
	if (!((index >= 1)
		 && (index <= fixedFields))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if ((fmt == 3)
	 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		/* begin externalInstVar:ofContext:put: */
		assert(isContext(rcvr));
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
		if (!((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
			 && (!(isWidowedContext(rcvr))))) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */

				if (((newValue & 3) == 0)
				 && ((((usqInt) newValue)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
						remember(rcvr);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
					}
				}
			}
			longAtput((rcvr + (BaseHeaderSize)) + ((index - 1) << 2), newValue);
			if ((index - 1) == StackPointerIndex) {
				/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
			}
			null;
			goto l5;
		}
		/* begin frameOfMarriedContext: */
		value = longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		index1 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index1, GIV(pages));
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		onCurrentPage = thePage == GIV(stackPage);
		if ((index - 1) == SenderIndex) {
			storeSenderOfFramewithValue(theFP, newValue);
		}
		else {
			externalDivorceFrameandContext(theFP, rcvr);
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */

				if (((newValue & 3) == 0)
				 && ((((usqInt) newValue)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
						remember(rcvr);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
					}
				}
			}
			longAtput((rcvr + (BaseHeaderSize)) + ((index - 1) << 2), newValue);
			if ((index - 1) == StackPointerIndex) {
				/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
			}
		}
		if (onCurrentPage) {
			GIV(framePointer) = (GIV(stackPage)->headFP);
			GIV(stackPointer) = (GIV(stackPage)->headSP);
		}
		else {
			markStackPageMostRecentlyUsed(GIV(stackPage));
		}
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		assert(pageListIsWellFormed());
		assert(validStackPageBaseFrames());
	l5:	/* end externalInstVar:ofContext:put: */;
	}
	else {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */

				if (((newValue & 3) == 0)
				 && ((((usqInt) newValue)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
						remember(rcvr);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
					}
				}
			}
			longAtput((rcvr + (BaseHeaderSize)) + ((index - 1) << 2), newValue);
		}
		else {
			if (fmt >= 16) {
				if (!((newValue & 1))) {
					GIV(primFailCode) = PrimErrBadIndex;
				}
				valueToStore = (newValue >> 1);
				if (!((valueToStore >= 0)
					 && (valueToStore <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
				}
				if (!GIV(primFailCode)) {
					byteAtput((rcvr + (BaseHeaderSize)) + (index - 1), valueToStore);
				}
			}
			else {

				/* long-word type objects */

				valueToStore = positive32BitValueOf(newValue);
				if (!GIV(primFailCode)) {
					long32Atput((rcvr + (BaseHeaderSize)) + ((index - 1) << 2), valueToStore);
				}
			}
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Return the 32bit signed integer contents of a words receiver */

static void
primitiveIntegerAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt index;
    sqInt integerPointer;
    int intValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt object;
    sqInt rcvr;
    char *sp;
    char *sp1;
    sqInt sz;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & 3) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) == 10))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) <= 9) {
		sz = numSlots;
		goto l1;
	}
	if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		sz = (numSlots << 2) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 7);
		goto l1;
	}
	if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 12) {
		sz = (numSlots << (2 - 1)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 3);
		goto l1;
	}
	sz = (numSlots << (2 - 2)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 1);
l1:	/* end lengthOf:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}

	/* for zero indexing */

	addr = (rcvr + (BaseHeaderSize)) + ((index - 1) * 4);
	value = intAt(addr);
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	null;
	if ((value ^ (value << 1)) >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ((value << 1) | 1));
		GIV(stackPointer) = sp1;
		null;
	}
	else {

		/* 32 bit int may have been stored in 32 or 64 bit sqInt */

		intValue = value;
		/* begin push: */
		object = signed32BitIntegerFor(intValue);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
}


/*	Return the 32bit signed integer contents of a words receiver */

static void
primitiveIntegerAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt index;
    sqInt integerPointer;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    int value;
    sqInt valueOop;

	valueOop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	value = signed32BitValueOf(valueOop);
	if (!(!GIV(primFailCode))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(((rcvr & 3) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) == 10))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) <= 9) {
		sz = numSlots;
		goto l1;
	}
	if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		sz = (numSlots << 2) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 7);
		goto l1;
	}
	if (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) >= 12) {
		sz = (numSlots << (2 - 1)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 3);
		goto l1;
	}
	sz = (numSlots << (2 - 2)) - (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) & 1);
l1:	/* end lengthOf:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}

	/* for zero indexing */

	addr = (rcvr + (BaseHeaderSize)) + ((index - 1) * 4);
	value = intAtput(addr, value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), valueOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the number of interrupt checks per milliseconds that we
	execute on this machine. This can be used to adjust the sub-msecs profiler
	to check (roughly) 
	n times per millisecond.
 */

EXPORT(sqInt)
primitiveInterruptChecksPerMSec(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin pop:thenPush: */
	oop = (((ioHeartbeatMilliseconds()) << 1) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore. */

static void
primitiveInterruptSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	arg = top;
	if ((fetchClassOf(arg)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2)))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((arg & 3) == 0)
			 && ((((usqInt) arg)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheInterruptSemaphore << 2), arg);
	}
	else {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((GIV(nilObj) & 3) == 0)
			 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheInterruptSemaphore << 2), GIV(nilObj));
	}
}


/*	Primitive. 'Invoke' an object like a function, sending the special message
	run: originalSelector with: arguments in: aReceiver.
	 */

static void
primitiveInvokeObjectAsMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt i;
    sqInt i1;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt rcvr;
    sqInt runArgs;
    sqInt runReceiver;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    sqInt tagBits;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;

	runArgs = (/* begin eeInstantiateClassIndex:format:numSlots: */
	assert((GIV(argumentCount) >= 0)
		 && (ClassArrayCompactIndex != 0)),
	assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex)))),
	allocateNewSpaceSlotsformatclassIndex(GIV(argumentCount), 2, ClassArrayCompactIndex));
	for (i = (GIV(argumentCount) - 1); i >= 0; i += -1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		/* begin popStack */
		top1 = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		valuePointer = top1;
		assert(!(isForwarded(runArgs)));
		longAtput((runArgs + (BaseHeaderSize)) + (i << 2), valuePointer);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	runReceiver = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(messageSelector));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), runArgs);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), runReceiver);
	GIV(stackPointer) = sp3;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorRunWithIn << 2));
	GIV(argumentCount) = 3;
	/* begin fetchClassTagOf: */
	if (((tagBits = GIV(newMethod) & 3)) != 0) {
		lookupClassTag = ((tagBits & 1) != 0
			? 1
			: tagBits);
		goto l1;
	}
	lookupClassTag = (longAt(GIV(newMethod))) & 0x3FFFFF;
l1:	/* end fetchClassTagOf: */;
	findNewMethodInClassTag(lookupClassTag);
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			null;
			goto l2;
		}
		/* begin slowPrimitiveResponse */
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		if (FailImbalancedPrimitives
		 && ((!GIV(primFailCode))
		 && (GIV(framePointer) == savedFramePointer))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */

			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				GIV(stackPointer) = savedStackPointer;
				failUnbalancedPrimitive();
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			null;
			goto l2;
		}
	}
	/* begin activateNewMethod */
	/* begin justActivateNewMethod */
	methodHeader1 = longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2));
	numTemps = (((usqInt) methodHeader1) >> 19) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> 25) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((headerOf(GIV(method))) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) methodHeader1)) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	/* begin push: */
	object = ((1 + (numArgs << 8)) + (0)) + (0);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? (((usqInt) methodHeader1) >> 1) & 0xFFFF
		: (((usqInt) methodHeader1) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader1) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize)) - 1;
	if (
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader1)) < 0
				? methodHeader1 & (65536 << SmallIntegerShift)
				: (methodHeader1 & 536871934) != 0)
#  else /* MULTIPLEBYTECODESETS */
		(methodHeader1 & 536871934) != 0
#  endif /* MULTIPLEBYTECODESETS */
		) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 
#    if MULTIPLEBYTECODESETS
			((((sqInt) methodHeader1)) < 0
						? 3
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? 234
		: 129)
#else /* MULTIPLEBYTECODESETS */
	129
#endif /* MULTIPLEBYTECODESETS */
	)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
					if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
						errorCode = longAt((table + (BaseHeaderSize)) + ((GIV(primFailCode) - 1) << 2));
						goto l3;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l3:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l2:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Primitive. Answer whether the OS window is currently partially or fully
	obscured. 
 */

EXPORT(sqInt)
primitiveIsWindowObscured(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    sqInt trueOrFalse;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	null;
	/* begin pushBool: */
	trueOrFalse = ioIsWindowObscured();
	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and remove it from the input buffer. The low byte
	is the 8-bit ISO character. The next four bits are the Smalltalk modifier
	bits <cmd><option><ctrl><shift>.
 */

static void
primitiveKbdNext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
	keystrokeWord = ioGetKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ((keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
		null;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and without removing it from the input buffer. The
	low byte is the 8-bit ISO character. The next four bits are the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

static void
primitiveKbdPeek(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
	keystrokeWord = ioPeekKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ((keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
		null;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		/* begin push: */
		object = (integerReceiver <= integerArgument
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveLessOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr <= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    sqInt object;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerArgument = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popInteger */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer1 = top1;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerReceiver = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l2;
	}
l2:	/* end popInteger */;
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		/* begin push: */
		object = (integerReceiver < integerArgument
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveLessThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr < integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Return the n-th builtin module name. */

static void
primitiveListBuiltinModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListBuiltinModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		null;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2)), length);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + (BaseHeaderSize)) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	Primitive. Return the n-th loaded external module name. */

static void
primitiveListExternalModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListLoadedModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		null;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2)), length);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + (BaseHeaderSize)) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well formed. It will return as its
	value the original array of roots, and the erstwhile segmentWordArray will
	have been truncated to a size of zero. If this primitive should fail, the
	segmentWordArray will, sadly, have been reduced to an unrecognizable and
	unusable jumble. But what more could you have done with it anyway?
 */

static void
primitiveLoadImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt outPointerArray;
    sqInt result;
    sqInt segmentWordArray;
    char *sp;

	outPointerArray = longAt(GIV(stackPointer));

	/* Essential type checks */

	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((outPointerArray & 3) == 0)
 && (((((usqInt) (longAt(outPointerArray))) >> 24) & 0x1F) == 2))
		 && (((segmentWordArray & 3) == 0)
		 && (((((usqInt) (longAt(segmentWordArray))) >> 24) & 0x1F) == 10)))) {

		/* Must be indexable words */

		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = PrimErrUnsupported;
	if (result == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
}


/*	Return the value of the microsecond clock as an integer. The microsecond
	clock is at
	least 60 bits wide which means it'll get to around August 38435 before it
	wraps around. */

static void
primitiveLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioLocalMicroseconds());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Natural log. */

static void
primitiveLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		rcvr = result;
		goto l2;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = log(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Primitive. Answer an Array with the current long-running primitive method
	identified by
	the heartbeat, the minimum number of milliseconds it was active for, and
	the milliseconds
	of GC activity there-in, or nil if none. Since the
	longRunningPrimitiveCheckMethod is
	sampled at interrupt time be careful to validate it before returning it. */

EXPORT(sqInt)
primitiveLongRunningPrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt gcms;
    sqInt lrpcm;
    sqInt primms;
    sqInt result;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	sqLowLevelMFence();
	if ((GIV(longRunningPrimitiveStopUsecs) > GIV(longRunningPrimitiveStartUsecs))
	 && ((((lrpcm = GIV(longRunningPrimitiveCheckMethod))) != null)
	 && ((addressCouldBeObj(lrpcm))
	 && ((!(((longAt(lrpcm)) & 0x3FFFFF) == 0))
	 && (((((usqInt) (longAt(lrpcm))) >> 24) & 0x1F) >= 24))))) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassArray << 2)), 3);
		primms = ((GIV(longRunningPrimitiveStopUsecs) - GIV(longRunningPrimitiveStartUsecs)) + 500) / 1000;
		gcms = (GIV(longRunningPrimitiveGCUsecs) + 500) / 1000;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(result)));
		if (isOldObject(result)) {

			/* most stores into young objects */

			if (((lrpcm & 3) == 0)
			 && ((((usqInt) lrpcm)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(result))) >> 29) & 1) != 0)) {
					remember(result);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(result, (longAt(result)) | (1 << 29));
				}
			}
		}
		longAtput((result + (BaseHeaderSize)) + (0 << 2), lrpcm);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (1 << 2), ((primms << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (2 << 2), ((gcms << 1) | 1));
	}
	else {
		result = GIV(nilObj);
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
	voidLongRunningPrimitive("get");
}


/*	Primitive. Install the semaphore to be used for collecting long-running
	primitives, 
	or nil if no semaphore should be used. */

EXPORT(sqInt)
primitiveLongRunningPrimitiveSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;

	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (((sema & 1))
	 || (GIV(argumentCount) != 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (sema == GIV(nilObj)) {
		GIV(longRunningPrimitiveCheckSemaphore) = null;
	}
	else {
		if (!((fetchClassOfNonImm(sema)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2))))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		GIV(longRunningPrimitiveCheckSemaphore) = sema;
	}
	voidLongRunningPrimitive("install");
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

static void
primitiveLowSpaceSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt top;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	arg = top;
	if ((fetchClassOf(arg)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2)))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((arg & 3) == 0)
			 && ((((usqInt) arg)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheLowSpaceSemaphore << 2), arg);
	}
	else {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((GIV(nilObj) & 3) == 0)
			 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheLowSpaceSemaphore << 2), GIV(nilObj));
	}
}


/*	Turn the receiver into an ephemeron.
	TEMPORARY. For testing ephemeron handling in the VM only.
	Ephemerons should be instantiated from a suitable class. */

EXPORT(sqInt)
primitiveMakeEphemeron(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objOop;
    sqInt reasonCode;

	if (!((((longAt(GIV(stackPointer))) & 3) == 0)
		 && ((((((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 24) & 0x1F) <= 1)
		 || (((((usqInt) (longAt(longAt(GIV(stackPointer))))) >> 24) & 0x1F) == 5)))) {
		/* begin primitiveFailFor: */
		reasonCode = (GIV(argumentCount) == 0
			? PrimErrBadReceiver
			: PrimErrBadArgument);
		return (GIV(primFailCode) = reasonCode);
	}
	/* begin setFormatOf:to: */
	objOop = longAt(GIV(stackPointer));
	assert(((5 >= 0) && (5 <= (formatMask()))));
	flag("endianness");
	longAtput(objOop, ((longAt(objOop)) & (~(0x1F << 24))) + (5 << 24));
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	null;
}

static void
primitiveMakePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argument;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classIndex2;
    sqInt err;
    sqInt err1;
    sqInt err2;
    sqInt newHash;
    sqInt newHash1;
    sqInt newHash2;
    sqInt pointResult;
    sqInt pointResult1;
    sqInt pointResult2;
    sqInt pt;
    sqInt rcvr;
    char *sp;

	argument = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 1)) {
		if ((argument & 1)) {
			/* begin makePointwithxValue:yValue: */
			/* begin eeInstantiateSmallClass:numSlots: */
			/* begin ensureBehaviorHash: */
			assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
			if (((newHash = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
				if (((err = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
					classIndex = -err;
					goto l1;
				}
				/* begin rawHashBitsOf: */
				flag("endianness");
				newHash = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
				assert((classAtIndex(newHash)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
			}
			classIndex = newHash;
		l1:	/* end ensureBehaviorHash: */;
			/* begin eeInstantiateClassIndex:format:numSlots: */
			assert(((YIndex + 1) >= 0)
			 && (classIndex != 0));
			assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex))));
			pointResult = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(pointResult)));
			longAtput((pointResult + (BaseHeaderSize)) + (XIndex << 2), ((((rcvr >> 1)) << 1) | 1));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(pointResult)));
			longAtput((pointResult + (BaseHeaderSize)) + (YIndex << 2), ((((argument >> 1)) << 1) | 1));
			pt = pointResult;
		}
		else {
			/* begin makePointwithxValue:yValue: */
			/* begin eeInstantiateSmallClass:numSlots: */
			/* begin ensureBehaviorHash: */
			assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
			if (((newHash1 = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
				if (((err1 = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
					classIndex1 = -err1;
					goto l2;
				}
				/* begin rawHashBitsOf: */
				flag("endianness");
				newHash1 = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
				assert((classAtIndex(newHash1)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
			}
			classIndex1 = newHash1;
		l2:	/* end ensureBehaviorHash: */;
			/* begin eeInstantiateClassIndex:format:numSlots: */
			assert(((YIndex + 1) >= 0)
			 && (classIndex1 != 0));
			assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex1))));
			pointResult1 = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex1);
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(pointResult1)));
			longAtput((pointResult1 + (BaseHeaderSize)) + (XIndex << 2), ((((rcvr >> 1)) << 1) | 1));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(pointResult1)));
			longAtput((pointResult1 + (BaseHeaderSize)) + (YIndex << 2), ((0 << 1) | 1));
			pt = pointResult1;
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(pt)));
			if (isOldObject(pt)) {

				/* most stores into young objects */

				if ((((longAt(GIV(stackPointer) + (0 * BytesPerWord))) & 3) == 0)
				 && ((((usqInt) (longAt(GIV(stackPointer) + (0 * BytesPerWord))))) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(pt))) >> 29) & 1) != 0)) {
						remember(pt);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(pt, (longAt(pt)) | (1 << 29));
					}
				}
			}
			longAtput((pt + (BaseHeaderSize)) + (1 << 2), longAt(GIV(stackPointer) + (0 * BytesPerWord)));
		}
	}
	else {
		if (!(((rcvr & 3) == 0)
			 && (ClassFloatCompactIndex == ((longAt(rcvr)) & 0x3FFFFF)))) {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

			return;
		}
		/* begin makePointwithxValue:yValue: */
		/* begin eeInstantiateSmallClass:numSlots: */
		/* begin ensureBehaviorHash: */
		assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
		if (((newHash2 = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
			if (((err2 = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
				classIndex2 = -err2;
				goto l3;
			}
			/* begin rawHashBitsOf: */
			flag("endianness");
			newHash2 = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
			assert((classAtIndex(newHash2)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
		}
		classIndex2 = newHash2;
	l3:	/* end ensureBehaviorHash: */;
		/* begin eeInstantiateClassIndex:format:numSlots: */
		assert(((YIndex + 1) >= 0)
		 && (classIndex2 != 0));
		assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex2))));
		pointResult2 = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex2);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(pointResult2)));
		longAtput((pointResult2 + (BaseHeaderSize)) + (XIndex << 2), ((0 << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(pointResult2)));
		longAtput((pointResult2 + (BaseHeaderSize)) + (YIndex << 2), ((0 << 1) | 1));
		pt = pointResult2;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(pt)));
		if (isOldObject(pt)) {

			/* most stores into young objects */

			if ((((longAt(GIV(stackPointer) + (1 * BytesPerWord))) & 3) == 0)
			 && ((((usqInt) (longAt(GIV(stackPointer) + (1 * BytesPerWord))))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(pt))) >> 29) & 1) != 0)) {
					remember(pt);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(pt, (longAt(pt)) | (1 << 29));
				}
			}
		}
		longAtput((pt + (BaseHeaderSize)) + (0 << 2), longAt(GIV(stackPointer) + (1 * BytesPerWord)));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(pt)));
		if (isOldObject(pt)) {

			/* most stores into young objects */

			if ((((longAt(GIV(stackPointer) + (0 * BytesPerWord))) & 3) == 0)
			 && ((((usqInt) (longAt(GIV(stackPointer) + (0 * BytesPerWord))))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(pt))) >> 29) & 1) != 0)) {
					remember(pt);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(pt, (longAt(pt)) | (1 << 29));
				}
			}
		}
		longAtput((pt + (BaseHeaderSize)) + (1 << 2), longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), pt);
	GIV(stackPointer) = sp;
}


/*	Primitive. Mark the method for exception handling. The primitive must fail
	after marking the context so that the regular code is run.
 */

static void
primitiveMarkHandlerMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Primitive. Mark the method for exception unwinding. The primitive must
	fail after marking the context so that the regular code is run. It must
	also *not* allow a context switch.
 */

static void
primitiveMarkUnwindMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
}

static void
primitiveMaxIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((0x3FFFFF << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the method an external primitive was defined in */

usqInt
primitiveMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newMethod);
}


/*	Return the value of the millisecond clock as an integer. Note that the
	millisecond clock wraps around periodically. On some platforms it can wrap
	daily. The range is limited to SmallInteger maxVal / 2 to allow delays of
	up to that length without overflowing a SmallInteger.
 */

static void
primitiveMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = ((((ioMSecs()) & MillisecondClockMask) << 1) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Provide access to the millisecond clock mask to support calculation
	of durations based on the millisecond clock value. */

EXPORT(sqInt)
primitiveMillisecondClockMask(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((MillisecondClockMask << 1) | 1));
	GIV(stackPointer) = sp;
}

static void
primitiveMod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mod;
    char *sp;

	mod = doPrimitiveModby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((mod ^ (mod << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((mod << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveModLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		return;
	}

	/* Handle remainder of same sign as argument */

	result = a % b;
	if (!(result == 0)) {
		if (!(bIsNegative == aIsNegative)) {
			result = b - result;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the mouse button state. The low three bits encode the state of the
	<red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

static void
primitiveMouseButtons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt buttonWord;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
	buttonWord = ioGetButtonState();
	/* begin pushInteger: */
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), ((buttonWord << 1) | 1));
	GIV(stackPointer) = sp;
	null;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return a Point indicating current position of the mouse. Note that mouse
	coordinates may be negative if the mouse moves above or to the left of the
	top-left corner of the Smalltalk window.
 */

static void
primitiveMousePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt err;
    sqInt newHash;
    sqInt object;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;
    sqInt x;
    sqInt y;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
	pointWord = ioMousePoint();
	/* begin signExtend16: */
	if ((((((usqInt) pointWord) >> 16) & 0xFFFF) & 32768) == 0) {
		x = (((usqInt) pointWord) >> 16) & 0xFFFF;
		goto l1;
	}
	else {
		x = ((((usqInt) pointWord) >> 16) & 0xFFFF) - 65536;
		goto l1;
	}
l1:	/* end signExtend16: */;
	/* begin signExtend16: */
	if (((pointWord & 0xFFFF) & 32768) == 0) {
		y = pointWord & 0xFFFF;
		goto l2;
	}
	else {
		y = (pointWord & 0xFFFF) - 65536;
		goto l2;
	}
l2:	/* end signExtend16: */;
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	/* begin eeInstantiateSmallClass:numSlots: */
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
	if (((newHash = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
		if (((err = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
			classIndex = -err;
			goto l3;
		}
		/* begin rawHashBitsOf: */
		flag("endianness");
		newHash = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
		assert((classAtIndex(newHash)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
	}
	classIndex = newHash;
l3:	/* end ensureBehaviorHash: */;
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert(((YIndex + 1) >= 0)
	 && (classIndex != 0));
	assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex))));
	pointResult = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + (BaseHeaderSize)) + (XIndex << 2), ((x << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + (BaseHeaderSize)) + (YIndex << 2), ((y << 1) | 1));
	object = pointResult;
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

static void
primitiveMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {

		/* check for C overflow by seeing if computation is reversible */

		integerResult = integerRcvr * integerArg;
		if ((integerArg == 0)
		 || ((integerResult / integerArg) == integerRcvr)) {
			/* begin pop2AndPushIntegerIfOK: */
			if (!GIV(primFailCode)) {
				if ((integerResult ^ (integerResult << 1)) >= 0) {
					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
					GIV(stackPointer) = sp;
				}
				else {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

				}
			}
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveMultiplyLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!(!GIV(primFailCode))) {
		return;
	}
	if ((a > 1)
	 && ((b > 1)
	 && (a > (0xFFFFFFFFFFFFFFFFULL / b)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a * b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

static void
primitiveNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt classObj;
    sqInt err;
    sqInt instSpec;
    sqInt newHash;
    sqInt newObj;
    sqInt newObj1;
    sqInt numBytes;
    sqInt numSlots;
    sqInt obj;
    sqInt oop;
    sqInt p;
    char *sp;
    char *sp1;
    sqInt spaceOkay;

	
	/* Allocate a new fixed-size instance.  Fail if the allocation would leave
	   less than lowSpaceThreshold bytes free. This *will not* cause a GC :-) */

	/* begin instantiateClass: */
	classObj = longAt(GIV(stackPointer));
	classFormat = ((longAt((classObj + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1);
	instSpec = (((usqInt) classFormat) >> 16) & 0x1F;
	if (!((instSpec <= 1)
		 || (instSpec == 5))) {
		obj = null;
		goto l3;
	}
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj));
	if (((newHash = rawHashBitsOf(classObj))) == 0) {
		if (((err = enterIntoClassTable(classObj))) != 0) {
			classIndex = -err;
			goto l1;
		}
		/* begin rawHashBitsOf: */
		flag("endianness");
		newHash = (longAt(classObj + 4)) & 0x3FFFFF;
		assert((classAtIndex(newHash)) == classObj);
	}
	classIndex = newHash;
l1:	/* end ensureBehaviorHash: */;
	if (classIndex < 0) {
		GIV(primFailCode) = -classIndex;
		obj = null;
		goto l3;
	}
	numSlots = classFormat & ((1 << 16) - 1);
	/* begin allocateSlots:format:classIndex: */
	if (numSlots >= 0xFF) {
		newObj1 = GIV(freeStart) + (BaseHeaderSize);

		/* double header */
		/* roundTo allocationUnit */

		numBytes = ((BaseHeaderSize) + (BaseHeaderSize)) + ((numSlots + (numSlots & 1)) * 4);
	}
	else {
		newObj1 = GIV(freeStart);
		numBytes = (BaseHeaderSize) + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * 4));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
		goto l2;
	}
	if (numSlots >= 0xFF) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */

		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, 0xFF << 24);
		longLongAtput(newObj1, (((((usqLong) 0xFF)) << 56) + (instSpec << 24)) + classIndex);
	}
	else {
		longLongAtput(newObj1, (((((usqLong) numSlots)) << 56) + (instSpec << 24)) + classIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj1 % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	newObj = newObj1;
l2:	/* end allocateSlots:format:classIndex: */;
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + (BaseHeaderSize)) + (numSlots * (bytesPerOop()))) - 1, addressAfter(newObj)));
		for (p = (newObj + (BaseHeaderSize)); p < ((newObj + (BaseHeaderSize)) + (numSlots * (wordSize()))); p += 8) {
			longAtput(p, GIV(nilObj));
			longAtput(p + 4, GIV(nilObj));
		}
	}
	obj = newObj;
l3:	/* end instantiateClass: */;
	if (obj == null) {
		GIV(primFailCode) = PrimErrNoMemory;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}

}

static void
primitiveNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytecodeCount;
    sqInt class;
    sqInt header;
    sqInt i;
    sqInt integerPointer;
    sqInt literalCount;
    sqInt size;
    char *sp;
    sqInt theMethod;

	header = longAt(GIV(stackPointer));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bytecodeCount = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bytecodeCount = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!((header & 1))) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		return;
	}
	class = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	size = (((
#if MULTIPLEBYTECODESETS
	((((sqInt) header)) < 0
		? (((usqInt) header) >> 1) & 0xFFFF
		: (((usqInt) header) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) header) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + 1) * BytesPerWord) + bytecodeCount;
	theMethod = instantiateClassindexableSize(class, size);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theMethod)));
	longAtput((theMethod + (BaseHeaderSize)) + (HeaderIndex << 2), header);
	literalCount = 
#  if MULTIPLEBYTECODESETS
		((((sqInt) header)) < 0
				? (((usqInt) header) >> 1) & 0xFFFF
				: (((usqInt) header) >> 10) & 0xFF)
#  else /* MULTIPLEBYTECODESETS */
		(((usqInt) header) >> 10) & 0xFF
#  endif /* MULTIPLEBYTECODESETS */
		;
	for (i = 1; i <= literalCount; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theMethod)));
		if (isOldObject(theMethod)) {

			/* most stores into young objects */

			if (((GIV(nilObj) & 3) == 0)
			 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theMethod))) >> 29) & 1) != 0)) {
					remember(theMethod);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(theMethod, (longAt(theMethod)) | (1 << 29));
				}
			}
		}
		longAtput((theMethod + (BaseHeaderSize)) + (i << 2), GIV(nilObj));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), theMethod);
	GIV(stackPointer) = sp;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free. May cause a GC.
 */

static void
primitiveNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt obj;
    sqInt oop;
    sqInt size;
    char *sp;
    char *sp1;
    sqInt spaceOkay;

	size = positive32BitValueOf(longAt(GIV(stackPointer)));
	
#  if NewspeakVM

	/* For the mirror prims check that the class obj is actually a valid class. */

	if (!((GIV(argumentCount) < 2)
		 || (addressCouldBeClassObj(longAt(GIV(stackPointer) + (1 * BytesPerWord)))))) {
		GIV(primFailCode) = PrimErrBadArgument;
	}

#  endif /* NewspeakVM */

	if ((!GIV(primFailCode))
	 && (size >= 0)) {
		obj = instantiateClassindexableSize(longAt(GIV(stackPointer) + (1 * BytesPerWord)), size);
		if (obj == null) {
			GIV(primFailCode) = PrimErrNoMemory;
		}
		else {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
			GIV(stackPointer) = sp;
		}

	}
	else {
		GIV(primFailCode) = PrimErrBadArgument;
	}
}

static void
primitiveNextInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualObj;
    sqInt address;
    sqInt classIndex;
    usqInt numSlots;
    sqInt object;
    char *sp;
    sqInt subsequentObject;

	object = longAt(GIV(stackPointer));
	if (!((object & 3) != 0)) {
		/* begin instanceAfter: */
		actualObj = object;
		classIndex = (longAt(object)) & 0x3FFFFF;
		if (oopisGreaterThanOrEqualToandLessThan(object, ((eden()).start), GIV(freeStart))) {
			while (1) {
				actualObj = objectAfterlimit(actualObj, GIV(freeStart));
				if (!((((usqInt) actualObj)) < (((usqInt) GIV(freeStart))))) break;
				if (classIndex == ((longAt(actualObj)) & 0x3FFFFF)) {
					subsequentObject = actualObj;
					goto l1;
				}
			}
			actualObj = (oopisGreaterThan(GIV(pastSpaceStart), ((pastSpace()).start))
				? (/* begin objectStartingAt: */
					(address = ((pastSpace()).start)),
					/* begin rawNumSlotsOf: */
					flag("endianness"),
					(numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24),
					(numSlots == 0xFF
							? address + (BaseHeaderSize)
							: address))
				: GIV(nilObj));
		}
		if (oopisGreaterThanOrEqualToandLessThan(actualObj, ((pastSpace()).start), GIV(pastSpaceStart))) {
			while (1) {
				actualObj = objectAfterlimit(actualObj, GIV(pastSpaceStart));
				if (!((((usqInt) actualObj)) < (((usqInt) GIV(pastSpaceStart))))) break;
				if (classIndex == ((longAt(actualObj)) & 0x3FFFFF)) {
					subsequentObject = actualObj;
					goto l1;
				}
			}
			actualObj = GIV(nilObj);
		}
		while (1) {
			actualObj = objectAfterlimit(actualObj, GIV(endOfMemory));
			if (!((((usqInt) actualObj)) < (((usqInt) GIV(endOfMemory))))) break;
			if (classIndex == ((longAt(actualObj)) & 0x3FFFFF)) {
				subsequentObject = actualObj;
				goto l1;
			}
		}
		subsequentObject = null;
	l1:	/* end instanceAfter: */;
		if (!(subsequentObject == null)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), subsequentObject);
			GIV(stackPointer) = sp;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Return the object following the receiver in the heap. Return the
	SmallInteger zero when there are no more objects.
 */

static void
primitiveNextObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    sqInt object;
    char *sp;
    char *sp1;

	object = longAt(GIV(stackPointer));
	instance = accessibleObjectAfter(object);
	if (instance == null) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((0 << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp1;
	}
}


/*	A placeholder for primitives that haven't been implemented or are being
	withdrawn gradually. Just absorbs any arguments and returns the receiver.
 */

static void
primitiveNoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	null;
}

static void
primitiveNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt object;
    sqInt result;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerArgument = top;
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerReceiver = top1;
	result = !(compare31or32Bitsequal(integerReceiver, integerArgument));
	/* begin checkBooleanResult: */
	if (!GIV(primFailCode)) {
		/* begin pushBool: */
		/* begin push: */
		object = (result
			? GIV(trueObj)
			: GIV(falseObj));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

EXPORT(void)
primitiveNotEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr != integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	is the receiver/first argument not the same object as the (last)
	argument?. pop argumentCount because this can be used as a mirror
	primitive. 
 */

static void
primitiveNotIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    sqInt referent;
    sqInt referent1;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	if (((otherObject & 3) == 0)
	 && (((longAt(otherObject)) & 0x3FFFFF) == 8)) {
		assert(GIV(argumentCount) > 1);
		/* begin followForwarded: */
		assert(isForwarded(thisObject));
		referent = longAt((thisObject + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		otherObject = referent;
	}
	if (((thisObject & 3) == 0)
	 && (((longAt(thisObject)) & 0x3FFFFF) == 8)) {
		/* begin followForwarded: */
		assert(isForwarded(thisObject));
		referent1 = longAt((thisObject + (BaseHeaderSize)) + (0 << 2));
		while (((referent1 & 3) == 0)
		 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
			referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
		}
		thisObject = referent1;
	}
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject != otherObject
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Defined for CompiledMethods only */

static void
primitiveObjectAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index > 0)
		 && (index <= ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((thisReceiver + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((thisReceiver + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((thisReceiver + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((thisReceiver + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), longAt((thisReceiver + (BaseHeaderSize)) + ((index - 1) << 2)));
	GIV(stackPointer) = sp;
}


/*	Store a literal into a CompiledMethod at the given index. Defined for
	CompiledMethods only.
 */

static void
primitiveObjectAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt newValue;
    char *sp;
    sqInt thisReceiver;

	newValue = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((index & 1) == 0)
	 || ((index == ConstOne)
	 && ((newValue & 1) == 0))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	index = (index >> 1);
	thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((index > 0)
		 && (index <= ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((thisReceiver + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((thisReceiver + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((thisReceiver + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((thisReceiver + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(thisReceiver)));
	if (isOldObject(thisReceiver)) {

		/* most stores into young objects */

		if (((newValue & 3) == 0)
		 && ((((usqInt) newValue)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(thisReceiver))) >> 29) & 1) != 0)) {
				remember(thisReceiver);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(thisReceiver, (longAt(thisReceiver)) | (1 << 29));
			}
		}
	}
	longAtput((thisReceiver + (BaseHeaderSize)) + ((index - 1) << 2), newValue);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	This primitive is assumed to be fast (see e.g.
	MethodDictionary>>includesKey:) so make it so.
	N.B. Written to use literalHeaderOf: so that in Cog subclasses cogged
	methods (whose headers
	point to the machine code method) are still correctly scanned, for the
	header as well as literals. */

static void
primitiveObjectPointsTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqLong header;
    sqInt i;
    sqInt lastField;
    sqInt methodHeader;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    sqInt thang;
    sqInt trueOrFalse;

	thang = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 3) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	header = longLongAt(rcvr);
	fmt = (((unsigned sqLong)header) >> 24) & 0x1F;
	if (fmt <= 5) {
		if ((fmt == 3)
		 && ((header & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
			if (((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
				/* begin externalWriteBackHeadFramePointers */
				assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(GIV(stackPointer) < GIV(framePointer));
				assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
				assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
				 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
				(GIV(stackPage)->headFP = GIV(framePointer));
				(GIV(stackPage)->headSP = GIV(stackPointer));
				assert(pageListIsWellFormed());
				if ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
				 && (!(isWidowedContext(rcvr)))) {
					/* begin pop:thenPushBool: */
					trueOrFalse = marriedContextpointsTostackDeltaForCurrentFrame(rcvr, thang, 2);
					longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (trueOrFalse
						? GIV(trueObj)
						: GIV(falseObj)));
					GIV(stackPointer) = sp1;
					return;
				}
			}
			lastField = (CtxtTempFrameStart + (fetchStackPointerOf(rcvr))) * BytesPerOop;
		}
		else {
			lastField = (((numSlotsOf(rcvr)) << 2) + (BaseHeaderSize)) - (BaseHeaderSize);
		}
	}
	else {
		if (fmt < 24) {

			/* no pointers */

			/* begin pop:thenPushBool: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
		methodHeader = longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2));
		if (methodHeader == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp3;
			return;
		}
		lastField = ((
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + 1) * BytesPerOop;
	}
	for (i = (BaseHeaderSize); i <= lastField; i += BytesPerOop) {
		if ((longAt(rcvr + i)) == thang) {
			/* begin pop:thenPushBool: */
			longAtput((sp4 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
			GIV(stackPointer) = sp4;
			return;
		}
	}
	/* begin pop:thenPushBool: */
	longAtput((sp5 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp5;
}


/*	Common routine used by perform:withArgs:, perform:withArgs:inSuperclass:,
	object:perform:withArgs:inClass: et al. Answer nil on success.
	
	NOTE: The case of doesNotUnderstand: is not a failure to perform.
	The only failures are arg types and consistency of argumentCount.
	
	Since we're in the stack VM we can assume there is space to push the
	arguments provided they are within limits (max argument count is 15). We
	can therefore deal
	with the arbitrary amount of state to remove from the stack (lookup class,
	selector, mirror receiver) and arbitrary argument orders by deferring
	popping anything until
	we know whether the send has succeeded. So on failure we merely have to
	remove the actual receiver and arguments pushed, and on success we have to
	slide the actual
	receiver and arguments down to replace the original ones. */

static sqInt
primitiveObjectperformwithArgumentslookedUpIn(sqInt actualReceiver, sqInt selector, sqInt argumentArray, sqInt lookupClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt arraySize;
    sqInt delta;
    sqInt errorCode;
    sqInt i;
    sqInt index;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt numArgs;
    usqInt numSlots;
    sqInt numTemps;
    sqInt object;
    sqInt offset;
    sqInt performArgCount;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    sqInt top;

	if (!(((argumentArray & 3) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> 24) & 0x1F) == 2))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(argumentArray + 4))))) >> 24;
	arraySize = (numSlots == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(argumentArray - (BaseHeaderSize)))
		: numSlots);
	if (arraySize > LargeContextSlots) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}

	/* Push newMethod to save it in case of failure,
	   then push the actual receiver and args out of the array. */

	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), actualReceiver);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + (BaseHeaderSize)) + ((index - 1) << 2)));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), actualReceiver);
	
	findNewMethodInClassTag(classTagForClass(lookupClass));
	if ((((GIV(newMethod) & 3) == 0)
 && (((((usqInt) (longAt(GIV(newMethod)))) >> 24) & 0x1F) >= 24))
	 && (((((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 25) & 15) != GIV(argumentCount))) {

		/* Restore the state by popping all those array entries and pushing back the selector and array, and fail */

		/* begin pop: */
		GIV(stackPointer) += (arraySize + 1) * BytesPerWord;
		null;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = ((sqInt) top);
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}

	/* +2 = receiver + saved newMethod */

	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	null;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			null;
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		if (FailImbalancedPrimitives
		 && ((!GIV(primFailCode))
		 && (GIV(framePointer) == savedFramePointer))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */

			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				GIV(stackPointer) = savedStackPointer;
				failUnbalancedPrimitive();
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			null;
			goto l1;
		}
	}
	/* begin activateNewMethod */
	/* begin justActivateNewMethod */
	methodHeader1 = longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2));
	numTemps = (((usqInt) methodHeader1) >> 19) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> 25) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((headerOf(GIV(method))) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) methodHeader1)) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	/* begin push: */
	object = ((1 + (numArgs << 8)) + (0)) + (0);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? (((usqInt) methodHeader1) >> 1) & 0xFFFF
		: (((usqInt) methodHeader1) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader1) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize)) - 1;
	if (
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader1)) < 0
				? methodHeader1 & (65536 << SmallIntegerShift)
				: (methodHeader1 & 536871934) != 0)
#  else /* MULTIPLEBYTECODESETS */
		(methodHeader1 & 536871934) != 0
#  endif /* MULTIPLEBYTECODESETS */
		) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 
#    if MULTIPLEBYTECODESETS
			((((sqInt) methodHeader1)) < 0
						? 3
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? 234
		: 129)
#else /* MULTIPLEBYTECODESETS */
	129
#endif /* MULTIPLEBYTECODESETS */
	)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
					if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
						errorCode = longAt((table + (BaseHeaderSize)) + ((GIV(primFailCode) - 1) << 2));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	return null;
}


/*	Return the value of the millisecond clock as an integer, using the old
	method prior to the 64-bit microsecond clock.
 */

EXPORT(sqInt)
primitiveOriginalMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = ((((ioOldMSecs()) & MillisecondClockMask) << 1) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}

static void
primitivePerform(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt i;
    sqInt i1;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt newReceiver;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt performMethod;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt table;
    sqInt tagBits;

	performMethod = GIV(newMethod);
	GIV(messageSelector) = longAt(GIV(stackPointer) + ((GIV(argumentCount) - 1) * BytesPerWord));

	/* NOTE: the following lookup may fail and be converted to #doesNotUnderstand:,
	   so we must adjust argumentCount and slide args now, so that will work. */
	/* Slide arguments down over selector */

	newReceiver = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	GIV(argumentCount) -= 1;
	for (i = GIV(argumentCount); i >= 1; i += -1) {
		longAtput(GIV(stackPointer) + (i * BytesPerWord), longAt(GIV(stackPointer) + ((i - 1) * BytesPerWord)));
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
	/* begin fetchClassTagOf: */
	if (((tagBits = newReceiver & 3)) != 0) {
		lookupClassTag = ((tagBits & 1) != 0
			? 1
			: tagBits);
		goto l1;
	}
	lookupClassTag = (longAt(newReceiver)) & 0x3FFFFF;
l1:	/* end fetchClassTagOf: */;
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), newReceiver);
	
	findNewMethodInClassTag(lookupClassTag);
	if (!((((GIV(newMethod) & 3) == 0)
 && (((((usqInt) (longAt(GIV(newMethod)))) >> 24) & 0x1F) >= 24))
		 && (((((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 25) & 15) == GIV(argumentCount)))) {

		/* Slide the args back up (sigh) and re-insert the selector. */

		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
		for (i = 1; i <= GIV(argumentCount); i += 1) {
			longAtput(GIV(stackPointer) + ((i - 1) * BytesPerWord), longAt(GIV(stackPointer) + (i * BytesPerWord)));
		}
		longAtput(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord), GIV(messageSelector));
		GIV(argumentCount) += 1;
		GIV(newMethod) = performMethod;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			null;
			goto l2;
		}
		/* begin slowPrimitiveResponse */
		nArgs = GIV(argumentCount);
		savedStackPointer = GIV(stackPointer);
		savedFramePointer = GIV(framePointer);

		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		if (FailImbalancedPrimitives
		 && ((!GIV(primFailCode))
		 && (GIV(framePointer) == savedFramePointer))) {

			/* Don't fail if primitive has done something radical, e.g. perform: */

			if (GIV(stackPointer) != (savedStackPointer + (nArgs * BytesPerWord))) {
				flag("Would be nice to make this a message send of e.g. unbalancedPrimitive to the current process or context");
				GIV(stackPointer) = savedStackPointer;
				failUnbalancedPrimitive();
			}
		}
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			null;
			goto l2;
		}
	}
	/* begin activateNewMethod */
	/* begin justActivateNewMethod */
	methodHeader1 = longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2));
	numTemps = (((usqInt) methodHeader1) >> 19) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> 25) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((headerOf(GIV(method))) == methodHeader1);
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) methodHeader1)) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	/* begin push: */
	object = ((1 + (numArgs << 8)) + (0)) + (0);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? (((usqInt) methodHeader1) >> 1) & 0xFFFF
		: (((usqInt) methodHeader1) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader1) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize)) - 1;
	if (
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader1)) < 0
				? methodHeader1 & (65536 << SmallIntegerShift)
				: (methodHeader1 & 536871934) != 0)
#  else /* MULTIPLEBYTECODESETS */
		(methodHeader1 & 536871934) != 0
#  endif /* MULTIPLEBYTECODESETS */
		) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 
#    if MULTIPLEBYTECODESETS
			((((sqInt) methodHeader1)) < 0
						? 3
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader1)) < 0
		? 234
		: 129)
#else /* MULTIPLEBYTECODESETS */
	129
#endif /* MULTIPLEBYTECODESETS */
	)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
					if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
						errorCode = longAt((table + (BaseHeaderSize)) + ((GIV(primFailCode) - 1) << 2));
						goto l3;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l3:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l2:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}

static void
primitivePerformInSuperclass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt currentClass;
    sqInt lookupClass;
    sqInt rcvr;
    sqInt tagBits;

	lookupClass = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin fetchClassOf: */
	if (((tagBits = rcvr & 3)) != 0) {
		currentClass = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
		goto l1;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		currentClass = rcvr;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		currentClass = null;
		goto l1;
	}
	currentClass = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l1:	/* end fetchClassOf: */;
	while (currentClass != lookupClass) {
		currentClass = longAt((currentClass + (BaseHeaderSize)) + (SuperclassIndex << 2));
		if (currentClass == GIV(nilObj)) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
	}
	primitiveObjectperformwithArgumentslookedUpIn(rcvr, longAt(GIV(stackPointer) + (2 * BytesPerWord)), longAt(GIV(stackPointer) + (1 * BytesPerWord)), lookupClass);
}

static void
primitivePerformWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classTablePage;
    sqInt lookupClass;
    sqInt rcvr;
    sqInt tagBits;

	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin fetchClassOf: */
	if (((tagBits = rcvr & 3)) != 0) {
		lookupClass = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
		goto l1;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		lookupClass = rcvr;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		lookupClass = null;
		goto l1;
	}
	lookupClass = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l1:	/* end fetchClassOf: */;
	primitiveObjectperformwithArgumentslookedUpIn(rcvr, longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)), lookupClass);
}


/*	Primitive. Answer the last primitive method sampled by the profiler. */

EXPORT(sqInt)
primitiveProfilePrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileMethod));
	GIV(stackPointer) = sp;
	GIV(profileMethod) = GIV(nilObj);
}


/*	Primitive. Answer the last sample taken by the profiler, or nil if the
	profiler isn't active.
	See also primitiveProfileStart.
 */

EXPORT(sqInt)
primitiveProfileSample(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileProcess));
	GIV(stackPointer) = sp;
	GIV(profileProcess) = GIV(nilObj);
}


/*	Primitive. Install the semaphore to be used for profiling, 
	or nil if no semaphore should be used.
	See also primitiveProfileStart. */

EXPORT(sqInt)
primitiveProfileSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;

	if (!(GIV(argumentCount) == 1)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!(sema == GIV(nilObj))) {
		if (!((fetchClassOf(sema)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2))))) {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

			return null;
		}
	}
	GIV(profileSemaphore) = sema;
	GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj));
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
}


/*	Primitive. Begin profiling execution every by using the interrupt
	check-counter instead of a time-based process (which is limited to timing
	resolution and triggers off the same signal that many of the processes
	being profiled trigger off leading to consistently wrong results).
	The argument is the number of interrupt checks (method activations) to let
	go by before taking a sample. The sample is being stored in the
	profileSample iVar which can be retrieved by executing
	primitiveProfileSample. When a sample is taken, it signals the semaphore
	specified in primitiveProfileSemaphore.
	If the argument is less or equal to zero, it disables profiling.
 */

EXPORT(sqInt)
primitiveProfileStart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaTicks;
    sqInt integerPointer;

	if (!(GIV(argumentCount) == 1)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		deltaTicks = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		deltaTicks = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(nextProfileTick) = (ioHighResClock()) + deltaTicks;
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		null;
	}
}

static void
primitiveQuit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioExitWithErrorCode((GIV(argumentCount) == 1
		? ((longAt(GIV(stackPointer))) >> 1)
		: 0));
}


/*	Rounds negative results towards zero. */

static void
primitiveQuo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!(integerArg != 0)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		if (integerRcvr > 0) {
			if (integerArg > 0) {
				integerResult = integerRcvr / integerArg;
			}
			else {
				integerResult = 0 - (integerRcvr / (0 - integerArg));
			}
		}
		else {
			if (integerArg > 0) {
				integerResult = 0 - ((0 - integerRcvr) / integerArg);
			}
			else {
				integerResult = (0 - integerRcvr) / (0 - integerArg);
			}
		}
	}
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((integerResult ^ (integerResult << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveQuoLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Relinquish the processor for up to the given number of microseconds. The
	exact behavior of this primitive is platform dependent.
 */

static void
primitiveRelinquishProcessor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt microSecs;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		microSecs = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		microSecs = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {

		/* DO NOT allow relinquishing the processor while we are profiling since this
		   may skew the time base for our measures (it may reduce processor speed etc).
		   Instead we go full speed, therefore measuring the precise time we spend in the
		   inner idle loop as a busy loop. */

		if (GIV(nextProfileTick) == 0) {
			ioRelinquishProcessorForMicroseconds(microSecs);
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		null;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveRemLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!(!GIV(primFailCode))) {
		return;
	}
	result = a % b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Put this process on the scheduler's lists thus allowing it to proceed next
	time there is
	a chance for processes of it's priority level. It must go to the back of
	its run queue so
	as not to preempt any already running processes at this level. If the
	process's priority
	is higher than the current process, preempt the current process. */

static void
primitiveResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt proc;


	/* rcvr */

	proc = longAt(GIV(stackPointer));
	if (!((((longAt((proc + (BaseHeaderSize)) + (SuspendedContextIndex << 2))) & 3) == 0)
		 && (((longAt(longAt((proc + (BaseHeaderSize)) + (SuspendedContextIndex << 2)))) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	resumepreemptedYieldingIf(proc, GIV(preemptionYields));
}


/*	The character scanner primitive. */

static void
primitiveScanCharacters(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ascii;
    sqInt glyphIndex;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt stopReason;
    sqInt stops;

	if (!(GIV(argumentCount) == 6)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		kernDelta = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		kernDelta = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		stops = null;
		goto l2;
	}
	stops = oop;
l2:	/* end stackObjectValue: */;
	if (!(((stops & 3) == 0)
		 && (((((usqInt) (longAt(stops))) >> 24) & 0x1F) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((slotSizeOf(stops)) >= 258)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		scanRightX = (integerPointer1 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanRightX = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((oop1 & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		sourceString = null;
		goto l4;
	}
	sourceString = oop1;
l4:	/* end stackObjectValue: */;
	if (!(((sourceString & 3) == 0)
		 && (((((usqInt) (longAt(sourceString))) >> 24) & 0x1F) >= 16))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		scanStopIndex = (integerPointer2 >> 1);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStopIndex = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (5 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		scanStartIndex = (integerPointer3 >> 1);
		goto l6;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStartIndex = 0;
		goto l6;
	}
l6:	/* end stackIntegerValue: */;
	if (!((scanStartIndex > 0)
		 && ((scanStopIndex > 0)
		 && (scanStopIndex <= (byteSizeOf(sourceString)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackObjectValue: */
	oop2 = longAt(GIV(stackPointer) + (6 * BytesPerWord));
	if ((oop2 & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l7;
	}
	rcvr = oop2;
l7:	/* end stackObjectValue: */;
	if (!((((rcvr & 3) == 0)
 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) <= 5))
		 && ((slotSizeOf(rcvr)) >= 4))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	scanDestX = fetchIntegerofObject(0, rcvr);
	scanLastIndex = fetchIntegerofObject(1, rcvr);
	scanXTable = longAt((rcvr + (BaseHeaderSize)) + (2 << 2));
	scanMap = longAt((rcvr + (BaseHeaderSize)) + (3 << 2));
	if (!((((scanXTable & 3) == 0)
 && (((((usqInt) (longAt(scanXTable))) >> 24) & 0x1F) == 2))
		 && (((scanMap & 3) == 0)
		 && (((((usqInt) (longAt(scanMap))) >> 24) & 0x1F) == 2)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((slotSizeOf(scanMap)) == 256)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(!GIV(primFailCode))) {
		return;
	}

	/* Okay, here we go. We have eliminated nearly all failure
	   conditions, to optimize the inner fetches. */

	maxGlyph = (slotSizeOf(scanXTable)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = GIV(nilObj);
	while (scanLastIndex <= scanStopIndex) {

		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */


		/* Known to be okay since stops size >= 258 */

		ascii = byteAt((sourceString + (BaseHeaderSize)) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + (BaseHeaderSize)) + (ascii << 2)))) == nilOop)) {

			/* Store everything back and get out of here since some stop conditionn needs to be checked */

			if (!((scanDestX ^ (scanDestX << 1)) >= 0)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanDestX ^ (scanDestX << 1)) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + (BaseHeaderSize)) + (0 << 2), ((scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			null;
			/* begin storeInteger:ofObject:withValue: */
			if ((scanLastIndex ^ (scanLastIndex << 1)) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + (BaseHeaderSize)) + (1 << 2), ((scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			null;
			/* begin pop: */
			GIV(stackPointer) += 7 * BytesPerWord;
			null;
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), stopReason);
			GIV(stackPointer) = sp;
			return;
		}

		/* fail if the glyphIndex is out of range */

		glyphIndex = fetchIntegerofObject(ascii, scanMap);
		if (GIV(primFailCode)
		 || ((glyphIndex < 0)
		 || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable);

		/* Above may fail if non-integer entries in scanXTable */

		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable);
		if (GIV(primFailCode)) {
			return;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {

			/* Store everything back and get out of here since we got to the right edge */

			if (!((scanDestX ^ (scanDestX << 1)) >= 0)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((scanDestX ^ (scanDestX << 1)) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + (BaseHeaderSize)) + (0 << 2), ((scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			null;
			/* begin storeInteger:ofObject:withValue: */
			if ((scanLastIndex ^ (scanLastIndex << 1)) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + (BaseHeaderSize)) + (1 << 2), ((scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			null;
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + (BaseHeaderSize)) + ((CrossedX - 1) << 2)));
			GIV(stackPointer) = sp1;
			return;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!((scanDestX ^ (scanDestX << 1)) >= 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((scanDestX ^ (scanDestX << 1)) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(rcvr)));
		longAtput((rcvr + (BaseHeaderSize)) + (0 << 2), ((scanDestX << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	null;
	/* begin storeInteger:ofObject:withValue: */
	if ((scanStopIndex ^ (scanStopIndex << 1)) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(rcvr)));
		longAtput((rcvr + (BaseHeaderSize)) + (1 << 2), ((scanStopIndex << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	null;
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + (BaseHeaderSize)) + ((EndOfRun - 1) << 2)));
	GIV(stackPointer) = sp2;
}


/*	Return a SmallInteger indicating the current depth of the OS screen.
	Negative values are used to imply LSB type pixel format an there is some
	support in the VM for handling either MSB or LSB
 */

EXPORT(sqInt)
primitiveScreenDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt depth;
    char *sp;

	depth = ioScreenDepth();
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((depth << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return a point indicating the current size of the Smalltalk window.
	Currently there is a limit of 65535 in each direction because the point is
	encoded into a single 32bit value in the image header. This might well
	become a problem one day
 */

static void
primitiveScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt err;
    sqInt newHash;
    sqInt object;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
	pointWord = ioScreenSize();
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	/* begin eeInstantiateSmallClass:numSlots: */
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
	if (((newHash = rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) == 0) {
		if (((err = enterIntoClassTable(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))))) != 0) {
			classIndex = -err;
			goto l1;
		}
		/* begin rawHashBitsOf: */
		flag("endianness");
		newHash = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + 4)) & 0x3FFFFF;
		assert((classAtIndex(newHash)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))));
	}
	classIndex = newHash;
l1:	/* end ensureBehaviorHash: */;
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert(((YIndex + 1) >= 0)
	 && (classIndex != 0));
	assert(((((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) < (firstByteFormat())
	? (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F
	: ((((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F) & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(classIndex))));
	pointResult = allocateNewSpaceSlotsformatclassIndex(YIndex + 1, (((usqInt) (((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassPoint << 2))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1))) >> 16) & 0x1F, classIndex);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + (BaseHeaderSize)) + (XIndex << 2), ((((((usqInt) pointWord) >> 16) & 0xFFFF) << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + (BaseHeaderSize)) + (YIndex << 2), (((pointWord & 0xFFFF) << 1) | 1));
	object = pointResult;
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

static void
primitiveSecondsClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive32BitIntegerFor(ioSeconds());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Set to OS to the requested display mode.
	See also DisplayScreen setDisplayDepth:extent:fullscreen: */

static void
primitiveSetDisplayMode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt okay;
    char *sp;
    sqInt w;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		fsFlag = 0;
		goto l1;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */

	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	fsFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		d = (integerPointer2 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		d = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioSetDisplayMode(w, h, d, fsFlag);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((5 - 1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	On platforms that support it, set full-screen mode to the value of the
	boolean argument.
 */

static void
primitiveSetFullScreen(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argOop;

	argOop = longAt(GIV(stackPointer));
	if (argOop == GIV(trueObj)) {
		ioSetFullScreen(1);
	}
	else {
		if (argOop == GIV(falseObj)) {
			ioSetFullScreen(0);
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		null;
	}
}


/*	Primitive. Indicate the semaphore to be signalled for upon garbage
	collection 
 */

EXPORT(void)
primitiveSetGCSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(gcSemaphoreIndex) = index;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		null;
	}
}

static void
primitiveSetIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt hash1;
    sqInt integerPointer;
    sqInt oldHash;
    sqInt oop;
    char *sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		hash = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		hash = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		thisReceiver = null;
		goto l2;
	}
	thisReceiver = oop;
l2:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		/* begin hashBitsOf: */
		/* begin rawHashBitsOf: */
		flag("endianness");
		hash1 = (longAt(thisReceiver + 4)) & 0x3FFFFF;
		if (hash1 == 0) {

			/* would like to assert
			   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
			   but instance-specific behaviors that are instances of themselves may
			   fail this test. */

			hash1 = (newObjectHash()) & 0x3FFFFF;
			/* begin setHashBitsOf:to: */
			flag("endianness");
			assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
			longAtput(thisReceiver + 4, ((((longAt(thisReceiver + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash1);
		}
		oldHash = hash1;
		/* begin setHashBitsOf:to: */
		flag("endianness");
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		longAtput(thisReceiver + 4, ((((longAt(thisReceiver + 4)) | 0x3FFFFF) - 0x3FFFFF)) + hash);
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((oldHash << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Set the user interrupt keycode. The keycode is an integer whose encoding
	is described in the comment for primitiveKbdNext.
 */

static void
primitiveSetInterruptKey(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt keycode;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		keycode = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		keycode = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		/* begin setInterruptKeycode: */
		GIV(interruptKeycode) = keycode;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		null;
	}
}


/*	Primitive. Set the VM's log directory */

EXPORT(sqInt)
primitiveSetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt stringOop;
    sqInt sz;

	stringOop = longAt(GIV(stackPointer));
	if (!(((stringOop & 3) == 0)
		 && (((((usqInt) (longAt(stringOop))) >> 24) & 0x1F) >= 16))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = byteSizeOf(stringOop);
	ioSetLogDirectoryOfSize(firstIndexableField(stringOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		null;
	}
}


/*	Primitive. Set the OS window's label */

EXPORT(sqInt)
primitiveSetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt labelOop;
    sqInt sz;

	labelOop = longAt(GIV(stackPointer));
	if (!(((labelOop & 3) == 0)
		 && (((((usqInt) (longAt(labelOop))) >> 24) & 0x1F) >= 16))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = byteSizeOf(labelOop);
	ioSetWindowLabelOfSize(firstIndexableField(labelOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		null;
	}
}


/*	Primitive. Answer the OS window's size (extent) */

EXPORT(sqInt)
primitiveSetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt w;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioSetWindowWidthHeight(w, h);
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
		null;
	}
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Return the contents of the given index.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word. 
 */

static void
primitiveShortAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt index;
    sqInt integerPointer;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & 3) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) > 5))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}

	/* number of 16-bit fields */

	sz = ((sqInt) ((numSlotsOf(rcvr)) * BytesPerOop) >> 1);
	if (!((index >= 1)
		 && (index <= sz))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	addr = (rcvr + (BaseHeaderSize)) + (2 * (index - 1));
	value = shortAt(addr);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Set the contents of the given index to the
	given value. Note that the index specifies the i-th 16-bit entry, not the
	i-th byte or word.
 */

static void
primitiveShortAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt index;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		value = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		index = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!((!GIV(primFailCode))
		 && ((value >= -32768)
		 && (value <= 0x7FFF)))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(((rcvr & 3) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> 24) & 0x1F) > 5))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}

	/* number of 16-bit fields */

	sz = ((sqInt) ((((numSlotsOf(rcvr)) << 2) + (BaseHeaderSize)) - BaseHeaderSize) >> 1);
	if (!((index >= 1)
		 && (index <= sz))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	addr = (rcvr + BaseHeaderSize) + (2 * (index - 1));
	shortAtput(addr, value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), ((value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

static void
primitiveShowDisplayRect(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt left;
    sqInt right;
    sqInt top;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bottom = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bottom = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		top = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		top = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		right = (integerPointer2 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		right = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		left = (integerPointer3 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		left = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	displayBitsOfLeftTopRightBottom(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheDisplay << 2)), left, top, right, bottom);
	if (!GIV(primFailCode)) {
		ioForceDisplayUpdate();
		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;
		null;
	}
}


/*	Synchronously signal the semaphore.
	This may change the active process as a result. */

static void
primitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	synchronousSignal(longAt(GIV(stackPointer)));
}


/*	Set the low-water mark for free space. When the free space 
	falls below this level, the new and new: primitives fail and 
	system attempts to allocate space (e.g., to create a method 
	context) cause the low-space semaphore (if one is 
	registered) to be signalled. */

static void
primitiveSignalAtBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;
    sqInt integerPointer;
    sqInt top;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bytes = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bytes = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	if (!GIV(primFailCode)) {
		/* begin lowSpaceThreshold: */
		GIV(lowSpaceThreshold) = bytes;
		if (GIV(totalFreeOldSpace) < bytes) {
			growOldSpaceByAtLeast(bytes - GIV(totalFreeOldSpace));
		}
		assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
	}
	else {
		/* begin lowSpaceThreshold: */
		GIV(lowSpaceThreshold) = 0;
		if (GIV(totalFreeOldSpace) < 0) {
			growOldSpaceByAtLeast(0 - GIV(totalFreeOldSpace));
		}
		assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

static void
primitiveSignalAtMilliseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaMsecs;
    usqInt msecs;
    sqInt msecsObj;
    sqInt sema;

	msecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	msecs = positive32BitValueOf(msecsObj);
	if (GIV(primFailCode)
	 || ((sema & 3) != 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((fetchClassOfNonImm(sema)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2)))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((sema & 3) == 0)
			 && ((((usqInt) sema)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheTimerSemaphore << 2), sema);
		deltaMsecs = msecs - ((ioMSecs()) & MillisecondClockMask);
		if (deltaMsecs < 0) {
			deltaMsecs = (deltaMsecs + MillisecondClockMask) + 1;
		}
		GIV(nextWakeupUsecs) = (ioUTCMicroseconds()) + (deltaMsecs * 1000);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((GIV(nilObj) & 3) == 0)
			 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheTimerSemaphore << 2), GIV(nilObj));
		GIV(nextWakeupUsecs) = 0;
	}
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	null;
}


/*	Cause the time semaphore, if one has been registered, to be
	signalled when the microsecond clock is greater than or equal to
	the given tick value. A tick value of zero turns off timer interrupts. */

static void
primitiveSignalAtUTCMicroseconds(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;
    usqLong usecs;
    sqInt usecsObj;

	usecsObj = longAt(GIV(stackPointer));
	sema = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	usecs = positive64BitValueOf(usecsObj);
	if (GIV(primFailCode)
	 || ((sema & 1))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((fetchClassOfNonImm(sema)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2)))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((sema & 3) == 0)
			 && ((((usqInt) sema)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheTimerSemaphore << 2), sema);
		GIV(nextWakeupUsecs) = usecs;
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((GIV(nilObj) & 3) == 0)
			 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheTimerSemaphore << 2), GIV(nilObj));
		GIV(nextWakeupUsecs) = 0;
	}
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	null;
}

static void
primitiveSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		rcvr = result;
		goto l2;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = sin(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}

static void
primitiveSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	if (((rcvr & 3) != 0)
	 || (((hdr = longLongAt(rcvr)),
	((fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F)) < 2))) {

		/* This is not an indexable object */

		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if ((fmt == 3)
	 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		primitiveContextSize();
		return;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l1;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l1;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = rcvr;
		goto l2;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l2;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l2:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l3:	/* end fixedFieldsOf:format:length: */;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((totalLength - fixedFields) << 1) | 1));
	GIV(stackPointer) = sp;
}

static void
primitiveSizeInBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin pop:thenPushInteger: */
	integerVal = (((longAt(GIV(stackPointer))) & 3) != 0
		? 0
		: bytesInObject(longAt(GIV(stackPointer))));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((integerVal << 1) | 1));
	GIV(stackPointer) = sp;
}

static void
primitiveSizeInBytesOfInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byteSizeOrErr;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt instSpec;
    sqInt instSpec1;
    sqInt numSlots;
    sqInt numSlots1;
    char *sp;
    char *sp1;

	if (GIV(argumentCount) > 1) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	if (GIV(argumentCount) == 1) {
		if (!(((longAt(GIV(stackPointer))) & 1))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		/* begin byteSizeOfInstanceOf:withIndexableSlots: */
		classFormat = ((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1);
		instSpec = (((usqInt) classFormat) >> 16) & 0x1F;
		
		switch (instSpec) {
		case 2:
			numSlots = ((longAt(GIV(stackPointer))) >> 1);
			break;
		case 3:
		case 4:
			numSlots = (classFormat & ((1 << 16) - 1)) + (((longAt(GIV(stackPointer))) >> 1));
			break;
		case 9:
			numSlots = (((longAt(GIV(stackPointer))) >> 1)) * 2;
			break;
		case 10:
			numSlots = ((longAt(GIV(stackPointer))) >> 1);
			break;
		case 12:
			numSlots = ((sqInt) ((((longAt(GIV(stackPointer))) >> 1)) + 1) >> 1);
			break;
		case 16:
			numSlots = ((((longAt(GIV(stackPointer))) >> 1)) + ((wordSize()) - 1)) / (wordSize());
			break;
		default:
			byteSizeOrErr = -PrimErrBadReceiver;
			goto l1;

		}
		byteSizeOrErr = ((numSlots == 0
	? 8
	: (numSlots + (numSlots & 1)) << 2)) + ((numSlots >= 0xFF
	? (BaseHeaderSize) + (BaseHeaderSize)
	: BaseHeaderSize));
	l1:	/* end byteSizeOfInstanceOf:withIndexableSlots: */;
		if (byteSizeOrErr < 0) {
			(GIV(primFailCode) = -byteSizeOrErr);
			return;
		}
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((byteSizeOrErr << 1) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin byteSizeOfInstanceOf: */
	classFormat1 = ((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1);
	instSpec1 = (((usqInt) classFormat1) >> 16) & 0x1F;
	if (!((instSpec1 <= 1)
		 || (instSpec1 == 5))) {
		byteSizeOrErr = -PrimErrBadReceiver;
		goto l2;
	}
	numSlots1 = classFormat1 & ((1 << 16) - 1);
	byteSizeOrErr = ((numSlots1 == 0
	? 8
	: (numSlots1 + (numSlots1 & 1)) << 2)) + ((numSlots1 >= 0xFF
	? (BaseHeaderSize) + (BaseHeaderSize)
	: BaseHeaderSize));
l2:	/* end byteSizeOfInstanceOf: */;
	if (byteSizeOrErr < 0) {
		(GIV(primFailCode) = -byteSizeOrErr);
		return;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((byteSizeOrErr << 1) | 1));
	GIV(stackPointer) = sp1;
}


/*	save a normal snapshot under the same name as it was loaded unless it has
	been renamed by the last primitiveImageName
 */

static void
primitiveSnapshot(void)
{
	snapshot(0);
}


/*	save an embedded snapshot */

static void
primitiveSnapshotEmbedded(void)
{
	snapshot(1);
}

static void
primitiveSomeInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt instance;
    char *sp;

	class = longAt(GIV(stackPointer));
	instance = initialInstanceOf(class);
	if (instance == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp;
	}
}


/*	Return the first object in the heap. */

static void
primitiveSomeObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	null;
	/* begin push: */
	object = firstAccessibleObject();
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Return the oop of the SpecialObjectsArray. */

static void
primitiveSpecialObjectsOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(specialObjectsOop));
	GIV(stackPointer) = sp;
}

static void
primitiveSquareRoot(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double f;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		rcvr = result;
		goto l2;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end floatValueOf: */;
	/* begin success: */
	if (!(rcvr >= 0.0)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = sqrt(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	This primitive is called from Squeak as...
	<imageSegment> storeSegmentFor: arrayOfRoots into: aWordArray outPointers:
	anArray. 
 */
/*	This primitive will store a binary image segment (in the same format as
	the Squeak image file) of the receiver and every object in its proper tree
	of subParts (ie, that is not refered to from anywhere else outside the
	tree). All pointers from within the tree to objects outside the tree will
	be copied into the array of outpointers. In their place in the image
	segment will be an oop equal to the offset in the outPointer array (the
	first would be 4). but with the high bit set.
 */
/*	The primitive expects the array and wordArray to be more than adequately
	long. In this case it returns normally, and truncates the two arrays to
	exactly the right size. To simplify truncation, both incoming arrays are
	required to be 256 bytes or more long (ie with 3-word headers). If either
	array is too small, the primitive will fail, but in no other case.
	
	During operation of the primitive, it is necessary to convert from both
	internal and external oops to their mapped values. To make this fast, the
	headers of the original objects in question are replaced by the mapped
	values (and this is noted by adding the forbidden XX header type). Tables
	are kept of both kinds of oops, as well as of the original headers for
	restoration. 
	To be specific, there are two similar two-part tables, the outpointer
	array, and one in the upper fifth of the segmentWordArray. Each grows oops
	from the bottom up, and preserved headers from halfway up.
	
	In case of either success or failure, the headers must be restored. In the
	event of primitive failure, the table of outpointers must also be nilled
	out (since the garbage in the high half will not have been discarded.
 */

static void
primitiveStoreImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arrayOfRoots;
    sqInt ecode;
    sqInt outPointerArray;
    sqInt segmentWordArray;

	outPointerArray = longAt(GIV(stackPointer));
	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));

	/* Essential type checks */

	arrayOfRoots = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((((arrayOfRoots & 3) == 0)
 && (((((usqInt) (longAt(arrayOfRoots))) >> 24) & 0x1F) == 2))
		 && ((((outPointerArray & 3) == 0)
 && (((((usqInt) (longAt(outPointerArray))) >> 24) & 0x1F) == 2))
		 && (((segmentWordArray & 3) == 0)
		 && (((((usqInt) (longAt(segmentWordArray))) >> 24) & 0x1F) == 10))))) {

		/* Must be indexable words */

		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	ecode = PrimErrUnsupported;
	if (ecode == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
		null;
	}
	else {
		GIV(primFailCode) = ecode;
	}
}


/*	Atomic store into context stackPointer. 
	Also ensures that any newly accessible cells are initialized to nil */

static void
primitiveStoreStackp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt newStackp;
    sqInt onCurrentPage;
    sqInt sp;
    sqInt stackp;
    char *theFP;
    StackPage *thePage;
    sqInt value;

	ctxt = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		newStackp = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		newStackp = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!((!GIV(primFailCode))
		 && (((newStackp >= 0) && (newStackp <= (lengthOfformat(ctxt, (((usqInt) (longAt(ctxt))) >> 24) & 0x1F))))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((((longAt((ctxt + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
	 && (!(isWidowedContext(ctxt)))) {
		/* begin frameOfMarriedContext: */
		value = longAt((ctxt + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (((onCurrentPage = thePage == GIV(stackPage)))
		 && (theFP == GIV(framePointer))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		externalDivorceFrameandContext(theFP, ctxt);
		if (onCurrentPage) {
			GIV(framePointer) = (GIV(stackPage)->headFP);
			GIV(stackPointer) = (GIV(stackPage)->headSP);
		}
		else {
			assert(GIV(stackPage) == (stackPageFor(GIV(framePointer))));
			markStackPageMostRecentlyUsed(GIV(stackPage));
		}
	}
	/* begin fetchStackPointerOf: */
	sp = longAt((ctxt + (BaseHeaderSize)) + (StackPointerIndex << 2));
	if (!((sp & 1))) {
		stackp = 0;
		goto l1;
	}
	assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(ctxt)));
	stackp = (sp >> 1);
l1:	/* end fetchStackPointerOf: */;
	for (i = (stackp + 1); i <= newStackp; i += 1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(ctxt)));
		longAtput((ctxt + (BaseHeaderSize)) + (((i + CtxtTempFrameStart) - 1) << 2), GIV(nilObj));
	}
	/* begin storeStackPointerValue:inContext: */
	assert((ReceiverIndex + newStackp) < (lengthOf(ctxt)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(ctxt)));
	longAtput((ctxt + (BaseHeaderSize)) + (StackPointerIndex << 2), ((newStackp << 1) | 1));
	/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
}

static void
primitiveStringAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;

	/* begin commonAt: */
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & 3) != 0) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}

	/* No need to test for large positive integers here.  No object has 1g elements */

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	index = (index >> 1);
	/* begin stObject:at: */
	hdr = longLongAt(rcvr);
	fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l2;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l2;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l2:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = rcvr;
		goto l3;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l3;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l3:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l4:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3)
	 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l5;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + (BaseHeaderSize)) + (StackPointerIndex << 2));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l5;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 1);
	l5:	/* end stackPointerForMaybeMarriedContext: */;
		if (((((usqInt) index)) >= (((usqInt) 1)))
		 && (((((usqInt) index)) <= (((usqInt) stSize)))
		 && ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l6;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= 24
	? (((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1
	: 1)))
	 && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			result = longAt((rcvr + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2));
			goto l6;
		}
		if (fmt >= 16) {
			result = (((byteAt((rcvr + (BaseHeaderSize)) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l6;
		}
		result = positive32BitIntegerFor(long32At((rcvr + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2)));
		goto l6;
	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
l6:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		result = (CharacterTable == null
			? (((result >> 1)) << 2) + 2
			: (/* begin fetchPointer:ofObject: */
				/* begin characterTable */
				error("shouldNotImplement"),
				longAt((objOop + (BaseHeaderSize)) + (((result >> 1)) << 2))));

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAt: */;
}

static void
primitiveStringAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt class1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classTablePage;
    sqInt classTablePage1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqLong hdr;
    sqLong hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt reasonCode1;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    sqInt sp2;
    sqInt sp3;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    sqInt value;
    sqInt value1;
    sqInt valueToStore;
    sqInt valueToStore1;

	/* begin commonAtPut: */
	value = longAt(GIV(stackPointer));
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((rcvr & 3) == 0)) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}

	/* No need to test for large positive integers here.  No object has 1g elements */

	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index & 1))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	index = (index >> 1);
	/* begin stObject:at:put: */
	value1 = asciiOfCharacter(value);
	hdr = longLongAt(rcvr);
	fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(rcvr + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(rcvr - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l2;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l2;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l2:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(rcvr)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = rcvr;
		goto l3;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l3;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l3:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l4:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3)
	 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l5;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + (BaseHeaderSize)) + (StackPointerIndex << 2));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l5;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 1);
	l5:	/* end stackPointerForMaybeMarriedContext: */;
		if (((((usqInt) index)) >= (((usqInt) 1)))
		 && (((((usqInt) index)) <= (((usqInt) stSize)))
		 && ((((longAt((rcvr + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr), value1);
			goto l6;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= 24
	? (((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((rcvr + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1
	: 1)))
	 && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */

				if (((value1 & 3) == 0)
				 && ((((usqInt) value1)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> 29) & 1) != 0)) {
						remember(rcvr);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(rcvr, (longAt(rcvr)) | (1 << 29));
					}
				}
			}
			longAtput((rcvr + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2), value1);
		}
		else {
			if (fmt >= 16) {
				if (!((value1 & 1))) {
					GIV(primFailCode) = PrimErrBadIndex;
				}
				valueToStore = (value1 >> 1);
				if (!((valueToStore >= 0)
					 && (valueToStore <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
				}
				if (!GIV(primFailCode)) {
					byteAtput((rcvr + (BaseHeaderSize)) + ((index + fixedFields) - 1), valueToStore);
				}
			}
			else {

				/* long-word type objects */

				valueToStore = positive32BitValueOf(value1);
				if (!GIV(primFailCode)) {
					long32Atput((rcvr + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2), valueToStore);
				}
			}
		}
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
	}
	value1;
l6:	/* end stObject:at:put: */;

	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAtPut: */;
}


/*	
	<array> primReplaceFrom: start to: stop with: replacement 
	startingAt: repStart 
	<primitive: 105>
	 */

static void
primitiveStringReplace(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt array;
    sqInt arrayFmt;
    sqInt arrayInstSize;
    sqInt class;
    sqInt class1;
    sqInt classIndex;
    sqInt classIndex1;
    sqInt classTablePage;
    sqInt classTablePage1;
    sqLong hdr;
    sqInt i;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt repl;
    sqInt replFmt;
    sqInt replInstSize;
    sqInt replStart;
    sqInt srcIndex;
    sqInt start;
    sqInt stop;
    sqInt totalLength;
    sqInt valueWord;

	array = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		start = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		start = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		stop = (integerPointer1 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		stop = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	repl = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		replStart = (integerPointer2 >> 1);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		replStart = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	if (!(!GIV(primFailCode))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((repl & 3) != 0) {

		/* can happen in LgInt copy */

		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	hdr = longLongAt(array);
	arrayFmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(array)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots2 = ((usqInt) (((usqInt)(longAt(array + 4))))) >> 24;
	numSlots = (numSlots2 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(array - (BaseHeaderSize)))
		: numSlots2);
	if (arrayFmt <= 9) {
		totalLength = numSlots;
		goto l1;
	}
	if (arrayFmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (arrayFmt & 7);
		goto l1;
	}
	if (arrayFmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (arrayFmt & 3);
		goto l1;
	}
	totalLength = (numSlots << (2 - 2)) - (arrayFmt & 1);
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((arrayFmt > 5)
	 || (arrayFmt == 2)) {
		arrayInstSize = 0;
		goto l7;
	}
	if (arrayFmt < 2) {
		arrayInstSize = totalLength;
		goto l7;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(array)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = array;
		goto l6;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l6;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l6:	/* end fetchClassOfNonImm: */;
	arrayInstSize = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l7:	/* end fixedFieldsOf:format:length: */;
	if (!((start >= 1)
		 && (((start - 1) <= stop)
		 && ((stop + arrayInstSize) <= totalLength)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	hdr = longLongAt(repl);
	replFmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(repl)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots3 = ((usqInt) (((usqInt)(longAt(repl + 4))))) >> 24;
	numSlots1 = (numSlots3 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(repl - (BaseHeaderSize)))
		: numSlots3);
	if (replFmt <= 9) {
		totalLength = numSlots1;
		goto l2;
	}
	if (replFmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots1 << 2) - (replFmt & 7);
		goto l2;
	}
	if (replFmt >= 12) {
		totalLength = (numSlots1 << (2 - 1)) - (replFmt & 3);
		goto l2;
	}
	totalLength = (numSlots1 << (2 - 2)) - (replFmt & 1);
l2:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((replFmt > 5)
	 || (replFmt == 2)) {
		replInstSize = 0;
		goto l9;
	}
	if (replFmt < 2) {
		replInstSize = totalLength;
		goto l9;
	}
	/* begin fetchClassOfNonImm: */
	classIndex1 = (longAt(repl)) & 0x3FFFFF;
	if (classIndex1 == 0x1F) {
		class1 = repl;
		goto l8;
	}
	assert(classIndex1 >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex1 <= (tagMask()))
	 || (classIndex1 >= (arrayClassIndexPun())));
	classTablePage1 = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex1) >> 10) << 2));
	if (classTablePage1 == GIV(nilObj)) {
		class1 = null;
		goto l8;
	}
	class1 = longAt((classTablePage1 + (BaseHeaderSize)) + ((classIndex1 & ((1 << 10) - 1)) << 2));
l8:	/* end fetchClassOfNonImm: */;
	replInstSize = (((longAt((class1 + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l9:	/* end fixedFieldsOf:format:length: */;
	if (!((replStart >= 1)
		 && ((((stop - start) + replStart) + replInstSize) <= totalLength))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	if (arrayFmt < 16) {
		if (!(arrayFmt == replFmt)) {
			(GIV(primFailCode) = PrimErrInappropriate);
			return;
		}
	}
	else {
		if (!((arrayFmt & 24) == (replFmt & 24))) {
			(GIV(primFailCode) = PrimErrInappropriate);
			return;
		}
	}

	/* - 1 for 0-based access */

	srcIndex = (replStart + replInstSize) - 1;
	if (arrayFmt <= 5) {
		for (i = ((start + arrayInstSize) - 1); i < (stop + arrayInstSize); i += 1) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(array)));
			if (isOldObject(array)) {

				/* most stores into young objects */

				if ((((longAt((repl + (BaseHeaderSize)) + (srcIndex << 2))) & 3) == 0)
				 && ((((usqInt) (longAt((repl + (BaseHeaderSize)) + (srcIndex << 2))))) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(array))) >> 29) & 1) != 0)) {
						remember(array);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(array, (longAt(array)) | (1 << 29));
					}
				}
			}
			longAtput((array + (BaseHeaderSize)) + (i << 2), longAt((repl + (BaseHeaderSize)) + (srcIndex << 2)));
			srcIndex += 1;
		}
	}
	else {
		if (arrayFmt < 16) {

			/* 32-bit-word type objects */

			for (i = ((start + arrayInstSize) - 1); i < (stop + arrayInstSize); i += 1) {
				/* begin storeLong32:ofObject:withValue: */
				valueWord = long32At((repl + (BaseHeaderSize)) + (srcIndex << 2));
				long32Atput((array + (BaseHeaderSize)) + (i << 2), valueWord);
				srcIndex += 1;
			}
		}
		else {

			/* byte-type objects */

			for (i = ((start + arrayInstSize) - 1); i < (stop + arrayInstSize); i += 1) {
				byteAtput((array + (BaseHeaderSize)) + i, byteAt((repl + (BaseHeaderSize)) + srcIndex));
				srcIndex += 1;
			}
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	null;
}

static void
primitiveSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) - (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((integerResult ^ (integerResult << 1)) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

EXPORT(void)
primitiveSubtractLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (!(!GIV(primFailCode))) {
		return;
	}
	if (aIsNegative != bIsNegative) {

		/* Protect against overflow */

		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = !aIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Suspend the receiver, aProcess such that it can be executed
	again by sending #resume. If the given process is not currently running,
	take it off
	its corresponding list. The primitive returns the list the receiver was
	previously on.
 */

static void
primitiveSuspend(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt lastLink;
    sqInt myList;
    sqInt nextLink;
    sqInt process;
    char *sp;
    char *sp1;
    sqInt tempLink;

	process = longAt(GIV(stackPointer));
	if (process == (longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2)))) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(nilObj));
		GIV(stackPointer) = sp;
		transferTo(wakeHighestPriority());
	}
	else {

		/* XXXX Fixme. We should really check whether myList is a kind of LinkedList or not
		   but we can't easily so just do a quick check for nil which is the most common case. */

		myList = longAt((process + (BaseHeaderSize)) + (MyListIndex << 2));
		if (myList == GIV(nilObj)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		/* begin removeProcess:fromList: */
		firstLink = longAt((myList + (BaseHeaderSize)) + (FirstLinkIndex << 2));
		lastLink = longAt((myList + (BaseHeaderSize)) + (LastLinkIndex << 2));
		if (process == firstLink) {
			nextLink = longAt((process + (BaseHeaderSize)) + (NextLinkIndex << 2));
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(myList)));
			if (isOldObject(myList)) {

				/* most stores into young objects */

				if (((nextLink & 3) == 0)
				 && ((((usqInt) nextLink)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(myList))) >> 29) & 1) != 0)) {
						remember(myList);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(myList, (longAt(myList)) | (1 << 29));
					}
				}
			}
			longAtput((myList + (BaseHeaderSize)) + (FirstLinkIndex << 2), nextLink);
			if (process == lastLink) {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(myList)));
				if (isOldObject(myList)) {

					/* most stores into young objects */

					if (((GIV(nilObj) & 3) == 0)
					 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(myList))) >> 29) & 1) != 0)) {
							remember(myList);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(myList, (longAt(myList)) | (1 << 29));
						}
					}
				}
				longAtput((myList + (BaseHeaderSize)) + (LastLinkIndex << 2), GIV(nilObj));
			}
		}
		else {
			tempLink = firstLink;
			while (1) {
				if (tempLink == GIV(nilObj)) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

					null;
					goto l1;
				}
				nextLink = longAt((tempLink + (BaseHeaderSize)) + (NextLinkIndex << 2));
				if (nextLink == process) break;
				tempLink = longAt((tempLink + (BaseHeaderSize)) + (NextLinkIndex << 2));
			}
			nextLink = longAt((process + (BaseHeaderSize)) + (NextLinkIndex << 2));
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(tempLink)));
			if (isOldObject(tempLink)) {

				/* most stores into young objects */

				if (((nextLink & 3) == 0)
				 && ((((usqInt) nextLink)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(tempLink))) >> 29) & 1) != 0)) {
						remember(tempLink);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(tempLink, (longAt(tempLink)) | (1 << 29));
					}
				}
			}
			longAtput((tempLink + (BaseHeaderSize)) + (NextLinkIndex << 2), nextLink);
			if (process == lastLink) {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(myList)));
				if (isOldObject(myList)) {

					/* most stores into young objects */

					if (((tempLink & 3) == 0)
					 && ((((usqInt) tempLink)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(myList))) >> 29) & 1) != 0)) {
							remember(myList);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(myList, (longAt(myList)) | (1 << 29));
						}
					}
				}
				longAtput((myList + (BaseHeaderSize)) + (LastLinkIndex << 2), tempLink);
			}
		}
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(process)));
		if (isOldObject(process)) {

			/* most stores into young objects */

			if (((GIV(nilObj) & 3) == 0)
			 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(process))) >> 29) & 1) != 0)) {
					remember(process);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(process, (longAt(process)) | (1 << 29));
				}
			}
		}
		longAtput((process + (BaseHeaderSize)) + (NextLinkIndex << 2), GIV(nilObj));
	l1:	/* end removeProcess:fromList: */;
		if (!GIV(primFailCode)) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(process)));
			if (isOldObject(process)) {

				/* most stores into young objects */

				if (((GIV(nilObj) & 3) == 0)
				 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(process))) >> 29) & 1) != 0)) {
						remember(process);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(process, (longAt(process)) | (1 << 29));
					}
				}
			}
			longAtput((process + (BaseHeaderSize)) + (MyListIndex << 2), GIV(nilObj));
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), myList);
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive. Terminate up the context stack from the receiver up to but not
	including the argument, if previousContext is on my Context stack. Make
	previousContext my
	sender. This prim has to shadow the code in ContextPart>terminateTo: to be
	correct. 
 */

static void
primitiveTerminateTo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aContextOrNil;
    char *callerFP;
    char *callerFP1;
    char *callerFP2;
    char *contextsFP;
    usqInt contextsIP;
    char *contextsSP;
    sqInt currentCtx;
    char *fp;
    char *fp1;
    char *fp2;
    char *frameAbove;
    sqInt index;
    sqInt index1;
    sqInt index2;
    sqInt index3;
    char *newFP;
    char *newSP;
    sqInt nextCntx;
    StackPage *pageToStopOn;
    char *source;
    sqInt stackedReceiverOffset;
    char *theFP;
    char *theFP1;
    StackPage *thePage;
    sqInt thisCtx;
    sqInt value;
    sqInt value1;
    sqInt value2;
    sqInt value3;
    sqInt value4;
    sqInt value5;
    sqInt valuePointer;
    sqInt valuePointer1;

	aContextOrNil = longAt(GIV(stackPointer));
	if (!((aContextOrNil == GIV(nilObj))
		 || (((aContextOrNil & 3) == 0)
		 && (((longAt(aContextOrNil)) & 0x3FFFFF) == ClassMethodContextCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	thisCtx = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (thisCtx == aContextOrNil) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if ((aContextOrNil != GIV(nilObj))
	 && ((((longAt((aContextOrNil + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
	 && (!(isWidowedContext(aContextOrNil))))) {
		/* begin frameOfMarriedContext: */
		value = longAt((aContextOrNil + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		contextsFP = pointerForOop(value - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage));
		pageToStopOn = stackPageAtpages(index, GIV(pages));
	}
	else {
		pageToStopOn = 0;
	}
	if ((((longAt((thisCtx + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
	 && (!(isWidowedContext(thisCtx)))) {
		/* begin frameOfMarriedContext: */
		value2 = longAt((thisCtx + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value2 & 1));
		theFP = pointerForOop(value2 - 1);
		if ((theFP == GIV(framePointer))
		 && (pageToStopOn == GIV(stackPage))) {
			if ((frameCallerFP(theFP)) != contextsFP) {
				stackedReceiverOffset = (FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord);
				/* begin findFrameAbove:inPage: */
				fp = (pageToStopOn->headFP);
				if (fp == contextsFP) {
					frameAbove = 0;
					goto l1;
				}
				while (((callerFP = frameCallerFP(fp))) != 0) {
					if (callerFP == contextsFP) {
						frameAbove = fp;
						goto l1;
					}
					fp = callerFP;
				}
				error("did not find theFP in stack page");
				frameAbove = 0;
			l1:	/* end findFrameAbove:inPage: */;
				contextsIP = ((usqInt)(frameCallerSavedIP(frameAbove)));
				/* begin frameCallerSP: */
				assert(!(isBaseFrame(frameAbove)));
				newSP = (frameAbove + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((frameAbove + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
				newFP = (newSP - stackedReceiverOffset) - BytesPerWord;
				for (source = (theFP + stackedReceiverOffset); source >= GIV(stackPointer); source += (-BytesPerWord)) {
					newSP -= BytesPerWord;
					longAtput(newSP, longAt(source));
				}
				longAtput(newFP + FoxSavedFP, contextsFP);
				longAtput(newFP + FoxCallerSavedIP, contextsIP);
				assert(isContext(thisCtx));
				/* begin storePointerUnchecked:ofObject:withValue: */
				/* begin withSmallIntegerTags: */
				assert(((oopForPointer(newFP)) & (BytesPerWord - 1)) == 0);
				valuePointer = (oopForPointer(newFP)) + 1;
				assert(!(isForwarded(thisCtx)));
				longAtput((thisCtx + (BaseHeaderSize)) + (SenderIndex << 2), valuePointer);
				/* begin storePointerUnchecked:ofObject:withValue: */
				/* begin withSmallIntegerTags: */
				assert(((oopForPointer(contextsFP)) & (BytesPerWord - 1)) == 0);
				valuePointer1 = (oopForPointer(contextsFP)) + 1;
				assert(!(isForwarded(thisCtx)));
				longAtput((thisCtx + (BaseHeaderSize)) + (InstructionPointerIndex << 2), valuePointer1);
				GIV(framePointer) = newFP;
				GIV(stackPointer) = newSP;
			}
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
			null;
			assert(GIV(stackPage) == (mostRecentlyUsedPage()));
			return;
		}

		/* May cause a GC!! */

		theFP = externalEnsureIsBaseFrame(theFP);

		/* May also reclaim aContextOrNil's page, hence... */

		currentCtx = longAt(theFP + FoxCallerContext);
		if ((aContextOrNil != GIV(nilObj))
		 && ((((longAt((aContextOrNil + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(aContextOrNil))))) {
			/* begin frameOfMarriedContext: */
			value1 = longAt((aContextOrNil + (BaseHeaderSize)) + (SenderIndex << 2));
			/* begin withoutSmallIntegerTags: */
			assert((value1 & 1));
			contextsFP = pointerForOop(value1 - 1);
			/* begin stackPageFor: */
			/* begin stackPageAt: */
			index1 = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage));
			pageToStopOn = stackPageAtpages(index1, GIV(pages));
		}
		else {
			pageToStopOn = 0;
		}
	}
	else {
		currentCtx = longAt((thisCtx + (BaseHeaderSize)) + (SenderIndex << 2));
	}
	if (contexthasSender(thisCtx, aContextOrNil)) {

		/* Need to walk the stack freeing stack pages and nilling contexts. */

		while (!((currentCtx == aContextOrNil)
		 || (currentCtx == GIV(nilObj)))) {
			assert(isContext(currentCtx));
			if (((longAt((currentCtx + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
				/* begin frameOfMarriedContext: */
				value4 = longAt((currentCtx + (BaseHeaderSize)) + (SenderIndex << 2));
				/* begin withoutSmallIntegerTags: */
				assert((value4 & 1));
				theFP = pointerForOop(value4 - 1);
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				index3 = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
				thePage = stackPageAtpages(index3, GIV(pages));
				if (thePage == GIV(stackPage)) {
					/* begin findFrameAbove:inPage: */
					fp1 = (thePage->headFP);
					if (fp1 == theFP) {
						frameAbove = 0;
						goto l2;
					}
					while (((callerFP1 = frameCallerFP(fp1))) != 0) {
						if (callerFP1 == theFP) {
							frameAbove = fp1;
							goto l2;
						}
						fp1 = callerFP1;
					}
					error("did not find theFP in stack page");
					frameAbove = 0;
				l2:	/* end findFrameAbove:inPage: */;
					assert(frameAbove != 0);

					/* May cause a GC!! May also reclaim aContextOrNil's page, hence... */

					frameAbove = externalEnsureIsBaseFrame(frameAbove);
					if ((aContextOrNil != GIV(nilObj))
					 && ((((longAt((aContextOrNil + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
					 && (!(isWidowedContext(aContextOrNil))))) {
						/* begin frameOfMarriedContext: */
						value3 = longAt((aContextOrNil + (BaseHeaderSize)) + (SenderIndex << 2));
						/* begin withoutSmallIntegerTags: */
						assert((value3 & 1));
						contextsFP = pointerForOop(value3 - 1);
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						index2 = pageIndexForstackMemorybytesPerPage(contextsFP, GIV(stackMemory), GIV(bytesPerPage));
						pageToStopOn = stackPageAtpages(index2, GIV(pages));
					}
					else {
						pageToStopOn = 0;
					}
				}
				else {
					if (thePage == pageToStopOn) {

						/* We're here.  Cut back the stack to aContextOrNil's frame,
						   push its instructionPointer if it's not already a head frame,
						   and we're done. */

						/* begin findFrameAbove:inPage: */
						fp2 = (thePage->headFP);
						if (fp2 == contextsFP) {
							frameAbove = 0;
							goto l3;
						}
						while (((callerFP2 = frameCallerFP(fp2))) != 0) {
							if (callerFP2 == contextsFP) {
								frameAbove = fp2;
								goto l3;
							}
							fp2 = callerFP2;
						}
						error("did not find theFP in stack page");
						frameAbove = 0;
					l3:	/* end findFrameAbove:inPage: */;
						if (frameAbove != 0) {
							contextsSP = (frameCallerSP(frameAbove)) - BytesPerWord;
							longAtput(contextsSP, frameCallerSavedIP(frameAbove));
							/* begin setHeadFP:andSP:inPage: */
							assert(contextsSP < contextsFP);
							assert((contextsSP < ((thePage->baseAddress)))
							 && (contextsSP > (((thePage->realStackLimit)) - LargeContextSize)));
							assert((contextsFP < ((thePage->baseAddress)))
							 && (contextsFP > (((thePage->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
							(thePage->headFP = contextsFP);
							(thePage->headSP = contextsSP);
						}
						currentCtx = aContextOrNil;
					}
					else {

						/* We can free the entire page without further ado. */

						/* begin frameCallerContext: */
						theFP1 = (thePage->baseFP);
						currentCtx = longAt(theFP1 + FoxCallerContext);
						freeStackPageNoAssert(thePage);
					}
				}
			}
			else {
				nextCntx = longAt((currentCtx + (BaseHeaderSize)) + (SenderIndex << 2));
				/* begin markContextAsDead: */
				assert(isContext(currentCtx));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(currentCtx)));
				longAtput((currentCtx + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(currentCtx)));
				longAtput((currentCtx + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
				currentCtx = nextCntx;
			}
		}
	}
	assert(pageListIsWellFormed());
	if (((longAt((thisCtx + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(thisCtx, GIV(framePointer)));
		assert(isBaseFrame(frameOfMarriedContext(thisCtx)));
		/* begin frameOfMarriedContext: */
		value5 = longAt((thisCtx + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value5 & 1));
		theFP = pointerForOop(value5 - 1);
		longAtput(theFP + FoxCallerContext, aContextOrNil);
	}
	else {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(thisCtx)));
		if (isOldObject(thisCtx)) {

			/* most stores into young objects */

			if (((aContextOrNil & 3) == 0)
			 && ((((usqInt) aContextOrNil)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(thisCtx))) >> 29) & 1) != 0)) {
					remember(thisCtx);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(thisCtx, (longAt(thisCtx)) | (1 << 29));
				}
			}
		}
		longAtput((thisCtx + (BaseHeaderSize)) + (SenderIndex << 2), aContextOrNil);
	}
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
}


/*	Attempt to test-and-set the ownership of the critical section. If not
	owned, set the owner to the current process and answer false. If owned by
	the current process answer true. If owned by some other process answer
	nil. For simulation if there is an argument it is taken to be the
	effective activeProcess
	(see Process>>effectiveProcess). */

static void
primitiveTestAndSetOwnershipOfCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer));
		activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
	}

	/* CriticalSections are laid out like Semaphores */

	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + (BaseHeaderSize)) + (owningProcessIndex << 2));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		if (isOldObject(criticalSection)) {

			/* most stores into young objects */

			if (((activeProc & 3) == 0)
			 && ((((usqInt) activeProc)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(criticalSection))) >> 29) & 1) != 0)) {
					remember(criticalSection);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(criticalSection, (longAt(criticalSection)) | (1 << 29));
				}
			}
		}
		longAtput((criticalSection + (BaseHeaderSize)) + (owningProcessIndex << 2), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(nilObj));
	GIV(stackPointer) = sp2;
}


/*	Return true if the host OS does support the given display depth. */

static void
primitiveTestDisplayDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsPerPixel;
    sqInt integerPointer;
    sqInt okay;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bitsPerPixel = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bitsPerPixel = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioHasDisplayDepth(bitsPerPixel);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

static void
primitiveTimesTwoPower(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ccIndex;
    double f;
    sqInt integerPointer;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;
    sqInt top1;

	/* begin popInteger */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	integerPointer = top;
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		arg = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = 0;
		goto l1;
	}
l1:	/* end popInteger */;
	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top1 = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top1;
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l2;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l2:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = ldexp(rcvr, arg);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 2 * BytesPerWord;
	}
}

static void
primitiveTruncated(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    double frac;
    sqInt isFloat;
    sqInt oop;
    double rcvr;
    double result;
    sqInt top;
    double trunc;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto(oop + (BaseHeaderSize), result);
		rcvr = result;
		goto l2;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l2:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		frac = modf(rcvr, &trunc);
		flag("Dan");
		success((-1073741824.0 <= trunc) && (trunc <= 1073741823.0));
	}
	if (!GIV(primFailCode)) {
		pushInteger((sqInt) trunc);
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Primitive. Unload the module with the given name. */
/*	Reloading of the module will happen *later* automatically, when a 
	function from it is called. This is ensured by invalidating current
	sessionID. 
 */

static void
primitiveUnloadModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt firstBytecode;
    sqInt i;
    sqInt i1;
    sqInt i2;
    sqInt i3;
    sqInt limit;
    sqInt moduleName;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt primBits;
    sqInt primIdx;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = longAt(GIV(stackPointer));
	if ((moduleName & 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(((moduleName & 3) == 0)
		 && (((((usqInt) (longAt(moduleName))) >> 24) & 0x1F) >= 16))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(ioUnloadModuleOfLength(oopForPointer(firstIndexableField(moduleName)), byteSizeOf(moduleName)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin flushExternalPrimitives */
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & 0x3FFFFF) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24) {

				/* This is a compiled method */

				primIdx = 
#        if MULTIPLEBYTECODESETS
					((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
										? ((longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
												? ((firstBytecode = (objOop1 + ((LiteralStart + ((((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
													(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
												: 0)
										: ((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
											(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#        else /* MULTIPLEBYTECODESETS */
					((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
									(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#        endif /* MULTIPLEBYTECODESETS */
					;
				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */

					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & 0x3FFFFF) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24) {

				/* This is a compiled method */

				primIdx = 
#        if MULTIPLEBYTECODESETS
					((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
										? ((longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
												? ((firstBytecode = (objOop1 + ((LiteralStart + ((((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
													(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
												: 0)
										: ((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
											(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#        else /* MULTIPLEBYTECODESETS */
					((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
									(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#        endif /* MULTIPLEBYTECODESETS */
					;
				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */

					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (!(((longAt(objOop11)) & 0x3FFFFF) == 0)) {
				if (((((usqInt) (longAt(objOop11))) >> 24) & 0x1F) >= 24) {

					/* This is a compiled method */

					primIdx = 
#          if MULTIPLEBYTECODESETS
						((((sqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
												? ((longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
														? ((firstBytecode = (objOop11 + ((LiteralStart + ((((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
															(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
														: 0)
												: ((primBits = ((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
													(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#          else /* MULTIPLEBYTECODESETS */
						((primBits = ((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
											(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#          endif /* MULTIPLEBYTECODESETS */
						;
					if (primIdx == PrimitiveExternalCallIndex) {

						/* It's primitiveExternalCall */

						flushExternalPrimitiveOf(objOop11);
					}
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin flushAtCache */
	for (i2 = 1; i2 <= AtCacheTotalSize; i2 += 1) {
		GIV(atCache)[i2] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i3 = 0; i3 < MaxExternalPrimitiveTableSize; i3 += 1) {
		externalPrimitiveTable[i3] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	forceInterruptCheck();
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	null;
}


/*	Update the VMs notion of the current timezone. The VM sets its notion
	of the timezone once at start-up. If one wants the VM to keep its notion
	up-to-date arrange to invoke this primitive periodically. */

static void
primitiveUpdateTimezone(void)
{
	ioUpdateVMTimezone();
}


/*	Return the value of the microsecond clock as an integer. The microsecond
	clock is at
	least 60 bits wide which means it'll get to around August 38435 before it
	wraps around. */

static void
primitiveUTCMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioUTCMicroseconds());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer an array with UTC microseconds since the Posix epoch and
	the current seconds offset from GMT in the local time zone.
	This is a named (not numbered) primitive in the null module (ie the VM) */

EXPORT(sqInt)
primitiveUtcWithOffset(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    sqInt oop1;
    sqInt resultArray;
    char *sp;
    sqInt valuePointer;
    sqInt valuePointer1;


	/* 2177452800000000 = '1/1/1970' asDate asSeconds - '1/1/1901' asDate asSeconds * 1,000,000 */

	/* begin pushRemappableOop: */
	oop = positive64BitIntegerFor((ioUTCMicroseconds()) - 2177452800000000ULL);
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	resultArray = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassArray << 2)), 2);
	/* begin storePointer:ofObject:withValue: */
	/* begin popRemappableOop */
	oop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	valuePointer1 = oop1;
	assert(!(isForwarded(resultArray)));
	if (isOldObject(resultArray)) {

		/* most stores into young objects */

		if (((valuePointer1 & 3) == 0)
		 && ((((usqInt) valuePointer1)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(resultArray))) >> 29) & 1) != 0)) {
				remember(resultArray);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(resultArray, (longAt(resultArray)) | (1 << 29));
			}
		}
	}
	longAtput((resultArray + (BaseHeaderSize)) + (0 << 2), valuePointer1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	valuePointer = (((ioLocalSecondsOffset()) << 1) | 1);
	assert(!(isForwarded(resultArray)));
	longAtput((resultArray + (BaseHeaderSize)) + (1 << 2), valuePointer);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), resultArray);
	GIV(stackPointer) = sp;
}


/*	Behaviour depends on argument count:
	0 args:	return an Array of VM parameter values;
	1 arg:	return the indicated VM parameter;
	2 args:	set the VM indicated parameter.
	VM parameters are numbered as follows:
	1	end of old-space (0-based, read-only)
	2	end of young-space (read-only)
	3	end of memory (read-only)
	4	nil (was allocationCount (read-only))
	5	nil (was allocations between GCs (read-write)
	6	survivor count tenuring threshold (read-write)
	7	full GCs since startup (read-only)
	8	total milliseconds in full GCs since startup (read-only)
	9	incremental GCs (SqueakV3) or scavenges (Spur) since startup (read-only)
	10	total milliseconds in incremental GCs (SqueakV3) or scavenges (Spur)
	since startup (read-only)
	11	tenures of surving objects since startup (read-only)
	12-20 specific to ikp's JITTER VM
	21	root table size (read-only)
	22	root table overflows since startup (read-only)
	23	bytes of extra memory to reserve for VM buffers, plugins, etc.
	24	memory threshold above which shrinking object memory (rw)
	25	memory headroom when growing object memory (rw)
	26	interruptChecksEveryNms - force an ioProcessEvents every N milliseconds
	(rw) 27	number of times mark loop iterated for current IGC/FGC (read-only)
	includes ALL marking
	28	number of times sweep loop iterated for current IGC/FGC (read-only)
	29	number of times make forward loop iterated for current IGC/FGC
	(read-only) 30	number of times compact move loop iterated for current
	IGC/FGC (read-only)
	31	number of grow memory requests (read-only)
	32	number of shrink memory requests (read-only)
	33	number of root table entries used for current IGC/FGC (read-only)
	34	number of allocations done before current IGC/FGC (read-only)
	35	number of survivor objects after current IGC/FGC (read-only)
	36	millisecond clock when current IGC/FGC completed (read-only)
	37	number of marked objects for Roots of the world, not including Root
	Table entries for current IGC/FGC (read-only)
	38	milliseconds taken by current IGC (read-only)
	39	Number of finalization signals for Weak Objects pending when current
	IGC/FGC completed (read-only)
	40	BytesPerWord for this image
	41	imageFormatVersion for the VM
	42	number of stack pages in use
	43	desired number of stack pages (stored in image file header, max 65535)
	44	size of eden, in bytes
	45	desired size of eden, in bytes (stored in image file header)
	46	machine code zone size, in bytes (Cog only; otherwise nil)
	47	desired machine code zone size (Cog only; otherwise nil)
	48	various header flags. See getCogVMFlags.
	49	max size the image promises to grow the external semaphore table to (0
	sets to default, which is 256 as of writing)
	50-55 nil; reserved for VM parameters that persist in the image (such as
	eden above)
	56	number of process switches since startup (read-only)
	57	number of ioProcessEvents calls since startup (read-only)
	58	number of ForceInterruptCheck calls since startup (read-only)
	59	number of check event calls since startup (read-only)
	60	number of stack page overflows since startup (read-only)
	61	number of stack page divorces since startup (read-only)
	62	compiled code compactions since startup (read-only; Cog only; otherwise
	nil) 63	total milliseconds in compiled code compactions since startup
	(read-only; Cog only; otherwise nil)
	64	the number of methods that currently have jitted machine-code
	65	whether the VM supports MULTIPLE_BYTECODE_SETS or not.
	66	the byte size of a stack page
	67 - 69 reserved for more Cog-related info
	70	the vmProxyMajorVersion (the interpreterProxy VM_MAJOR_VERSION)
	71	the vmProxyMinorVersion (the interpreterProxy VM_MINOR_VERSION)
	Note: Thanks to Ian Piumarta for this primitive. */

static void
primitiveVMParameter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    float aProportion;
    sqInt arg;
    sqInt averageObjectSize;
    sqInt i;
    sqInt index;
    sqInt paramsArraySize;
    sqInt result;
    char *sp;
    char *sp1;
    char *sp2;
    usqLong statIGCDeltaUsecs = 0;
    sqInt statIncrGCs = 0;
    usqLong statIncrGCUsecs = 0;
    sqInt statRootTableOverflows = 0;
    sqInt statShrinkMemory = 0;
    sqInt statSpecialMarkCount = 0;
    sqInt statSurvivorCount = 0;
    sqInt valuePointer;
    sqInt valuePointer1;
    sqInt valuePointer10;
    sqInt valuePointer11;
    sqInt valuePointer12;
    sqInt valuePointer13;
    sqInt valuePointer14;
    sqInt valuePointer15;
    sqInt valuePointer16;
    sqInt valuePointer2;
    sqInt valuePointer3;
    sqInt valuePointer4;
    sqInt valuePointer5;
    sqInt valuePointer6;
    sqInt valuePointer7;
    sqInt valuePointer8;
    sqInt valuePointer9;

	paramsArraySize = 71;
	if (GIV(argumentCount) == 0) {
		result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassArray << 2)), paramsArraySize);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer = ((((GIV(freeStart) - (((eden()).start))) + (GIV(pastSpaceStart) - (((pastSpace()).start)))) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (0 << 2), valuePointer);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer1 = (((totalBytesInSegments()) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (1 << 2), valuePointer1);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer2 = ((((((GIV(eden).limit)) - (((((GIV(futureSpace).start)) < ((GIV(pastSpace).start))) ? ((GIV(futureSpace).start)) : ((GIV(pastSpace).start))))) + (totalBytesInSegments())) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (2 << 2), valuePointer2);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (3 << 2), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (4 << 2), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer3 = (((tenuringThreshold()) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (5 << 2), valuePointer3);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (6 << 2), ((GIV(statFullGCs) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (7 << 2), ((((GIV(statFullGCUsecs) + 500) / 1000) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer4 = (((GIV(statScavenges)) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (8 << 2), valuePointer4);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer5 = (((((GIV(statScavengeGCUsecs)) + 500) / 1000) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (9 << 2), valuePointer5);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (10 << 2), ((GIV(statTenures) << 1) | 1));
		for (i = 11; i <= 19; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(result)));
			longAtput((result + (BaseHeaderSize)) + (i << 2), ConstZero);
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer6 = (((rememberedSetSize()) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (20 << 2), valuePointer6);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (21 << 2), ((statRootTableOverflows << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (22 << 2), ((extraVMMemory << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (23 << 2), ((GIV(shrinkThreshold) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (24 << 2), ((GIV(growHeadroom) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer7 = (((ioHeartbeatMilliseconds()) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (25 << 2), valuePointer7);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (26 << 2), ((GIV(statMarkCount) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (27 << 2), ((0 << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (28 << 2), ((0 << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (29 << 2), ((GIV(statCompactPassCount) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (30 << 2), ((GIV(statGrowMemory) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (0x1F << 2), ((statShrinkMemory << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (32 << 2), ((GIV(statRootTableCount) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (33 << 2), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (34 << 2), ((statSurvivorCount << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (35 << 2), ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (36 << 2), ((statSpecialMarkCount << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (37 << 2), ((((statIGCDeltaUsecs + 500) / 1000) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (38 << 2), ((GIV(statPendingFinalizationSignals) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (39 << 2), ((BytesPerWord << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer8 = (((imageFormatVersion()) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (40 << 2), valuePointer8);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (41 << 2), ((GIV(numStackPages) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (42 << 2), ((desiredNumStackPages << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer9 = (((((GIV(eden).limit)) - ((GIV(eden).start))) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (43 << 2), valuePointer9);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (44 << 2), ((desiredEdenBytes << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (45 << 2), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (46 << 2), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer10 = ((((GIV(preemptionYields)
	? 0
	: 4)) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (47 << 2), valuePointer10);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer11 = (((ioGetMaxExtSemTableSize()) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (48 << 2), valuePointer11);
		for (i = 49; i <= 54; i += 1) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(result)));
			longAtput((result + (BaseHeaderSize)) + (i << 2), GIV(nilObj));
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (55 << 2), ((GIV(statProcessSwitch) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (56 << 2), ((GIV(statIOProcessEvents) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer12 = ((GIV(statForceInterruptCheck) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (57 << 2), valuePointer12);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (58 << 2), ((GIV(statCheckForEvents) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (59 << 2), ((GIV(statStackOverflow) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (60 << 2), ((GIV(statStackPageDivorce) << 1) | 1));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (61 << 2), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (0x3E << 2), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (0x3F << 2), ConstZero);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer13 = GIV(falseObj);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (64 << 2), valuePointer13);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer14 = (((stackPageByteSize()) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (65 << 2), valuePointer14);
		for (i = 66; i <= 68; i += 1) {

			/* reserved for more Cog-related info */

			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(result)));
			longAtput((result + (BaseHeaderSize)) + (i << 2), GIV(nilObj));
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer15 = (((VM_PROXY_MAJOR) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (69 << 2), valuePointer15);
		/* begin storePointerUnchecked:ofObject:withValue: */
		valuePointer16 = (((VM_PROXY_MINOR) << 1) | 1);
		assert(!(isForwarded(result)));
		longAtput((result + (BaseHeaderSize)) + (70 << 2), valuePointer16);
		assert(paramsArraySize == 71);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	arg = longAt(GIV(stackPointer));
	if (!((arg & 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	arg = (arg >> 1);
	if (GIV(argumentCount) == 1) {

		/* read VM parameter */

		if ((arg < 1)
		 || (arg > paramsArraySize)) {
			(GIV(primFailCode) = PrimErrBadIndex);
			return;
		}
		result = GIV(nilObj);
		if (arg == 1) {
			result = ((((GIV(freeStart) - (((eden()).start))) + (GIV(pastSpaceStart) - (((pastSpace()).start)))) << 1) | 1);
		}
		if (arg == 2) {
			result = (((totalBytesInSegments()) << 1) | 1);
		}
		if (arg == 3) {
			result = ((((((GIV(eden).limit)) - (((((GIV(futureSpace).start)) < ((GIV(pastSpace).start))) ? ((GIV(futureSpace).start)) : ((GIV(pastSpace).start))))) + (totalBytesInSegments())) << 1) | 1);
		}
		if (arg == 4) {

			/* was allocationCount */

			result = GIV(nilObj);
		}
		if (arg == 5) {

			/* was allocationsBetweenGCs */

			result = GIV(nilObj);
		}
		if (arg == 6) {
			result = (((tenuringThreshold()) << 1) | 1);
		}
		if (arg == 7) {
			result = ((GIV(statFullGCs) << 1) | 1);
		}
		if (arg == 8) {
			result = ((((GIV(statFullGCUsecs) + 500) / 1000) << 1) | 1);
		}
		if (arg == 9) {
			result = (((GIV(statScavenges)) << 1) | 1);
		}
		if (arg == 10) {
			result = (((((GIV(statScavengeGCUsecs)) + 500) / 1000) << 1) | 1);
		}
		if (arg == 11) {
			result = ((GIV(statTenures) << 1) | 1);
		}
		if (((arg >= 12) && (arg <= 20))) {
			result = ConstZero;
		}
		if (arg == 21) {
			result = (((rememberedSetSize()) << 1) | 1);
		}
		if (arg == 22) {
			result = ((statRootTableOverflows << 1) | 1);
		}
		if (arg == 23) {
			result = ((extraVMMemory << 1) | 1);
		}
		if (arg == 24) {
			result = ((GIV(shrinkThreshold) << 1) | 1);
		}
		if (arg == 25) {
			result = ((GIV(growHeadroom) << 1) | 1);
		}
		if (arg == 26) {
			result = (((ioHeartbeatMilliseconds()) << 1) | 1);
		}
		if (arg == 27) {
			result = ((GIV(statMarkCount) << 1) | 1);
		}
		if (arg == 28) {
			result = ((0 << 1) | 1);
		}
		if (arg == 29) {
			result = ((0 << 1) | 1);
		}
		if (arg == 30) {
			result = ((GIV(statCompactPassCount) << 1) | 1);
		}
		if (arg == 0x1F) {
			result = ((GIV(statGrowMemory) << 1) | 1);
		}
		if (arg == 32) {
			result = ((statShrinkMemory << 1) | 1);
		}
		if (arg == 33) {
			result = ((GIV(statRootTableCount) << 1) | 1);
		}
		if (arg == 34) {

			/* was statAllocationCount */

			result = GIV(nilObj);
		}
		if (arg == 35) {
			result = ((statSurvivorCount << 1) | 1);
		}
		if (arg == 36) {
			result = ((((GIV(statGCEndUsecs) / 1000) & MillisecondClockMask) << 1) | 1);
		}
		if (arg == 37) {
			result = ((statSpecialMarkCount << 1) | 1);
		}
		if (arg == 38) {
			result = ((((statIGCDeltaUsecs + 500) / 1000) << 1) | 1);
		}
		if (arg == 39) {
			result = ((GIV(statPendingFinalizationSignals) << 1) | 1);
		}
		if (arg == 40) {
			result = ((BytesPerWord << 1) | 1);
		}
		if (arg == 41) {
			result = (((imageFormatVersion()) << 1) | 1);
		}
		if (arg == 42) {
			result = ((GIV(numStackPages) << 1) | 1);
		}
		if (arg == 43) {
			result = ((desiredNumStackPages << 1) | 1);
		}
		if (arg == 44) {
			result = (((((GIV(eden).limit)) - ((GIV(eden).start))) << 1) | 1);
		}
		if (arg == 45) {
			result = ((desiredEdenBytes << 1) | 1);
		}
		if (arg == 46) {
			result = GIV(nilObj);
		}
		if (arg == 47) {
			result = GIV(nilObj);
		}
		if (arg == 48) {
			result = ((((GIV(preemptionYields)
	? 0
	: 4)) << 1) | 1);
		}
		if (arg == 49) {
			result = (((ioGetMaxExtSemTableSize()) << 1) | 1);
		}
		if (arg == 56) {
			result = ((GIV(statProcessSwitch) << 1) | 1);
		}
		if (arg == 57) {
			result = ((GIV(statIOProcessEvents) << 1) | 1);
		}
		if (arg == 58) {
			result = ((GIV(statForceInterruptCheck) << 1) | 1);
		}
		if (arg == 59) {
			result = ((GIV(statCheckForEvents) << 1) | 1);
		}
		if (arg == 60) {
			result = ((GIV(statStackOverflow) << 1) | 1);
		}
		if (arg == 61) {
			result = ((GIV(statStackPageDivorce) << 1) | 1);
		}
		if (arg == 0x3E) {
			result = GIV(nilObj);
		}
		if (arg == 0x3F) {
			result = GIV(nilObj);
		}
		if (arg == 64) {
			result = ConstZero;
		}
		if (arg == 65) {
			result = GIV(falseObj);
		}
		if (arg == 66) {
			result = (((stackPageByteSize()) << 1) | 1);
		}
		if (arg == 70) {
			result = (((VM_PROXY_MAJOR) << 1) | 1);
		}
		if (arg == 71) {
			result = (((VM_PROXY_MINOR) << 1) | 1);
		}
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	if (!(GIV(argumentCount) == 2)) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index & 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	index = (index >> 1);
	if ((index <= 0)
	 || (index > 0x3F)) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */

	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	if (index == 5) {

		/* Was:
		   result := allocationsBetweenGCs.
		   allocationsBetweenGCs := arg. */
		/* Ignore for now, because old images won't start up otherwise.
		   See 44 & 45 for eden size setting. */

		result = GIV(nilObj);
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 6) {
		/* begin tenuringThreshold */
		averageObjectSize = 8 * (wordSize());
		result = ((sqInt)(((scavengerTenuringThreshold()) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / averageObjectSize));
		/* begin tenuringThreshold: */
		/* begin scavengerTenuringThreshold: */
		aProportion = (((double) ((arg * 8) * (wordSize())) )) / (((double) (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) ));
		GIV(tenuringProportion) = aProportion;
		GIV(tenureThreshold) = (aProportion == 0.0
			? 0
			: (round(((((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) * (1.0 - aProportion)))) + ((GIV(pastSpace).start)));
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 23) {
		result = extraVMMemory;
		extraVMMemory = arg;
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
	}
	if (index == 24) {
		result = GIV(shrinkThreshold);
		if (arg > 0) {
			/* begin shrinkThreshold: */
			GIV(shrinkThreshold) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 25) {
		result = GIV(growHeadroom);
		if (arg > 0) {
			GIV(growHeadroom) = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 26) {
		if (arg > 1) {
			result = ioHeartbeatMilliseconds();
			ioSetHeartbeatMilliseconds(arg);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 43) {
		if ((arg >= 0)
		 && (arg <= 0xFFFF)) {
			result = desiredNumStackPages;
			desiredNumStackPages = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if (index == 45) {
		if (arg >= 0) {
			result = desiredEdenBytes;
			desiredEdenBytes = arg;
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if ((index == 47)
	 && (0)) {
		if (arg >= 0) {
			result = GIV(nilObj);
			/* begin setDesiredCogCodeSize: */
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
		}
	}
	if ((index == 48)
	 && (0)) {
		if (arg >= 0) {
			result = ((((GIV(preemptionYields)
	? 0
	: 4)) << 1) | 1);
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setCogVMFlags: */
			if ((((usqInt)arg)) > 7) {
				GIV(primFailCode) = PrimErrUnsupported;
				goto l1;
			}
			GIV(preemptionYields) = (arg & 4) == 0;
		l1:	/* end setCogVMFlags: */;
		}
	}
	if (index == 49) {
		if ((arg >= 0)
		 && (arg <= 0xFFFF)) {
			result = ioGetMaxExtSemTableSize();
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			/* begin setMaxExtSemSizeTo: */
			GIV(maxExtSemTabSizeSet) = 1;
			ioSetMaxExtSemTableSize(arg);
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp2 = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), ((result << 1) | 1));
		GIV(stackPointer) = sp2;
		return;
	}
	GIV(primFailCode) = PrimErrInappropriate;
}


/*	Return a string containing the path name of VM's directory. */

static void
primitiveVMPath(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt s;
    char *sp;
    sqInt sz;

	sz = vmPathSize();
	s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2)), sz);
	vmPathGetLength(s + BaseHeaderSize, sz);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
	GIV(stackPointer) = sp;
}


/*	Primitive.
	0 args: Answer whether the VM Profiler is running or not.
	1 arg:	Copy the sample data into the supplied argument, which must be a
	Bitmap of suitable size. Answer the number of samples copied into the
	buffer.  */

static void
primitiveVMProfileSamplesInto(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    long bufferSize;
    sqInt numSamples;
    sqInt oop;
    sqInt running;
    sqInt sampleBuffer;
    unsigned long *sampleBufferAddress;
    char *sp;
    char *sp1;
    sqInt successBoolean;
    sqInt successBoolean1;

	ioNewProfileStatus(&running,&bufferSize);
	if (GIV(argumentCount) == 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (running
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin success: */
	if (!(GIV(argumentCount) == 1)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin stackObjectValue: */
		oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
		if ((oop & 3) != 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			sampleBuffer = null;
			goto l1;
		}
		sampleBuffer = oop;
	l1:	/* end stackObjectValue: */;
		/* begin assertClassOf:is: */
		/* begin success: */
		successBoolean1 = ((longAt(sampleBuffer)) & 0x3FFFFF) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassBitmap << 2))));
		if (!successBoolean1) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		/* begin success: */
		successBoolean = (numSlotsOf(sampleBuffer)) >= bufferSize;
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!(!GIV(primFailCode))) {
		return;
	}
	/* begin firstFixedField: */
	sampleBufferAddress = ((void *) (pointerForOop(sampleBuffer + (BaseHeaderSize))));
	numSamples = ioNewProfileSamplesInto(sampleBufferAddress);
	/* begin pop:thenPushInteger: */
	longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((numSamples << 1) | 1));
	GIV(stackPointer) = sp1;
}


/*	Potentially crash the VM by voiding the receiver. A subsequent inst var
	access in the caller's frame should indirect through a null pointer. */

EXPORT(void)
primitiveVoidReceiver(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	longAtPointerput(frameReceiverOffset(GIV(framePointer)), 0);
}


/*	Void all internal VM state in the stack and machine code zones */

static void
primitiveVoidVMState(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(0);
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
}

static void
primitiveWait(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt excessSignals;
    sqInt sema;


	/* rcvr */

	sema = longAt(GIV(stackPointer));
	excessSignals = fetchIntegerofObject(ExcessSignalsIndex, sema);
	if (excessSignals > 0) {
		/* begin storeInteger:ofObject:withValue: */
		if (((excessSignals - 1) ^ ((excessSignals - 1) << 1)) >= 0) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(sema)));
			longAtput((sema + (BaseHeaderSize)) + (ExcessSignalsIndex << 2), (((excessSignals - 1) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		null;
	}
	else {
		activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
		addLastLinktoList(activeProc, sema);
		transferTo(wakeHighestPriority());
	}
}


/*	primitively do the equivalent of Process>yield */

static void
primitiveYield(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + (BaseHeaderSize)) + (PriorityIndex << 2));
	assert((oop & 1));
	priority = (oop >> 1);
	processLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ProcessListsIndex << 2));
	processList = longAt((processLists + (BaseHeaderSize)) + ((priority - 1) << 2));
	if (!((longAt((processList + (BaseHeaderSize)) + (FirstLinkIndex << 2))) == GIV(nilObj))) {
		addLastLinktoList(activeProc, processList);
		transferTo(wakeHighestPriority());
	}
}

static void
printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classDict;
    usqInt classDictSize;
    sqInt currClass;
    sqInt i;
    sqInt methClass;
    usqInt numSlots;

	if (addressCouldBeObj(startClass)) {
		/* begin findClassForSelector:lookupClass:do: */
		currClass = startClass;
		do {
			classDict = longAt((currClass + (BaseHeaderSize)) + (MethodDictionaryIndex << 2));
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(classDict)) > (isForwardedObjectClassIndexPun()));
			/* begin rawNumSlotsOf: */
			flag("endianness");
			numSlots = ((usqInt) (((usqInt)(longAt(classDict + 4))))) >> 24;
			classDictSize = (numSlots == 0xFF
				? (/* begin rawOverflowSlotsOf: */
					flag("endianness"),
					longAt(classDict - (BaseHeaderSize)))
				: numSlots);
			i = SelectorStart;
			while (i < classDictSize) {
				if (aSelector == (longAt((classDict + (BaseHeaderSize)) + (i << 2)))) {
					methClass = currClass;

					goto l1;
				}
				i += 1;
			}
			currClass = longAt((currClass + (BaseHeaderSize)) + (SuperclassIndex << 2));
		} while(!(currClass == GIV(nilObj)));
		methClass = null;

	l1:	/* end findClassForSelector:lookupClass:do: */;
		if ((methClass == null)
		 || (startClass == methClass)) {
			printNameOfClasscount(methClass, 5);
			/* begin printChar: */
			putchar('>');
			if (!(methClass)) {
				printStringOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorDoesNotUnderstand << 2)));
				print(" ");
			}
		}
		else {
			printNameOfClasscount(startClass, 5);
			/* begin printChar: */
			putchar('(');
			printNameOfClasscount(methClass, 5);
			/* begin printChar: */
			putchar(')');
			/* begin printChar: */
			putchar('>');
		}
	}
	else {
		print("INVALID CLASS");
	}
	if (((aSelector & 3) != 0)
	 || (addressCouldBeObj(aSelector))) {
		if (((aSelector & 3) == 0)
		 && (((((usqInt) (longAt(aSelector))) >> 24) & 0x1F) >= 16)) {
			printStringOf(aSelector);
		}
		else {
			printOopShort(aSelector);
		}
	}
	else {
		print("INVALID SELECTOR");
	}
}

static void
printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classObj;
    sqInt classTablePage;
    sqInt methClass;
    sqInt methodSel;
    sqInt rclass;
    sqInt tagBits;

	if (isBlock) {
		print("[] in ");
	}
	/* begin findClassOfMethod:forReceiver: */
	if ((((anObject & 3) != 0)
 || (addressCouldBeObj(anObject)))
	 && (!(((anObject & 3) == 0)
 && (((longAt(anObject)) & 0x3FFFFF) == 8)))) {
		/* begin fetchClassOf: */
		if (((tagBits = anObject & 3)) != 0) {
			rclass = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (tagBits << 2));
			goto l2;
		}
		/* begin fetchClassOfNonImm: */
		classIndex = (longAt(anObject)) & 0x3FFFFF;
		if (classIndex == 0x1F) {
			rclass = anObject;
			goto l2;
		}
		assert(classIndex >= (arrayClassIndexPun()));
		/* begin classAtIndex: */
		assert((classIndex <= (tagMask()))
		 || (classIndex >= (arrayClassIndexPun())));
		classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
		if (classTablePage == GIV(nilObj)) {
			rclass = null;
			goto l2;
		}
		rclass = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
	l2:	/* end fetchClassOf: */;
		if (addressCouldBeClassObj(rclass)) {
			rclass = findClassContainingMethodstartingAt(aMethod, rclass);
			if (rclass != GIV(nilObj)) {
				methClass = rclass;
				goto l1;
			}
		}
	}
	if (!((addressCouldBeObj(aMethod))
		 && (((((usqInt) (longAt(aMethod))) >> 24) & 0x1F) >= 24))) {
		methClass = GIV(nilObj);
		goto l1;
	}
	methClass = findClassContainingMethodstartingAt(aMethod, methodClassOf(aMethod));
l1:	/* end findClassOfMethod:forReceiver: */;
	methodSel = findSelectorOfMethod(aMethod);
	if ((((anObject & 3) != 0)
 || (addressCouldBeObj(anObject)))
	 && ((!(((anObject & 3) == 0)
 && (((longAt(anObject)) & 0x3FFFFF) == 8)))
	 && (addressCouldBeClassObj((classObj = fetchClassOf(anObject)))))) {
		if ((classObj == methClass)
		 || ((methClass == null)
		 || (methClass == GIV(nilObj)))) {
			printNameOfClasscount(classObj, 5);
		}
		else {
			printNameOfClasscount(classObj, 5);
			print("(");
			printNameOfClasscount(methClass, 5);
			print(")");
		}
	}
	else {
		;
		print("INVALID RECEIVER");
	}
	print(">");
	if (((methodSel & 3) != 0)
	 || (addressCouldBeObj(methodSel))) {
		if (methodSel == GIV(nilObj)) {
			print("(nil)");
		}
		else {
			printStringOf(methodSel);
		}
	}
	else {
		print("INVALID SELECTOR");
	}
	if ((methodSel == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorDoesNotUnderstand << 2))))
	 && ((addressCouldBeObj(maybeMessage))
	 && ((fetchClassOfNonImm(maybeMessage)) == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassMessage << 2)))))) {

		/* print arg message selector */

		methodSel = longAt((maybeMessage + (BaseHeaderSize)) + (MessageSelectorIndex << 2));
		print(" ");
		printStringOf(methodSel);
	}
}


/*	Print all the stacks of all running processes, including those that are
	currently suspended.
 */

void
printAllStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt address11;
    sqInt address2;
    sqInt classIdx;
    sqInt classIndex;
    sqInt classObj;
    sqInt classTablePage;
    sqInt limit;
    sqInt limit1;
    sqInt mutexClass;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop12;
    sqInt objOop2;
    sqInt objOop3;
    sqInt p;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevObj11;
    sqInt prevObj2;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt prevPrevObj11;
    sqInt prevPrevObj2;
    sqInt pri;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;
    sqInt semaphoreClass;

	proc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
	printNameOfClasscount(fetchClassOf(proc), 5);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printHex(proc);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, proc));
	/* begin cr */
	printf("\n");
	printCallStackFP(GIV(framePointer));

	/* then the runnable processes */

	schedLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ProcessListsIndex << 2));
	p = (GIV(highestRunnableProcessPriority) == 0
		? (/* begin numSlotsOf: */
			flag("endianness"),
			assert((classIndexOf(schedLists)) > (isForwardedObjectClassIndexPun())),
			/* begin rawNumSlotsOf: */
			flag("endianness"),
			(numSlots = ((usqInt) (((usqInt)(longAt(schedLists + 4))))) >> 24),
			(numSlots == 0xFF
					? (/* begin rawOverflowSlotsOf: */
						flag("endianness"),
						longAt(schedLists - (BaseHeaderSize)))
					: numSlots))
		: GIV(highestRunnableProcessPriority));
	for (pri = (p - 1); pri >= 0; pri += -1) {
		processList = longAt((schedLists + (BaseHeaderSize)) + (pri << 2));
		if (!((longAt((processList + (BaseHeaderSize)) + (FirstLinkIndex << 2))) == GIV(nilObj))) {
			/* begin cr */
			printf("\n");
			print("processes at priority ");
			printNum(pri + 1);
			printProcsOnList(processList);
		}
	}
	/* begin cr */
	printf("\n");
	print("suspended processes");
	semaphoreClass = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassSemaphore << 2));
	mutexClass = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassMutex << 2));
	/* begin compactIndexOfClass: */
	assert((rawHashBitsOf(semaphoreClass)) != 0);
	/* begin rawHashBitsOf: */
	flag("endianness");
	semaphoreClass = (longAt(semaphoreClass + 4)) & 0x3FFFFF;
	/* begin compactIndexOfClass: */
	assert((rawHashBitsOf(mutexClass)) != 0);
	/* begin rawHashBitsOf: */
	flag("endianness");
	mutexClass = (longAt(mutexClass + 4)) & 0x3FFFFF;
	/* begin allHeapEntitiesDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots2 = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop = (numSlots2 == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop)) < (((usqInt) limit))) {
		classIdx = (longAt(objOop)) & 0x3FFFFF;
		if ((classIdx == semaphoreClass)
		 || (classIdx == mutexClass)) {
			printProcsOnList(objOop);
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = objectAfterlimit(objOop, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop)) < (((usqInt) GIV(freeStart)))) {
		classIdx = (longAt(objOop)) & 0x3FFFFF;
		if ((classIdx == semaphoreClass)
		 || (classIdx == mutexClass)) {
			printProcsOnList(objOop);
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = objectAfterlimit(objOop, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop1)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop1)) != 0);
		classIdx = (longAt(objOop1)) & 0x3FFFFF;
		if ((classIdx == semaphoreClass)
		 || (classIdx == mutexClass)) {
			printProcsOnList(objOop1);
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(endOfMemory));
	}
	
	

}

void
printCallStack(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (GIV(framePointer) == null) {
		printCallStackOf(longAt(((longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2))) + (BaseHeaderSize)) + (SuspendedContextIndex << 2)));
	}
	else {
		printCallStackFP(GIV(framePointer));
	}
}

static sqInt
printCallStackFP(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	context = shortReversePrintFrameAndCallers(theFP);
	while (!(context == GIV(nilObj))) {
		if (((longAt((context + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
}

sqInt
printCallStackOf(sqInt aContextOrProcessOrFrame)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt context;

	if ((((((usqInt)aContextOrProcessOrFrame)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)aContextOrProcessOrFrame)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)aContextOrProcessOrFrame)) <= (((usqInt)GIV(pages))))))) {
		return printCallStackFP(((char *) aContextOrProcessOrFrame));
	}
	if ((!(((aContextOrProcessOrFrame & 3) == 0)
 && (((longAt(aContextOrProcessOrFrame)) & 0x3FFFFF) == ClassMethodContextCompactIndex)))
	 && (((lengthOfformat(aContextOrProcessOrFrame, (((usqInt) (longAt(aContextOrProcessOrFrame))) >> 24) & 0x1F)) > MyListIndex)
	 && ((((longAt((aContextOrProcessOrFrame + (BaseHeaderSize)) + (SuspendedContextIndex << 2))) & 3) == 0)
	 && (((longAt(longAt((aContextOrProcessOrFrame + (BaseHeaderSize)) + (SuspendedContextIndex << 2)))) & 0x3FFFFF) == ClassMethodContextCompactIndex)))) {
		return printCallStackOf(longAt((aContextOrProcessOrFrame + (BaseHeaderSize)) + (SuspendedContextIndex << 2)));
	}
	context = aContextOrProcessOrFrame;
	while (!(context == GIV(nilObj))) {
		if (((longAt((context + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
			if (!(checkIsStillMarriedContextcurrentFP(context, GIV(framePointer)))) {
				shortPrintContext(context);
				return null;
			}
			context = shortReversePrintFrameAndCallers(frameOfMarriedContext(context));
		}
		else {
			context = printContextCallStackOf(context);
		}
	}
}

static sqInt
printCallStackOfcurrentFP(sqInt aContext, char *currFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    sqInt index;
    char *theFP;
    StackPage *thePage;
    sqInt value;

	ctxt = aContext;
	while (!(ctxt == GIV(nilObj))) {
		if (((longAt((ctxt + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
			/* begin frameOfMarriedContext: */
			value = longAt((ctxt + (BaseHeaderSize)) + (SenderIndex << 2));
			/* begin withoutSmallIntegerTags: */
			assert((value & 1));
			theFP = pointerForOop(value - 1);
			if (checkIsStillMarriedContextcurrentFP(ctxt, currFP)) {
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
				thePage = stackPageAtpages(index, GIV(pages));
				if (isFree(thePage)) {
					/* begin printHexPtr: */
					printHex(oopForPointer(theFP));
					print(" is on a free page?!");
					/* begin cr */
					printf("\n");
					return null;
				}
				shortPrintFrameAndCallers(theFP);
				theFP = (thePage->baseFP);
				ctxt = longAt(theFP + FoxCallerContext);
			}
			else {
				print("widowed caller frame ");
				/* begin printHexPtr: */
				printHex(oopForPointer(theFP));
				/* begin cr */
				printf("\n");
				return null;
			}
		}
		else {
			shortPrintContext(ctxt);
			ctxt = longAt((ctxt + (BaseHeaderSize)) + (SenderIndex << 2));
		}
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

void
printChar(sqInt aByte)
{
	putchar(aByte);
}


/*	Print the call stack of aContext until it links to a frame. */

static sqInt
printContextCallStackOf(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;

	ctxt = aContext;
	while (!((ctxt == GIV(nilObj))
	 || (((longAt((ctxt + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)))) {
		shortPrintContext(ctxt);
		ctxt = longAt((ctxt + (BaseHeaderSize)) + (SenderIndex << 2));
	}
	return ctxt;
}

void
printContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt ip;
    void *p;
    void *p1;
    sqInt sender;
    sqInt sp;

	shortPrintContext(aContext);
	sender = longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2));
	ip = longAt((aContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2));
	if ((sender & 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			print("married (assuming framePointer valid)");
			/* begin cr */
			printf("\n");
		}
		else {
			print("widowed (assuming framePointer valid)");
			/* begin cr */
			printf("\n");
		}
		print("sender   ");
		printNum(sender);
		print(" (");
		/* begin printHexPtr: */
		/* begin withoutSmallIntegerTags: */
		assert((sender & 1));
		p = ((char *) (pointerForOop(sender - 1)));
		printHex(oopForPointer(p));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
		print("ip       ");
		printNum(ip);
		print(" (");
		/* begin printHexPtr: */
		/* begin withoutSmallIntegerTags: */
		assert((ip & 1));
		p1 = ((char *) (pointerForOop(ip - 1)));
		printHex(oopForPointer(p1));
		/* begin printChar: */
		putchar(')');
		/* begin cr */
		printf("\n");
	}
	else {
		print("sender   ");
		shortPrintOop(sender);
		print("ip       ");
		if (ip == GIV(nilObj)) {
			shortPrintOop(ip);
		}
		else {
			printNum(ip);
			print(" (");
			printNum((ip >> 1));
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			printHex((ip >> 1));
			/* begin printChar: */
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
	sp = longAt((aContext + (BaseHeaderSize)) + (StackPointerIndex << 2));
	sp = ((sp < ((lengthOfformat(aContext, (((usqInt) (longAt(aContext))) >> 24) & 0x1F)) - ReceiverIndex)) ? sp : ((lengthOfformat(aContext, (((usqInt) (longAt(aContext))) >> 24) & 0x1F)) - ReceiverIndex));
	print("sp       ");
	printNum(sp);
	print(" (");
	printNum((sp >> 1));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
	print("method   ");
	shortPrintOop(longAt((aContext + (BaseHeaderSize)) + (MethodIndex << 2)));
	print("closure  ");
	shortPrintOop(longAt((aContext + (BaseHeaderSize)) + (ClosureIndex << 2)));
	print("receiver ");
	shortPrintOop(longAt((aContext + (BaseHeaderSize)) + (ReceiverIndex << 2)));
	sp = (sp >> 1);
	for (i = 1; i <= sp; i += 1) {
		print("       ");
		printNum(i);
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		shortPrintOop(longAt((aContext + (BaseHeaderSize)) + ((ReceiverIndex + i) << 2)));
	}
}

void
printExternalHeadFrame(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	printFrameWithSP(GIV(framePointer), GIV(stackPointer));
}

static sqInt
printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		printFrameAndCallersSPshort(frameCallerFP(theFP), frameCallerSP(theFP), printShort);
	}
	if (printShort) {
		shortPrintFrame(theFP);
		return null;
	}
	/* begin cr */
	printf("\n");
	printFrameWithSP(theFP, theSP);
}

static void
printFrameFlagsForFP(char *theFP)
{
    char *address;
    sqInt it;

	address = theFP + FoxFrameFlags;
	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	print(":       flags: ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		printNum(it);
	}
	print("  numArgs: ");
	printNum(byteAt((theFP + FoxFrameFlags) + 1));
	print(((byteAt((theFP + FoxFrameFlags) + 2)) != 0
		? " hasContext"
		: " noContext"));
	print(((byteAt((theFP + FoxFrameFlags) + 3)) != 0
		? " isBlock"
		: " notBlock"));
	/* begin cr */
	printf("\n");
}

static void
printFrameOopat(char *name, char *address)
{
    sqInt i;
    sqInt iLimiT;
    sqInt it;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	for (i = 1, iLimiT = (12 - (strlen(name))); i <= iLimiT; i += 1) {
		/* begin printChar: */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	/* begin printChar: */
	putchar('=');
	printOopShort(it);
	/* begin cr */
	printf("\n");
}


/*	use export: not api, so it won't be written to cointerp.h. cogit.c is
	unaware of StackPage
 */

EXPORT(void)
printFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 0);
}

EXPORT(void)
printFramesOnStackPageListInUse(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			print("page ");
			/* begin printHexPtrnp: */
			/* begin printHexnp: */
			printf("0x%x", oopForPointer(page));
			/* begin cr */
			printf("\n");
			printFramesInPage(page);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

static void
printFrameThingandFrameat(char *name, char *theFP, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		/* begin printChar: */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil");
		}
		else {
			printNum(it);
		}
	}
	print(" frame: ");
	/* begin printHexPtr: */
	printHex(oopForPointer(theFP));
	/* begin cr */
	printf("\n");
}

static void
printFrameThingat(char *name, char *address)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt it;
    sqInt len;

	it = longAt(address);
	/* begin printHexPtr: */
	printHex(oopForPointer(address));
	/* begin printChar: */
	putchar(':');
	len = strlen(name);
	for (i = 1; i <= (12 - len); i += 1) {
		/* begin space */
		/* begin printChar: */
		putchar(' ');
	}
	print(name);
	print(": ");
	printHex(it);
	if (it != 0) {
		/* begin printChar: */
		putchar('=');
		if (it == GIV(nilObj)) {
			print("nil");
		}
		else {
			printNum(it);
		}
	}
	/* begin cr */
	printf("\n");
}

sqInt
printFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *aFrame;
    sqInt index;
    char *startFrame;
    StackPage *thePage;
    char *theSP;
    char *theSP1;

	if (theFP == GIV(framePointer)) {
		theSP = GIV(stackPointer);
	}
	else {
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (isFree(thePage)) {
			/* begin printHexPtr: */
			printHex(oopForPointer(theFP));
			print(" is on a free page?!");
			/* begin cr */
			printf("\n");
			return null;
		}
		/* begin findSPOrNilOf:on:startingFrom: */
		startFrame = ((thePage == GIV(stackPage))
		 && (GIV(framePointer) < ((thePage->headFP)))
			? GIV(framePointer)
			: (thePage->headFP));
		assert(!(isFree(thePage)));
		aFrame = startFrame;
		theSP1 = (thePage->headSP);
		if (aFrame == theFP) {
			if (theSP1 >= aFrame) {

				/* If the SP is invalid return the pointer to the receiver field. */

				/* begin frameReceiverOffset: */
				theSP = aFrame + FoxReceiver;
				goto l1;
			}
			theSP = (thePage == GIV(stackPage)
				? theSP1
				: theSP1 + BytesPerWord);
			goto l1;
		}
		while (1) {
			/* begin frameCallerSP: */
			assert(!(isBaseFrame(aFrame)));
			theSP1 = (aFrame + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((aFrame + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
			/* begin frameCallerFP: */
			aFrame = pointerForOop(longAt(aFrame + FoxSavedFP));
			if (!(aFrame != 0)) break;
			if (theFP == aFrame) {
				theSP = theSP1;
				goto l1;
			}
		}
		theSP = null;
	l1:	/* end findSPOrNilOf:on:startingFrom: */;
	}
	if (theSP == null) {
		print("could not find sp; using bogus value");
		/* begin cr */
		printf("\n");
		theSP = theFP + FoxReceiver;
	}
	printFrameWithSP(theFP, theSP);
}

void
printFrameWithSP(char *theFP, char *theSP)
{
    char *addr;
    sqInt i;
    sqInt numArgs;
    sqInt theMethod;
    sqInt topThing;

	
	theMethod = longAt(theFP + FoxMethod);
	numArgs = byteAt((theFP + FoxFrameFlags) + 1);
	shortPrintFrame(theFP);
	printFrameOopat("rcvr/clsr", (theFP + FoxCallerSavedIP) + ((numArgs + 1) * BytesPerWord));
	for (i = numArgs; i >= 1; i += -1) {
		printFrameOopat("arg", (theFP + FoxCallerSavedIP) + (i * BytesPerWord));
	}
	printFrameThingat("cllr ip/ctxt", theFP + FoxCallerSavedIP);
	printFrameThingat("saved fp", theFP + FoxSavedFP);
	printFrameOopat("method", theFP + FoxMethod);
	printFrameFlagsForFP(theFP);
	printFrameThingat("context", theFP + FoxThisContext);
	printFrameOopat("receiver", theFP + FoxReceiver);
	topThing = longAt(theSP);
	if ((topThing >= theMethod)
	 && (topThing <= (theMethod + (((numSlotsOf(theMethod)) << 2) + (BaseHeaderSize))))) {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= (theSP + BytesPerWord); addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr);
		}
		printFrameThingat("frame ip", theSP);
	}
	else {
		for (addr = ((theFP + FoxReceiver) - BytesPerWord); addr >= theSP; addr += (-BytesPerWord)) {
			printFrameOopat("temp/stck", addr);
		}
	}
}

void
printFreeChunk(sqInt freeChunk)
{
    usqLong numBytes;

	numBytes = bytesInObject(freeChunk);
	print("freeChunk ");
	/* begin printHexPtrnp: */
	/* begin printHexnp: */
	printf("0x%x", oopForPointer(freeChunk));
	print(" bytes ");
	printNum(numBytes);
	print(" next ");
	/* begin printHexPtrnp: */
	/* begin printHexnp: */
	printf("0x%x", oopForPointer(longAt((freeChunk + (BaseHeaderSize)) + (0 << 2))));
	if ((((sqInt) numBytes >> 3)) >= 32) {
		print(" ^ ");
		/* begin printHexPtrnp: */
		/* begin printHexnp: */
		printf("0x%x", oopForPointer(longAt((freeChunk + (BaseHeaderSize)) + (2 << 2))));
		print(" < ");
		/* begin printHexPtrnp: */
		/* begin printHexnp: */
		printf("0x%x", oopForPointer(longAt((freeChunk + (BaseHeaderSize)) + (3 << 2))));
		print(" > ");
		/* begin printHexPtrnp: */
		/* begin printHexnp: */
		printf("0x%x", oopForPointer(longAt((freeChunk + (BaseHeaderSize)) + (4 << 2))));
	}
	/* begin cr */
	printf("\n");
}

void
printFreeList(sqInt chunkOrIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt freeChunk;
    usqLong numBytes;

	if ((chunkOrIndex >= 0)
	 && (chunkOrIndex < 32)) {
		printFreeList(GIV(freeLists)[chunkOrIndex]);
		return;
	}
	freeChunk = chunkOrIndex;
	while (freeChunk != 0) {
		/* begin printFreeChunk: */
		numBytes = bytesInObject(freeChunk);
		print("freeChunk ");
		/* begin printHexPtrnp: */
		/* begin printHexnp: */
		printf("0x%x", oopForPointer(freeChunk));
		print(" bytes ");
		printNum(numBytes);
		print(" next ");
		/* begin printHexPtrnp: */
		/* begin printHexnp: */
		printf("0x%x", oopForPointer(longAt((freeChunk + (BaseHeaderSize)) + (0 << 2))));
		if ((((sqInt) numBytes >> 3)) >= 32) {
			print(" ^ ");
			/* begin printHexPtrnp: */
			/* begin printHexnp: */
			printf("0x%x", oopForPointer(longAt((freeChunk + (BaseHeaderSize)) + (2 << 2))));
			print(" < ");
			/* begin printHexPtrnp: */
			/* begin printHexnp: */
			printf("0x%x", oopForPointer(longAt((freeChunk + (BaseHeaderSize)) + (3 << 2))));
			print(" > ");
			/* begin printHexPtrnp: */
			/* begin printHexnp: */
			printf("0x%x", oopForPointer(longAt((freeChunk + (BaseHeaderSize)) + (4 << 2))));
		}
		/* begin cr */
		printf("\n");
		freeChunk = longAt((freeChunk + (BaseHeaderSize)) + (0 << 2));
	}
}


/*	Print n in hex, in the form ' 0x1234', padded to a width of 10 characters
	in 32-bits ('0x' + 8 nibbles) or 18 characters in 64-bits ('0x' + 16
	nibbles)  */

void
printHex(sqInt n)
{
    char buf[35];
    sqInt len;


	/* large enough for a 64-bit value in hex plus the null plus 16 spaces */

	memset(buf,' ',34);
	len = sprintf(buf + 2 + 2 * BytesPerWord, "0x%lx", (unsigned long)(n));
	printf("%s", buf + len);
	
}


/*	Scan the heap printing the oops of any and all objects that are instances
	of aClassOop
 */

void
printInstancesOf(sqInt aClassOop)
{
	printInstancesWithClassIndex(rawHashBitsOf(aClassOop));
}


/*	Scan the heap printing the oops of any and all objects whose classIndex
	equals the argument.
 */

void
printInstancesWithClassIndex(sqInt classIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allHeapEntitiesDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop)) < (((usqInt) limit))) {
		if (((longAt(objOop)) & 0x3FFFFF) == classIndex) {
			printHex(objOop);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = objectAfterlimit(objOop, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop)) < (((usqInt) GIV(freeStart)))) {
		if (((longAt(objOop)) & 0x3FFFFF) == classIndex) {
			printHex(objOop);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj = prevObj;
		prevObj = objOop;
		objOop = objectAfterlimit(objOop, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceEntitiesDo: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop1 = GIV(nilObj);
	while (1) {
		assert((objOop1 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop1)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop1)) != 0);
		if (((longAt(objOop1)) & 0x3FFFFF) == classIndex) {
			printHex(objOop1);
			/* begin cr */
			printf("\n");
		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(endOfMemory));
	}
	
	
}

void
printMethodCache(void)
{
	printMethodCacheFor(-1);
}

void
printMethodCacheFor(sqInt thing)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt c;
    sqInt i;
    sqInt m;
    sqInt p;
    sqInt s;

	for (i = 0; i < MethodCacheSize; i += MethodCacheEntrySize) {
		s = GIV(methodCache)[i + MethodCacheSelector];
		c = GIV(methodCache)[i + MethodCacheClass];
		m = GIV(methodCache)[i + MethodCacheMethod];
		p = GIV(methodCache)[i + MethodCachePrimFunction];
		if (((thing == -1)
 || ((s == thing)
 || ((c == thing)
 || ((p == thing)
 || ((m == thing)
 || ((addressCouldBeObj(m))
 && ((maybeMethodHasCogMethod(m))
 && ((((sqInt)(cogMethodOf(m)))) == thing))))))))
		 && ((((s & 3) != 0)
 || (addressCouldBeObj(s)))
		 && ((c != 0)
		 && ((addressCouldBeClassObj(c))
		 || (addressCouldBeClassObj(classAtIndex(c))))))) {
			null;
			printNum(i);
			/* begin cr */
			printf("\n");
			/* begin tab */
			/* begin printChar: */
			putchar('	');
			if (((((usqInt) (longAt(s))) >> 24) & 0x1F) >= 16) {
				printf("%x %.*s\n", s, byteLengthOf(s), (char *)firstIndexableField(s));
			}
			else {
				shortPrintOop(s);
			}
			/* begin tab */
			/* begin printChar: */
			putchar('	');
			if (addressCouldBeClassObj(c)) {
				shortPrintOop(c);
			}
			else {
				printNum(c);
				/* begin space */
				/* begin printChar: */
				putchar(' ');
				shortPrintOop(classAtIndex(c));
			}
			/* begin tab */
			/* begin printChar: */
			putchar('	');
			shortPrintOop(m);
			/* begin tab */
			/* begin printChar: */
			putchar('	');
			if (p > 1024) {
				/* begin printHexnp: */
				printf("0x%x", p);
			}
			else {
				printNum(p);
			}
			/* begin cr */
			printf("\n");
		}
	}
}

void
printMethodDictionaryOf(sqInt behavior)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt indexLimiT;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;

	/* begin printMethodDictionary: */
	methodArray = longAt(((longAt((behavior + (BaseHeaderSize)) + (MethodDictionaryIndex << 2))) + (BaseHeaderSize)) + (MethodArrayIndex << 2));
	for (index = SelectorStart, indexLimiT = ((numSlotsOf(longAt((behavior + (BaseHeaderSize)) + (MethodDictionaryIndex << 2)))) - 1); index <= indexLimiT; index += 1) {
		selector = longAt(((longAt((behavior + (BaseHeaderSize)) + (MethodDictionaryIndex << 2))) + (BaseHeaderSize)) + (index << 2));
		if (selector != GIV(nilObj)) {
			meth = longAt((methodArray + (BaseHeaderSize)) + ((index - SelectorStart) << 2));
			printOopShort(selector);
			print(" => ");
			printOopShort(meth);
			print(" (");
			printHex(selector);
			print(" => ");
			printHex(meth);
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
}

void
printMethodDictionary(sqInt dictionary)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt indexLimiT;
    sqInt meth;
    sqInt methodArray;
    sqInt selector;

	methodArray = longAt((dictionary + (BaseHeaderSize)) + (MethodArrayIndex << 2));
	for (index = SelectorStart, indexLimiT = ((numSlotsOf(dictionary)) - 1); index <= indexLimiT; index += 1) {
		selector = longAt((dictionary + (BaseHeaderSize)) + (index << 2));
		if (selector != GIV(nilObj)) {
			meth = longAt((methodArray + (BaseHeaderSize)) + ((index - SelectorStart) << 2));
			printOopShort(selector);
			print(" => ");
			printOopShort(meth);
			print(" (");
			printHex(selector);
			print(" => ");
			printHex(meth);
			putchar(')');
			/* begin cr */
			printf("\n");
		}
	}
}


/*	Scan the heap printing the oops of any and all methods that refer to anOop */

void
printMethodReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt i;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;

	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24) {
			i = ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) - 1;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + (BaseHeaderSize)) + (i << 2)))) {
					printHex(objOop1);
					print(" @ ");
					printNum(i);
					/* begin space */
					/* begin printChar: */
					putchar(' ');
					printOopShort(objOop1);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (((((usqInt) (longAt(objOop1))) >> 24) & 0x1F) >= 24) {
			i = ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) - 1;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop1 + (BaseHeaderSize)) + (i << 2)))) {
					printHex(objOop1);
					print(" @ ");
					printNum(i);
					/* begin space */
					/* begin printChar: */
					putchar(' ');
					printOopShort(objOop1);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (((((usqInt) (longAt(objOop11))) >> 24) & 0x1F) >= 24) {
				i = ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) - 1;
				while (((i -= 1)) >= 0) {
					if (anOop == (longAt((objOop11 + (BaseHeaderSize)) + (i << 2)))) {
						printHex(objOop11);
						print(" @ ");
						printNum(i);
						/* begin space */
						/* begin printChar: */
						putchar(' ');
						printOopShort(objOop11);
						/* begin cr */
						printf("\n");
						i = 0;
					}
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
}


/*	Details: The count argument is used to avoid a possible infinite recursion
	if classOop is a corrupted object.
 */

static void
printNameOfClasscount(sqInt classOop, sqInt cnt)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt numSlots1;

	if (!(GIV(classNameIndex))) {
		print("??nil cnidx??");
		return;
	}
	if ((classOop == null)
	 || ((classOop == 0)
	 || (cnt <= 0))) {
		print("bad class");
		return;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classOop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(classOop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(classOop - (BaseHeaderSize)))
		: numSlots1);
	if ((numSlots == GIV(metaclassNumSlots))
	 && (GIV(metaclassNumSlots) > GIV(thisClassIndex))) {
		printNameOfClasscount(longAt((classOop + (BaseHeaderSize)) + (GIV(thisClassIndex) << 2)), cnt - 1);
		print(" class");
	}
	else {
		if (numSlots <= GIV(classNameIndex)) {
			print("bad class");
		}
		else {
			printStringOf(longAt((classOop + (BaseHeaderSize)) + (GIV(classNameIndex) << 2)));
		}
	}
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

static void
printNum(sqInt n)
{
	printf("%ld", (long) n);
}

void
printObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	while ((((usqInt) oop)) < (((usqInt) endAddress))) {
		if (!(((longAt(oop)) & 0x3FFFFF) == 0)) {
			printOop(oop);
		}
		oop = objectAfter(oop);
	}
}

static void
printObjStackPagemyIndexpageType(sqInt objStackPage, sqInt myx, sqInt pageType)
{
    sqInt freeOrNextPage;
    sqInt isFirstPage;
    sqInt isFreePage;
    sqInt isNextPage;
    sqInt page;

	isFirstPage = pageType == ObjStackMyx;
	isNextPage = pageType == ObjStackNextx;
	isFreePage = pageType == ObjStackFreex;
	printObjStackPagemyIndextag(objStackPage, myx, (isFirstPage
		? "head"
		: (isFreePage
				? "free"
				: "next")));
	if (isFirstPage
	 || (isNextPage)) {
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		print("topx: ");
		printNum(longAt((objStackPage + (BaseHeaderSize)) + (ObjStackTopx << 2)));
		print(" next: ");
		printHex(longAt((objStackPage + (BaseHeaderSize)) + (ObjStackNextx << 2)));
		if (isFirstPage) {
			print(" free: ");
			printHex(longAt((objStackPage + (BaseHeaderSize)) + (ObjStackFreex << 2)));
		}
		/* begin cr */
		printf("\n");
	}
	if (isFirstPage) {
		freeOrNextPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackFreex << 2));
		while (freeOrNextPage != 0) {
			printObjStackPagemyIndexpageType(freeOrNextPage, myx, ObjStackFreex);
			page = longAt((freeOrNextPage + (BaseHeaderSize)) + (ObjStackFreex << 2));
			if ((page == freeOrNextPage)
			 || (page == objStackPage)) {
				print("circularity in free page list!!");
				/* begin cr */
				printf("\n");
				page = 0;
			}
			freeOrNextPage = page;
		}
	}
	freeOrNextPage = longAt((objStackPage + (BaseHeaderSize)) + (ObjStackNextx << 2));
	if (freeOrNextPage != 0) {
		printObjStackPagemyIndexpageType(freeOrNextPage, myx, ObjStackNextx);
	}
}

static void
printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType)
{
	print(pageType);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printHex(objStackPage);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	print("cx ");
	printNum((longAt(objStackPage)) & 0x3FFFFF);
	print(" (");
	printNum(18);
	print(") fmt ");
	printNum((((usqInt) (longAt(objStackPage))) >> 24) & 0x1F);
	print(" (");
	printNum(10);
	print(") sz ");
	printNum(numSlotsOfAny(objStackPage));
	print(" (");
	printNum(ObjStackPageSlots);
	print(") myx: ");
	printNum(longAt((objStackPage + (BaseHeaderSize)) + (ObjStackMyx << 2)));
	print(" (");
	printNum(myx);
	print((isMarked(objStackPage)
		? ") mkd"
		: ") unmkd"));
	/* begin cr */
	printf("\n");
}

void
printObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (objStack == GIV(nilObj)) {
		print("nil");
		/* begin cr */
		printf("\n");
	}
	else {
		printObjStackPagemyIndexpageType(objStack, longAt((objStack + (BaseHeaderSize)) + (ObjStackMyx << 2)), ObjStackMyx);
	}
}

static void
printOopShort(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classIndex;
    sqInt classOop;
    sqInt classTablePage;
    sqInt i;
    char *name;
    sqInt nameLen;

	/* begin printOopShortInner: */
	if ((oop & 3) != 0) {
		if ((oop & 3) == 2) {
			/* begin printChar: */
			putchar('$');
			/* begin printChar: */
			putchar(((usqInt) (((usqInt)oop))) >> 2);
			/* begin printChar: */
			putchar('(');
			printHex((oop >> 1));
			/* begin printChar: */
			putchar(')');

			goto l3;
		}
		printNum((oop >> 1));
		/* begin printChar: */
		putchar('(');
		printHex((oop >> 1));
		/* begin printChar: */
		putchar(')');

		goto l3;
	}
	if (!(addressCouldBeObj(oop))) {
		print(((oop & (8 - 1)) != 0
			? " is misaligned"
			: " is not on the heap"));
		goto l3;
	}
	if (((oop & 3) == 0)
	 && (((longAt(oop)) & 0x3FFFFF) == 8)) {
		printHex(oop);
		print(" is a forwarder to ");
		printHex(followForwarded(oop));

		goto l3;
	}
	if (((oop & 3) == 0)
	 && (ClassFloatCompactIndex == ((longAt(oop)) & 0x3FFFFF))) {
		printFloat(dbgFloatValueOf(oop));
		goto l3;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(oop)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		classOop = oop;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		classOop = null;
		goto l2;
	}
	classOop = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l2:	/* end classAtIndex: */;
l1:	/* end fetchClassOfNonImm: */;
	if (!(addressCouldBeObj(classOop))) {
		print("a ??");
		goto l3;
	}
	if ((numSlotsOf(classOop)) == GIV(metaclassNumSlots)) {
		printNameOfClasscount(oop, 5);
		goto l3;
	}
	if (oop == GIV(nilObj)) {
		print("nil");
		goto l3;
	}
	if (oop == GIV(trueObj)) {
		print("true");
		goto l3;
	}
	if (oop == GIV(falseObj)) {
		print("false");
		goto l3;
	}
	nameLen = lengthOfNameOfClass(classOop);
	if (nameLen == 0) {
		print("a ??");
		goto l3;
	}
	name = nameOfClass(classOop);
	if (nameLen == 10) {
		if (!(strncmp(name, "ByteString", 10))) {

			/* strncmp is weird */

			/* begin printChar: */
			putchar('\'');
			printStringOf(oop);
			/* begin printChar: */
			putchar('\'');

			goto l3;
		}
		if (!(strncmp(name, "ByteSymbol", 10))) {

			/* strncmp is weird */

			/* begin printChar: */
			putchar('#');
			printStringOf(oop);
			goto l3;
		}
	}
	if ((nameLen == 9)
	 && (!(strncmp(name, "Character", 9)))) {
		/* begin printChar: */
		putchar('$');
		/* begin printChar: */
		putchar(((longAt((oop + (BaseHeaderSize)) + (0 << 2))) >> 1));

		goto l3;
	}
	print("a(n) ");
	for (i = 0; i < nameLen; i += 1) {
		/* begin printChar: */
		putchar(name[i]);
	}
	if (((instanceSizeOf(classOop)) == (ValueIndex + 1))
	 && (((longAt((classOop + (BaseHeaderSize)) + (SuperclassIndex << 2))) == (superclassOf(fetchClassOfNonImm(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))))))
	 && ((((longAt((oop + (BaseHeaderSize)) + (KeyIndex << 2))) & 3) == 0)
	 && (((((usqInt) (longAt(longAt((oop + (BaseHeaderSize)) + (KeyIndex << 2))))) >> 24) & 0x1F) >= 16)))) {
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		printOopShort(longAt((oop + (BaseHeaderSize)) + (KeyIndex << 2)));
		print(" -> ");
		printHex(longAt((oop + (BaseHeaderSize)) + (ValueIndex << 2)));
	}
l3:	/* end printOopShortInner: */;
	flush();
}

void
printOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byte;
    sqInt bytecodesPerLine;
    sqInt cls;
    sqInt column;
    sqInt fmt;
    sqInt index;
    sqInt lastIndex;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt startIP;

	if ((oop & 3) != 0) {
		shortPrintOop(oop);
		return;
	}
	printHex(oop);
	if (!(addressCouldBeObj(oop))) {
		print(((oop & (8 - 1)) != 0
			? " is misaligned"
			: " is not on the heap"));
		/* begin cr */
		printf("\n");

		return;
	}
	if (((longAt(oop)) & 0x3FFFFF) == 0) {
		print(" is a free chunk of size ");
		printNum(sizeOfFree(oop));
		/* begin cr */
		printf("\n");

		return;
	}
	if (((longAt(oop)) & 0x3FFFFF) == 8) {
		print(" is a forwarded object to ");
		printHex(followForwarded(oop));
		print(" of slot size ");
		printNum(numSlotsOfAny(oop));
		/* begin cr */
		printf("\n");

		return;
	}
	print(": a(n) ");
	printNameOfClasscount((cls = fetchClassOfNonImm(oop)), 5);
	if (cls == (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2)))) {
		/* begin cr */
		printf("\n");
		printFloat(dbgFloatValueOf(oop));
		/* begin cr */
		printf("\n");

		return;
	}
	fmt = (((usqInt) (longAt(oop))) >> 24) & 0x1F;
	if (fmt > 5) {
		print(" nbytes ");
		printNum(byteLengthOf(oop));
	}
	/* begin cr */
	printf("\n");
	if (((fmt >= 10) && (fmt <= (24 - 1)))) {

		/* This will answer false if splObj: ClassAlien is nilObject */

		if (isKindOfClass(oop, longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassAlien << 2)))) {
			print(" datasize ");
			printNum(sizeOfAlienData(oop));
			print(((longAt(oop + BaseHeaderSize)) < 0
				? " indirect @ "
				: ((longAt(oop + BaseHeaderSize)) == 0
						? " pointer @ "
						: " direct @ ")));
			printHex(((usqInt)(startOfAlienData(oop))));
			/* begin cr */
			printf("\n");

			return;
		}
		if (((oop & 3) == 0)
		 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) == 10)) {
			lastIndex = ((64 < (((sqInt) (byteLengthOf(oop)) >> 2))) ? 64 : (((sqInt) (byteLengthOf(oop)) >> 2)));
			if (lastIndex > 0) {
				for (index = 1; index <= lastIndex; index += 1) {
					/* begin space */
					/* begin printChar: */
					putchar(' ');
					printHex(long32At((oop + (BaseHeaderSize)) + ((index - 1) << 2)));
					if ((index % 5) == 0) {
						/* begin cr */
						printf("\n");
					}
				}
				if (!((lastIndex % 5) == 0)) {
					/* begin cr */
					printf("\n");
				}
			}
			return;
		}
		printStringOf(oop);
		/* begin cr */
		printf("\n");

		return;
	}
	startIP = ((sqInt) (((lastPointerOf(oop)) + BytesPerOop) - (BaseHeaderSize)) >> 2);
	lastIndex = ((256 < startIP) ? 256 : startIP);
	if (lastIndex > 0) {
		for (index = 1; index <= lastIndex; index += 1) {
			printHex(longAt((oop + (BaseHeaderSize)) + ((index - 1) << 2)));
			/* begin space */
			/* begin printChar: */
			putchar(' ');
			if ((index % 5) == 0) {
				/* begin cr */
				printf("\n");
			}
		}
		if (!((lastIndex % 5) == 0)) {
			/* begin cr */
			printf("\n");
		}
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 24) {
		startIP = (startIP * BytesPerWord) + 1;
		/* begin lengthOf:format: */
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots1 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
		numSlots = (numSlots1 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(oop - (BaseHeaderSize)))
			: numSlots1);
		if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 9) {
			lastIndex = numSlots;
			goto l1;
		}
		if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16) {

			/* bytes, including CompiledMethod */

			lastIndex = (numSlots << 2) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 7);
			goto l1;
		}
		if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 12) {
			lastIndex = (numSlots << (2 - 1)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 3);
			goto l1;
		}
		lastIndex = (numSlots << (2 - 2)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 1);
	l1:	/* end lengthOf:format: */;
		if ((lastIndex - startIP) > 100) {
			lastIndex = startIP + 100;
		}
		bytecodesPerLine = 8;
		column = 1;
		for (index = startIP; index <= lastIndex; index += 1) {
			if (column == 1) {
				printf("0x%08x: ", oop+BaseHeaderSize+index-1);
			}
			byte = byteAt((oop + (BaseHeaderSize)) + (index - 1));
			printf(" %02x/%-3d", byte,byte);
			column += 1;
			if (column > bytecodesPerLine) {
				column = 1;
				/* begin cr */
				printf("\n");
			}
		}
		if (!(column == 1)) {
			/* begin cr */
			printf("\n");
		}
	}
	else {
		if (startIP > 64) {
			print("...");
			/* begin cr */
			printf("\n");
		}
	}
}

void
printProcessStack(sqInt aProcess)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctx;
    sqInt objOop;

	/* begin cr */
	printf("\n");
	printNameOfClasscount(fetchClassOf(aProcess), 5);
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printHex(aProcess);
	print(" priority ");
	printNum(quickFetchIntegerofObject(PriorityIndex, aProcess));
	/* begin cr */
	printf("\n");
	/* begin followField:ofObject: */
	objOop = longAt((aProcess + (BaseHeaderSize)) + (SuspendedContextIndex << 2));
	if (((objOop & 3) == 0)
	 && (((longAt(objOop)) & 0x3FFFFF) == 8)) {
		objOop = fixFollowedFieldofObjectwithInitialValue(SuspendedContextIndex, aProcess, objOop);
	}
	ctx = objOop;
	if (!(ctx == GIV(nilObj))) {
		printCallStackOfcurrentFP(ctx, GIV(framePointer));
	}
}

sqInt
printProcsOnList(sqInt procList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstProc;
    sqInt objOop;
    sqInt proc;

	proc = (firstProc = followFieldofObject(FirstLinkIndex, procList));
	while (!(proc == GIV(nilObj))) {
		printProcessStack(proc);
		/* begin followField:ofObject: */
		objOop = longAt((proc + (BaseHeaderSize)) + (NextLinkIndex << 2));
		if (((objOop & 3) == 0)
		 && (((longAt(objOop)) & 0x3FFFFF) == 8)) {
			objOop = fixFollowedFieldofObjectwithInitialValue(NextLinkIndex, proc, objOop);
		}
		proc = objOop;
		if (proc == firstProc) {
			warning("circular process list!!");
			return null;
		}
	}
}


/*	Scan the heap printing the oops of any and all objects that refer to anOop */

void
printReferencesTo(sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt contextSize;
    sqInt fmt;
    sqInt i;
    sqInt limit;
    sqInt numLiterals;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt sp;

	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots2 = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots2 == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		/* begin numPointerSlotsOf: */
		fmt = (((usqInt) (longAt(objOop1))) >> 24) & 0x1F;
		if (fmt <= 5) {
			if ((fmt == 3)
			 && (((longAt(objOop1)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */

				/* begin fetchStackPointerOf: */
				sp = longAt((objOop1 + (BaseHeaderSize)) + (StackPointerIndex << 2));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l3;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop1)));
				contextSize = (sp >> 1);
			l3:	/* end fetchStackPointerOf: */;
				i = CtxtTempFrameStart + contextSize;
				goto l4;
			}
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(objOop1)) > (isForwardedObjectClassIndexPun()));
			/* begin rawNumSlotsOf: */
			flag("endianness");
			numSlots = ((usqInt) (((usqInt)(longAt(objOop1 + 4))))) >> 24;
			i = ((usqInt) ((numSlots == 0xFF
	? (/* begin rawOverflowSlotsOf: */
		flag("endianness"),
		longAt(objOop1 - (BaseHeaderSize)))
	: numSlots)));
			goto l4;
		}
		if (fmt == 7) {
			i = 1;
			goto l4;
		}
		if (fmt < 24) {
			i = 0;
			goto l4;
		}
		numLiterals = 
#    if MULTIPLEBYTECODESETS
			((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
						? (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
						: (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#    else /* MULTIPLEBYTECODESETS */
			(((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#    endif /* MULTIPLEBYTECODESETS */
			;
		i = numLiterals + LiteralStart;
	l4:	/* end numPointerSlotsOf: */;
		while (((i -= 1)) >= 0) {
			if (anOop == (longAt((objOop1 + (BaseHeaderSize)) + (i << 2)))) {
				printHex(objOop1);
				print(" @ ");
				printNum(i);
				/* begin space */
				/* begin printChar: */
				putchar(' ');
				printOopShort(objOop1);
				/* begin cr */
				printf("\n");
				i = 0;
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		/* begin numPointerSlotsOf: */
		fmt = (((usqInt) (longAt(objOop1))) >> 24) & 0x1F;
		if (fmt <= 5) {
			if ((fmt == 3)
			 && (((longAt(objOop1)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

				/* contexts end at the stack pointer */

				/* begin fetchStackPointerOf: */
				sp = longAt((objOop1 + (BaseHeaderSize)) + (StackPointerIndex << 2));
				if (!((sp & 1))) {
					contextSize = 0;
					goto l5;
				}
				assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop1)));
				contextSize = (sp >> 1);
			l5:	/* end fetchStackPointerOf: */;
				i = CtxtTempFrameStart + contextSize;
				goto l6;
			}
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(objOop1)) > (isForwardedObjectClassIndexPun()));
			/* begin rawNumSlotsOf: */
			flag("endianness");
			numSlots = ((usqInt) (((usqInt)(longAt(objOop1 + 4))))) >> 24;
			i = ((usqInt) ((numSlots == 0xFF
	? (/* begin rawOverflowSlotsOf: */
		flag("endianness"),
		longAt(objOop1 - (BaseHeaderSize)))
	: numSlots)));
			goto l6;
		}
		if (fmt == 7) {
			i = 1;
			goto l6;
		}
		if (fmt < 24) {
			i = 0;
			goto l6;
		}
		numLiterals = 
#    if MULTIPLEBYTECODESETS
			((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
						? (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
						: (((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#    else /* MULTIPLEBYTECODESETS */
			(((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#    endif /* MULTIPLEBYTECODESETS */
			;
		i = numLiterals + LiteralStart;
	l6:	/* end numPointerSlotsOf: */;
		while (((i -= 1)) >= 0) {
			if (anOop == (longAt((objOop1 + (BaseHeaderSize)) + (i << 2)))) {
				printHex(objOop1);
				print(" @ ");
				printNum(i);
				/* begin space */
				/* begin printChar: */
				putchar(' ');
				printOopShort(objOop1);
				/* begin cr */
				printf("\n");
				i = 0;
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			/* begin numPointerSlotsOf: */
			fmt = (((usqInt) (longAt(objOop11))) >> 24) & 0x1F;
			if (fmt <= 5) {
				if ((fmt == 3)
				 && (((longAt(objOop11)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {

					/* contexts end at the stack pointer */

					/* begin fetchStackPointerOf: */
					sp = longAt((objOop11 + (BaseHeaderSize)) + (StackPointerIndex << 2));
					if (!((sp & 1))) {
						contextSize = 0;
						goto l7;
					}
					assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(objOop11)));
					contextSize = (sp >> 1);
				l7:	/* end fetchStackPointerOf: */;
					i = CtxtTempFrameStart + contextSize;
					goto l8;
				}
				/* begin numSlotsOf: */
				flag("endianness");
				assert((classIndexOf(objOop11)) > (isForwardedObjectClassIndexPun()));
				/* begin rawNumSlotsOf: */
				flag("endianness");
				numSlots = ((usqInt) (((usqInt)(longAt(objOop11 + 4))))) >> 24;
				i = ((usqInt) ((numSlots == 0xFF
	? (/* begin rawOverflowSlotsOf: */
		flag("endianness"),
		longAt(objOop11 - (BaseHeaderSize)))
	: numSlots)));
				goto l8;
			}
			if (fmt == 7) {
				i = 1;
				goto l8;
			}
			if (fmt < 24) {
				i = 0;
				goto l8;
			}
			numLiterals = 
#      if MULTIPLEBYTECODESETS
				((((sqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
								? (((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
								: (((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#      else /* MULTIPLEBYTECODESETS */
				(((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#      endif /* MULTIPLEBYTECODESETS */
				;
			i = numLiterals + LiteralStart;
		l8:	/* end numPointerSlotsOf: */;
			while (((i -= 1)) >= 0) {
				if (anOop == (longAt((objOop11 + (BaseHeaderSize)) + (i << 2)))) {
					printHex(objOop11);
					print(" @ ");
					printNum(i);
					/* begin space */
					/* begin printChar: */
					putchar(' ');
					printOopShort(objOop11);
					/* begin cr */
					printf("\n");
					i = 0;
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
}

sqInt
printStackCallStackOf(char *aFramePointer)
{
    sqInt context;
    char *theFP;

	theFP = aFramePointer;
	while(1) {
		context = shortReversePrintFrameAndCallers(theFP);
		if (!((((longAt((context + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
			 && (((theFP = frameOfMarriedContext(context)),
			checkIsStillMarriedContextcurrentFP(context, theFP))))) {
			return null;
		}
	}
}

void
printStackPageList(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		printStackPage(page);
		/* begin cr */
		printf("\n");
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

void
printStackPageListInUse(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			printStackPage(page);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

void
printStackPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		printStackPage(stackPageAt(i));
		/* begin cr */
		printf("\n");
	}
}

void
printStackPagesInUse(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		if (!(isFree(stackPageAt(i)))) {
			printStackPage(stackPageAt(i));
			/* begin cr */
			printf("\n");
		}
	}
}

static void
printStackPage(StackPage *page)
{
    void *p;
    void *p1;
    void *p2;
    void *p3;
    void *p4;
    void *p5;
    void *p6;
    void *p7;
    void *p8;

	print("page ");
	/* begin printHexPtr: */
	printHex(oopForPointer(page));
	print(" (");
	printNum(pageIndexFor((page->realStackLimit)));
	print(")  (trace: ");
	printNum((page->trace));
	/* begin printChar: */
	putchar(')');
	if (isFree(page)) {
		print(" (free)");
	}
	if (page == (mostRecentlyUsedPage())) {
		print(" (MRU)");
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	print("ba: ");
	/* begin printHexPtr: */
	p3 = (page->baseAddress);
	printHex(oopForPointer(p3));
	print(" - sl: ");
	/* begin printHexPtr: */
	p4 = (page->realStackLimit);
	printHex(oopForPointer(p4));
	print(" - sl-so: ");
	/* begin printHexPtr: */
	p5 = ((page->realStackLimit)) - ((FrameSlots + 64) * BytesPerWord);
	printHex(oopForPointer(p5));
	print(" - la:");
	/* begin printHexPtr: */
	p6 = (page->lastAddress);
	printHex(oopForPointer(p6));
	if (!(isFree(page))) {
		/* begin cr */
		printf("\n");
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		print("baseFP ");
		/* begin printHexPtr: */
		p = (page->baseFP);
		printHex(oopForPointer(p));
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		print("headFP ");
		/* begin printHexPtr: */
		p1 = (page->headFP);
		printHex(oopForPointer(p1));
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		print("headSP ");
		/* begin printHexPtr: */
		p2 = (page->headSP);
		printHex(oopForPointer(p2));
	}
	/* begin cr */
	printf("\n");
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	print("prev ");
	/* begin printHexPtr: */
	p7 = page->prevPage;
	printHex(oopForPointer(p7));
	print(" (");
	printNum(pageIndexFor((((page->prevPage))->realStackLimit)));
	/* begin printChar: */
	putchar(')');
	/* begin tab */
	/* begin printChar: */
	putchar('	');
	print("next ");
	/* begin printHexPtr: */
	p8 = page->nextPage;
	printHex(oopForPointer(p8));
	print(" (");
	printNum(pageIndexFor((((page->nextPage))->realStackLimit)));
	/* begin printChar: */
	putchar(')');
	/* begin cr */
	printf("\n");
}

static sqInt
printStringOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cnt;
    sqInt fmt;
    sqInt i;
    sqInt len;
    sqInt max;

	if ((oop & 3) != 0) {
		return null;
	}
	if (!(addressCouldBeObj(oop))) {
		return null;
	}
	fmt = (((usqInt) (longAt(oop))) >> 24) & 0x1F;
	if (fmt < 16) {
		return null;
	}
	cnt = ((((max = 128)) < ((len = lengthOfformat(oop, (((usqInt) (longAt(oop))) >> 24) & 0x1F)))) ? ((max = 128)) : ((len = lengthOfformat(oop, (((usqInt) (longAt(oop))) >> 24) & 0x1F))));
	i = 0;
	if ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteArray << 2)), GIV(classByteArrayCompactIndex)))
	 || ((isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2)), ClassLargePositiveIntegerCompactIndex))
	 || (isinstanceOfcompactClassIndex(oop, longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargeNegativeInteger << 2)), ClassLargeNegativeIntegerCompactIndex)))) {
		while (i < cnt) {
			printHex(byteAt((oop + (BaseHeaderSize)) + i));
			i += 1;
		}
	}
	else {
		while (i < cnt) {
			/* begin printChar: */
			putchar(byteAt((oop + (BaseHeaderSize)) + i));
			i += 1;
		}
	}
	if (len > max) {
		print("...");
	}
	flush();
}


/*	For testing in Smalltalk, this method should be overridden in a subclass. */

void
print(char *s)
{
	fputs(s, stdout);
}


/*	There are ephemerons to be scavenged. Scavenge them and fire any whose
	keys are
	still in pastSpace and/or eden. The unscavenged ephemerons in this cycle
	can only be
	fired if all the unscavenged ephemerons in this cycle are firable, because
	references to ephemeron keys from unfired ephemerons should prevent the
	ephemerons with
	those keys from firing. So scavenge ephemerons with surviving keys, and
	only if none
	are found, fire ephemerons with unreferenced keys, and scavenge them. Read
	the class comment for a more in-depth description of the algorithm. */

static void
processEphemerons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ephemeron;
    sqInt ephemeron1;
    sqInt ephemeronCorpse;
    sqInt hasNewReferents;
    sqInt i;
    sqInt i1;
    sqInt listOffset;
    sqInt referent;
    sqInt referrer;
    sqInt unfiredEphemeronsScavenged;
    sqInt unfiredEphemeronsScavenged1;

	/* begin scavengeUnfiredEphemeronsInRememberedSet */
	unfiredEphemeronsScavenged1 = 0;
	i1 = 0;
	while (i1 < GIV(numRememberedEphemerons)) {
		referrer = GIV(rememberedSet)[i1];
		assert(isEphemeron(referrer));
		if (isScavengeSurvivor(keyOfEphemeron(referrer))) {
			unfiredEphemeronsScavenged1 = 1;

			/* remove from unscanned ephemerons in set by swapping with last ephemeron */

			hasNewReferents = scavengeReferentsOf(referrer);
			GIV(numRememberedEphemerons) -= 1;
			GIV(rememberedSet)[i1] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
			if (hasNewReferents) {

				/* keep in set */

				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = referrer;
			}
			else {

				/* remove from set by overwriting with next-to-be scanned */

				GIV(previousRememberedSetSize) -= 1;
				GIV(rememberedSetSize) -= 1;
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = (GIV(rememberedSet)[GIV(previousRememberedSetSize)]);
				GIV(rememberedSet)[GIV(previousRememberedSetSize)] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(referrer, (longAt(referrer)) & (~(1 << 29)));
			}
		}
		else {
			i1 += 1;
		}
	}
	unfiredEphemeronsScavenged = unfiredEphemeronsScavenged1;
	if (scavengeUnfiredEphemeronsOnEphemeronList()) {
		unfiredEphemeronsScavenged = 1;
	}
	if (!unfiredEphemeronsScavenged) {
		/* begin fireEphemeronsInRememberedSet */
		assert(noUnfiredEphemeronsAtEndOfRememberedSet());
		i = 0;
		while (i < GIV(numRememberedEphemerons)) {
			ephemeron = GIV(rememberedSet)[i];
			assert(isEphemeron(ephemeron));
			assert(!(isScavengeSurvivor(keyOfEphemeron(ephemeron))));
			/* begin fireEphemeron: */
			/* begin queueEphemeron: */
			assert((isNonImmediate(ephemeron))
			 && ((formatOf(ephemeron)) == (ephemeronFormat())));
			pushonObjStack(ephemeron, GIV(ephemeronQueue));
			forceInterruptCheck();
			copyAndForward(keyOfEphemeron(ephemeron));
			if (scavengeReferentsOf(ephemeron)) {

				/* keep in set */

				i += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(ephemeron, (longAt(ephemeron)) & (~(1 << 29)));
				GIV(numRememberedEphemerons) -= 1;
				GIV(previousRememberedSetSize) -= 1;

				/* First overwrite with last firable ephemeron (could be a noop if this is the last one).
				   Then overwrite last firable entry with next unscanned rememberedSet entry (could also be a noop).
				   Then overwrite next unscanned entry with last unscanned rememberedSet entry (could also be a noop). */

				GIV(rememberedSetSize) -= 1;
				GIV(rememberedSet)[i] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
				GIV(rememberedSet)[GIV(numRememberedEphemerons)] = (GIV(rememberedSet)[GIV(previousRememberedSetSize)]);
				GIV(rememberedSet)[GIV(previousRememberedSetSize)] = (GIV(rememberedSet)[GIV(rememberedSetSize)]);
			}
		}
		GIV(numRememberedEphemerons) = 0;
		/* begin fireEphemeronsOnEphemeronList */
		if (!(GIV(ephemeronList))) {
			goto l1;
		}

		/* Reset the list head so that new ephemerons will get added
		   to a new list, not concatenated on the one we are scanning. */

		ephemeronCorpse = (GIV(ephemeronList) << 3) + GIV(newSpaceStart);
		GIV(ephemeronList) = null;
		while (ephemeronCorpse != null) {
			assert(isForwarded(ephemeronCorpse));
			/* begin followForwarded: */
			assert(isForwarded(ephemeronCorpse));
			referent = longAt((ephemeronCorpse + (BaseHeaderSize)) + (0 << 2));
			while (((referent & 3) == 0)
			 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
				referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
			}
			ephemeron1 = referent;
			assert(!(isScavengeSurvivor(keyOfEphemeron(ephemeron1))));
			/* begin fireEphemeron: */
			/* begin queueEphemeron: */
			assert((isNonImmediate(ephemeron1))
			 && ((formatOf(ephemeron1)) == (ephemeronFormat())));
			pushonObjStack(ephemeron1, GIV(ephemeronQueue));
			forceInterruptCheck();
			copyAndForward(keyOfEphemeron(ephemeron1));
			((void) (scavengeReferentsOf(ephemeron1)));
			/* begin nextCorpseOrNil: */
			assert(isYoung(ephemeronCorpse));
			listOffset = ((rawHashBitsOf(ephemeronCorpse)) << 5) + ((((usqInt) (longAt(ephemeronCorpse))) >> 24) & 0x1F);
			ephemeronCorpse = (listOffset != 0
				? (listOffset << 3) + GIV(newSpaceStart)
				: 0);
		}
	l1:	/* end fireEphemeronsOnEphemeronList */;
	}
}


/*	Go through the remembered set and the weak list, nilling references to
	any objects that didn't survive the scavenge. Read the class comment
	for a more in-depth description of the algorithm. */

static void
processWeaklings(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt listOffset;
    sqInt referent;
    sqInt rootObj;
    sqInt weakCorpse;
    sqInt weakObj;

	i = 0;
	while (i < GIV(rememberedSetSize)) {
		rootObj = GIV(rememberedSet)[i];
		if (((((usqInt) (longAt(rootObj))) >> 24) & 0x1F) == 4) {
			processWeakSurvivor(rootObj);
			if (hasYoungReferents(rootObj)) {
				i += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(rootObj, (longAt(rootObj)) & (~(1 << 29)));
				if ((i + 1) < GIV(rememberedSetSize)) {
					GIV(rememberedSet)[i] = (GIV(rememberedSet)[GIV(rememberedSetSize) - 1]);
				}
				GIV(rememberedSetSize) -= 1;
			}
		}
		else {
			i += 1;
		}
	}
	if (!(GIV(weakList) == null)) {
		weakCorpse = (GIV(weakList) << 3) + GIV(newSpaceStart);
		while (weakCorpse != null) {
			assert(isForwarded(weakCorpse));
			/* begin followForwarded: */
			assert(isForwarded(weakCorpse));
			referent = longAt((weakCorpse + (BaseHeaderSize)) + (0 << 2));
			while (((referent & 3) == 0)
			 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
				referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
			}
			weakObj = referent;
			processWeakSurvivor(weakObj);
			/* begin nextCorpseOrNil: */
			assert(isYoung(weakCorpse));
			listOffset = ((rawHashBitsOf(weakCorpse)) << 5) + ((((usqInt) (longAt(weakCorpse))) >> 24) & 0x1F);
			weakCorpse = (listOffset != 0
				? (listOffset << 3) + GIV(newSpaceStart)
				: 0);
		}
		GIV(weakList) = null;
	}
}


/*	Process a weak survivor on the weakList. Those of its fields
	which have not survived the scavenge should be nilled, and if any
	are, the coInterpreter should be informed via signalFinalization:. */

static void
processWeakSurvivor(sqInt weakObj)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt referent;
    sqInt referent1;
    sqInt weakObjShouldMourn;

	weakObjShouldMourn = 0;
	for (i = (fixedFieldsOfClassFormat(formatOfClass(fetchClassOfNonImm(weakObj)))), iLimiT = ((numSlotsOf(weakObj)) - 1); i <= iLimiT; i += 1) {

		/* Referent could be forwarded due to scavenging or a become:, don't assume. */

		referent = longAt((weakObj + (BaseHeaderSize)) + (i << 2));
		if (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			/* begin followForwarded: */
			assert(isForwarded(referent));
			referent1 = longAt((referent + (BaseHeaderSize)) + (0 << 2));
			while (((referent1 & 3) == 0)
			 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
				referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
			}
			referent = referent1;
			if (isScavengeSurvivor(referent)) {
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(weakObj)));
				if (isOldObject(weakObj)) {

					/* most stores into young objects */

					if (((referent & 3) == 0)
					 && ((((usqInt) referent)) < (((usqInt) GIV(newSpaceLimit))))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(weakObj))) >> 29) & 1) != 0)) {
							remember(weakObj);
							/* begin setIsRememberedOf:to: */
							flag("endianness");
							longAtput(weakObj, (longAt(weakObj)) | (1 << 29));
						}
					}
				}
				longAtput((weakObj + (BaseHeaderSize)) + (i << 2), referent);
			}
		}
		if (isScavengeSurvivor(referent)) {
			assert(referent == (fetchPointerofObject(i, weakObj)));
		}
		else {
			weakObjShouldMourn = 1;
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(weakObj)));
			longAtput((weakObj + (BaseHeaderSize)) + (i << 2), GIV(nilObj));
		}
	}
	if (weakObjShouldMourn) {
		/* begin signalFinalization: */
		forceInterruptCheck();
		GIV(pendingFinalizationSignals) += 1;
	}
}

void
pushBool(sqInt trueOrFalse)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	The receiver of a message send or the closure of a block activation is
	always on the stack above any arguments and the frame itself. See the
	diagram in StackInterpreter class>>initializeFrameIndices. */

static sqInt
pushedReceiverOrClosureOfFrame(char *theFP)
{
	return longAt(theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord)));
}

void
pushFloat(double f)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin push: */
	object = floatObjectOf(f);
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

sqInt
pushInteger(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), ((integerValue << 1) | 1));
	GIV(stackPointer) = sp;
	return null;
}


/*	Attempt to push anEphemeron on the unscanned ephemerons stack
	and answer if the attempt succeeded. Note that the ephemeron
	stack overflowing isn't a disaster; it simply means treating the
	ephemeron as strong in this GC cycle. */

static sqInt
pushOnUnscannedEphemeronsStack(sqInt anEphemeron)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(isEphemeron(anEphemeron));
	if (((GIV(unscannedEphemerons).top)) >= ((GIV(unscannedEphemerons).limit))) {
		return 0;
	}
	longAtput((GIV(unscannedEphemerons).top), anEphemeron);
	(GIV(unscannedEphemerons).top = ((GIV(unscannedEphemerons).top)) + (wordSize()));
	return 1;
}


/*	Record the given object in a the remap buffer. Objects in this buffer are
	remapped when a compaction occurs. This facility is used by the
	interpreter to ensure that
	objects in temporary variables are properly remapped.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

void
pushRemappableOop(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(oop));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = oop;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
}


/*	In the StackInterpreter stacks grow down. */

void
push(sqInt object)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

static sqInt
pushonObjStack(sqInt objOop, sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(addressCouldBeOop(objOop));
	if ((objOop & 3) != 0) {
		assert(objStack == GIV(markStack));
		assert(addressCouldBeObj(topOfObjStack((0 == (fetchPointerofObject(ObjStackTopx, objStack))
			? fetchPointerofObject(ObjStackNextx, objStack)
			: objStack))));
	}
	else {

		/* There should be no weaklings on the mark stack. */

		assert(!((objStack == GIV(markStack))
 && (isWeakNonImm(objOop))));
		assert((objStack != GIV(weaklingStack))
		 || (isWeakNonImm(objOop)));
	}
	return noCheckPushonObjStack(objOop, objStack);
}


/*	Append aWord to aFile in this platforms 'natural' byte order. (Bytes will
	be swapped, if
	necessary, when the image is read on a different platform.) Set
	successFlag to false if
	the write fails.
 */

static void
putLongtoFile(sqInt aWord, sqImageFile  aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite(&aWord, sizeof(aWord), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Append the 16-bit aShort to aFile in this platforms 'natural' byte order.
	(Bytes will be swapped, if necessary, when the image is read on a
	different platform.) Set successFlag to false if the write fails. */

static void
putShorttoFile(sqInt aShort, sqImageFile  aFile)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt objectsWritten;

	objectsWritten = sqImageFileWrite(&aShort, sizeof(short), 1, aFile);
	/* begin success: */
	if (!(objectsWritten == 1)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Save the given process on the scheduler process list for its priority,
	adding to the back if yieldImplicitly or to the front if not
	yieldImplicitly. 
 */

static void
putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstLink;
    sqInt oop;
    sqInt priority;
    sqInt processList;
    sqInt processLists;

	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((aProcess + (BaseHeaderSize)) + (PriorityIndex << 2));
	assert((oop & 1));
	priority = (oop >> 1);
	if ((GIV(highestRunnableProcessPriority) != 0)
	 && (priority > GIV(highestRunnableProcessPriority))) {
		GIV(highestRunnableProcessPriority) = priority;
	}
	processLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ProcessListsIndex << 2));
	processList = longAt((processLists + (BaseHeaderSize)) + ((priority - 1) << 2));
	if (yieldImplicitly) {
		addLastLinktoList(aProcess, processList);
	}
	else {
		/* begin addFirstLink:toList: */
		assert((fetchPointerofObject(NextLinkIndex, aProcess)) == (nilObject()));
		firstLink = longAt((processList + (BaseHeaderSize)) + (FirstLinkIndex << 2));
		assert(firstLink != aProcess);
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(processList)));
		if (isOldObject(processList)) {

			/* most stores into young objects */

			if (((aProcess & 3) == 0)
			 && ((((usqInt) aProcess)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(processList))) >> 29) & 1) != 0)) {
					remember(processList);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(processList, (longAt(processList)) | (1 << 29));
				}
			}
		}
		longAtput((processList + (BaseHeaderSize)) + (FirstLinkIndex << 2), aProcess);
		if (firstLink == GIV(nilObj)) {

			/* a.k.a. (self isEmptyList: aList) */

			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(processList)));
			if (isOldObject(processList)) {

				/* most stores into young objects */

				if (((aProcess & 3) == 0)
				 && ((((usqInt) aProcess)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(processList))) >> 29) & 1) != 0)) {
						remember(processList);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(processList, (longAt(processList)) | (1 << 29));
					}
				}
			}
			longAtput((processList + (BaseHeaderSize)) + (LastLinkIndex << 2), aProcess);
		}
		else {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(aProcess)));
			if (isOldObject(aProcess)) {

				/* most stores into young objects */

				if (((firstLink & 3) == 0)
				 && ((((usqInt) firstLink)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(aProcess))) >> 29) & 1) != 0)) {
						remember(aProcess);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(aProcess, (longAt(aProcess)) | (1 << 29));
					}
				}
			}
			longAtput((aProcess + (BaseHeaderSize)) + (NextLinkIndex << 2), firstLink);
		}
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aProcess)));
		if (isOldObject(aProcess)) {

			/* most stores into young objects */

			if (((processList & 3) == 0)
			 && ((((usqInt) processList)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aProcess))) >> 29) & 1) != 0)) {
					remember(aProcess);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(aProcess, (longAt(aProcess)) | (1 << 29));
				}
			}
		}
		longAtput((aProcess + (BaseHeaderSize)) + (MyListIndex << 2), processList);
	}
}


/*	Return the integer value of the field without verifying that it is an
	integer value! For use in time-critical places where the integer-ness of
	the field can be guaranteed.
 */

static sqInt
quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer)
{
    sqInt oop;

	oop = longAt((objectPointer + (BaseHeaderSize)) + (fieldIndex << 2));
	assert((oop & 1));
	return (oop >> 1);
}

static sqInt
rawHashBitsOf(sqInt objOop)
{
	flag("endianness");
	return (longAt(objOop + 4)) & 0x3FFFFF;
}

static usqInt
rawNumSlotsOf(sqInt objOop)
{
	flag("endianness");
	return ((usqInt) (((usqInt)(longAt(objOop + 4))))) >> 24;
}

static usqInt
rawOverflowSlotsOf(sqInt objOop)
{
	flag("endianness");
	return longAt(objOop - (BaseHeaderSize));
}


/*	Anwer true if images of the given format are readable by this interpreter.
	Allows a virtual machine to accept selected older image formats. */

sqInt
readableFormat(sqInt imageVersion)
{
	return (imageVersion == (imageFormatVersion()))
	 || (imageVersion == ((BytesPerWord == 4
	? 6504
	: 68002)));
}


/*	Read numBytes of image data from f into memory at memoryBaseForImageRead.
	Answer the number of bytes written. In addition, read each segment, build
	up the
	segment info, while eliminating the bridge objects that end each segment
	and give the size of the subsequent segment. */

static sqInt
readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bridge;
    sqInt bridgeSpan;
    sqInt bytesRead;
    usqInt newBase;
    sqInt nextSegmentSize;
    sqInt oldBase;
    SpurSegmentInfo *segInfo;
    sqInt totalBytesRead;

	allocateOrExtendSegmentInfos();
	GIV(numSegments) = (totalBytesRead = 0);

	/* N.B. still must be adjusted by oldBaseAddr. */

	oldBase = 0;
	newBase = oldSpaceStart();
	nextSegmentSize = GIV(firstSegmentSize);
	bridge = (GIV(firstSegmentSize) + (oldSpaceStart())) - (BaseHeaderSize);
	while (1) {
		segInfo = (&(GIV(segments)[GIV(numSegments)]));
		(segInfo->segStart = oldBase);
		(segInfo->segSize = nextSegmentSize);
		(segInfo->swizzle = newBase - oldBase);
		bytesRead = sqImageFileRead(pointerForOop(newBase), sizeof(char), nextSegmentSize, f);
		if (bytesRead > 0) {
			totalBytesRead += bytesRead;
		}
		if (bytesRead != nextSegmentSize) {
			return totalBytesRead;
		}
		GIV(numSegments) += 1;
		bridgeSpan = 4 * (rawOverflowSlotsOf(bridge));
		oldBase = (oldBase + nextSegmentSize) + bridgeSpan;
		newBase = (newBase + nextSegmentSize) - (2 * (BaseHeaderSize));
		nextSegmentSize = longLongAt(bridge);
		if (!(nextSegmentSize != 0)) break;
		bridge = (bridge - (2 * (BaseHeaderSize))) + nextSegmentSize;
	}
	assert((newBase - (oldSpaceStart())) == (totalBytesRead - (GIV(numSegments) * (bridgeSize()))));
	/* begin setFreeOldSpaceStart: */
	GIV(freeOldSpaceStart) = newBase;
	GIV(firstSegmentSize) = null;
	return totalBytesRead;
}


/*	Read an image from the given file stream, allocating the given amount of
	memory to its object heap. Fail if the image has an unknown format or
	requires more than the given amount of memory.
 */
/*	Details: This method detects when the image was stored on a machine with
	the opposite byte ordering from this machine and swaps the bytes
	automatically. Furthermore, it allows the header information to start 512
	bytes into the file, since some file transfer programs for the Macintosh
	apparently prepend a Mac-specific header of this size. Note that this same
	512 bytes of prefix area could also be used to store an exec command on
	Unix systems, allowing one to launch Smalltalk by invoking the image name
	as a command.
 */
/*	This code is based on C code by Ian Piumarta and Smalltalk code by Tim
	Rowledge. Many thanks to both of you!!
 */

size_t
readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualEdenBytes;
    sqInt anObject;
    sqInt aValue;
    sqInt baseOfHeap;
    sqInt bytes;
    sqInt bytesRead;
    sqInt bytesToShift;
    sqInt classArrayClass;
    sqInt classArrayObj;
    sqInt classIndex;
    sqInt classTablePage;
    size_t dataSize;
    sqInt edenBytes;
    sqInt firstSegSize;
    sqInt hdrEdenBytes;
    sqInt hdrMaxExtSemTabSize;
    sqInt hdrNumStackPages;
    sqInt headerFlags;
    sqInt headerSize;
    squeakFileOffsetType headerStart;
    sqInt heapSize;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i12;
    sqInt i2;
    sqInt i21;
    sqInt i3;
    sqInt i4;
    sqInt iLimiT;
    sqInt memEnd;
    sqInt memLimit;
    sqInt minimumMemory;
    usqInt numSlots;
    sqInt oldBaseAddr;
    sqInt oldStart;
    sqInt oop;
    sqInt p;
    sqInt requestedEdenBytes;
    sqInt seed;
    sqInt startAddress;
    sqInt survivorBytes;
    sqInt swapBytes;
    sqInt totalBytes;


	/* guess Metaclass instSize */

	GIV(metaclassNumSlots) = 6;

	/* guess (Class instVarIndexFor: 'name' ifAbsent: []) - 1 */

	GIV(classNameIndex) = 6;
	swapBytes = checkImageVersionFromstartingAt(f, imageOffset);

	/* record header start position */

	headerStart = (sqImageFilePosition(f)) - BytesPerWord;
	headerSize = getLongFromFileswap(f, swapBytes);
	dataSize = getLongFromFileswap(f, swapBytes);
	oldBaseAddr = getLongFromFileswap(f, swapBytes);
	/* begin specialObjectsOop: */
	anObject = getLongFromFileswap(f, swapBytes);
	GIV(specialObjectsOop) = anObject;
	/* begin lastHash: */
	seed = getLongFromFileswap(f, swapBytes);
	GIV(lastHash) = seed;
	GIV(savedWindowSize) = getLongFromFileswap(f, swapBytes);
	headerFlags = getLongFromFileswap(f, swapBytes);
	/* begin setImageHeaderFlagsFrom: */

	/* so as to preserve unrecognised flags. */

	GIV(imageHeaderFlags) = headerFlags;
	GIV(fullScreenFlag) = headerFlags & 1;
	GIV(imageFloatsBigEndian) = ((headerFlags & 2) == 0
		? 1
		: 0);
	GIV(preemptionYields) = (headerFlags & 16) == 0;
	extraVMMemory = getLongFromFileswap(f, swapBytes);

	/* 4 stack pages is small.  Should be able to run with as few as
	   three. 4 should be comfortable but slow.  8 is a reasonable
	   default.  Can be changed via vmParameterAt: 43 put: n.
	   Can be set as a preference (Info.plist, VM.ini, command line etc).
	   If desiredNumStackPages is already non-zero then it has been
	   set as a preference.  Ignore (but preserve) the header's default. */

	hdrNumStackPages = getShortFromFileswap(f, swapBytes);
	GIV(numStackPages) = (desiredNumStackPages != 0
		? desiredNumStackPages
		: (hdrNumStackPages == 0
				? defaultNumStackPages()
				: hdrNumStackPages));

	/* pad to word boundary.  This slot can be used for anything else that will fit in 16 bits.
	   It is used for the cog code size in Cog.  Preserve it to be polite to other VMs. */

	desiredNumStackPages = hdrNumStackPages;
	GIV(theUnknownShort) = getShortFromFileswap(f, swapBytes);
	hdrEdenBytes = getLongFromFileswap(f, swapBytes);
	/* begin edenBytes: */
	bytes = (desiredEdenBytes != 0
		? desiredEdenBytes
		: (hdrEdenBytes == 0
				? defaultEdenBytes()
				: hdrEdenBytes));
	edenBytes = bytes;
	desiredEdenBytes = hdrEdenBytes;
	hdrMaxExtSemTabSize = getShortFromFileswap(f, swapBytes);
	if (hdrMaxExtSemTabSize != 0) {
		/* begin setMaxExtSemSizeTo: */
		GIV(maxExtSemTabSizeSet) = 1;
		ioSetMaxExtSemTableSize(hdrMaxExtSemTabSize);
	}
	GIV(the2ndUnknownShort) = getShortFromFileswap(f, swapBytes);
	firstSegSize = getLongFromFileswap(f, swapBytes);
	/* begin firstSegmentSize: */
	GIV(firstSegmentSize) = firstSegSize;
	heapSize = (desiredHeapSize + edenBytes) + (interpreterAllocationReserveBytes());
	heapSize = reserveExtraCHeapBytes(heapSize, extraVMMemory);
	minimumMemory = (dataSize + edenBytes) + (interpreterAllocationReserveBytes());
	if (heapSize < minimumMemory) {
		insufficientMemorySpecifiedError();
	}
	/* begin memory: */
	aValue = ((usqInt)(allocateMemoryminimumimageFileheaderSize(heapSize, minimumMemory, f, headerSize)));
	GIV(memory) = aValue;
	if (!(memory())) {
		insufficientMemoryAvailableError();
	}
	/* begin setHeapBase:memoryLimit:endOfMemory: */
	baseOfHeap = memory();
	memLimit = (memory()) + heapSize;
	memEnd = (memory()) + dataSize;
	GIV(newSpaceStart) = baseOfHeap;
	GIV(newSpaceLimit) = (baseOfHeap + edenBytes) + (interpreterAllocationReserveBytes());
	/* begin newSpaceStart:newSpaceBytes:edenBytes: */
	startAddress = GIV(newSpaceStart);
	totalBytes = GIV(newSpaceLimit) - GIV(newSpaceStart);
	requestedEdenBytes = ((GIV(newSpaceLimit) - GIV(newSpaceStart)) * (7 - 2)) / 7;
	actualEdenBytes = requestedEdenBytes;
	survivorBytes = ((((sqInt) (totalBytes - actualEdenBytes) >> 1)) & ~7);
	actualEdenBytes = (((totalBytes - survivorBytes) - survivorBytes) & ~7);
	assert((((totalBytes - actualEdenBytes) - survivorBytes) - survivorBytes) < (allocationUnit()));
	(GIV(pastSpace).start = startAddress);
	(GIV(pastSpace).limit = startAddress + survivorBytes);
	(GIV(futureSpace).start = (GIV(pastSpace).limit));
	(GIV(futureSpace).limit = ((GIV(pastSpace).limit)) + survivorBytes);
	(GIV(eden).start = (GIV(futureSpace).limit));
	(GIV(eden).limit = ((GIV(futureSpace).limit)) + actualEdenBytes);
	assert(((GIV(futureSpace).limit)) <= (startAddress + totalBytes));
	assert(((((GIV(eden).start)) % (allocationUnit())) + (((GIV(eden).limit)) % (allocationUnit()))) == 0);
	assert(((((GIV(pastSpace).start)) % (allocationUnit())) + (((GIV(pastSpace).limit)) % (allocationUnit()))) == 0);
	assert(((((GIV(futureSpace).start)) % (allocationUnit())) + (((GIV(futureSpace).limit)) % (allocationUnit()))) == 0);
	/* begin initFutureSpaceStart */
	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	oldStart;
	/* begin initSpaceForAllocationCheck: */
	if (!(GIV(memory) == null)) {
		for (p = ((((&GIV(eden)))->start)); p < ((((&GIV(eden)))->limit)); p += (wordSize())) {
			longAtput(p, p);
		}

	}
	GIV(tenuringProportion) = 0.9;
	GIV(freeStart) = ((eden()).start);
	GIV(pastSpaceStart) = ((pastSpace()).start);
	GIV(oldSpaceStart) = GIV(newSpaceLimit);
	GIV(freeOldSpaceStart) = memEnd;
	GIV(endOfMemory) = memLimit;
	baseOfHeap;
	sqImageFileSeek(f, headerStart + headerSize);
	bytesRead = readHeapFromImageFiledataBytes(f, dataSize);
	if (bytesRead != dataSize) {
		unableToReadImageError();
	}
	ensureImageFormatIsUpToDate(swapBytes);
	bytesToShift = GIV(oldSpaceStart) - oldBaseAddr;
	/* begin initializeInterpreter: */
	interpreterProxy = sqGetInterpreterProxy();
	dummyReferToProxy();
	initializeObjectMemory(bytesToShift);
	/* begin checkAssumedCompactClasses */
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassArrayCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassArray << 2))) != (knownClassAtIndex(ClassArrayCompactIndex)))) {
		invalidCompactClassError("Array");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassLargeNegativeIntegerCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargeNegativeInteger << 2))) != (knownClassAtIndex(ClassLargeNegativeIntegerCompactIndex)))) {
		invalidCompactClassError("LargeNegativeInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassLargePositiveIntegerCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) != (knownClassAtIndex(ClassLargePositiveIntegerCompactIndex)))) {
		invalidCompactClassError("LargePositiveInteger");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassFloatCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) != (knownClassAtIndex(ClassFloatCompactIndex)))) {
		invalidCompactClassError("Float");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassBlockClosureCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassBlockClosure << 2))) != (knownClassAtIndex(ClassBlockClosureCompactIndex)))) {
		invalidCompactClassError("BlockClosure");
	}
	/* begin checkCompactIndex:isClass:named: */
	if ((ClassMethodContextCompactIndex != 0)
	 && ((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassMethodContext << 2))) != (knownClassAtIndex(ClassMethodContextCompactIndex)))) {
		invalidCompactClassError("MethodContext");
	}
	/* begin compactIndexOfClass: */
	assert((rawHashBitsOf(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteArray << 2)))) != 0);
	/* begin rawHashBitsOf: */
	flag("endianness");
	GIV(classByteArrayCompactIndex) = (longAt((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteArray << 2))) + 4)) & 0x3FFFFF;
	GIV(primFailCode) = 0;
	/* begin initializeExtraClassInstVarIndices */
	classArrayObj = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassArray << 2));
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(classArrayObj)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		classArrayClass = classArrayObj;
		goto l1;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		classArrayClass = null;
		goto l2;
	}
	classArrayClass = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l2:	/* end classAtIndex: */;
l1:	/* end fetchClassOfNonImm: */;
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(classArrayClass)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(classArrayClass + 4))))) >> 24;
	GIV(metaclassNumSlots) = ((usqInt) ((numSlots == 0xFF
	? (/* begin rawOverflowSlotsOf: */
		flag("endianness"),
		longAt(classArrayClass - (BaseHeaderSize)))
	: numSlots)));

	/* default */

	GIV(thisClassIndex) = 5;
	for (i4 = (InstanceSpecificationIndex + 1), iLimiT = (lengthOfformat(classArrayClass, (((usqInt) (longAt(classArrayClass))) >> 24) & 0x1F)); i4 <= iLimiT; i4 += 1) {
		if ((longAt((classArrayClass + (BaseHeaderSize)) + ((i4 - 1) << 2))) == classArrayObj) {
			GIV(thisClassIndex) = i4 - 1;
		}
	}

	/* default */

	GIV(classNameIndex) = 6;
	for (i4 = (InstanceSpecificationIndex + 1), iLimiT = (lengthOfformat(classArrayObj, (((usqInt) (longAt(classArrayObj))) >> 24) & 0x1F)); i4 <= iLimiT; i4 += 1) {
		oop = longAt((classArrayObj + (BaseHeaderSize)) + ((i4 - 1) << 2));
		if ((((oop & 3) == 0)
 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16))
		 && (((lengthOfformat(oop, (((usqInt) (longAt(oop))) >> 24) & 0x1F)) == 5)
		 && ((strncmp("Array", firstFixedField(oop), 5)) == 0))) {
			GIV(classNameIndex) = i4 - 1;
		}
	}

	/* This is also the initialization flag for the stack system. */

	GIV(stackLimit) = 0;
	GIV(stackPage) = (GIV(overflowedPage) = 0);
	GIV(extraFramesToMoveOnOverflow) = 0;
	GIV(method) = (GIV(newMethod) = GIV(nilObj));
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = 0;

#  endif /* MULTIPLEBYTECODESETS */

	GIV(methodDictLinearSearchLimit) = 8;
	/* begin flushMethodCache */
	for (i = 1; i <= MethodCacheSize; i += 1) {
		GIV(methodCache)[i] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i1 = 1; i1 <= AtCacheTotalSize; i1 += 1) {
		GIV(atCache)[i1] = 0;
	}
	/* begin flushAtCache */
	for (i2 = 1; i2 <= AtCacheTotalSize; i2 += 1) {
		GIV(atCache)[i2] = 0;
	}
	/* begin initialCleanup */
	/* begin flushMethodCache */
	for (i21 = 1; i21 <= MethodCacheSize; i21 += 1) {
		GIV(methodCache)[i21] = 0;
	}

	/* this for primitiveExternalMethod */

	GIV(lastMethodCacheProbeWrite) = 0;
	/* begin flushAtCache */
	for (i11 = 1; i11 <= AtCacheTotalSize; i11 += 1) {
		GIV(atCache)[i11] = 0;
	}
	/* begin flushAtCache */
	for (i3 = 1; i3 <= AtCacheTotalSize; i3 += 1) {
		GIV(atCache)[i3] = 0;
	}
	/* begin flushExternalPrimitiveTable */
	for (i12 = 0; i12 < MaxExternalPrimitiveTableSize; i12 += 1) {
		externalPrimitiveTable[i12] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
	GIV(highestRunnableProcessPriority) = 0;
	GIV(nextProfileTick) = 0;
	GIV(profileSemaphore) = GIV(nilObj);
	GIV(profileProcess) = GIV(nilObj);
	GIV(profileMethod) = GIV(nilObj);
	GIV(nextPollUsecs) = 0;
	GIV(nextWakeupUsecs) = 0;
	GIV(tempOop) = (GIV(theUnknownShort) = 0);

	/* cmd-. as used for Mac but no other OS */

	GIV(interruptKeycode) = 2094;
	GIV(interruptPending) = 0;
	inIOProcessEvents = 0;
	GIV(fullScreenFlag) = 0;
	deferDisplayUpdates = 0;
	GIV(pendingFinalizationSignals) = (GIV(statPendingFinalizationSignals) = 0);
	GIV(globalSessionID) = 0;
	while (GIV(globalSessionID) == 0) {
		GIV(globalSessionID) = (time(NULL)) + (ioMSecs());
	}
	GIV(jmpDepth) = 0;
	GIV(longRunningPrimitiveStartUsecs) = (GIV(longRunningPrimitiveStopUsecs) = 0);
	GIV(maxExtSemTabSizeSet) = 0;
	GIV(statForceInterruptCheck) = 0;
	GIV(statStackOverflow) = 0;
	GIV(statCheckForEvents) = 0;
	GIV(statProcessSwitch) = 0;
	GIV(statIOProcessEvents) = 0;
	GIV(statStackPageDivorce) = 0;
	return dataSize;
}


/*	post sweep and pre compact, rebuild the large free chunk tree from the
	sortedFreeChunks list, such that the lists are ordered from low to high
	address. 
 */
/*	first add all the chunks to the tree. This will result in almost
	address-sorted lists.
	We will need to reorder the lists. */

static sqInt
rebuildFreeTreeFrom(sqInt sortedFreeChunks)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bytes;
    sqInt cameFrom;
    sqInt first;
    sqInt freeChunk;
    sqInt largeChild;
    sqInt newTreeNode;
    sqInt next;
    sqInt node;
    sqInt prev;
    sqInt smallChild;
    sqInt totalBytes;
    sqInt treeNode;
    sqInt treeNode1;

	freeChunk = sortedFreeChunks;
	totalBytes = 0;
	while (freeChunk != 0) {
		bytes = bytesInObject(freeChunk);
		totalBytes += bytes;
		addToFreeTreebytes(freeChunk, bytes);
		freeChunk = longAt((freeChunk + (BaseHeaderSize)) + (1 << 2));
	}
	/* begin freeTreeNodesDo: */
	treeNode1 = GIV(freeLists)[0];
	if (treeNode1 == 0) {
		goto l1;
	}
	cameFrom = -1;
	do {
		smallChild = longAt((treeNode1 + (BaseHeaderSize)) + (3 << 2));
		largeChild = longAt((treeNode1 + (BaseHeaderSize)) + (4 << 2));
		assert((smallChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {

			/* and since we've applied we must move on up */

			/* begin reorderReversedTreeList: */

			/* no next node, so no change */

			first = longAt((treeNode1 + (BaseHeaderSize)) + (0 << 2));
			if (first == 0) {
				newTreeNode = treeNode1;
				goto l3;
			}
			node = longAt((first + (BaseHeaderSize)) + (0 << 2));
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(first));
			assert((treeNode1 == 0)
			 || (isFreeObject(treeNode1)));
			longAtput((first + (BaseHeaderSize)) + (0 << 2), treeNode1);
			inFreeTreeReplacewith(treeNode1, first);
			prev = 0;
			while (node != 0) {
				next = longAt((node + (BaseHeaderSize)) + (0 << 2));
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(node));
				assert((prev == 0)
				 || (isFreeObject(prev)));
				longAtput((node + (BaseHeaderSize)) + (0 << 2), prev);
				prev = node;
				node = next;
			}
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(treeNode1));
			assert((prev == 0)
			 || (isFreeObject(prev)));
			longAtput((treeNode1 + (BaseHeaderSize)) + (0 << 2), prev);
			newTreeNode = first;
		l3:	/* end reorderReversedTreeList: */;
			treeNode1 = newTreeNode;

			cameFrom = treeNode1;
			treeNode1 = longAt((treeNode1 + (BaseHeaderSize)) + (2 << 2));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode1 = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode1 = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode1 != 0);
l1:	/* end freeTreeNodesDo: */;
	return totalBytes;
}


/*	callbackContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state,
	and mark calloutContext as dead. */

EXPORT(sqInt)
reestablishContextPriorToCallback(sqInt callbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutContext;
    sqInt index;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;
    sqInt value;
    sqInt value1;

	flag("obsolete");
	if (!(isLiveContext(callbackContext))) {
		return 0;
	}
	calloutContext = externalInstVarofContext(SenderIndex, callbackContext);
	if (!(isLiveContext(calloutContext))) {
		return 0;
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (((longAt((callbackContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 3) == 0) {
		/* begin markContextAsDead: */
		assert(isContext(callbackContext));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(callbackContext)));
		longAtput((callbackContext + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(callbackContext)));
		longAtput((callbackContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
	}
	else {
		/* begin frameOfMarriedContext: */
		value = longAt((callbackContext + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		if (GIV(framePointer) == theFP) {

			/* common case */

			if ((longAt(theFP + FoxSavedFP)) == 0) {
				/* begin freeStackPage: */
				freeStackPageNoAssert(GIV(stackPage));
				assert(pageListIsWellFormed());
			}
			else {

				/* calloutContext is immediately below on the same page.  Make it current. */

				GIV(instructionPointer) = ((usqInt)(frameCallerSavedIP(GIV(framePointer))));
				GIV(stackPointer) = (GIV(framePointer) + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((GIV(framePointer) + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
				/* begin frameCallerFP: */
				GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				return 1;
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackContext));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(callbackContext)));
			longAtput((callbackContext + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(callbackContext)));
			longAtput((callbackContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
		}
	}
	if ((((longAt((calloutContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
	 && (!(isWidowedContext(calloutContext)))) {
		/* begin frameOfMarriedContext: */
		value1 = longAt((calloutContext + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value1 & 1));
		theFP = pointerForOop(value1 - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage)) - BytesPerWord;
		GIV(framePointer) = theFP;
	}
	else {
		thePage = makeBaseFrameFor(calloutContext);
		GIV(framePointer) = (thePage->headFP);
		GIV(stackPointer) = (thePage->headSP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	return 1;
}


/*	Scavenge or simply follow objOop. Answer the new location of objOop. The
	send should have been guarded by a send of shouldRemapOop: or
	shouldScavengeObj:. The method is called remapObj: for compatibility with
	ObjectMemory.  */

sqInt
remapObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt referent;
    sqInt resolvedObj;

	assert(shouldRemapOop(objOop));
	if (((longAt(objOop)) & 0x3FFFFF) == 8) {
		/* begin followForwarded: */
		assert(isForwarded(objOop));
		referent = longAt((objOop + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		resolvedObj = referent;
		if (oopisGreaterThanOrEqualToandLessThan(resolvedObj, ((futureSpace()).start), GIV(futureSurvivorStart))) {

			/* already scavenged */

			return resolvedObj;
		}
	}
	else {
		resolvedObj = objOop;
	}
	if (!(((resolvedObj & 3) == 0)
		 && (isYoungObject(resolvedObj)))) {

		/* a becommed or compacted object whose target is in old space, or a CogMethod. */

		return resolvedObj;
	}
	return copyAndForward(resolvedObj);
}


/*	bit 0 of 3-bit field above format (little endian) */

sqInt
rememberedBitShift(void)
{
	return 29;
}

static void
remember(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!(isYoung(objOop)));
	if (GIV(rememberedSetSize) < RememberedSetLimit) {
		GIV(rememberedSet)[GIV(rememberedSetSize)] = objOop;
		if (((GIV(rememberedSetSize) += 1)) >= RememberedSetRedZone) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
	}
	else {
		error("remembered set overflow");
	}
}


/*	Remove the first process from the given linked list. */

static sqInt
removeFirstLinkOfList(sqInt aList)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt first;
    sqInt last;
    sqInt next;

	first = longAt((aList + (BaseHeaderSize)) + (FirstLinkIndex << 2));
	last = longAt((aList + (BaseHeaderSize)) + (LastLinkIndex << 2));
	if (first == last) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		if (isOldObject(aList)) {

			/* most stores into young objects */

			if (((GIV(nilObj) & 3) == 0)
			 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aList))) >> 29) & 1) != 0)) {
					remember(aList);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(aList, (longAt(aList)) | (1 << 29));
				}
			}
		}
		longAtput((aList + (BaseHeaderSize)) + (FirstLinkIndex << 2), GIV(nilObj));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		if (isOldObject(aList)) {

			/* most stores into young objects */

			if (((GIV(nilObj) & 3) == 0)
			 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aList))) >> 29) & 1) != 0)) {
					remember(aList);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(aList, (longAt(aList)) | (1 << 29));
				}
			}
		}
		longAtput((aList + (BaseHeaderSize)) + (LastLinkIndex << 2), GIV(nilObj));
	}
	else {
		next = longAt((first + (BaseHeaderSize)) + (NextLinkIndex << 2));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(aList)));
		if (isOldObject(aList)) {

			/* most stores into young objects */

			if (((next & 3) == 0)
			 && ((((usqInt) next)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(aList))) >> 29) & 1) != 0)) {
					remember(aList);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(aList, (longAt(aList)) | (1 << 29));
				}
			}
		}
		longAtput((aList + (BaseHeaderSize)) + (FirstLinkIndex << 2), next);
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(first)));
	if (isOldObject(first)) {

		/* most stores into young objects */

		if (((GIV(nilObj) & 3) == 0)
		 && ((((usqInt) GIV(nilObj))) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(first))) >> 29) & 1) != 0)) {
				remember(first);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(first, (longAt(first)) | (1 << 29));
			}
		}
	}
	longAtput((first + (BaseHeaderSize)) + (NextLinkIndex << 2), GIV(nilObj));
	return first;
}


/*	Remove the given variable location to the extra roots table. */

sqInt
removeGCRoot(sqInt *varLoc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	for (i = 1; i <= GIV(extraRootCount); i++) {
		if (varLoc == (GIV(extraRoots)[i])) {

			/* swap varLoc with last entry */

			GIV(extraRoots)[i] = (GIV(extraRoots)[GIV(extraRootCount)]);
			GIV(extraRootCount) -= 1;
			return 1;
		}
	}
	return 0;
}


/*	Make aProcess runnable and if its priority is higher than that of the
	current process, preempt the current process. Answer if the current
	process was preempted. If the current process was preempted then if
	yieldImplicitly add the current process to the back of its run queue,
	causing an implicit yiled to other processes on the run queue, otherwise
	add the current process to the front of its run queue, hence not yielding.
	Blue book behaviour is to yield implicitly but is arguably incorrect. */

static sqInt
resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activePriority;
    sqInt activeProc;
    sqInt newPriority;
    sqInt oop;
    sqInt oop1;

	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((activeProc + (BaseHeaderSize)) + (PriorityIndex << 2));
	assert((oop & 1));
	activePriority = (oop >> 1);
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((aProcess + (BaseHeaderSize)) + (PriorityIndex << 2));
	assert((oop1 & 1));
	newPriority = (oop1 >> 1);
	if (newPriority <= activePriority) {
		putToSleepyieldingIf(aProcess, 1);
		return 0;
	}
	putToSleepyieldingIf(activeProc, yieldImplicitly);
	transferTo(aProcess);
	return 1;
}


/*	callbackMethodContext is an activation of
	invokeCallback:[stack:registers:jmpbuf:]. Its sender is the VM's state
	prior to the callback. Reestablish that state (via longjmp),
	and mark callbackMethodContext as dead. */

EXPORT(sqInt)
returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt calloutMethodContext;
    sqInt index;
    char *sp;
    char *theFP;
    StackPage *thePage;
    sqInt top;
    sqInt value;
    sqInt value1;

	if (!(((returnTypeOop & 1))
		 && (isLiveContext(callbackMethodContext)))) {
		return 0;
	}
	calloutMethodContext = externalInstVarofContext(SenderIndex, callbackMethodContext);
	if (!(isLiveContext(calloutMethodContext))) {
		return 0;
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (((longAt((callbackMethodContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 3) == 0) {
		/* begin markContextAsDead: */
		assert(isContext(callbackMethodContext));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(callbackMethodContext)));
		longAtput((callbackMethodContext + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(callbackMethodContext)));
		longAtput((callbackMethodContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
	}
	else {
		/* begin frameOfMarriedContext: */
		value = longAt((callbackMethodContext + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFP = pointerForOop(value - 1);
		if (GIV(framePointer) == theFP) {

			/* common case */

			if ((longAt(theFP + FoxSavedFP)) == 0) {
				/* begin freeStackPage: */
				freeStackPageNoAssert(GIV(stackPage));
				assert(pageListIsWellFormed());
			}
			else {

				/* calloutMethodContext is immediately below on the same page.  Make it current. */

				GIV(instructionPointer) = ((usqInt)(frameCallerSavedIP(GIV(framePointer))));
				GIV(stackPointer) = (GIV(framePointer) + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((GIV(framePointer) + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
				/* begin frameCallerFP: */
				GIV(framePointer) = pointerForOop(longAt(GIV(framePointer) + FoxSavedFP));
				/* begin restoreCStackStateForCallbackContext: */
				siglongjmp((vmCallbackContext->trampoline), (returnTypeOop >> 1));
				return 1;
			}
		}
		else {
			externalDivorceFrameandContext(theFP, callbackMethodContext);
			/* begin markContextAsDead: */
			assert(isContext(callbackMethodContext));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(callbackMethodContext)));
			longAtput((callbackMethodContext + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(callbackMethodContext)));
			longAtput((callbackMethodContext + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
		}
	}
	if ((((longAt((calloutMethodContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
	 && (!(isWidowedContext(calloutMethodContext)))) {
		/* begin frameOfMarriedContext: */
		value1 = longAt((calloutMethodContext + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value1 & 1));
		theFP = pointerForOop(value1 - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(thePage != GIV(stackPage));
		GIV(stackPointer) = (findSPOfon(theFP, thePage)) - BytesPerWord;
		GIV(framePointer) = theFP;
	}
	else {
		thePage = makeBaseFrameFor(calloutMethodContext);
		GIV(framePointer) = (thePage->headFP);
		GIV(stackPointer) = (thePage->headSP);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	/* begin restoreCStackStateForCallbackContext: */
	siglongjmp((vmCallbackContext->trampoline), (returnTypeOop >> 1));
	return 1;
}


/*	Reverse the given range of Display words (at different bit 
	depths, this will reverse different numbers of pixels). Used to 
	give feedback during VM activities such as garbage 
	collection when debugging. It is assumed that the given 
	word range falls entirely within the first line of the Display. */

static sqInt
reverseDisplayFromto(sqInt startIndex, sqInt endIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt displayBits;
    sqInt displayObj;
    sqInt primFailCodeValue;
    sqInt ptr;
    sqInt reversed;
    sqInt w;
    sqInt wordEndIndex;
    sqInt wordStartIndex;

	displayObj = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (TheDisplay << 2));
	if (!((((displayObj & 3) == 0)
 && (((((usqInt) (longAt(displayObj))) >> 24) & 0x1F) <= 5))
		 && ((lengthOfformat(displayObj, (((usqInt) (longAt(displayObj))) >> 24) & 0x1F)) >= 4))) {
		return null;
	}
	w = longAt((displayObj + (BaseHeaderSize)) + (1 << 2));
	displayBits = longAt((displayObj + (BaseHeaderSize)) + (0 << 2));
	if (((displayBits & 3) != 0)
	 || (((w & 1) == 0)
	 || (((((usqInt) (longAt(displayBits))) >> 24) & 0x1F) <= 5))) {
		return null;
	}
	wordStartIndex = startIndex * 4;
	wordEndIndex = (((endIndex * 4) < (((numSlotsOf(displayBits)) << 2) + (BaseHeaderSize))) ? (endIndex * 4) : (((numSlotsOf(displayBits)) << 2) + (BaseHeaderSize)));
	displayBits += BaseHeaderSize;
	for (ptr = (displayBits + wordStartIndex); ptr <= (displayBits + wordEndIndex); ptr += 4) {
		reversed = (long32At(ptr)) ^ 0xFFFFFFFFUL;
		longAtput(ptr, reversed);
	}
	primFailCodeValue = GIV(primFailCode);
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	displayBitsOfLeftTopRightBottom(displayObj, 0, 0, (w >> 1), 1);
	ioForceDisplayUpdate();
	GIV(primFailCode) = primFailCodeValue;
}


/*	Rewrite an existing entry in the method cache with a new primitive
	function address.
	Used by primitiveExternalCall to make direct calls to found external
	prims, or quickly
	fail not found external prims. */

static void
rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void))
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCacheMethod]) == GIV(newMethod)) {
		GIV(methodCache)[GIV(lastMethodCacheProbeWrite) + MethodCachePrimFunction] = (((long) localPrimAddress));
	}
}


/*	Answer if there is room to push n arguments onto the current stack. We
	assume this is called by primitives that check there is enough room in any
	new context, and
	won't actually push the arguments in the current context if the primitive
	fails. With
	this assumption it is safe to answer based on the maximum argument count,
	/not/ the ammount of space in the current frame were it converted to a
	context..  */

static sqInt
roomToPushNArgs(sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt cntxSize;

	
	/* simpler code that simply insists args are <= max arg count */

	return n <= (LargeContextSlots - CtxtTempFrameStart);

}

static void
runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(sqInt fullGCFlag, sqInt excludeUnmarkedNewSpaceObjs)
{
	if ((fullGCFlag
		? (checkForLeaks & 1) != 0
		: (checkForLeaks & 2) != 0)) {
		if (fullGCFlag) {
			reverseDisplayFromto(0, 7);
		}
		else {
			reverseDisplayFromto(8, 15);
		}
		clearLeakMapAndMapAccessibleObjects();
		assert(checkHeapIntegrity(excludeUnmarkedNewSpaceObjs));
		assert(checkInterpreterIntegrity());
		assert(checkStackIntegrity());
		assert(checkCodeIntegrity(fullGCFlag));
	}
}


/*	Scan a class in the class table post-become. Make sure the superclass
	chain contains no forwarding pointers, and that the method dictionaries
	are not forwarded either, and that methoidClassAssociations in methods
	are not followed either. */
/*	Algorithm depend on this to terminate loop at root of superclass chain. */

static void
scanClassPostBecomeeffects(sqInt startClassObj, sqInt becomeEffects)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt i;
    sqInt iLimiT;
    sqInt obj;
    sqInt obj2;
    sqInt referent;
    sqInt referent1;
    sqInt referent2;

	assert((rawHashBitsOf(GIV(nilObj))) != 0);
	assert(becomeEffects & (BecamePointerObjectFlag + BecameCompiledMethodFlag));
	classObj = startClassObj;
	while (1) {
		obj = longAt((classObj + (BaseHeaderSize)) + (MethodDictionaryIndex << 2));
		assert(isNonImmediate(obj));
		if (((longAt(obj)) & 0x3FFFFF) == 8) {
			/* begin followForwarded: */
			assert(isForwarded(obj));
			referent = longAt((obj + (BaseHeaderSize)) + (0 << 2));
			while (((referent & 3) == 0)
			 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
				referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
			}
			obj = referent;
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(classObj)));
			if (isOldObject(classObj)) {

				/* most stores into young objects */

				if (((obj & 3) == 0)
				 && ((((usqInt) obj)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(classObj))) >> 29) & 1) != 0)) {
						remember(classObj);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(classObj, (longAt(classObj)) | (1 << 29));
					}
				}
			}
			longAtput((classObj + (BaseHeaderSize)) + (MethodDictionaryIndex << 2), obj);
		}
		obj2 = longAt((obj + (BaseHeaderSize)) + (MethodArrayIndex << 2));
		assert(isNonImmediate(obj2));
		if (((longAt(obj2)) & 0x3FFFFF) == 8) {
			/* begin followForwarded: */
			assert(isForwarded(obj2));
			referent1 = longAt((obj2 + (BaseHeaderSize)) + (0 << 2));
			while (((referent1 & 3) == 0)
			 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
				referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
			}
			obj2 = referent1;
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(obj)));
			if (isOldObject(obj)) {

				/* most stores into young objects */

				if (((obj2 & 3) == 0)
				 && ((((usqInt) obj2)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(obj))) >> 29) & 1) != 0)) {
						remember(obj);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(obj, (longAt(obj)) | (1 << 29));
					}
				}
			}
			longAtput((obj + (BaseHeaderSize)) + (MethodArrayIndex << 2), obj2);
		}
		if (becomeEffects & BecameCompiledMethodFlag) {
			followForwardedObjectFieldstoDepth(obj2, 0);
		}
		if (becomeEffects & BecamePointerObjectFlag) {
			for (i = 0, iLimiT = ((numSlotsOf(obj2)) - 1); i <= iLimiT; i += 1) {
				obj = longAt((obj2 + (BaseHeaderSize)) + (i << 2));
				if (((obj2 & 3) == 0)
				 && (((((usqInt) (longAt(obj2))) >> 24) & 0x1F) >= 24)) {
					followNecessaryForwardingInMethod(obj2);
				}
			}
		}
		obj = longAt((classObj + (BaseHeaderSize)) + (SuperclassIndex << 2));
		assert(isNonImmediate(obj));
		if (((longAt(obj)) & 0x3FFFFF) == 8) {
			/* begin followForwarded: */
			assert(isForwarded(obj));
			referent2 = longAt((obj + (BaseHeaderSize)) + (0 << 2));
			while (((referent2 & 3) == 0)
			 && (((longAt(referent2)) & 0x3FFFFF) == 8)) {
				referent2 = longAt((referent2 + (BaseHeaderSize)) + (0 << 2));
			}
			obj = referent2;
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(classObj)));
			if (isOldObject(classObj)) {

				/* most stores into young objects */

				if (((obj & 3) == 0)
				 && ((((usqInt) obj)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(classObj))) >> 29) & 1) != 0)) {
						remember(classObj);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(classObj, (longAt(classObj)) | (1 << 29));
					}
				}
			}
			longAtput((classObj + (BaseHeaderSize)) + (SuperclassIndex << 2), obj);
		}
		if (!((rawHashBitsOf(obj)) == 0)) break;

		/* effectively self scanClassPostBecome: obj */

		classObj = obj;
	}
}


/*	scavengeFutureSurvivorSpaceStartingAt: does a depth-first traversal of the
	new objects starting at the one at initialAddress in futureSurvivorSpace. */

static void
scavengeFutureSurvivorSpaceStartingAt(sqInt initialAddress)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots2;
    sqInt obj;
    sqInt ptr;
    sqInt slotBytes;

	ptr = initialAddress;
	while (ptr < GIV(futureSurvivorStart)) {
		/* begin objectStartingAt: */
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots = ((usqInt) (((usqInt)(longAt(ptr + 4))))) >> 24;
		obj = (numSlots == 0xFF
			? ptr + (BaseHeaderSize)
			: ptr);
		/* begin addressAfter: */
		/* begin numSlotsOfAny: */
		/* begin rawNumSlotsOf: */
		flag("endianness");
		numSlots2 = ((usqInt) (((usqInt)(longAt(obj + 4))))) >> 24;
		numSlots1 = (numSlots2 == 0xFF
			? (/* begin rawOverflowSlotsOf: */
				flag("endianness"),
				longAt(obj - (BaseHeaderSize)))
			: numSlots2);
		slotBytes = (numSlots1 == 0
			? 8
			: (numSlots1 + (numSlots1 & 1)) << 2);
		ptr = (obj + (BaseHeaderSize)) + slotBytes;
		((void) (scavengeReferentsOf(obj)));
	}
}


/*	This is the inner loop of the main routine, scavenge. It first scavenges
	the new objects immediately
	reachable from old ones. Then it scavenges those that are transitively
	reachable. If this results in a
	promotion, the promotee gets remembered, and it first scavenges objects
	adjacent to the promotee,
	then scavenges the ones reachable from the promoted. This loop continues
	until no more reachable
	objects are left. At that point, pastSurvivorSpace is exchanged with
	futureSurvivorSpace. 
	Notice that each pointer in a live object is inspected once and only once.
	The previousRememberedSetSize
	and previousFutureSurvivorSpaceLimit variables ensure that no object is
	scanned twice, as well as
	detecting closure. If this were not true, some pointers might get
	forwarded twice.
	
	An extension of the algorithm presented in David's original paper is to
	handle weak arrays and ephemerons.
	Weak arrays should not have their weak referents scavenged unless there
	are strong references to them.
	Ephemerons should fire if their key is not reachable other than from
	ephemerons and weak arrays.
	Handle this by maintaining a list for weak arrays and a list for
	ephemerons, which allow scavenging these
	objects once all other objects in new space have been scavenged, hence
	allowing the scavenger to
	detect which referents in new space of weak arrays are dead and of
	ephemeron keys are only live due to
	ephemerons. Read the class comment for a more in-depth description of the
	algorithm.  */

static void
scavengeLoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt firstTime;
    sqInt i;
    sqInt i1;
    sqInt oop;
    sqInt previousFutureSurvivorStart;
    StackPage *thePage;

	assert(GIV(futureSurvivorStart) == ((GIV(futureSpace).start)));
	GIV(weakList) = (GIV(ephemeronList) = null);
	GIV(numRememberedEphemerons) = 0;
	firstTime = 1;
	GIV(previousRememberedSetSize) = 0;
	previousFutureSurvivorStart = GIV(futureSurvivorStart);
	/* begin initStackPageGC */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	for (i1 = 0; i1 < GIV(numStackPages); i1 += 1) {
		/* begin stackPageAt: */
		thePage = stackPageAtpages(i1, GIV(pages));
		(thePage->trace = StackPageUnreached);
	}
	while(1) {
		scavengeRememberedSetStartingAt(GIV(previousRememberedSetSize));
		GIV(previousRememberedSetSize) = GIV(rememberedSetSize);
		if (firstTime) {
			mapInterpreterOops();
			/* begin mapExtraRoots */
			assert(GIV(remapBufferCount) == 0);
			for (i = 1; i <= GIV(extraRootCount); i += 1) {
				oop = (GIV(extraRoots)[i])[0];
				if (!(((oop & 3) != 0)
					 || (((longAt(oop)) & 0x3FFFFF) == 0))) {
					if ((((longAt(oop)) & 0x3FFFFF) == 8)
					 || (isYoungObject(oop))) {
						(GIV(extraRoots)[i])[0] = (remapObj(oop));
					}
				}
			}
			firstTime = 0;
		}
		if ((GIV(previousRememberedSetSize) == GIV(rememberedSetSize))
		 && ((previousFutureSurvivorStart == GIV(futureSurvivorStart))
		 && ((GIV(numRememberedEphemerons) == 0)
		 && (GIV(ephemeronList) == null)))) {
			return;
		}
		scavengeFutureSurvivorSpaceStartingAt(previousFutureSurvivorStart);

		/* no more roots created to scavenge... */

		previousFutureSurvivorStart = GIV(futureSurvivorStart);
		if (GIV(previousRememberedSetSize) == GIV(rememberedSetSize)) {
			if ((GIV(numRememberedEphemerons) == 0)
			 && (GIV(ephemeronList) == null)) {
				return;
			}
			processEphemerons();
		}
	}
}


/*	scavengeReferentsOf: referrer inspects all the pointers in referrer. If
	any are new objects, it has them moved to FutureSurvivorSpace, and
	answers truth. If there are no new referents, it answers falsity. To
	handle weak arrays, if the referrer is weak only scavenge strong slots and
	answer true so that it won't be removed from the remembered set until
	later.  */
/*	forwarding objects should be followed by callers,
	unless the forwarder is a root in the remembered table. */

static sqInt
scavengeReferentsOf(sqInt referrer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt foundNewReferent;
    sqInt i;
    sqInt iLimiT;
    sqInt newLocation;
    sqInt referent;
    sqInt referent1;

	assert((!(isForwarded(referrer)))
	 || (isRemembered(referrer)));
	assert((!(isEphemeron(referrer)))
	 || ((isScavengeSurvivor(keyOfEphemeron(referrer)))
	 || (isonWeaklingList(referrer, GIV(ephemeronList)))));
	foundNewReferent = 0;
	for (i = 0, iLimiT = ((numStrongSlotsOfephemeronInactiveIf(referrer, isScavengeSurvivor)) - 1); i <= iLimiT; i += 1) {
		referent = longAt((referrer + (BaseHeaderSize)) + (i << 2));
		if ((referent & 3) == 0) {

			/* a forwarding pointer could be because of become: or scavenging. */

			if (((longAt(referent)) & 0x3FFFFF) == 8) {
				/* begin followForwarded: */
				assert(isForwarded(referent));
				referent1 = longAt((referent + (BaseHeaderSize)) + (0 << 2));
				while (((referent1 & 3) == 0)
				 && (((longAt(referent1)) & 0x3FFFFF) == 8)) {
					referent1 = longAt((referent1 + (BaseHeaderSize)) + (0 << 2));
				}
				referent = referent1;
			}
			if (isYoungObject(referent)) {

				/* if target is already in future space forwarding pointer was due to a become:. */

				if (oopisGreaterThanOrEqualToandLessThan(referent, ((futureSpace()).start), GIV(futureSurvivorStart))) {
					newLocation = referent;
					foundNewReferent = 1;
				}
				else {
					newLocation = copyAndForward(referent);
					if (((newLocation & 3) == 0)
					 && ((((usqInt) newLocation)) < (((usqInt) GIV(newSpaceLimit))))) {
						foundNewReferent = 1;
					}
				}
				longAtput((referrer + (BaseHeaderSize)) + (i << 2), newLocation);
			}
			else {
				longAtput((referrer + (BaseHeaderSize)) + (i << 2), referent);
			}
		}
	}
	return foundNewReferent
	 || (((((usqInt) (longAt(referrer))) >> 24) & 0x1F) == 4);
}


/*	scavengeRememberedSetStartingAt: n traverses objects in the remembered
	set starting at the nth one. If the object does not refer to any new
	objects, it
	is removed from the set. Otherwise, its new referents are scavenged. Defer
	scavenging ephemerons until after a complete scavenge has been performed,
	so that triggered ephemerons can be fired. Move them to the front of the
	set and count them in numRememberedEphemerons for later scanning. */

static void
scavengeRememberedSetStartingAt(sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt destIndex;
    sqInt referrer;
    sqInt sourceIndex;

	sourceIndex = (destIndex = n);
	while (sourceIndex < GIV(rememberedSetSize)) {

		/* *Don't* follow forwarding pointers here. oldSpace objects may refer
		   to these roots, and so they can't be removed in the scavenge. */


		/* Any potential firing ephemerons should not be scanned yet.
		   Move any to the front of the set to save time in later scanning. */

		referrer = GIV(rememberedSet)[sourceIndex];
		if ((isEphemeron(referrer))
		 && (!(isScavengeSurvivor(keyOfEphemeron(referrer))))) {
			assert(destIndex >= GIV(numRememberedEphemerons));
			GIV(rememberedSet)[destIndex] = (GIV(rememberedSet)[GIV(numRememberedEphemerons)]);
			GIV(rememberedSet)[GIV(numRememberedEphemerons)] = referrer;
			GIV(numRememberedEphemerons) += 1;
			destIndex += 1;
		}
		else {
			if (scavengeReferentsOf(referrer)) {
				GIV(rememberedSet)[destIndex] = referrer;
				destIndex += 1;
			}
			else {
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(referrer, (longAt(referrer)) & (~(1 << 29)));
			}
		}
		sourceIndex += 1;
	}
	GIV(rememberedSetSize) = destIndex;
	assert(noUnfiredEphemeronsAtEndOfRememberedSet());
}


/*	(Slang flattens so need unique selectors) */

static float
scavengerTenuringThreshold(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(tenureThreshold) >= ((GIV(pastSpace).start))
		? (((double) (GIV(tenureThreshold) - ((GIV(pastSpace).start))) )) / (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))
		: 0);
}


/*	There may be ephemerons to be scavenged on the ephemeronList.
	Scavenge any with unfired (live) keys, removing them from the
	list, and answer if any with unfired keys were found. */

static sqInt
scavengeUnfiredEphemeronsOnEphemeronList(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt corpseOffset;
    sqInt ephemeron;
    sqInt ephemeronCorpse;
    sqInt nextCorpseOffset;
    sqInt previousCorpse;
    sqInt referent;
    sqInt unfiredEphemeronsScavenged;

	if (!(GIV(ephemeronList))) {
		return 0;
	}
	unfiredEphemeronsScavenged = 0;
	corpseOffset = GIV(ephemeronList);
	while (corpseOffset != 0) {
		ephemeronCorpse = (corpseOffset << 3) + GIV(newSpaceStart);
		assert(isForwarded(ephemeronCorpse));
		/* begin followForwarded: */
		assert(isForwarded(ephemeronCorpse));
		referent = longAt((ephemeronCorpse + (BaseHeaderSize)) + (0 << 2));
		while (((referent & 3) == 0)
		 && (((longAt(referent)) & 0x3FFFFF) == 8)) {
			referent = longAt((referent + (BaseHeaderSize)) + (0 << 2));
		}
		ephemeron = referent;
		nextCorpseOffset = ((rawHashBitsOf(ephemeronCorpse)) << 5) + ((((usqInt) (longAt(ephemeronCorpse))) >> 24) & 0x1F);
		if (isScavengeSurvivor(keyOfEphemeron(ephemeron))) {
			if (corpseOffset == GIV(ephemeronList)) {
				GIV(ephemeronList) = (nextCorpseOffset != 0
					? nextCorpseOffset
					: 0);
			}
			else {
				/* begin setCorpseOffsetOf:to: */
				assert(isYoung(previousCorpse));
				assert(isForwarded(previousCorpse));
				/* begin setHashBitsOf:to: */
				flag("endianness");
				assert((((((usqInt) nextCorpseOffset) >> 5) >= 0) && ((((usqInt) nextCorpseOffset) >> 5) <= (identityHashHalfWordMask()))));
				longAtput(previousCorpse + 4, ((((longAt(previousCorpse + 4)) | 0x3FFFFF) - 0x3FFFFF)) + (((usqInt) nextCorpseOffset) >> 5));
				/* begin setFormatOf:to: */
				assert((((nextCorpseOffset & 0x1F) >= 0) && ((nextCorpseOffset & 0x1F) <= (formatMask()))));
				flag("endianness");
				longAtput(previousCorpse, ((longAt(previousCorpse)) & (~(0x1F << 24))) + ((nextCorpseOffset & 0x1F) << 24));
			}
			unfiredEphemeronsScavenged = 1;
			((void) (scavengeReferentsOf(ephemeron)));
		}
		else {
			previousCorpse = ephemeronCorpse;
		}
		corpseOffset = nextCorpseOffset;
	}
	return unfiredEphemeronsScavenged;
}


/*	Run the scavenger. */

static void
scavengingGCTenuringIf(sqInt tenuringCriterion)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    SpurNewSpaceSpace *aNewSpace;
    float fractionSurvived;
    sqInt freeSizeNow;
    sqInt i;
    sqInt i1;
    sqInt i11;
    sqInt i2;
    sqInt oldStart;
    sqInt p;
    sqInt probe;
    usqLong statSGCDeltaUsecs = 0;
    SpurNewSpaceSpace temp;

	assert(GIV(remapBufferCount) == 0);
	if (!(asserta(((((eden()).limit)) - GIV(freeStart)) > (interpreterAllocationReserveBytes())))) {
		/* begin tab */
		/* begin printChar: */
		putchar('	');
		printNum((((eden()).limit)) - GIV(freeStart));
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		printNum(interpreterAllocationReserveBytes());
		/* begin space */
		/* begin printChar: */
		putchar(' ');
		printNum((interpreterAllocationReserveBytes()) - ((((eden()).limit)) - GIV(freeStart)));
		/* begin cr */
		printf("\n");
	}
	/* begin checkMemoryMap */
	assert(isYoungObject(GIV(newSpaceStart)));
	assert(isYoungObject(GIV(newSpaceLimit) - (wordSize())));
	assert(!(isOldObject(GIV(newSpaceStart))));
	assert(!(isOldObject(GIV(newSpaceLimit) - (wordSize()))));
	assert(!(isYoungObject(GIV(newSpaceLimit))));
	assert(!(isYoungObject(GIV(oldSpaceStart))));
	assert(!(isYoungObject(GIV(endOfMemory))));
	assert(isOldObject(GIV(newSpaceLimit)));
	assert(isOldObject(GIV(oldSpaceStart)));
	assert(isOldObject(GIV(endOfMemory)));
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
	/* begin runLeakCheckerForFullGC: */
	runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(0, 0);
	/* return self */
	/* begin preGCAction: */
	if (GIV(stackPage) != 0) {
		/* begin externalWriteBackHeadFramePointers */
		assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
		assert(GIV(stackPage) == (mostRecentlyUsedPage()));
		/* begin setHeadFP:andSP:inPage: */
		assert(GIV(stackPointer) < GIV(framePointer));
		assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
		assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
		 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
		(GIV(stackPage)->headFP = GIV(framePointer));
		(GIV(stackPage)->headSP = GIV(stackPointer));
		assert(pageListIsWellFormed());
	}
	
	/* begin flushMethodCacheFrom:to: */
	probe = 0;
	for (i2 = 1; i2 <= MethodCacheEntries; i2 += 1) {
		if (!((GIV(methodCache)[probe + MethodCacheSelector]) == 0)) {
			if (((((((usqInt) (GIV(methodCache)[probe + MethodCacheSelector]))) >= (((usqInt) GIV(newSpaceStart))))
 && ((((usqInt) (GIV(methodCache)[probe + MethodCacheSelector]))) < (((usqInt) GIV(newSpaceLimit)))))
 || (((((usqInt) (GIV(methodCache)[probe + MethodCacheClass]))) >= (((usqInt) GIV(newSpaceStart))))
 && ((((usqInt) (GIV(methodCache)[probe + MethodCacheClass]))) < (((usqInt) GIV(newSpaceLimit))))))
			 || (((((usqInt) (GIV(methodCache)[probe + MethodCacheMethod]))) >= (((usqInt) GIV(newSpaceStart))))
			 && ((((usqInt) (GIV(methodCache)[probe + MethodCacheMethod]))) < (((usqInt) GIV(newSpaceLimit)))))) {
				GIV(methodCache)[probe + MethodCacheSelector] = 0;
			}
		}
		probe += MethodCacheEntrySize;
	}
	/* begin flushAtCache */
	for (i11 = 1; i11 <= AtCacheTotalSize; i11 += 1) {
		GIV(atCache)[i11] = 0;
	}
	GIV(needGCFlag) = 0;
	GIV(gcStartUsecs) = ioUTCMicrosecondsNow();
	/* begin doScavenge: */
	GIV(scavengeInProgress) = 1;
	/* begin scavenge: */
	GIV(tenureCriterion) = tenuringCriterion;
	scavengeLoop();
	processWeaklings();
	/* begin computeTenuringThreshold */
	fractionSurvived = (((GIV(futureSpace).limit)) == ((GIV(futureSpace).start))
		? 0.0
		: (((double) (GIV(futureSurvivorStart) - ((GIV(futureSpace).start))) )) / (((GIV(futureSpace).limit)) - ((GIV(futureSpace).start))));
	GIV(tenureThreshold) = (fractionSurvived > 0.9
		? (round(((((GIV(pastSpace).limit)) - ((GIV(pastSpace).start))) * (1.0 - GIV(tenuringProportion))))) + ((GIV(pastSpace).start))
		: 0);
	/* begin exchangeSurvivorSpaces */
	temp = GIV(pastSpace);
	GIV(pastSpace) = GIV(futureSpace);
	GIV(futureSpace) = temp;
	/* begin initFutureSpaceStart */
	oldStart = GIV(futureSurvivorStart);
	GIV(futureSurvivorStart) = (GIV(futureSpace).start);
	GIV(pastSpaceStart) = ((sqInt) oldStart);
	assert(oopisGreaterThanOrEqualToandLessThanOrEqualTo(GIV(pastSpaceStart), ((pastSpace()).start), ((pastSpace()).limit)));
	GIV(freeStart) = ((eden()).start);
	/* begin initSpaceForAllocationCheck: */
	aNewSpace = (&(eden()));
	if (!(GIV(memory) == null)) {
		for (p = ((aNewSpace->start)); p < ((aNewSpace->limit)); p += (wordSize())) {
			longAtput(p, p);
		}

	}
	GIV(scavengeInProgress) = 0;
	GIV(statScavenges) += 1;
	GIV(statGCEndUsecs) = ioUTCMicrosecondsNow();
	statSGCDeltaUsecs = GIV(statGCEndUsecs) - GIV(gcStartUsecs);
	GIV(statScavengeGCUsecs) += statSGCDeltaUsecs;
	GIV(statRootTableCount) = rememberedSetSize();
	/* begin postGCAction: */
	;
	signalSemaphoreWithIndex(GIV(gcSemaphoreIndex));
	/* begin runLeakCheckerForFullGC: */
	runLeakCheckerForFullGCexcludeUnmarkedNewSpaceObjs(0, 0);
	/* return self */
	/* begin checkFreeSpace */
	assert(bitsSetInFreeSpaceMaskForAllFreeLists());
	assert(GIV(totalFreeOldSpace) == (totalFreeListBytes()));
}

static usqInt
segLimit(SpurSegmentInfo * self_in_segLimit)
{
	return ((self_in_segLimit->segSize)) + ((self_in_segLimit->segStart));
}


/*	Send the calllback message to Alien class with the supplied arg(s). Use
	either the
	1 arg invokeCallbackContext: or the 4 arg
	invokeCallback:stack:registers:jmpbuf: message, depending on what selector
	is installed in the specialObjectsArray.
	Note that if invoking the legacy invokeCallback:stack:registers:jmpbuf: we
	pass the
	vmCallbackContext as the jmpbuf argument (see
	reestablishContextPriorToCallback:). The arguments are raw C addresses and
	are converted to integer objects on the way. */

EXPORT(sqInt)
sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt errorCode;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt object5;
    sqInt object6;
    sqInt object7;
    sqInt object8;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp51;
    char *sp6;
    char *sp61;
    char *sp7;
    char *sp8;
    char *sp9;
    sqInt table;

	classTag = (longAt(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassAlien << 2)))) & 0x3FFFFF;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorInvokeCallback << 2));
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag))) {
		if ((lookupMethodNoMNUEtcInClass(classAtIndex(classTag))) != 0) {
			return 0;
		}
	}
	if (primitiveFunctionPointer != 0) {
		return 0;
	}
	/* begin saveCStackStateForCallbackContext: */
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassAlien << 2)));
	GIV(stackPointer) = sp8;
	
#  if BytesPerWord == 8
	if (((((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 25) & 15) == 4) {
		/* begin push: */
		object = positive64BitIntegerFor(((usqInt)((vmCallbackContext->thunkp))));
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
		/* begin push: */
		object1 = positive64BitIntegerFor(((usqInt)((vmCallbackContext->stackp))));
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object1);
		GIV(stackPointer) = sp1;
		/* begin push: */
		object2 = positive64BitIntegerFor(((usqInt)((vmCallbackContext->intregargsp))));
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object2);
		GIV(stackPointer) = sp2;
	}
	/* begin push: */
	object3 = positive64BitIntegerFor(((usqInt)vmCallbackContext));
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp3;

#  else /* BytesPerWord == 8 */
	if (((((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 25) & 15) == 4) {
		/* begin push: */
		object4 = positive32BitIntegerFor(((usqInt)((vmCallbackContext->thunkp))));
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object4);
		GIV(stackPointer) = sp4;
		/* begin push: */
		object5 = positive32BitIntegerFor(((usqInt)((vmCallbackContext->stackp))));
		longAtput((sp5 = GIV(stackPointer) - BytesPerWord), object5);
		GIV(stackPointer) = sp5;
		/* begin push: */
		object6 = positive32BitIntegerFor(((usqInt)((vmCallbackContext->intregargsp))));
		longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object6);
		GIV(stackPointer) = sp6;
	}
	/* begin push: */
	object7 = positive32BitIntegerFor(((usqInt)vmCallbackContext));
	longAtput((sp7 = GIV(stackPointer) - BytesPerWord), object7);
	GIV(stackPointer) = sp7;

#  endif /* BytesPerWord == 8 */

	/* begin ifAppropriateCompileToNativeCode:selector: */
	/* begin justActivateNewMethod */
	methodHeader = longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2));
	numTemps = (((usqInt) methodHeader) >> 19) & 0x3F;
	numArgs = (((usqInt) methodHeader) >> 25) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((headerOf(GIV(method))) == methodHeader);
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) methodHeader)) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	/* begin push: */
	object8 = ((1 + (numArgs << 8)) + (0)) + (0);
	longAtput((sp41 = GIV(stackPointer) - BytesPerWord), object8);
	GIV(stackPointer) = sp41;
	/* begin push: */
	longAtput((sp51 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp51;
	/* begin push: */
	longAtput((sp61 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp61;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp9 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp9;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize)) - 1;
	if (
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader)) < 0
				? methodHeader & (65536 << SmallIntegerShift)
				: (methodHeader & 536871934) != 0)
#  else /* MULTIPLEBYTECODESETS */
		(methodHeader & 536871934) != 0
#  endif /* MULTIPLEBYTECODESETS */
		) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 
#    if MULTIPLEBYTECODESETS
			((((sqInt) methodHeader)) < 0
						? 3
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? 234
		: 129)
#else /* MULTIPLEBYTECODESETS */
	129
#endif /* MULTIPLEBYTECODESETS */
	)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
					if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
						errorCode = longAt((table + (BaseHeaderSize)) + ((GIV(primFailCode) - 1) << 2));
						goto l1;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l1:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader;
	/* begin maybeFlagMethodAsInterpreted: */
;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handleStackOverflow();
	/* begin enterSmalltalkExecutiveFromCallback */
	interpret();
	return 1;
}


/*	Send the 4 argument callback message
	invokeCallback:stack:registers:jmpbuf: to Alien class with the supplied
	args. The arguments are raw C addresses
	and are converted to integer objects on the way. */

EXPORT(sqInt)
sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classTag;
    sqInt errorCode;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt object1;
    sqInt object2;
    sqInt object3;
    sqInt object4;
    sqInt rcvr;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp41;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;

	classTag = (longAt(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassAlien << 2)))) & 0x3FFFFF;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SelectorInvokeCallback << 2));
	GIV(argumentCount) = 4;
	if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), classTag))) {
		if ((lookupMethodNoMNUEtcInClass(classAtIndex(classTag))) != 0) {
			return 0;
		}
	}
	if (!((((((usqInt) (longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 25) & 15) == 4)
		 && (primitiveFunctionPointer == 0))) {
		return 0;
	}
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassAlien << 2)));
	GIV(stackPointer) = sp;
	/* begin push: */
	object = positive32BitIntegerFor(thunkPtr);
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp1;
	/* begin push: */
	object1 = positive32BitIntegerFor(stackPtr);
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp2;
	/* begin push: */
	object2 = positive32BitIntegerFor(regsPtr);
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), object2);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object3 = positive32BitIntegerFor(jmpBufPtr);
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object3);
	GIV(stackPointer) = sp4;
	/* begin ifAppropriateCompileToNativeCode:selector: */
	/* begin justActivateNewMethod */
	methodHeader = longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2));
	numTemps = (((usqInt) methodHeader) >> 19) & 0x3F;
	numArgs = (((usqInt) methodHeader) >> 25) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((headerOf(GIV(method))) == methodHeader);
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) methodHeader)) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

	/* begin push: */
	object4 = ((1 + (numArgs << 8)) + (0)) + (0);
	longAtput((sp41 = GIV(stackPointer) - BytesPerWord), object4);
	GIV(stackPointer) = sp41;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize)) - 1;
	if (
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader)) < 0
				? methodHeader & (65536 << SmallIntegerShift)
				: (methodHeader & 536871934) != 0)
#  else /* MULTIPLEBYTECODESETS */
		(methodHeader & 536871934) != 0
#  endif /* MULTIPLEBYTECODESETS */
		) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 
#    if MULTIPLEBYTECODESETS
			((((sqInt) methodHeader)) < 0
						? 3
						: 0)
#    else /* MULTIPLEBYTECODESETS */
			0
#    endif /* MULTIPLEBYTECODESETS */
			;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? 234
		: 129)
#else /* MULTIPLEBYTECODESETS */
	129
#endif /* MULTIPLEBYTECODESETS */
	)) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
					if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
						errorCode = longAt((table + (BaseHeaderSize)) + ((GIV(primFailCode) - 1) << 2));
						goto l1;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l1:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader;
	/* begin maybeFlagMethodAsInterpreted: */
;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	handleStackOverflow();
	/* begin enterSmalltalkExecutiveFromCallback */
	interpret();
	return 1;
}

void
setBreakSelector(char *aString)
{
	if (aString == null) {

		/* nil's effective length is zero */

		breakSelectorLength = -1;
		breakSelector = null;
	}
	else {
		breakSelectorLength = strlen(aString);
		breakSelector = aString;
	}
}

void
setFullScreenFlag(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(fullScreenFlag) = value;
}

EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))())

{
    void (*prevFunction)();

	prevFunction = interruptCheckChain;
	interruptCheckChain = aFunction;
	return prevFunction;
}

void
setInterruptKeycode(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(interruptKeycode) = value;
}

void
setInterruptPending(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	forceInterruptCheck();
	GIV(interruptPending) = value;
}

static void
setIsMarkedOfto(sqInt objOop, sqInt aBoolean)
{
	assert(!(isFreeObject(objOop)));
	flag("endianness");
	longAtput(objOop + 4, (aBoolean
		? (longAt(objOop + 4)) | (1 << 23)
		: (longAt(objOop + 4)) & (~(1 << 23))));
}

void
setNextWakeupUsecs(usqLong value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(nextWakeupUsecs) = value;
}

void
setSavedWindowSize(sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(savedWindowSize) = value;
}


/*	The low space semaphore is about to be signaled. Set the signalLowSpace
	flag, and force an interrupt check. Save the currently active process in
	the special
	objects array so that the low space handler will be able to determine the
	process that first triggered a low space condition. The image's low space
	handler is expected
	to nil out the special objects array slot when it handles the low space
	condition.  */

static void
setSignalLowSpaceFlagAndSaveProcess(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt lastSavedProcess;

	
	GIV(signalLowSpace) = 1;
	/* begin lowSpaceThreshold: */
	GIV(lowSpaceThreshold) = 0;
	if (GIV(totalFreeOldSpace) < 0) {
		growOldSpaceByAtLeast(0 - GIV(totalFreeOldSpace));
	}
	assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
	lastSavedProcess = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ProcessSignalingLowSpace << 2));
	if (lastSavedProcess == GIV(nilObj)) {
		activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((activeProc & 3) == 0)
			 && ((((usqInt) activeProc)) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> 29) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(GIV(specialObjectsOop), (longAt(GIV(specialObjectsOop))) | (1 << 29));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ProcessSignalingLowSpace << 2), activeProc);
	}
	forceInterruptCheck();
}

static void
setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    void *pointer;
    StackPage *thePage;
    sqInt value;

	if ((((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
	 && (!(isWidowedContext(aContext)))) {
		/* begin stackPageFor: */
		/* begin frameOfMarriedContext: */
		value = longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		pointer = ((char *) (pointerForOop(value - 1)));
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		assert(((((thePage->trace)) >= StackPageUnreached) && (((thePage->trace)) <= StackPageTraced)));
		if (((thePage->trace)) == StackPageUnreached) {
			(thePage->trace = StackPageReachedButUntraced);
		}
	}
}

sqInt
shiftForWord(void)
{
	return 2;
}

static sqInt
shortPrintContext(sqInt aContext)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt home;
    char *theFP;

	if (!(((aContext & 3) == 0)
		 && (((longAt(aContext)) & 0x3FFFFF) == ClassMethodContextCompactIndex))) {
		printHex(aContext);
		print(" is not a context");
		/* begin cr */
		printf("\n");
		return null;
	}
	printHex(aContext);
	if (((longAt((aContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
		if (checkIsStillMarriedContextcurrentFP(aContext, GIV(framePointer))) {
			print(" I (");

			printHex(((usqInt)theFP));
			print(") ");
		}
		else {
			print(" w ");
		}
	}
	else {
		print(" s ");
	}
	home = findHomeForContext(aContext);
	if (home == null) {
		print(" BOGUS CONTEXT (can't determine home)");
	}
	else {
		printActivationNameForreceiverisBlockfirstTemporary(longAt((aContext + (BaseHeaderSize)) + (MethodIndex << 2)), (home == null
			? GIV(nilObj)
			: longAt((home + (BaseHeaderSize)) + (ReceiverIndex << 2))), home != aContext, longAt((home + (BaseHeaderSize)) + ((0 + CtxtTempFrameStart) << 2)));
	}
	/* begin cr */
	printf("\n");
}

static sqInt
shortPrintFrameAndCallers(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		return null;
	}
	shortPrintFrame(theFP);
	if (!((longAt(theFP + FoxSavedFP)) == 0)) {
		shortPrintFrameAndCallers(frameCallerFP(theFP));
	}
}


/*	use export: not api, so it won't be written to cointerp.h. cogit.c is
	unaware of StackPage
 */

EXPORT(void)
shortPrintFramesInPage(StackPage *thePage)
{
	printFrameAndCallersSPshort((thePage->headFP), (thePage->headSP), 1);
}

EXPORT(void)
shortPrintFramesOnStackPageListInUse(void)
{
    StackPage *page;

	page = mostRecentlyUsedPage();
	do {
		if (!(isFree(page))) {
			print("page ");
			/* begin printHexPtrnp: */
			/* begin printHexnp: */
			printf("0x%x", oopForPointer(page));
			/* begin cr */
			printf("\n");
			shortPrintFramesInPage(page);
			/* begin cr */
			printf("\n");
		}
	} while(((page = (page->prevPage))) != (mostRecentlyUsedPage()));
}

static sqInt
shortPrintFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt frameNumArgs;
    sqInt rcvr;

	if (!((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
		 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		print("invalid frame pointer");
		/* begin cr */
		printf("\n");
		return null;
	}
	rcvr = longAt(theFP + FoxReceiver);
	/* begin printHexPtr: */
	printHex(oopForPointer(theFP));
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	printActivationNameForreceiverisBlockfirstTemporary(longAt(theFP + FoxMethod), rcvr, (byteAt((theFP + FoxFrameFlags) + 3)) != 0, (0 < ((frameNumArgs = byteAt((theFP + FoxFrameFlags) + 1)))
		? longAt((theFP + FoxCallerSavedIP) + ((frameNumArgs - 0) * BytesPerWord))
		: longAt(((theFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 0) * BytesPerWord))));
	/* begin space */
	/* begin printChar: */
	putchar(' ');
	shortPrintOop(rcvr);
}

void
shortPrintFrameAndNCallers(char *theFP, sqInt n)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((n != 0)
	 && ((((((usqInt)theFP)) & (BytesPerWord - 1)) == 0)
	 && ((((((usqInt)theFP)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)theFP)) <= (((usqInt)GIV(pages)))))))) {
		shortPrintFrame(theFP);
		shortPrintFrameAndNCallers(frameCallerFP(theFP), n - 1);
	}
}

void
shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress)
{
    sqInt oop;

	oop = objectBefore(startAddress);
	oop = (oop == null
		? startAddress
		: ((objectAfter(oop)) == startAddress
				? startAddress
				: oop));
	while ((((usqInt) oop)) < (((usqInt) endAddress))) {
		if (!(((longAt(oop)) & 0x3FFFFF) == 0)) {
			shortPrintOop(oop);
		}
		oop = objectAfter(oop);
	}
}

static void
shortPrintOop(sqInt oop)
{
	/* begin printHexnp: */
	printf("0x%x", oop);
	if ((oop & 3) != 0) {
		if ((oop & 3) == 2) {
			printf("=$%ld ($%lc)\n", (long)characterValueOf(oop), (wint_t)characterValueOf(oop));
		}
		if ((oop & 1)) {
			printf("=%ld\n", (long)integerValueOf(oop));
		}
		return;
	}
	if (!(addressCouldBeObj(oop))) {
		print(((oop & (8 - 1)) != 0
			? " is misaligned"
			: " is not on the heap"));
		/* begin cr */
		printf("\n");

		return;
	}
	if ((((longAt(oop)) & 0x3FFFFF) == 0)
	 || (((longAt(oop)) & 0x3FFFFF) == 8)) {
		printOop(oop);
		return;
	}
	print(": a(n) ");
	printNameOfClasscount(fetchClassOfNonImm(oop), 5);
	/* begin cr */
	printf("\n");
}

static sqInt
shortReversePrintFrameAndCallers(char *aFramePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    char *theFP;

	if (aFramePointer == 0) {
		return GIV(nilObj);
	}
	theFP = aFramePointer;
	while (1) {
		shortPrintFrame(theFP);
		/* begin frameCallerFP: */
		callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
		if (!(callerFP != 0)) break;
		theFP = callerFP;
	}
	return longAt(theFP + FoxCallerContext);
}


/*	Answer if an object should be tenured. The default policy tenuring policy
	is to use the tenuringThreshold to decide. If the survivors (measured in
	bytes) are above some fraction of the survivor space then objects below
	the threshold (older objects, since allocation grows upwards and hence
	new objects are later than old) are scavenged. Otherwise, the threshold
	is set to 0 and no objects are tenured. e.g. see
	An adaptive tenuring policy for generation scavengers,
	David Ungar & Frank Jackson.
	ACM TOPLAS, Volume 14 Issue 1, Jan. 1992, pp 1 - 27.
	
	The other policies are for special purposes. */
/*	Slang limitations given this used in (... or: []) ifTrue: */

static sqInt
shouldBeTenured(sqInt survivor)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	
	switch (GIV(tenureCriterion)) {
	case TenureByAge:
		return survivor < GIV(tenureThreshold);

	case TenureByClass:
		return ((longAt(survivor)) & 0x3FFFFF) == GIV(tenuringClassIndex);

	case DontTenureButDoUnmark:
		setIsMarkedOfto(survivor, 0);
		return 0;

	default:
		return 0;

	}
}


/*	Answer if the obj should be scavenged (or simply followed). The method is
	called shouldRemapObj: for compatibility with ObjectMemory. */

sqInt
shouldRemapObj(sqInt objOop)
{
	return (((longAt(objOop)) & 0x3FFFFF) == 8)
	 || (isYoungObject(objOop));
}


/*	Answer if the oop should be scavenged.. The method is called
	shouldRemapOop: for compatibility with ObjectMemory. */

sqInt
shouldRemapOop(sqInt oop)
{
	return ((oop & 3) == 0)
	 && ((((longAt(oop)) & 0x3FFFFF) == 8)
	 || (isYoungObject(oop)));
}


/*	Repaint the portion of the Smalltalk screen bounded by the affected
	rectangle. Used to synchronize the screen after a Bitblt to the Smalltalk
	Display object.
 */

sqInt
showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b)
{
	if (deferDisplayUpdates) {
		return null;
	}
	displayBitsOfLeftTopRightBottom(aForm, l, t, r, b);
}


/*	Signal all requested semaphores. Answer if a context switch has occurred. */

static sqInt
signalExternalSemaphores(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt xArray;

	xArray = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ExternalObjectsArray << 2));
	return doSignalExternalSemaphores(stSizeOf(xArray));
}


/*	Signal the given semaphore from within the interpreter. Used to serialize
	callbacks. 
 */

sqInt
signalNoResume(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt empty;

	empty = (longAt((aSemaphore + (BaseHeaderSize)) + (FirstLinkIndex << 2))) == GIV(nilObj);
	if (!empty) {
		putToSleepyieldingIf(removeFirstLinkOfList(aSemaphore), 1);
	}
	return empty;
}


/*	Return a full 32 bit integer object for the given integer value */

sqInt
signed32BitIntegerFor(sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt value;

	if ((integerValue ^ (integerValue << 1)) >= 0) {
		return ((integerValue << 1) | 1);
	}
	if (integerValue < 0) {
		largeClass = ClassLargeNegativeIntegerCompactIndex;
		value = 0 - integerValue;
	}
	else {
		largeClass = ClassLargePositiveIntegerCompactIndex;
		value = integerValue;
	}
	allocateBytesclassIndex(4, largeClass);

	byteAtput((newLargeInteger + (BaseHeaderSize)) + 3, (((usqInt) value) >> 24) & 0xFF);
	byteAtput((newLargeInteger + (BaseHeaderSize)) + 2, (((usqInt) value) >> 16) & 0xFF);
	byteAtput((newLargeInteger + (BaseHeaderSize)) + 1, (((usqInt) value) >> 8) & 0xFF);
	byteAtput((newLargeInteger + (BaseHeaderSize)) + 0, value & 0xFF);
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargeInteger. 
 */

int
signed32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt negative;
    sqInt ok;
    int value;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex1));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & 0x3FFFFF;
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

		ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargeNegativeInteger << 2))) == (classAtIndex(ccIndex));
	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	if ((lengthOfformat(oop, (((usqInt) (longAt(oop))) >> 24) & 0x1F)) > 4) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	value = (((byteAt((oop + (BaseHeaderSize)) + 0)) + ((byteAt((oop + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((oop + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((oop + (BaseHeaderSize)) + 3)) << 24);
	null;
	if (value < 0) {
		assert((sizeof(value)) == 4);
		if (negative
		 && (0 == (value << 1))) {
			return value;
		}
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return (negative
		? 0 - value
		: value);
}


/*	Return a Large Integer object for the given integer value */

sqInt
signed64BitIntegerFor(sqLong integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt highWord;
    sqInt i;
    sqInt intValue;
    sqInt largeClass;
    sqLong magnitude;
    sqInt newLargeInteger;
    sqInt sz;

	if (integerValue < 0) {
		/* begin knownClassAtIndex: */
		assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize()))));
		largeClass = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (ClassLargeNegativeIntegerCompactIndex << 2));
		magnitude = 0 - integerValue;
	}
	else {
		/* begin knownClassAtIndex: */
		assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize()))));
		largeClass = longAt((GIV(classTableFirstPage) + (BaseHeaderSize)) + (ClassLargePositiveIntegerCompactIndex << 2));
		magnitude = integerValue;
	}
	if ((magnitude <= 0x7FFFFFFFUL)
	 && ((integerValue >= 0)
	 || (0 != (integerValue << 1)))) {
		return signed32BitIntegerFor(integerValue);
	}
	highWord = ((unsigned sqLong)magnitude) >> 32;
	if (highWord == 0) {
		sz = 4;
	}
	else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
		}
	}
	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	for (i = 0; i < sz; i += 1) {
		intValue = (((unsigned sqLong)magnitude) >> (i * 8)) & 0xFF;
		byteAtput((newLargeInteger + (BaseHeaderSize)) + i, intValue);
	}
	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a eight-byte
	LargeInteger. 
 */

sqLong
signed64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt i;
    sqInt negative;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt ok;
    sqInt sz;
    sqLong value;

	if ((oop & 1)) {
		return ((sqLong) ((oop >> 1)));
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex1));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & 0x3FFFFF;
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

		ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargeNegativeInteger << 2))) == (classAtIndex(ccIndex));
	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(oop - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 9) {
		sz = numSlots;
		goto l3;
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		sz = (numSlots << 2) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 7);
		goto l3;
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 12) {
		sz = (numSlots << (2 - 1)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 3);
		goto l3;
	}
	sz = (numSlots << (2 - 2)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 1);
l3:	/* end lengthOf:format: */;
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	value = 0;
	for (i = 0; i < sz; i += 1) {
		value += (((sqLong) (byteAt((oop + (BaseHeaderSize)) + i)))) << (i * 8);
	}
	null;
	if (value < 0) {
		assert((sizeof(value)) == 8);
		assert((sizeof(value << 1)) == 8);
		if (negative
		 && (0 == (value << 1))) {
			return value;
		}
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return (negative
		? 0 - value
		: value);
}


/*	Answer a signed value of an integer up to the size of a machine word.
	The object may be either a positive SmallInteger or a LargeInteger of size
	<= word size.
 */

long
signedMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt negative;
    sqInt ok;
    long value;

	if ((oop & 1)) {
		return (oop >> 1);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex1));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & 0x3FFFFF;
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

		ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargeNegativeInteger << 2))) == (classAtIndex(ccIndex));
	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	if (((bs = lengthOfformat(oop, (((usqInt) (longAt(oop))) >> 24) & 0x1F))) > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		value = (((((((byteAt((oop + (BaseHeaderSize)) + 0)) + ((byteAt((oop + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((oop + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((oop + (BaseHeaderSize)) + 3)) << 24)) + ((byteAt((oop + (BaseHeaderSize)) + 4)) << 32)) + ((byteAt((oop + (BaseHeaderSize)) + 5)) << 40)) + ((byteAt((oop + (BaseHeaderSize)) + 6)) << 48)) + ((byteAt((oop + (BaseHeaderSize)) + 7)) << 56);
	}
	else {
		value = (((byteAt((oop + (BaseHeaderSize)) + 0)) + ((byteAt((oop + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((oop + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((oop + (BaseHeaderSize)) + 3)) << 24);
	}
	null;
	if (value < 0) {

		/* Don't fail for -16r80000000[00000000].
		   Alas the simple (negative and: [value - 1 > 0]) isn't adequate since in C the result of signed integer
		   overflow is undefined and hence under optimization this may fail.  The shift, however, is well-defined. */

		if (negative
		 && (0 == (value << 1))) {
			return value;
		}
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return (negative
		? 0 - value
		: value);
}

static sqInt
sixtyFourBitIndexableFormat(void)
{
	return 9;
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

usqInt
sizeOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt size;

	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassAlien << 2))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	size = longAt(oop + BaseHeaderSize);
	return abs(size);
}


/*	Answer if the method starts with a long store temp bytecode, which
	indicates it has a primitive error code.
 */
/*	249		11111001	i i i i i i i i	jjjjjjjj		Call Primitive #iiiiiiii +
	(jjjjjjjj * 256)
 */

sqInt
sizeOfCallPrimitiveBytecode(sqInt methodHeader)
{
	return 
#  if MULTIPLEBYTECODESETS
		((((sqInt) methodHeader)) < 0
				? 3
				: 0)
#  else /* MULTIPLEBYTECODESETS */
		0
#  endif /* MULTIPLEBYTECODESETS */
		;
}


/*	For compatibility with ObjectMemory, answer the size of a free chunk in
	bytes. Do *not* use internally. */

static usqLong
sizeOfFree(sqInt objOop)
{
	assert(isFreeObject(objOop));
	return bytesInObject(objOop);
}


/*	234		11101010	i i i i i i i i	Store Temporary Variable #iiiiiiii */
/*	129 10000001 jjkkkkkk Store (Receiver Variable, Temporary Location,
	Illegal, Literal Variable) [jj] #kkkkkk */

sqInt
sizeOfLongStoreTempBytecode(sqInt methodHeader)
{
	return 2;
}


/*	Return the number of indexable fields of the given object. This method is
	to be called from an automatically generated C primitive. The argument is
	assumed to be a pointer to the first indexable field of a words or bytes
	object; the object header starts 4 bytes before that.
 */
/*	Note: Only called by translated primitive code. */

sqInt
sizeOfSTArrayFromCPrimitive(void *cPtr)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt numSlots;
    usqInt numSlots1;
    sqInt oop;

	oop = (oopForPointer(cPtr)) - BaseHeaderSize;
	if (!(((oop & 3) == 0)
		 && (((((usqInt) (longAt(oop))) >> 24) & 0x1F) > 5))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(oop - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 9) {
		return numSlots;
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		return (numSlots << 2) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 7);
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 12) {
		return (numSlots << (2 - 1)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 3);
	}
	return (numSlots << (2 - 2)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 1);
}


/*	*DO NOT CONFUSE THIS WITH numSlotsOf:.
	This is an ObjectMemory compatibility method with quesitonable semantics.
	Answers the number of slots in the receiver.
	If the receiver is a byte object, return the number of bytes.
	Otherwise return the number of words. */

sqInt
slotSizeOf(sqInt oop)
{
    usqInt numSlots;
    usqInt numSlots1;

	if ((oop & 3) != 0) {
		return 0;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(oop - (BaseHeaderSize)))
		: numSlots1);
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) <= 9) {
		return numSlots;
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 16) {

		/* bytes, including CompiledMethod */

		return (numSlots << 2) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 7);
	}
	if (((((usqInt) (longAt(oop))) >> 24) & 0x1F) >= 12) {
		return (numSlots << (2 - 1)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 3);
	}
	return (numSlots << (2 - 2)) - (((((usqInt) (longAt(oop))) >> 24) & 0x1F) & 1);
}


/*	update state of active context */

static sqInt
snapshot(sqInt embedded)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt activeProc;
    sqInt errorCode;
    sqInt i;
    sqInt methodHeader;
    sqInt numArgs;
    sqInt numTemps;
    sqInt object;
    sqInt oop;
    sqInt rcvr;
    sqInt rcvr1;
    sqInt savedTenuringThreshold;
    void *setMacType;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    char *sp8;
    sqInt stackIndex;
    sqInt table;


	/* For now the stack munging below doesn't deal with more than one argument.
	   It can, and should. */

	if (GIV(argumentCount) != 0) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	/* begin push: */
	longAtput((sp8 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp8;

	/* update state of active process */

	activeContext = voidVMStateForSnapshotFlushingExternalPrimitivesIf(1);
	activeProc = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(activeProc)));
	if (isOldObject(activeProc)) {

		/* most stores into young objects */

		if (((activeContext & 3) == 0)
		 && ((((usqInt) activeContext)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(activeProc))) >> 29) & 1) != 0)) {
				remember(activeProc);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(activeProc, (longAt(activeProc)) | (1 << 29));
			}
		}
	}
	longAtput((activeProc + (BaseHeaderSize)) + (SuspendedContextIndex << 2), activeContext);
	GIV(tempOop) = activeContext;
	/* begin garbageCollectForSnapshot */
	/* begin flushNewSpace */
	savedTenuringThreshold = GIV(tenureThreshold);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = GIV(newSpaceLimit);
	scavengingGCTenuringIf(TenureByAge);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize()) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace()).start)));
	assert(GIV(freeStart) == (((eden()).start)));
	fullGC();
	activeContext = GIV(tempOop);
	GIV(tempOop) = 0;
	if (!GIV(primFailCode)) {

		/* Without contexts or stacks simulate
		   rcvr := self popStack. ''pop rcvr''
		   self push: trueObj.
		   to arrange that the snapshot resumes with true.  N.B. stackIndex is one-relative. */

		/* begin quickFetchInteger:ofObject: */
		oop = longAt((activeContext + (BaseHeaderSize)) + (StackPointerIndex << 2));
		assert((oop & 1));
		stackIndex = (oop >> 1);
		rcvr = longAt((activeContext + (BaseHeaderSize)) + (((stackIndex + CtxtTempFrameStart) - 1) << 2));
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(activeContext)));
		longAtput((activeContext + (BaseHeaderSize)) + (((stackIndex + CtxtTempFrameStart) - 1) << 2), GIV(trueObj));
		writeImageFileIO();
		if ((!GIV(primFailCode))
		 && (!embedded)) {

			/* set Mac file type and creator; this is a noop on other platforms */

			setMacType = ioLoadFunctionFrom("setMacFileTypeAndCreator", "FilePlugin");
			if (!(setMacType == 0)) {
				((sqInt (*)(char *, char *, char *))setMacType)(imageName, "STim", "FAST");
			}
		}
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(activeContext)));
		longAtput((activeContext + (BaseHeaderSize)) + (StackPointerIndex << 2), (((stackIndex - 1) << 1) | 1));
	}
	marryContextInNewStackPageAndInitializeInterpreterRegisters(activeContext);
	if (!GIV(primFailCode)) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(falseObj));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), rcvr);
		GIV(stackPointer) = sp1;
		/* begin justActivateNewMethod */
		methodHeader = longAt((GIV(newMethod) + (BaseHeaderSize)) + (HeaderIndex << 2));
		numTemps = (((usqInt) methodHeader) >> 19) & 0x3F;
		numArgs = (((usqInt) methodHeader) >> 25) & 15;

		/* could new rcvr be set at point of send? */

		rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
		/* begin push: */
		longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
		GIV(stackPointer) = sp11;
		/* begin push: */
		longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
		GIV(stackPointer) = sp2;
		GIV(framePointer) = GIV(stackPointer);
		/* begin push: */
		longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
		GIV(stackPointer) = sp3;
		/* begin setMethod:methodHeader: */
		GIV(method) = GIV(newMethod);
		assert(isOopCompiledMethod(GIV(method)));
		assert((headerOf(GIV(method))) == methodHeader);
		
#    if MULTIPLEBYTECODESETS
		bytecodeSetSelector = ((((sqInt) methodHeader)) < 0
			? 256
			: 0);

#    endif /* MULTIPLEBYTECODESETS */

		/* begin push: */
		object = ((1 + (numArgs << 8)) + (0)) + (0);
		longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp4;
		/* begin push: */
		longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp5;
		/* begin push: */
		longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
		GIV(stackPointer) = sp6;
		for (i = (numArgs + 1); i <= numTemps; i += 1) {
			/* begin push: */
			longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
			GIV(stackPointer) = sp7;
		}
		GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? (((usqInt) methodHeader) >> 1) & 0xFFFF
		: (((usqInt) methodHeader) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) methodHeader) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	)) * BytesPerOop)) + (BaseHeaderSize)) - 1;
		if (
#    if MULTIPLEBYTECODESETS
			((((sqInt) methodHeader)) < 0
						? methodHeader & (65536 << SmallIntegerShift)
						: (methodHeader & 536871934) != 0)
#    else /* MULTIPLEBYTECODESETS */
			(methodHeader & 536871934) != 0
#    endif /* MULTIPLEBYTECODESETS */
			) {

			/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
			   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

			GIV(instructionPointer) += 
#      if MULTIPLEBYTECODESETS
				((((sqInt) methodHeader)) < 0
								? 3
								: 0)
#      else /* MULTIPLEBYTECODESETS */
				0
#      endif /* MULTIPLEBYTECODESETS */
				;
			if (GIV(primFailCode) != 0) {
				if ((byteAt(GIV(instructionPointer) + 1)) == (
#if MULTIPLEBYTECODESETS
	((((sqInt) methodHeader)) < 0
		? 234
		: 129)
#else /* MULTIPLEBYTECODESETS */
	129
#endif /* MULTIPLEBYTECODESETS */
	)) {
					/* begin getErrorObjectFromPrimFailCode */
					if (GIV(primFailCode) > 0) {
						table = longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (PrimErrTableIndex << 2));
						if (GIV(primFailCode) <= (((sqInt) (lastPointerOf(table)) >> 2))) {
							errorCode = longAt((table + (BaseHeaderSize)) + ((GIV(primFailCode) - 1) << 2));
							goto l1;
						}
					}
					errorCode = ((GIV(primFailCode) << 1) | 1);
				l1:	/* end getErrorObjectFromPrimFailCode */;
					longAtPointerput(GIV(stackPointer), errorCode);
				}
				GIV(primFailCode) = 0;
			}
		}
		methodHeader;
	}
}

static void
space(void)
{
	/* begin printChar: */
	putchar(' ');
}

sqInt
specialSelector(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SpecialSelectors << 2))) + (BaseHeaderSize)) + ((index * 2) << 2));
}


/*	Return one of the objects in the specialObjectsArray */

sqInt
splObj(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (index << 2));
}


/*	In the StackInterpreter stacks grow down. */

double
stackFloatValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt isFloat;
    double result;

	/* begin floatValueOf: */
	/* begin is:instanceOf:compactClassIndex: */
	if (((longAt(GIV(stackPointer) + (offset * BytesPerWord))) & 3) != 0) {
		isFloat = 0;
		goto l1;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(longAt(GIV(stackPointer) + (offset * BytesPerWord)))));
	ccIndex = (longAt(longAt(GIV(stackPointer) + (offset * BytesPerWord)))) & 0x3FFFFF;
	isFloat = ClassFloatCompactIndex == ccIndex;
	goto l1;

	isFloat = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassFloat << 2))) == (classAtIndex(ccIndex));
l1:	/* end is:instanceOf:compactClassIndex: */;
	if (isFloat) {
		;
		fetchFloatAtinto((longAt(GIV(stackPointer) + (offset * BytesPerWord))) + (BaseHeaderSize), result);
		return result;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0.0;
}


/*	In the StackInterpreter stacks grow down. */

sqInt
stackIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		return (integerPointer >> 1);
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
}


/*	Answer the actual stackLimit offset in a page. Since stackPageByteSize may
	have chosen to shrink a page
	this may be less than stackPageFrameBytes, but it should be no more than
	stackPageFrameBytes. 
 */

static sqInt
stackLimitBytes(void)
{
	return ((512 < (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord)) - 0)) ? 512 : (((stackPageByteSize()) - ((FrameSlots + 64) * BytesPerWord)) - 0));
}


/*	Answer the amount of slots needed to fit a new frame at the point the
	stack limit is checked. A frame looks like this at the point the stack
	limit is checked:
	stacked receiver/closure
	arg0
	...
	argN
	caller's method ip/base frame's sender context
	fp->	saved fp
	method
	method header fields
	context (uninitialized)
	receiver
	first temp
	...
	sp->	Nth temp
	So the amount of headroom is
	the maximum number of arguments + 1 (for stacked receiver and arguments)
	+ the frame size
	+ the max number of temps.
	Since a method's number of temps includes its arguments the actual offset
	is:  */

static sqInt
stackLimitOffset(void)
{
	return (FrameSlots + 64) * BytesPerWord;
}


/*	Ensures that the given object is a real object, not a SmallInteger. */
/*	In the StackInterpreter stacks grow down. */

sqInt
stackObjectValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;

	oop = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	if ((oop & 3) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return oop;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

static StackPage *
stackPageAt(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(index, GIV(pages));
}


/*	Answer a page size that is a power-of-two and contains a useful number of
	frames. Room for 512 bytes of frames gives around 40 frames a page which
	is a
	good compromise between overflow rate and latency in divorcing a page. */

static sqInt
stackPageByteSize(void)
{
    sqInt largeSize;
    sqInt pageBytes;
    sqInt smallSize;

	pageBytes = (512 + ((FrameSlots + 64) * BytesPerWord)) + 0;
	if ((pageBytes & (pageBytes - 1)) == 0) {

		/* = 0 => a power of two */

		return pageBytes;
	}
	largeSize = 1 << (highBit(pageBytes));
	smallSize = 1 << ((highBit(pageBytes)) - 1);
	assert((largeSize > pageBytes)
	 && (pageBytes > smallSize));
	return ((pageBytes - smallSize) <= (((sqInt) smallSize >> 3))
		? smallSize
		: largeSize);
}


/*	<Integer> */

static StackPage *
stackPageFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
	return stackPageAtpages(index, GIV(pages));
}


/*	Return a minimum amount of headroom for each stack page (in bytes).
	In a JIT the stack has to have room for interrupt handlers which will run
	on the
	stack. In the interpreter we don't actually need any headroom. */

static sqInt
stackPageHeadroom(void)
{
	return 0;
}


/*	Return the 0-based index rel to the given frame.
	(This is what stackPointer used to be before conversion to pointer) */
/*	In the StackInterpreter stacks grow down. */

static sqInt
stackPointerIndexForFrame(char *theFP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    StackPage *thePage;
    char *theSP;

	/* begin stackPageFor: */
	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	theSP = findSPOfon(theFP, thePage);
	return (((usqInt) ((theFP + FoxReceiver) - theSP)) >> ShiftForWord) + (byteAt((theFP + FoxFrameFlags) + 1));
}


/*	In the StackInterpreter stacks grow down. */

unsigned long
stackPositiveMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt integerPointer;
    sqInt ok;
    sqInt value;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin positiveMachineIntegerValueOf: */
	if ((integerPointer & 1)) {
		value = (integerPointer >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(integerPointer)));
	ccIndex = (longAt(integerPointer)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex));
l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!(ok
		 && (((bs = lengthOfformat(integerPointer, (((usqInt) (longAt(integerPointer))) >> 24) & 0x1F))) <= (sizeof(unsigned long))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		return (((((((byteAt((integerPointer + (BaseHeaderSize)) + 0)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 3)) << 24)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 4)) << 32)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 5)) << 40)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 6)) << 48)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 7)) << 56);
	}
	return (((byteAt((integerPointer + (BaseHeaderSize)) + 0)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 3)) << 24);
}


/*	In the StackInterpreter stacks grow down. */

long
stackSignedMachineIntegerValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt integerPointer;
    sqInt negative;
    sqInt ok;
    long value;

	integerPointer = longAt(GIV(stackPointer) + (offset * BytesPerWord));
	/* begin signedMachineIntegerValueOf: */
	if ((integerPointer & 1)) {
		return (integerPointer >> 1);
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(integerPointer)));
	ccIndex1 = (longAt(integerPointer)) & 0x3FFFFF;
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

	ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargePositiveInteger << 2))) == (classAtIndex(ccIndex1));
l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (ok) {
		negative = 0;
	}
	else {
		negative = 1;
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(integerPointer)));
		ccIndex = (longAt(integerPointer)) & 0x3FFFFF;
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

		ok = (longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassLargeNegativeInteger << 2))) == (classAtIndex(ccIndex));
	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	if (((bs = lengthOfformat(integerPointer, (((usqInt) (longAt(integerPointer))) >> 24) & 0x1F))) > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		value = (((((((byteAt((integerPointer + (BaseHeaderSize)) + 0)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 3)) << 24)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 4)) << 32)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 5)) << 40)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 6)) << 48)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 7)) << 56);
	}
	else {
		value = (((byteAt((integerPointer + (BaseHeaderSize)) + 0)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 1)) << 8)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 2)) << 16)) + ((byteAt((integerPointer + (BaseHeaderSize)) + 3)) << 24);
	}
	null;
	if (value < 0) {

		/* Don't fail for -16r80000000[00000000].
		   Alas the simple (negative and: [value - 1 > 0]) isn't adequate since in C the result of signed integer
		   overflow is undefined and hence under optimization this may fail.  The shift, however, is well-defined. */

		if (negative
		 && (0 == (value << 1))) {
			return value;
		}
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	return (negative
		? 0 - value
		: value);
}

sqInt
stackTop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer));
}


/*	In the StackInterpreter stacks grow down. */

sqInt
stackValue(sqInt offset)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return longAt(GIV(stackPointer) + (offset * BytesPerWord));
}


/*	Answer the start of the Alien's data or fail if oop is not an Alien. */

void *
startOfAlienData(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!(isKindOfClass(oop, longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassAlien << 2))))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return 0;
	}
	return ((void *) (((longAt(oop + BaseHeaderSize)) > 0
	? (oop + BaseHeaderSize) + BytesPerOop
	: longAt((oop + BaseHeaderSize) + BytesPerOop))));
}


/*	Answer the start of objOop, which is either the address of the overflow
	size word, or objOop itself, depending on the size of the object. This may
	be applied to any kind of object, normal, forwarders or free chunks. */

static sqInt
startOfObject(sqInt objOop)
{
	return ((rawNumSlotsOf(objOop)) == 0xFF
		? objOop - (BaseHeaderSize)
		: objOop);
}


/*	Zero-relative version of CompiledMethod>>startpc. */

sqInt
startPCOfMethod(sqInt aCompiledMethod)
{
	return ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((aCompiledMethod + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((aCompiledMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((aCompiledMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((aCompiledMethod + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop;
}


/*	Return what ST would return for <obj> at: index. */

sqInt
stObjectat(sqInt array, sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt reasonCode;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt totalLength;

	hdr = longLongAt(array);
	fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(array)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(array + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(array - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l2;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l2;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l2:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(array)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = array;
		goto l3;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l3;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l3:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l4:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3)
	 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((array + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array)));
			stSize = sp;
			goto l1;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + (BaseHeaderSize)) + (StackPointerIndex << 2));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l1;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(array)));
		stSize = (sp1 >> 1);
	l1:	/* end stackPointerForMaybeMarriedContext: */;
		if (((((usqInt) index)) >= (((usqInt) 1)))
		 && (((((usqInt) index)) <= (((usqInt) stSize)))
		 && ((((longAt((array + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(array)))))) {
			return noInlineTemporaryin(index - 1, frameOfMarriedContext(array));
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= 24
	? (((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((array + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((array + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((array + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((array + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1
	: 1)))
	 && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			return longAt((array + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2));
		}
		if (fmt >= 16) {
			return (((byteAt((array + (BaseHeaderSize)) + ((index + fixedFields) - 1))) << 1) | 1);
		}
		return positive32BitIntegerFor(long32At((array + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2)));
	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	return 0;
}


/*	Do what ST would return for <obj> at: index put: value. */

sqInt
stObjectatput(sqInt array, sqInt index, sqInt value)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt reasonCode;
    sqInt sp;
    sqInt sp1;
    sqInt stSize;
    sqInt totalLength;
    sqInt valueToStore;

	hdr = longLongAt(array);
	fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(array)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(array + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(array - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l2;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l2;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l2;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l2:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l4;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l4;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(array)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = array;
		goto l3;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l3;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l3:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l4:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == 3)
	 && ((hdr & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((array + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(array)))) {
			sp = stackPointerIndexForFrame(frameOfMarriedContext(array));
			assert((ReceiverIndex + ((sp >> 1))) < (lengthOf(array)));
			stSize = sp;
			goto l1;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((array + (BaseHeaderSize)) + (StackPointerIndex << 2));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l1;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(array)));
		stSize = (sp1 >> 1);
	l1:	/* end stackPointerForMaybeMarriedContext: */;
		if (((((usqInt) index)) >= (((usqInt) 1)))
		 && (((((usqInt) index)) <= (((usqInt) stSize)))
		 && ((((longAt((array + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
		 && (!(isWidowedContext(array)))))) {
			return noInlineTemporaryinput(index - 1, frameOfMarriedContext(array), value);
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= 24
	? (((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((array + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? (((usqInt) (longAt((array + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF
		: (((usqInt) (longAt((array + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF)
#else /* MULTIPLEBYTECODESETS */
	(((usqInt) (longAt((array + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 10) & 0xFF
#endif /* MULTIPLEBYTECODESETS */
	) + LiteralStart) * BytesPerOop) + 1
	: 1)))
	 && ((((usqInt) index)) <= (((usqInt) stSize)))) {
		/* begin subscript:with:storing:format: */
		if (fmt <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(array)));
			if (isOldObject(array)) {

				/* most stores into young objects */

				if (((value & 3) == 0)
				 && ((((usqInt) value)) < (((usqInt) GIV(newSpaceLimit))))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(array))) >> 29) & 1) != 0)) {
						remember(array);
						/* begin setIsRememberedOf:to: */
						flag("endianness");
						longAtput(array, (longAt(array)) | (1 << 29));
					}
				}
			}
			longAtput((array + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2), value);
		}
		else {
			if (fmt >= 16) {
				if (!((value & 1))) {
					GIV(primFailCode) = PrimErrBadIndex;
				}
				valueToStore = (value >> 1);
				if (!((valueToStore >= 0)
					 && (valueToStore <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
				}
				if (!GIV(primFailCode)) {
					byteAtput((array + (BaseHeaderSize)) + ((index + fixedFields) - 1), valueToStore);
				}
			}
			else {

				/* long-word type objects */

				valueToStore = positive32BitValueOf(value);
				if (!GIV(primFailCode)) {
					long32Atput((array + (BaseHeaderSize)) + (((index + fixedFields) - 1) << 2), valueToStore);
				}
			}
		}
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode = (fmt <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode;
	}
	return value;
}


/*	A renaming for the Cogit, which couldn't make sense of GIV(newSpaceLimit) */

usqInt
storeCheckBoundary(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newSpaceLimit);
}


/*	Note: May be called by translated primitive code. */

sqInt
storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if ((integerValue ^ (integerValue << 1)) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(objectPointer)));
		longAtput((objectPointer + (BaseHeaderSize)) + (fieldIndex << 2), ((integerValue << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	return null;
}

sqInt
storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{
	assert(!(isForwarded(objOop)));
	return longAtput((objOop + (BaseHeaderSize)) + (fieldIndex << 2), valuePointer);
}


/*	Note must check here for stores of young objects into old ones. */

sqInt
storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(!(isForwarded(objOop)));
	if (isOldObject(objOop)) {

		/* most stores into young objects */

		if (((valuePointer & 3) == 0)
		 && ((((usqInt) valuePointer)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objOop))) >> 29) & 1) != 0)) {
				remember(objOop);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(objOop, (longAt(objOop)) | (1 << 29));
			}
		}
	}
	return longAtput((objOop + (BaseHeaderSize)) + (fieldIndex << 2), valuePointer);
}


/*	Set the sender of a frame. If the frame is a base frame then this is
	trivial; merely store into the FoxCallerSavedIP/FoxCallerContext field. If
	not, then
	split the stack at the frame, moving the frame and those hotter than it to
	a new stack page. In the new stack page the frame will be the base frame
	and storing trivial. Answer the possibly changed location of theFP. */

static char *
storeSenderOfFramewithValue(char *theFP, sqInt anOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *callerFP;
    sqInt index;
    StackPage *lruOrFree;
    StackPage *newPage;
    sqInt onCurrentPage;
    char *theMovedFP;
    StackPage *thePage;
    char *theSP;

	if ((longAt(theFP + FoxSavedFP)) == 0) {
		longAtput(theFP + FoxCallerContext, anOop);
		return theFP;
	}
	/* begin ensureCallerContext: */
	/* begin frameCallerFP: */
	callerFP = pointerForOop(longAt(theFP + FoxSavedFP));
	if (callerFP == 0) {

		/* base frame, context in saved ip slot (or base of stack in Cog) */

		longAt(theFP + FoxCallerContext);
		goto l2;
	}
	/* begin ensureFrameIsMarried:SP: */
	/* begin frameCallerStackPointer: */
	assert(!(isBaseFrame(theFP)));
	theSP = (theFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFP + FoxFrameFlags) + 1)) << ShiftForWord))) + BytesPerWord;
	if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(callerFP)));
		longAt(callerFP + FoxThisContext);
		goto l2;
	}
	marryFrameSP(callerFP, theSP);
l2:	/* end ensureCallerContext: */;
	/* begin stackPageFor: */
	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
	thePage = stackPageAtpages(index, GIV(pages));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	onCurrentPage = thePage == GIV(stackPage);
	if (!onCurrentPage) {

		/* Make sure the frame's page isn't divorced when a new page is allocated. */

		markStackPageNextMostRecentlyUsed(thePage);
	}
	/* begin newStackPage */
	lruOrFree = ((mostRecentlyUsedPage())->nextPage);
	if (isFree(lruOrFree)) {
		newPage = lruOrFree;
		goto l1;
	}
	divorceFramesIn(lruOrFree);
	newPage = lruOrFree;
l1:	/* end newStackPage */;
	theMovedFP = moveFramesInthroughtoPage(thePage, theFP, newPage);
	if (onCurrentPage) {
		/* begin setStackPageAndLimit: */
		assert(newPage != 0);
		GIV(stackPage) = newPage;
		if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
			GIV(stackLimit) = (GIV(stackPage)->stackLimit);
		}
		markStackPageMostRecentlyUsed(newPage);
	}
	else {
		markStackPageMostRecentlyUsed(newPage);
	}
	assert(isBaseFrame(theMovedFP));
	longAtput(theMovedFP + FoxCallerContext, anOop);
	return theMovedFP;
}


/*	Answer a new String copied from a null-terminated C string,
	or nil if out of memory.
	Caution: This may invoke the garbage collector. */

sqInt
stringForCString(const char *aCString)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (ClassByteString << 2)), len);
	if (!(newString == null)) {
		strncpy(arrayValueOf(newString), aCString, len);
	}
	return newString;
}


/*	Return the number of indexable fields in the given object. (i.e., what
	Smalltalk would return for <obj> size).
 */
/*	Note: Assume oop is not a SmallInteger! */

sqInt
stSizeOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt classIndex;
    sqInt classTablePage;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt totalLength;

	hdr = longLongAt(oop);
	fmt = (((unsigned sqLong)hdr) >> 24) & 0x1F;
	/* begin lengthOf:format: */
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(oop)) > (isForwardedObjectClassIndexPun()));
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(oop + 4))))) >> 24;
	numSlots = (numSlots1 == 0xFF
		? (/* begin rawOverflowSlotsOf: */
			flag("endianness"),
			longAt(oop - (BaseHeaderSize)))
		: numSlots1);
	if (fmt <= 9) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= 16) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << 2) - (fmt & 7);
		goto l1;
	}
	if (fmt >= 12) {
		totalLength = (numSlots << (2 - 1)) - (fmt & 3);
		goto l1;
	}
	totalLength = (numSlots << (2 - 2)) - (fmt & 1);
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt > 5)
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	/* begin fetchClassOfNonImm: */
	classIndex = (longAt(oop)) & 0x3FFFFF;
	if (classIndex == 0x1F) {
		class = oop;
		goto l2;
	}
	assert(classIndex >= (arrayClassIndexPun()));
	/* begin classAtIndex: */
	assert((classIndex <= (tagMask()))
	 || (classIndex >= (arrayClassIndexPun())));
	classTablePage = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + ((((usqInt) classIndex) >> 10) << 2));
	if (classTablePage == GIV(nilObj)) {
		class = null;
		goto l2;
	}
	class = longAt((classTablePage + (BaseHeaderSize)) + ((classIndex & ((1 << 10) - 1)) << 2));
l2:	/* end fetchClassOfNonImm: */;
	fixedFields = (((longAt((class + (BaseHeaderSize)) + (InstanceSpecificationIndex << 2))) >> 1)) & ((1 << 16) - 1);
l3:	/* end fixedFieldsOf:format:length: */;
	if (fmt == 3) {
		assert(!(isContextHeader(hdr)));
	}
	return totalLength - fixedFields;
}


/*	Set the state of the primitive failure code/success flag, iff
	successBoolean is false. If primFailCode is non-zero a primitive has
	failed. If primFailCode
	is greater than one then its value indicates the reason for failure. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self success: false to exit. */

sqInt
success(sqInt successBoolean)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	This is ObjectMemory's funky entry-point into its incremental GC,
	which is a stop-the-world a young generation reclaimer. In Spur
	we run the scavenger. Answer if space is not low. */

static sqInt
sufficientSpaceAfterGC(sqInt numBytes)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(numBytes == 0);
	scavengingGCTenuringIf(TenureByAge);
	while ((GIV(totalFreeOldSpace) < GIV(growHeadroom))
	 && ((growOldSpaceByAtLeast(0)) != null)) {
		if (GIV(totalFreeOldSpace) >= GIV(growHeadroom)) {
			return 1;
		}
	}
	if (GIV(lowSpaceThreshold) > GIV(totalFreeOldSpace)) {

		/* space is low */


		/* avoid signalling low space twice */

		GIV(lowSpaceThreshold) = 0;
		return 0;
	}
	return 1;
}

sqInt
superclassOf(sqInt classPointer)
{
	return longAt((classPointer + (BaseHeaderSize)) + (SuperclassIndex << 2));
}


/*	On load, swizzle the pointers in an obj stack. Answer the obj stack's oop. */

static sqInt
swizzleObjStackAt(sqInt objStackRootIndex)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt field;
    sqInt firstPage;
    sqInt index;
    sqInt page;
    sqInt stackOrNil;

	firstPage = (stackOrNil = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (objStackRootIndex << 2)));
	if (stackOrNil == GIV(nilObj)) {
		return stackOrNil;
	}
	do {
		assert((numSlotsOfAny(stackOrNil)) == ObjStackPageSlots);
		assert((fetchPointerofObject(ObjStackMyx, stackOrNil)) == objStackRootIndex);

		/* swizzle fields including ObjStackNextx and leave field containing the next link. */

		index = (longAt((stackOrNil + (BaseHeaderSize)) + (ObjStackTopx << 2))) + ObjStackNextx;
		do {
			field = longAt((stackOrNil + (BaseHeaderSize)) + (index << 2));
			if (!((field == 0)
				 || ((field & 3) != 0))) {
				field = swizzleObj(field);
				/* begin storePointer:ofObjStack:withValue: */
				assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
				null;
				longAtput((stackOrNil + (BaseHeaderSize)) + (index << 2), field);
			}
		} while(((index -= 1)) > ObjStackMyx);
	} while(((stackOrNil = field)) != 0);
	if (((stackOrNil = longAt((firstPage + (BaseHeaderSize)) + (ObjStackFreex << 2)))) != 0) {
		while (1) {
			page = longAt((stackOrNil + (BaseHeaderSize)) + (ObjStackFreex << 2));
			if (!(page != 0)) break;
			field = swizzleObj(page);
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
			null;
			longAtput((stackOrNil + (BaseHeaderSize)) + (ObjStackFreex << 2), field);
			stackOrNil = field;
		}
	}
	if (((stackOrNil = longAt((firstPage + (BaseHeaderSize)) + (ObjStackNextx << 2)))) != 0) {
		while (1) {
			page = longAt((stackOrNil + (BaseHeaderSize)) + (ObjStackNextx << 2));
			if (!(page != 0)) break;
			field = swizzleObj(page);
			/* begin storePointer:ofObjStack:withValue: */
			assert((formatOf(stackOrNil)) == (wordIndexableFormat()));
			null;
			longAtput((stackOrNil + (BaseHeaderSize)) + (ObjStackNextx << 2), field);
			stackOrNil = field;
		}
	}
	assert(isValidObjStackAt(objStackRootIndex));
	return longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (objStackRootIndex << 2));
}

static sqInt
swizzleObj(sqInt objOop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;

	assert(GIV(canSwizzle));
	for (i = (GIV(numSegments) - 1); i >= 1; i += -1) {
		if (objOop >= (((GIV(segments)[i]).segStart))) {
			return objOop + (((GIV(segments)[i]).swizzle));
		}
	}
	return objOop + (((GIV(segments)[0]).swizzle));
}


/*	Signal the given semaphore from within the interpreter.
	Answer if the current process was preempted. */

static sqInt
synchronousSignal(sqInt aSemaphore)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt excessSignals;

	if ((longAt((aSemaphore + (BaseHeaderSize)) + (FirstLinkIndex << 2))) == GIV(nilObj)) {

		/* no process is waiting on this semaphore */

		excessSignals = fetchIntegerofObject(ExcessSignalsIndex, aSemaphore);
		/* begin storeInteger:ofObject:withValue: */
		if (((excessSignals + 1) ^ ((excessSignals + 1) << 1)) >= 0) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(aSemaphore)));
			longAtput((aSemaphore + (BaseHeaderSize)) + (ExcessSignalsIndex << 2), (((excessSignals + 1) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		null;
		return 0;
	}
	return resumepreemptedYieldingIf(removeFirstLinkOfList(aSemaphore), GIV(preemptionYields));
}

sqInt
tagMask(void)
{
	return 3;
}

sqInt
tempCountOf(sqInt methodPointer)
{
	return (((usqInt) (longAt((methodPointer + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 19) & 0x3F;
}

sqInt
temporaryCountOfMethodHeader(sqInt header)
{
	return (((usqInt) header) >> 19) & 0x3F;
}


/*	Do an incremental GC that tenures all surviving young objects to old
	space. 
 */

void
tenuringIncrementalGC(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt savedTenuringThreshold;

	/* begin flushNewSpace */
	savedTenuringThreshold = GIV(tenureThreshold);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = GIV(newSpaceLimit);
	scavengingGCTenuringIf(TenureByAge);
	/* begin setRawTenuringThreshold: */
	GIV(tenureThreshold) = savedTenuringThreshold;
	assert((rememberedSetSize()) == 0);
	assert(GIV(pastSpaceStart) == (((pastSpace()).start)));
	assert(GIV(freeStart) == (((eden()).start)));
}


/*	In the scavenger the tenuring threshold is effectively a number of bytes
	of objects,
	accessed as a proportion of pastSpace from 0 to 1. In the Squeak image the
	tenuring threshold is an object count. Marry the two notions by
	multiplying the proportion by
	the size of pastSpace and dividing by the average object size, as derived
	from observation. */

static sqInt
tenuringThreshold(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt averageObjectSize;

	averageObjectSize = 8 * (wordSize());
	return ((sqInt)(((scavengerTenuringThreshold()) * (((GIV(pastSpace).limit)) - ((GIV(pastSpace).start)))) / averageObjectSize));
}


/*	This assert is tricky. push:onObjStack: may call topOfObjStack: just after
	pushing an
	empty page on the stack, and will ask if the second page is valid. */

static sqInt
topOfObjStack(sqInt objStack)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt topx;

	assert(isValidObjStackPagemyIndexfirstPage(objStack, fetchPointerofObject(ObjStackMyx, objStack), objStack == (fetchPointerofObject(fetchPointerofObject(ObjStackMyx, objStack), GIV(hiddenRootsObj)))));
	topx = longAt((objStack + (BaseHeaderSize)) + (ObjStackTopx << 2));
	if (topx == 0) {
		assert((fetchPointerofObject(ObjStackNextx, objStack)) == 0);
		return null;
	}
	return longAt((objStack + (BaseHeaderSize)) + (((topx + ObjStackFixedSlots) - 1) << 2));
}


/*	Answers the top of the remappable oop stack. Useful when writing loops.
	We support this excessence for compatibility with ObjectMemory.
	Spur doesn't GC during allocation. */

sqInt
topRemappableOop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(remapBuffer)[GIV(remapBufferCount)];
}

static sqInt
totalBytesInSegments(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt total;

	total = 0;
	for (i = 0; i < GIV(numSegments); i += 1) {
		total += ((GIV(segments)[i]).segSize);
	}
	return total;
}


/*	This method both computes the actual number of free bytes by traversing
	all free objects
	on the free lists/tree, and checks that the tree is valid. It is used
	mainly by checkFreeSpace. */

static sqInt
totalFreeListBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong bytesInChunk;
    sqInt cameFrom;
    sqInt i;
    sqInt iLimiT;
    sqInt largeChild;
    sqInt listNode;
    sqInt smallChild;
    sqInt totalFreeBytes;
    sqInt treeNode;
    sqInt treeNode1;

	totalFreeBytes = 0;
	for (i = 1, iLimiT = (32 - 1); i <= iLimiT; i += 1) {
		bytesInChunk = i * 8;
		listNode = GIV(freeLists)[i];
		while (listNode != 0) {
			totalFreeBytes += bytesInChunk;
			assert(isValidFreeObject(listNode));
			assert(bytesInChunk == (bytesInObject(listNode)));
			listNode = longAt((listNode + (BaseHeaderSize)) + (0 << 2));
		}
	}
	/* begin freeTreeNodesDo: */
	treeNode1 = GIV(freeLists)[0];
	if (treeNode1 == 0) {
		goto l1;
	}
	cameFrom = -1;
	do {
		smallChild = longAt((treeNode1 + (BaseHeaderSize)) + (3 << 2));
		largeChild = longAt((treeNode1 + (BaseHeaderSize)) + (4 << 2));
		assert((smallChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), smallChild))));
		assert((largeChild == 0)
		 || (treeNode1 == (fetchPointerofFreeChunk(freeChunkParentIndex(), largeChild))));
		if (((smallChild == 0)
 && (largeChild == 0))
		 || ((largeChild == 0
			? cameFrom == smallChild
			: cameFrom == largeChild))) {

			/* and since we've applied we must move on up */

			bytesInChunk = bytesInObject(treeNode1);
			assert((bytesInChunk / (allocationUnit())) >= (numFreeLists()));
			listNode = treeNode1;
			while (listNode != 0) {

				/* self printFreeChunk: listNode */

				assert(isValidFreeObject(listNode));
				assert((listNode == treeNode1)
				 || ((fetchPointerofFreeChunk(freeChunkParentIndex(), listNode)) == 0));
				totalFreeBytes += bytesInChunk;
				assert(bytesInChunk == (bytesInObject(listNode)));
				listNode = longAt((listNode + (BaseHeaderSize)) + (0 << 2));
			}
			treeNode1 = treeNode1;

			cameFrom = treeNode1;
			treeNode1 = longAt((treeNode1 + (BaseHeaderSize)) + (2 << 2));
		}
		else {
			if ((smallChild != 0)
			 && (cameFrom != smallChild)) {
				treeNode1 = smallChild;
			}
			else {
				assert(largeChild != 0);
				treeNode1 = largeChild;
			}
			cameFrom = -1;
		}
	} while(treeNode1 != 0);
l1:	/* end freeTreeNodesDo: */;
	return totalFreeBytes;
}


/*	Record a process to be awoken on the next interpreter cycle. */

static void
transferTo(sqInt newProc)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt index;
    StackPage *lastUsedPage;
    StackPage *lruOrFree;
    sqInt newContext;
    StackPage *newPage;
    sqInt oldProc;
    sqInt sched;
    char *sp;
    char *theFrame;
    StackPage *thePage;
    char *theSP;
    sqInt top;
    sqInt value;

	GIV(statProcessSwitch) += 1;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !0, __LINE__);
	sched = longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2));
	oldProc = longAt((sched + (BaseHeaderSize)) + (ActiveProcessIndex << 2));
	/* begin ensureFrameIsMarried:SP: */
	theSP = GIV(stackPointer) + BytesPerWord;
	if ((byteAt((GIV(framePointer) + FoxFrameFlags) + 2)) != 0) {
		assert(isContext(frameContext(GIV(framePointer))));
		activeContext = longAt(GIV(framePointer) + FoxThisContext);
		goto l1;
	}
	activeContext = marryFrameSP(GIV(framePointer), theSP);
l1:	/* end ensureFrameIsMarried:SP: */;
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(oldProc)));
	if (isOldObject(oldProc)) {

		/* most stores into young objects */

		if (((activeContext & 3) == 0)
		 && ((((usqInt) activeContext)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(oldProc))) >> 29) & 1) != 0)) {
				remember(oldProc);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(oldProc, (longAt(oldProc)) | (1 << 29));
			}
		}
	}
	longAtput((oldProc + (BaseHeaderSize)) + (SuspendedContextIndex << 2), activeContext);
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(sched)));
	if (isOldObject(sched)) {

		/* most stores into young objects */

		if (((newProc & 3) == 0)
		 && ((((usqInt) newProc)) < (((usqInt) GIV(newSpaceLimit))))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(sched))) >> 29) & 1) != 0)) {
				remember(sched);
				/* begin setIsRememberedOf:to: */
				flag("endianness");
				longAtput(sched, (longAt(sched)) | (1 << 29));
			}
		}
	}
	longAtput((sched + (BaseHeaderSize)) + (ActiveProcessIndex << 2), newProc);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newProc)));
	longAtput((newProc + (BaseHeaderSize)) + (MyListIndex << 2), GIV(nilObj));
	/* begin externalSetStackPageAndPointersForSuspendedContextOfProcess: */
	newContext = longAt((newProc + (BaseHeaderSize)) + (SuspendedContextIndex << 2));
	assert(isContext(newContext));
	if (((longAt((newContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {
		assert(checkIsStillMarriedContextcurrentFP(newContext, GIV(framePointer)));
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(newProc)));
	longAtput((newProc + (BaseHeaderSize)) + (SuspendedContextIndex << 2), GIV(nilObj));
	if ((((longAt((newContext + (BaseHeaderSize)) + (SenderIndex << 2))) & 1))
	 && (!(isWidowedContext(newContext)))) {
		/* begin frameOfMarriedContext: */
		value = longAt((newContext + (BaseHeaderSize)) + (SenderIndex << 2));
		/* begin withoutSmallIntegerTags: */
		assert((value & 1));
		theFrame = pointerForOop(value - 1);
		/* begin stackPageFor: */
		/* begin stackPageAt: */
		index = pageIndexForstackMemorybytesPerPage(theFrame, GIV(stackMemory), GIV(bytesPerPage));
		thePage = stackPageAtpages(index, GIV(pages));
		if (theFrame != ((thePage->headFP))) {

			/* explicit assignment of suspendedContext can cause switch to interior frame. */

			/* begin newStackPage */
			lruOrFree = ((mostRecentlyUsedPage())->nextPage);
			if (isFree(lruOrFree)) {
				newPage = lruOrFree;
				goto l3;
			}
			divorceFramesIn(lruOrFree);
			newPage = lruOrFree;
		l3:	/* end newStackPage */;
			moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFrame, thePage), newPage);
			/* begin markStackPageLeastMostRecentlyUsed: */
			assert(newPage == ((GIV(mostRecentlyUsedPage)->nextPage)));
			lastUsedPage = (newPage->nextPage);
			while (((lastUsedPage->baseFP)) == 0) {
				lastUsedPage = (lastUsedPage->nextPage);
			}
			if (((lastUsedPage->nextPage)) == newPage) {
				null;
				goto l2;
			}
			(((newPage->prevPage))->nextPage = (newPage->nextPage));
			(((newPage->nextPage))->prevPage = (newPage->prevPage));
			(((lastUsedPage->prevPage))->nextPage = newPage);
			(newPage->prevPage = (lastUsedPage->prevPage));
			(newPage->nextPage = lastUsedPage);
			(lastUsedPage->prevPage = newPage);
			assert(pageListIsWellFormed());
		l2:	/* end markStackPageLeastMostRecentlyUsed: */;
		}
		assert(((thePage->headFP)) == theFrame);
	}
	else {
		thePage = makeBaseFrameFor(newContext);
		theFrame = (thePage->baseFP);
	}
	/* begin setStackPageAndLimit: */
	assert(thePage != 0);
	GIV(stackPage) = thePage;
	if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
		GIV(stackLimit) = (GIV(stackPage)->stackLimit);
	}
	markStackPageMostRecentlyUsed(thePage);
	GIV(stackPointer) = (thePage->headSP);
	GIV(framePointer) = (thePage->headFP);
	/* begin setMethod: */
	GIV(method) = longAt(GIV(framePointer) + FoxMethod);
	assert(isOopCompiledMethod(GIV(method)));
	
#  if MULTIPLEBYTECODESETS
	bytecodeSetSelector = ((((sqInt) (longAt((GIV(method) + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? 256
		: 0);

#  endif /* MULTIPLEBYTECODESETS */

;
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	GIV(instructionPointer) = ((sqInt) top);
	/* begin assertValidExecutionPointe:r:s: */
	assertValidExecutionPointersimbarline(GIV(instructionPointer), GIV(framePointer), GIV(stackPointer), !0, __LINE__);
}

sqInt
trueObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(trueObj);
}


/*	Unlink a freeTreeNode. Assumes the node has no list (null next link). */

static void
unlinkSolitaryFreeTreeNode(sqInt freeTreeNode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt larger;
    sqInt parent;
    sqInt smaller;

	assert((fetchPointerofObject(freeChunkNextIndex(), freeTreeNode)) == 0);
	smaller = longAt((freeTreeNode + (BaseHeaderSize)) + (3 << 2));
	larger = longAt((freeTreeNode + (BaseHeaderSize)) + (4 << 2));
	parent = longAt((freeTreeNode + (BaseHeaderSize)) + (2 << 2));
	if (parent == 0) {

		/* no parent; stitch the subnodes back into the root */

		if (smaller == 0) {
			if (larger != 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(larger));
				assert((0 == 0)
				 || (isFreeObject(0)));
				longAtput((larger + (BaseHeaderSize)) + (2 << 2), 0);
			}
			GIV(freeLists)[0] = larger;
		}
		else {
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(smaller));
			assert((0 == 0)
			 || (isFreeObject(0)));
			longAtput((smaller + (BaseHeaderSize)) + (2 << 2), 0);
			GIV(freeLists)[0] = smaller;
			if (larger != 0) {
				addFreeSubTree(larger);
			}
		}
	}
	else {

		/* parent; stitch back into appropriate side of parent. */

		if (smaller == 0) {
			/* begin storePointer:ofFreeChunk:withValue: */
			fieldIndex = (freeTreeNode == (longAt((parent + (BaseHeaderSize)) + (3 << 2)))
				? 3
				: 4);
			assert(isFreeObject(parent));
			assert((larger == 0)
			 || (isFreeObject(larger)));
			longAtput((parent + (BaseHeaderSize)) + (fieldIndex << 2), larger);
			if (larger != 0) {
				/* begin storePointer:ofFreeChunk:withValue: */
				assert(isFreeObject(larger));
				assert((parent == 0)
				 || (isFreeObject(parent)));
				longAtput((larger + (BaseHeaderSize)) + (2 << 2), parent);
			}
		}
		else {
			/* begin storePointer:ofFreeChunk:withValue: */
			fieldIndex1 = (freeTreeNode == (longAt((parent + (BaseHeaderSize)) + (3 << 2)))
				? 3
				: 4);
			assert(isFreeObject(parent));
			assert((smaller == 0)
			 || (isFreeObject(smaller)));
			longAtput((parent + (BaseHeaderSize)) + (fieldIndex1 << 2), smaller);
			/* begin storePointer:ofFreeChunk:withValue: */
			assert(isFreeObject(smaller));
			assert((parent == 0)
			 || (isFreeObject(parent)));
			longAtput((smaller + (BaseHeaderSize)) + (2 << 2), parent);
			if (larger != 0) {
				addFreeSubTree(larger);
			}
		}
	}
}


/*	Update the frame's spouse context with the frame's current state except
	for the
	sender and instruction pointer, which are used to mark the context as
	married. 
 */

static void
updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char *pointer;
    sqInt tempIndex;
    sqInt theContext;

	assert(frameHasContext(theFP));
	theContext = longAt(theFP + FoxThisContext);
	assert((frameReceiver(theFP)) == (fetchPointerofObject(ReceiverIndex, theContext)));

	/* update the arguments. this would appear not to be strictly necessary, but is for two reasons.
	   First, the fact that arguments are read-only is only as convention in the Smalltalk compiler;
	   other languages may choose to modify arguments.
	   Second, the Squeak runUntilErrorOrReturnFrom: nightmare pops the stack top, which may, in
	   certain circumstances, be the last argument, and hence the last argument may not have been
	   stored into the context. */

	tempIndex = byteAt((theFP + FoxFrameFlags) + 1);
	pointer = theFP + ((FoxCallerSavedIP + BytesPerWord) + (tempIndex << ShiftForWord));
	for (i = 1; i <= tempIndex; i += 1) {
		pointer -= BytesPerWord;
		assert(addressCouldBeOop(longAt(pointer)));
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		if (isOldObject(theContext)) {

			/* most stores into young objects */

			if ((((longAt(pointer)) & 3) == 0)
			 && ((((usqInt) (longAt(pointer)))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theContext))) >> 29) & 1) != 0)) {
					remember(theContext);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(theContext, (longAt(theContext)) | (1 << 29));
				}
			}
		}
		longAtput((theContext + (BaseHeaderSize)) + ((ReceiverIndex + i) << 2), longAt(pointer));
	}
	pointer = (theFP + FoxReceiver) - BytesPerWord;
	while (pointer >= theSP) {
		assert(addressCouldBeOop(longAt(pointer)));
		tempIndex += 1;
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theContext)));
		if (isOldObject(theContext)) {

			/* most stores into young objects */

			if ((((longAt(pointer)) & 3) == 0)
			 && ((((usqInt) (longAt(pointer)))) < (((usqInt) GIV(newSpaceLimit))))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theContext))) >> 29) & 1) != 0)) {
					remember(theContext);
					/* begin setIsRememberedOf:to: */
					flag("endianness");
					longAtput(theContext, (longAt(theContext)) | (1 << 29));
				}
			}
		}
		longAtput((theContext + (BaseHeaderSize)) + ((ReceiverIndex + tempIndex) << 2), longAt(pointer));
		pointer -= BytesPerWord;
	}
	assert((ReceiverIndex + tempIndex) < (lengthOf(theContext)));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theContext)));
	longAtput((theContext + (BaseHeaderSize)) + (StackPointerIndex << 2), ((tempIndex << 1) | 1));
}

static sqInt
usedSize(SpurCircularBuffer * self_in_usedSize)
{
	return (((self_in_usedSize->last)) < ((self_in_usedSize->start))
		? 0
		: (((self_in_usedSize->last)) >= ((self_in_usedSize->first))
				? ((((self_in_usedSize->last)) - ((self_in_usedSize->first))) / (wordSize())) + 1
				: (((((self_in_usedSize->limit)) - ((self_in_usedSize->start))) - (((self_in_usedSize->first)) - ((self_in_usedSize->last)))) / (wordSize())) - 1));
}


/*	Answer if hiddenRootsObj is of the right size with the
	expected contents, and if numClassTablePages is correct. */

static sqInt
validClassTableRootPages(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt iLimiT;
    sqInt obj;

	if (!((numSlotsOf(GIV(hiddenRootsObj))) == ((1 << (22 - 10)) + 8))) {
		return 0;
	}
	if (!((GIV(numClassTablePages) > 1)
		 && (GIV(numClassTablePages) <= (1 << (22 - 10))))) {
		return 0;
	}
	for (i = 0; i < GIV(numClassTablePages); i += 1) {
		obj = longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (i << 2));
		if (!((addressCouldBeObj(obj))
			 && ((numSlotsOf(obj)) == (1 << 10)))) {
			return 0;
		}
	}
	for (i = GIV(numClassTablePages), iLimiT = ((1 << (22 - 10)) - 1); i <= iLimiT; i += 1) {
		if ((longAt((GIV(hiddenRootsObj) + (BaseHeaderSize)) + (i << 2))) != GIV(nilObj)) {
			return 0;
		}
	}
	return 1;
}

static sqInt
validInstructionPointerinFrame(usqInt anInstrPointer, char *fp)
{
	return validInstructionPointerinMethodframePointer(anInstrPointer, longAt(fp + FoxMethod), fp);
}

sqInt
validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp)
{
    sqInt methodHeader;

	return 
#  if MULTIPLEBYTECODESETS
		(
			/* -1 for pre-increment in fetchNextBytecode */
		
		(methodHeader = longAt((aMethod + (BaseHeaderSize)) + (HeaderIndex << 2))),
			(theInstrPointer >= (((aMethod + (lastPointerOf(aMethod))) + BaseHeaderSize) - 1))
				 && ((theInstrPointer < (((aMethod + (byteLengthOf(aMethod))) + BaseHeaderSize) - 1))
				 && (!(((((sqInt) methodHeader)) < 0)
		 && ((methodHeader & (65536 << SmallIntegerShift))
		 && (theInstrPointer < (((((aMethod + BaseHeaderSize) - 1) + (lastPointerOf(aMethod))) + (((((sqInt) methodHeader)) < 0
				? 3
				: 0))) - 1)))))))
#  else /* MULTIPLEBYTECODESETS */
		(theInstrPointer >= (aMethod + (lastPointerOf(aMethod))))
			 && (theInstrPointer < (((aMethod + (byteLengthOf(aMethod))) + (BaseHeaderSize)) - 1))
#  endif /* MULTIPLEBYTECODESETS */
		;
}

static sqInt
validObjStacks(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return ((GIV(markStack) == GIV(nilObj))
 || (isValidObjStack(GIV(markStack))))
	 && (((GIV(weaklingStack) == GIV(nilObj))
 || (isValidObjStack(GIV(weaklingStack))))
	 && ((GIV(ephemeronQueue) == GIV(nilObj))
	 || (isValidObjStack(GIV(ephemeronQueue)))));
}


/*	Check that the base frames in all in-use stack pages have a sender and a
	saved context.
 */

static sqInt
validStackPageBaseFrames(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *aPage;
    sqInt i;

	for (i = 0; i < GIV(numStackPages); i += 1) {
		/* begin stackPageAt: */
		aPage = stackPageAtpages(i, GIV(pages));
		if (!(isFree(aPage))) {
			if (!(validStackPageBaseFrame(aPage))) {
				return 0;
			}
		}
	}
	return 1;
}


/*	Check that the base frame in the stack page has a valid sender context. */

static sqInt
validStackPageBaseFrame(StackPage *aPage)
{
    sqInt senderContextOrNil;
    char *theFP;

	if (!(asserta(isBaseFrame((aPage->baseFP))))) {
		return 0;
	}
	/* begin frameCallerContext: */
	theFP = (aPage->baseFP);
	senderContextOrNil = longAt(theFP + FoxCallerContext);
	if (!(asserta(addressCouldBeObj(senderContextOrNil)))) {
		return 0;
	}
	if (!(asserta((senderContextOrNil == (nilObject()))
		 || (isContext(senderContextOrNil))))) {
		return 0;
	}
	return 1;
}


/*	1 = big, 0 = little */

sqInt
vmEndianness(void)
{
	return VMBIGENDIAN;
}


/*	Void the state associated with the long-running primitive check.
	This is done when a new semaphore is installed or when it appears
	that is longRunningPrimitiveCheckMethod is invalid, e.g. because it
	has eben sampled in the middle of a GC. */

static void
voidLongRunningPrimitive(char *reason)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	GIV(longRunningPrimitiveCheckMethod) = null;
	GIV(longRunningPrimitiveCheckSequenceNumber) == 0;
	GIV(longRunningPrimitiveStartUsecs) = (GIV(longRunningPrimitiveStopUsecs) = 0);
	GIV(longRunningPrimitiveSignalUndelivered) = 1;
	sqLowLevelMFence();
}


/*	Make sure that all VM state that affects the heap contents is voided so
	that the heap is
	ready to be snapshotted. If flushExtPrims is true, flush references to
	external primitives in methods. Answer the activeContext that should be
	stored in the snapshot. */

static sqInt
voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeContext;
    sqInt address;
    sqInt address1;
    sqInt decodedIP;
    sqInt firstBytecode;
    sqInt fmt;
    sqInt i;
    sqInt iLimiT;
    sqInt limit;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt obj;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt primBits;

	activeContext = divorceAllFrames();
	/* begin bereaveAllMarriedContextsForSnapshotFlushingExternalPrimitivesIf: */
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((bootstrapping())
	 || ((((pastSpace()).start)) < (((eden()).start))));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots = ((usqInt) (((usqInt)(longAt(address + 4))))) >> 24;
	objOop1 = (numSlots == 0xFF
		? address + (BaseHeaderSize)
		: address);
	limit = GIV(pastSpaceStart);
	while ((((usqInt) objOop1)) < (((usqInt) limit))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		fmt = (((usqInt) (longAt(objOop1))) >> 24) & 0x1F;
		if ((fmt == 3)
		 && (((longAt(objOop1)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
			if (((longAt((objOop1 + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {

				/* The stack pages have already been discarded.  Any remaining married contexts are actually widows. */

				/* begin markContextAsDead: */
				assert(isContext(objOop1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
			}
			else {
				decodedIP = longAt((objOop1 + (BaseHeaderSize)) + (InstructionPointerIndex << 2));
				if (((decodedIP & 1))
				 && ((((sqInt) decodedIP)) < 0)) {
					decodedIP = mustMapMachineCodePCcontext((decodedIP >> 1), objOop1);
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop1)));
					longAtput((objOop1 + (BaseHeaderSize)) + (InstructionPointerIndex << 2), decodedIP);
				}
			}
			for (i = ((fetchStackPointerOf(objOop1)) + CtxtTempFrameStart), iLimiT = ((numSlotsOf(objOop1)) - 1); i <= iLimiT; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + (BaseHeaderSize)) + (i << 2), GIV(nilObj));
			}
		}
		if (flushExtPrims
		 && (fmt >= 24)) {

			/* Its primitiveExternalCall */

			if ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? ((longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
				? ((firstBytecode = (objOop1 + ((LiteralStart + ((((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
					(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
				: 0)
		: ((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#else /* MULTIPLEBYTECODESETS */
	((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#endif /* MULTIPLEBYTECODESETS */
	) == PrimitiveExternalCallIndex) {
				flushExternalPrimitiveOf(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	/* begin rawNumSlotsOf: */
	flag("endianness");
	numSlots1 = ((usqInt) (((usqInt)(longAt(address1 + 4))))) >> 24;
	objOop1 = (numSlots1 == 0xFF
		? address1 + (BaseHeaderSize)
		: address1);
	while ((((usqInt) objOop1)) < (((usqInt) GIV(freeStart)))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		fmt = (((usqInt) (longAt(objOop1))) >> 24) & 0x1F;
		if ((fmt == 3)
		 && (((longAt(objOop1)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
			if (((longAt((objOop1 + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {

				/* The stack pages have already been discarded.  Any remaining married contexts are actually widows. */

				/* begin markContextAsDead: */
				assert(isContext(objOop1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
			}
			else {
				decodedIP = longAt((objOop1 + (BaseHeaderSize)) + (InstructionPointerIndex << 2));
				if (((decodedIP & 1))
				 && ((((sqInt) decodedIP)) < 0)) {
					decodedIP = mustMapMachineCodePCcontext((decodedIP >> 1), objOop1);
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop1)));
					longAtput((objOop1 + (BaseHeaderSize)) + (InstructionPointerIndex << 2), decodedIP);
				}
			}
			for (i = ((fetchStackPointerOf(objOop1)) + CtxtTempFrameStart), iLimiT = ((numSlotsOf(objOop1)) - 1); i <= iLimiT; i += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(objOop1)));
				longAtput((objOop1 + (BaseHeaderSize)) + (i << 2), GIV(nilObj));
			}
		}
		if (flushExtPrims
		 && (fmt >= 24)) {

			/* Its primitiveExternalCall */

			if ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? ((longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
				? ((firstBytecode = (objOop1 + ((LiteralStart + ((((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
					(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
				: 0)
		: ((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#else /* MULTIPLEBYTECODESETS */
	((primBits = ((usqInt) (longAt((objOop1 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#endif /* MULTIPLEBYTECODESETS */
	) == PrimitiveExternalCallIndex) {
				flushExternalPrimitiveOf(objOop1);
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!((((usqInt) objOop11)) < (((usqInt) GIV(endOfMemory))))) break;
		assert((longLongAt(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			fmt = (((usqInt) (longAt(objOop11))) >> 24) & 0x1F;
			if ((fmt == 3)
			 && (((longAt(objOop11)) & 0x3FFFFF) == ClassMethodContextCompactIndex)) {
				if (((longAt((objOop11 + (BaseHeaderSize)) + (SenderIndex << 2))) & 1)) {

					/* The stack pages have already been discarded.  Any remaining married contexts are actually widows. */

					/* begin markContextAsDead: */
					assert(isContext(objOop11));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop11)));
					longAtput((objOop11 + (BaseHeaderSize)) + (SenderIndex << 2), GIV(nilObj));
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop11)));
					longAtput((objOop11 + (BaseHeaderSize)) + (InstructionPointerIndex << 2), GIV(nilObj));
				}
				else {
					decodedIP = longAt((objOop11 + (BaseHeaderSize)) + (InstructionPointerIndex << 2));
					if (((decodedIP & 1))
					 && ((((sqInt) decodedIP)) < 0)) {
						decodedIP = mustMapMachineCodePCcontext((decodedIP >> 1), objOop11);
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(objOop11)));
						longAtput((objOop11 + (BaseHeaderSize)) + (InstructionPointerIndex << 2), decodedIP);
					}
				}
				for (i = ((fetchStackPointerOf(objOop11)) + CtxtTempFrameStart), iLimiT = ((numSlotsOf(objOop11)) - 1); i <= iLimiT; i += 1) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(objOop11)));
					longAtput((objOop11 + (BaseHeaderSize)) + (i << 2), GIV(nilObj));
				}
			}
			if (flushExtPrims
			 && (fmt >= 24)) {

				/* Its primitiveExternalCall */

				if ((
#if MULTIPLEBYTECODESETS
	((((sqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2))))) < 0
		? ((longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2))) & (65536 << SmallIntegerShift)
				? ((firstBytecode = (objOop11 + ((LiteralStart + ((((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1) & 0xFFFF)) * BytesPerWord)) + BaseHeaderSize),
					(byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8))
				: 0)
		: ((primBits = ((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
			(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512)))
#else /* MULTIPLEBYTECODESETS */
	((primBits = ((usqInt) (longAt((objOop11 + (BaseHeaderSize)) + (HeaderIndex << 2)))) >> 1),
	(primBits & 0x1FF) + ((((usqInt) primBits) >> 19) & 512))
#endif /* MULTIPLEBYTECODESETS */
	) == PrimitiveExternalCallIndex) {
					flushExternalPrimitiveOf(objOop11);
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
	return activeContext;
}


/*	Return the highest priority process that is ready to run.
	To save time looking at many empty lists before finding a
	runnable process the VM maintains a variable holding the
	highest priority runnable process. If this variable is 0 then the
	VM does not know the highest priority and must search all lists.
	Note: It is a fatal VM error if there is no runnable process. */

static sqInt
wakeHighestPriority(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ctxt;
    usqInt numSlots;
    sqInt p;
    sqInt proc;
    sqInt processList;
    sqInt schedLists;

	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < LargeContextSize);
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - LargeContextSize)));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - (((sqInt) LargeContextSize >> 1)))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	schedLists = longAt(((longAt(((longAt((GIV(specialObjectsOop) + (BaseHeaderSize)) + (SchedulerAssociation << 2))) + (BaseHeaderSize)) + (ValueIndex << 2))) + (BaseHeaderSize)) + (ProcessListsIndex << 2));
	p = (GIV(highestRunnableProcessPriority) == 0
		? (/* begin numSlotsOf: */
			flag("endianness"),
			assert((classIndexOf(schedLists)) > (isForwardedObjectClassIndexPun())),
			/* begin rawNumSlotsOf: */
			flag("endianness"),
			(numSlots = ((usqInt) (((usqInt)(longAt(schedLists + 4))))) >> 24),
			(numSlots == 0xFF
					? (/* begin rawOverflowSlotsOf: */
						flag("endianness"),
						longAt(schedLists - (BaseHeaderSize)))
					: numSlots))
		: GIV(highestRunnableProcessPriority));
	while (((p -= 1)) >= 0) {
		processList = longAt((schedLists + (BaseHeaderSize)) + (p << 2));
		while (!((longAt((processList + (BaseHeaderSize)) + (FirstLinkIndex << 2))) == GIV(nilObj))) {

			/* Only answer processes with a runnable suspendedContext.
			   Discard those that aren't; the VM would crash otherwise. */

			proc = removeFirstLinkOfList(processList);
			ctxt = longAt((proc + (BaseHeaderSize)) + (SuspendedContextIndex << 2));
			if (isLiveContext(ctxt)) {
				GIV(highestRunnableProcessPriority) = p + 1;
				return proc;
			}
			warning("evicted zombie process from run queue");
		}
	}
	error("scheduler could not find a runnable process");
	return null;
}

sqInt
weakArrayFormat(void)
{
	return 4;
}

static sqInt
withSmallIntegerTags(char *value)
{
	assert(((oopForPointer(value)) & (BytesPerWord - 1)) == 0);
	return (oopForPointer(value)) + 1;
}

static sqInt
wordIndexableFormat(void)
{
	return 10;
}

static sqInt
writeImageFileIO(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytesWritten;
    sqImageFile f;
    sqInt headerSize;
    squeakFileOffsetType  headerStart;
    sqInt i;
    sqInt i1;
    usqInt memStart;
    sqInt nextSegSize;
    sqInt okToWrite;
    void *sCWIfn;
    sqInt successBoolean;
    sqInt total;


	/* If the security plugin can be loaded, use it to check for write permission.
	   If not, assume it's ok */

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin");
	if (sCWIfn != 0) {
		okToWrite = ((sqInt (*)(void))sCWIfn)();
		if (!okToWrite) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
	}
	headerStart = 0;

	/* header size in bytes; do not change! */

	headerSize = 64;
	f = sqImageFileOpen(imageName, "wb");
	if (f == null) {

		/* could not open the image file for writing */

		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	headerStart = sqImageFileStartLocation(f,imageName,headerSize+imageBytes);
	/* Note: on Unix systems one could put an exec command here, padded to 512 bytes */;
	sqImageFileSeek(f, headerStart);
	putLongtoFile(imageFormatVersion(), f);
	putLongtoFile(headerSize, f);
	putLongtoFile(imageSizeToWrite(), f);
	putLongtoFile(GIV(oldSpaceStart), f);
	putLongtoFile(GIV(specialObjectsOop), f);
	putLongtoFile(newObjectHash(), f);
	putLongtoFile(ioScreenSize(), f);
	putLongtoFile(((GIV(fullScreenFlag) + (2)) + ((GIV(preemptionYields)
	? 0
	: 16))) + (((GIV(imageHeaderFlags) | 19) - 19)), f);
	putLongtoFile(extraVMMemory, f);
	putShorttoFile(desiredNumStackPages, f);
	putShorttoFile(GIV(theUnknownShort), f);
	putLongtoFile(desiredEdenBytes, f);
	putShorttoFile((GIV(maxExtSemTabSizeSet)
		? ioGetMaxExtSemTableSize()
		: 0), f);
	putShorttoFile(GIV(the2ndUnknownShort), f);
	putLongtoFile(((GIV(segments)[0]).segSize), f);
	for (i = 1; i <= 3; i += 1) {
		putLongtoFile(0, f);
	}

	if (!(!GIV(primFailCode))) {

		/* file write or seek failure */

		sqImageFileClose(f);
		return null;
	}
	sqImageFileSeek(f, headerStart + headerSize);
	/* begin writeImageToFile: */
	total = 0;
	assert(((endOfMemory()) == (segLimit(&GIV(segments)[GIV(numSegments) - 1])))
	 || (((endOfMemory()) + (bridgeSize())) == (segLimit(&GIV(segments)[GIV(numSegments) - 1]))));
	if (!(GIV(firstSegmentSize) == null)) {
		assert(GIV(firstSegmentSize) == (((GIV(segments)[0]).segSize)));
	}
	for (i1 = 0; i1 < GIV(numSegments); i1 += 1) {
		nextSegSize = (i1 == (GIV(numSegments) - 1)
			? 0
			: ((GIV(segments)[i1 + 1]).segSize));
		total += writeSegmentnextSegmentSizetoFile((&(GIV(segments)[i1])), nextSegSize, f);
	}
	bytesWritten = total;

	/* begin success: */
	successBoolean = bytesWritten == (imageSizeToWrite());
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	sqImageFileClose(f);
}

static sqInt
writeSegmentnextSegmentSizetoFile(SpurSegmentInfo *segment, sqInt nextSegSize, FILE *aBinaryStream)
{
    sqInt lastDoubleWord;
    sqInt nWritten;
    usqLong savedDoubleWord;

	lastDoubleWord = (((segment->segSize)) + ((segment->segStart))) - (BaseHeaderSize);
	assert(isValidSegmentBridge(bridgeFor(segment)));
	assert((startOfObject(bridgeFor(segment))) == (lastDoubleWord - (BaseHeaderSize)));
	savedDoubleWord = longLongAt(lastDoubleWord);
	longLongAtput(lastDoubleWord, nextSegSize);
	nWritten = sqImageFileWrite(((void *)((segment->segStart))), 1, (segment->segSize), aBinaryStream);
	longLongAtput(lastDoubleWord, savedDoubleWord);
	return nWritten;
}


void* vm_exports[][3] = {
	{"", "callbackEnter", (void*)callbackEnter},
	{"", "callbackLeave", (void*)callbackLeave},
	{"", "dumpImage", (void*)dumpImage},
	{"", "moduleUnloaded", (void*)moduleUnloaded},
	{"", "primitiveAddLargeIntegers", (void*)primitiveAddLargeIntegers},
	{"", "primitiveBitAndLargeIntegers", (void*)primitiveBitAndLargeIntegers},
	{"", "primitiveBitOrLargeIntegers", (void*)primitiveBitOrLargeIntegers},
	{"", "primitiveBitShiftLargeIntegers", (void*)primitiveBitShiftLargeIntegers},
	{"", "primitiveBitXorLargeIntegers", (void*)primitiveBitXorLargeIntegers},
	{"", "primitiveClockLogAddresses", (void*)primitiveClockLogAddresses},
	{"", "primitiveCompareBytes", (void*)primitiveCompareBytes},
	{"", "primitiveCrashVM", (void*)primitiveCrashVM},
	{"", "primitiveDisablePowerManager", (void*)primitiveDisablePowerManager},
	{"", "primitiveDivideLargeIntegers", (void*)primitiveDivideLargeIntegers},
	{"", "primitiveDivLargeIntegers", (void*)primitiveDivLargeIntegers},
	{"", "primitiveEqualLargeIntegers", (void*)primitiveEqualLargeIntegers},
	{"", "primitiveEventProcessingControl", (void*)primitiveEventProcessingControl},
	{"", "primitiveGetLogDirectory", (void*)primitiveGetLogDirectory},
	{"", "primitiveGetWindowLabel", (void*)primitiveGetWindowLabel},
	{"", "primitiveGetWindowSize", (void*)primitiveGetWindowSize},
	{"", "primitiveGreaterOrEqualLargeIntegers", (void*)primitiveGreaterOrEqualLargeIntegers},
	{"", "primitiveGreaterThanLargeIntegers", (void*)primitiveGreaterThanLargeIntegers},
	{"", "primitiveHeartbeatFrequency", (void*)primitiveHeartbeatFrequency},
	{"", "primitiveHighResClock", (void*)primitiveHighResClock},
	{"", "primitiveInterruptChecksPerMSec", (void*)primitiveInterruptChecksPerMSec},
	{"", "primitiveIsWindowObscured", (void*)primitiveIsWindowObscured},
	{"", "primitiveLessOrEqualLargeIntegers", (void*)primitiveLessOrEqualLargeIntegers},
	{"", "primitiveLessThanLargeIntegers", (void*)primitiveLessThanLargeIntegers},
	{"", "primitiveLongRunningPrimitive", (void*)primitiveLongRunningPrimitive},
	{"", "primitiveLongRunningPrimitiveSemaphore", (void*)primitiveLongRunningPrimitiveSemaphore},
	{"", "primitiveMakeEphemeron", (void*)primitiveMakeEphemeron},
	{"", "primitiveMillisecondClockMask", (void*)primitiveMillisecondClockMask},
	{"", "primitiveModLargeIntegers", (void*)primitiveModLargeIntegers},
	{"", "primitiveMultiplyLargeIntegers", (void*)primitiveMultiplyLargeIntegers},
	{"", "primitiveNotEqualLargeIntegers", (void*)primitiveNotEqualLargeIntegers},
	{"", "primitiveOriginalMillisecondClock", (void*)primitiveOriginalMillisecondClock},
	{"", "primitiveProfilePrimitive", (void*)primitiveProfilePrimitive},
	{"", "primitiveProfileSample", (void*)primitiveProfileSample},
	{"", "primitiveProfileSemaphore", (void*)primitiveProfileSemaphore},
	{"", "primitiveProfileStart", (void*)primitiveProfileStart},
	{"", "primitiveQuoLargeIntegers", (void*)primitiveQuoLargeIntegers},
	{"", "primitiveRemLargeIntegers", (void*)primitiveRemLargeIntegers},
	{"", "primitiveScreenDepth", (void*)primitiveScreenDepth},
	{"", "primitiveSetGCSemaphore", (void*)primitiveSetGCSemaphore},
	{"", "primitiveSetLogDirectory", (void*)primitiveSetLogDirectory},
	{"", "primitiveSetWindowLabel", (void*)primitiveSetWindowLabel},
	{"", "primitiveSetWindowSize", (void*)primitiveSetWindowSize},
	{"", "primitiveSubtractLargeIntegers", (void*)primitiveSubtractLargeIntegers},
	{"", "primitiveUtcWithOffset", (void*)primitiveUtcWithOffset},
	{"", "primitiveVoidReceiver", (void*)primitiveVoidReceiver},
	{"", "printFramesInPage", (void*)printFramesInPage},
	{"", "printFramesOnStackPageListInUse", (void*)printFramesOnStackPageListInUse},
	{"", "reestablishContextPriorToCallback", (void*)reestablishContextPriorToCallback},
	{"", "returnAsThroughCallbackContext", (void*)returnAsThroughCallbackContext},
	{"", "sendInvokeCallbackContext", (void*)sendInvokeCallbackContext},
	{"", "sendInvokeCallbackStackRegistersJmpbuf", (void*)sendInvokeCallbackStackRegistersJmpbuf},
	{"", "setInterruptCheckChain", (void*)setInterruptCheckChain},
	{"", "shortPrintFramesInPage", (void*)shortPrintFramesInPage},
	{"", "shortPrintFramesOnStackPageListInUse", (void*)shortPrintFramesOnStackPageListInUse},
	{NULL, NULL, NULL}
};

void initGlobalStructure(void) {
#if SQ_USE_GLOBAL_STRUCT_REG
foo = &fum;
#endif
}
