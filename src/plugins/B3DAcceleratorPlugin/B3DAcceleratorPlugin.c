/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.787 uuid: 4b38ebc1-339f-4523-a9fc-047923108211
   from
	B3DAcceleratorPlugin VMMaker.oscog-eem.787 uuid: 4b38ebc1-339f-4523-a9fc-047923108211
 */
static char __buildInfo[] = "B3DAcceleratorPlugin VMMaker.oscog-eem.787 uuid: 4b38ebc1-339f-4523-a9fc-047923108211 " __DATE__ ;



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif

#include "B3DAcceleratorPlugin.h"
#include "sqMemoryAccess.h"


/*** Constants ***/


/*** Function Prototypes ***/
static sqInt checkBoundsRangefacescount(sqInt vertices, unsigned int *facePtr, sqInt faceCount);
static sqInt checkVertexData(sqInt vertices);
static void* fetchLightSourceofObject(sqInt index, sqInt anArray);
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt halt(void);
EXPORT(sqInt) initialiseModule(void);
static sqInt loadClientStateverticescolorsnormalstexCoords(sqInt handle, sqInt vertices, sqInt colors, sqInt normals, sqInt texCoords);
static sqInt msg(char *s);
EXPORT(sqInt) primitiveAllocateTexture(void);
EXPORT(sqInt) primitiveClearDepthBuffer(void);
EXPORT(sqInt) primitiveClearViewport(void);
EXPORT(sqInt) primitiveCompositeTexture(void);
EXPORT(sqInt) primitiveCreateRenderer(void);
EXPORT(sqInt) primitiveCreateRendererFlags(void);
EXPORT(sqInt) primitiveDestroyRenderer(void);
EXPORT(sqInt) primitiveDestroyTexture(void);
EXPORT(sqInt) primitiveDrawArrays(void);
EXPORT(sqInt) primitiveDrawElements(void);
EXPORT(sqInt) primitiveDrawRangeElements(void);
EXPORT(sqInt) primitiveEnableDrawRangeChecks(void);
EXPORT(sqInt) primitiveFinishRenderer(void);
EXPORT(sqInt) primitiveFlushRenderer(void);
EXPORT(sqInt) primitiveGetIntProperty(void);
EXPORT(sqInt) primitiveGetRendererColorMasks(void);
EXPORT(sqInt) primitiveGetRendererSurfaceDepth(void);
EXPORT(sqInt) primitiveGetRendererSurfaceHandle(void);
EXPORT(sqInt) primitiveGetRendererSurfaceHeight(void);
EXPORT(sqInt) primitiveGetRendererSurfaceWidth(void);
EXPORT(sqInt) primitiveIsOverlayRenderer(void);
EXPORT(sqInt) primitiveRendererVersion(void);
EXPORT(sqInt) primitiveRenderVertexBuffer(void);
EXPORT(sqInt) primitiveSetBufferRect(void);
EXPORT(sqInt) primitiveSetFog(void);
EXPORT(sqInt) primitiveSetIntProperty(void);
EXPORT(sqInt) primitiveSetLights(void);
EXPORT(sqInt) primitiveSetMaterial(void);
EXPORT(sqInt) primitiveSetTransform(void);
EXPORT(sqInt) primitiveSetVerboseLevel(void);
EXPORT(sqInt) primitiveSetViewport(void);
EXPORT(sqInt) primitiveSwapRendererBuffers(void);
EXPORT(sqInt) primitiveTextureByteSex(void);
EXPORT(sqInt) primitiveTextureDepth(void);
EXPORT(sqInt) primitiveTextureGetColorMasks(void);
EXPORT(sqInt) primitiveTextureSurfaceHandle(void);
EXPORT(sqInt) primitiveTextureUpload(void);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
EXPORT(sqInt) shutdownModule(void);
static sqInt stackLightArrayValue(sqInt stackIndex);
static void * stackMaterialValue(sqInt stackIndex);
static void* stackMatrix(sqInt index);
static void* stackPrimitiveIndexArrayofSizevalidateforVertexSize(sqInt stackIndex, sqInt nItems, sqInt aBool, sqInt maxIndex);
static void* stackPrimitiveVertexArrayofSize(sqInt index, sqInt nItems);
static void* stackPrimitiveVertex(sqInt index);


/*** Variables ***/
static sqInt doRangeChecks;

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static sqInt (*booleanValueOf)(sqInt obj);
static sqInt (*classArray)(void);
static sqInt (*failed)(void);
static sqInt (*fetchClassOf)(sqInt oop);
static sqInt (*fetchIntegerofObject)(sqInt fieldIndex, sqInt objectPointer);
static sqInt (*fetchPointerofObject)(sqInt index, sqInt oop);
static void * (*firstIndexableField)(sqInt oop);
static double (*floatValueOf)(sqInt oop);
static sqInt (*isArray)(sqInt oop);
static sqInt (*isPointers)(sqInt oop);
static sqInt (*isWords)(sqInt oop);
static sqInt (*methodArgumentCount)(void);
static sqInt (*nilObject)(void);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(sqInt integerValue);
static usqInt (*positive32BitValueOf)(sqInt oop);
static sqInt (*primitiveFail)(void);
static sqInt (*pushBool)(sqInt trueOrFalse);
static sqInt (*pushInteger)(sqInt integerValue);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*slotSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern sqInt booleanValueOf(sqInt obj);
extern sqInt classArray(void);
extern sqInt failed(void);
extern sqInt fetchClassOf(sqInt oop);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchPointerofObject(sqInt index, sqInt oop);
extern void * firstIndexableField(sqInt oop);
extern double floatValueOf(sqInt oop);
extern sqInt isArray(sqInt oop);
extern sqInt isPointers(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt methodArgumentCount(void);
extern sqInt nilObject(void);
extern sqInt pop(sqInt nItems);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(sqInt integerValue);
extern usqInt positive32BitValueOf(sqInt oop);
extern sqInt primitiveFail(void);
extern sqInt pushBool(sqInt trueOrFalse);
extern sqInt pushInteger(sqInt integerValue);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"B3DAcceleratorPlugin VMMaker.oscog-eem.787 (i)"
#else
	"B3DAcceleratorPlugin VMMaker.oscog-eem.787 (e)"
#endif
;



/*	Verify the bounds condition on the entire faces array */

static sqInt
checkBoundsRangefacescount(sqInt vertices, unsigned int *facePtr, sqInt faceCount)
{
    sqInt i;
    sqInt vtxSize;

	vtxSize = (slotSizeOf(vertices)) / 3;
	for (i = 0; i < faceCount; i += 1) {
		if ((facePtr[i]) > vtxSize) {
			return primitiveFail();
		}
	}
}


/*	Check the entire vertex data to ensure no nan/inf values */

static sqInt
checkVertexData(sqInt vertices)
{
    float f;
    sqInt i;
    float *vtxPtr;
    sqInt vtxSize;

	vtxSize = slotSizeOf(vertices);
	vtxPtr = firstIndexableField(vertices);
	for (i = 0; i < vtxSize; i += 1) {
		f = vtxPtr[i];
		if (isnan(f - f)) {
			return primitiveFail();
		}
	}
}


/*	Fetch the primitive light source from the given array.
	Note: No checks are done within here - that happened in
	stackLightArrayValue: 
 */

static void*
fetchLightSourceofObject(sqInt index, sqInt anArray)
{
    sqInt lightOop;

	lightOop = fetchPointerofObject(index, anArray);
	return firstIndexableField(lightOop);
}


/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void)
{
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

static sqInt
halt(void)
{
	;
	return 0;
}

EXPORT(sqInt)
initialiseModule(void)
{
	doRangeChecks = 1;
	return b3dxInitialize();
}


/*	Common method to set up client state for some render ops */

static sqInt
loadClientStateverticescolorsnormalstexCoords(sqInt handle, sqInt vertices, sqInt colors, sqInt normals, sqInt texCoords)
{
    void *colorPtr;
    void *normalPtr;
    sqInt ok;
    sqInt sz;
    void *txPtr;
    void *vertexPtr;
    sqInt vtxSize;


	/* Verify vertex data */

	colorPtr = (normalPtr = (txPtr = (vertexPtr = null)));
	if (!(isWords(vertices))) {
		return primitiveFail();
	}

	/* Verify assumptions of color, normal, texCoords data */

	vtxSize = (slotSizeOf(vertices)) / 3;
	if (!((colors == (nilObject()))
		 || ((isWords(colors))
		 && ((slotSizeOf(colors)) == (vtxSize * 4))))) {
		return primitiveFail();
	}
	if (!((normals == (nilObject()))
		 || ((isWords(normals))
		 && ((slotSizeOf(normals)) == (vtxSize * 3))))) {
		return primitiveFail();
	}
	if (!((texCoords == (nilObject()))
		 || (isWords(texCoords)))) {
		return primitiveFail();
	}
	if (!(colors == (nilObject()))) {
		colorPtr = firstIndexableField(colors);
	}
	if (!(normals == (nilObject()))) {
		normalPtr = firstIndexableField(normals);
	}
	if (!(texCoords == (nilObject()))) {
		sz = (slotSizeOf(texCoords)) / vtxSize;
		txPtr = firstIndexableField(texCoords);
	}
	vertexPtr = firstIndexableField(vertices);
	if (failed()) {
		return null;
	}
	ok = b3dLoadClientState(handle, vertexPtr, 3, colorPtr, 4, normalPtr, 3, txPtr, sz);
	if (!ok) {
		return primitiveFail();
	}
}

static sqInt
msg(char *s)
{
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}

EXPORT(sqInt)
primitiveAllocateTexture(void)
{
    sqInt d;
    sqInt h;
    sqInt renderer;
    sqInt result;
    sqInt w;

	if (!((methodArgumentCount()) == 4)) {
		return primitiveFail();
	}
	h = stackIntegerValue(0);
	w = stackIntegerValue(1);
	d = stackIntegerValue(2);
	renderer = stackIntegerValue(3);
	if (failed()) {
		return null;
	}
	result = b3dxAllocateTexture(renderer, w, h, d);
	if (result == -1) {
		return primitiveFail();
	}
	pop(5);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveClearDepthBuffer(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxClearDepthBuffer(handle);
	if (!result) {
		return primitiveFail();
	}
	return pop(1);
}

EXPORT(sqInt)
primitiveClearViewport(void)
{
    sqInt handle;
    sqInt pv;
    sqInt result;
    sqInt rgba;

	if (!((methodArgumentCount()) == 3)) {
		return primitiveFail();
	}
	pv = positive32BitValueOf(stackValue(0));
	rgba = positive32BitValueOf(stackValue(1));
	handle = stackIntegerValue(2);
	if (failed()) {
		return null;
	}
	result = b3dxClearViewport(handle, rgba, pv);
	if (!result) {
		return primitiveFail();
	}
	return pop(3);
}

EXPORT(sqInt)
primitiveCompositeTexture(void)
{
    sqInt h;
    sqInt rendererHandle;
    sqInt result;
    sqInt texHandle;
    sqInt translucent;
    sqInt w;
    sqInt x;
    sqInt y;

	if (!((methodArgumentCount()) == 7)) {
		return primitiveFail();
	}
	translucent = booleanValueOf(stackValue(0));
	h = stackIntegerValue(1);
	w = stackIntegerValue(2);
	y = stackIntegerValue(3);
	x = stackIntegerValue(4);
	texHandle = stackIntegerValue(5);
	rendererHandle = stackIntegerValue(6);
	if (failed()) {
		return null;
	}
	result = b3dxCompositeTexture(rendererHandle, texHandle, x, y, w, h, translucent);
	if (!result) {
		return primitiveFail();
	}
	return pop(7);
}


/*	NOTE: This primitive is obsolete but should be supported for older images */

EXPORT(sqInt)
primitiveCreateRenderer(void)
{
    sqInt allowHardware;
    sqInt allowSoftware;
    sqInt h;
    sqInt result;
    sqInt w;
    sqInt x;
    sqInt y;

	if (!((methodArgumentCount()) == 6)) {
		return primitiveFail();
	}
	h = stackIntegerValue(0);
	w = stackIntegerValue(1);
	y = stackIntegerValue(2);
	x = stackIntegerValue(3);
	allowHardware = booleanValueOf(stackValue(4));
	allowSoftware = booleanValueOf(stackValue(5));
	if (failed()) {
		return null;
	}
	result = b3dxCreateRenderer(allowSoftware, allowHardware, x, y, w, h);
	if (result < 0) {
		return primitiveFail();
	}
	pop(7);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveCreateRendererFlags(void)
{
    sqInt flags;
    sqInt h;
    sqInt result;
    sqInt w;
    sqInt x;
    sqInt y;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFail();
	}
	h = stackIntegerValue(0);
	w = stackIntegerValue(1);
	y = stackIntegerValue(2);
	x = stackIntegerValue(3);
	flags = stackIntegerValue(4);
	if (failed()) {
		return null;
	}
	result = b3dxCreateRendererFlags(x, y, w, h, flags);
	if (result < 0) {
		return primitiveFail();
	}
	pop(6);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveDestroyRenderer(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxDestroyRenderer(handle);
	if (!result) {
		return primitiveFail();
	}
	return pop(1);
}

EXPORT(sqInt)
primitiveDestroyTexture(void)
{
    sqInt handle;
    sqInt renderer;
    sqInt result;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	renderer = stackIntegerValue(1);
	if (failed()) {
		return null;
	}
	result = b3dxDestroyTexture(renderer, handle);
	if (!result) {
		return primitiveFail();
	}
	return pop(2);
}


/*	Primitive. Setup non-VBO client state and call drawRangeElements in one go
	to avoid
	garbage collection to move the buffers underneith.
 */

EXPORT(sqInt)
primitiveDrawArrays(void)
{
    sqInt colors;
    float f;
    sqInt handle;
    sqInt i;
    sqInt maxIdx;
    sqInt minIdx;
    sqInt mode;
    sqInt normals;
    sqInt ok;
    sqInt texCoords;
    sqInt vertices;
    float *vtxPtr;
    sqInt vtxSize;
    sqInt vtxSize1;

	if (!((methodArgumentCount()) == 8)) {
		return primitiveFail();
	}
	maxIdx = stackIntegerValue(0);
	minIdx = stackIntegerValue(1);
	mode = stackIntegerValue(2);
	texCoords = stackValue(3);
	normals = stackValue(4);
	colors = stackValue(5);
	vertices = stackValue(6);
	handle = stackIntegerValue(7);
	loadClientStateverticescolorsnormalstexCoords(handle, vertices, colors, normals, texCoords);
	if (failed()) {
		return null;
	}
	if (doRangeChecks) {

		/* Verify the vertex data itself */

		/* begin checkVertexData: */
		vtxSize1 = slotSizeOf(vertices);
		vtxPtr = firstIndexableField(vertices);
		for (i = 0; i < vtxSize1; i += 1) {
			f = vtxPtr[i];
			if (isnan(f - f)) {
				primitiveFail();
				goto l1;
			}
		}
	l1:	/* end checkVertexData: */;
		vtxSize = (slotSizeOf(vertices)) / 3;
		if ((minIdx < 0)
		 || ((minIdx > maxIdx)
		 || (maxIdx > vtxSize))) {
			return primitiveFail();
		}
	}
	if (failed()) {
		return null;
	}
	ok = b3dDrawArrays(handle, mode, minIdx, maxIdx);
	if (!ok) {
		return primitiveFail();
	}
	if (!(failed())) {
		pop(methodArgumentCount());
	}
}


/*	Primitive. Setup non-VBO client state and call drawElements in one go to
	avoid garbage collection to move the buffers underneith. */

EXPORT(sqInt)
primitiveDrawElements(void)
{
    sqInt colors;
    float f;
    unsigned int *facePtr;
    sqInt faceSize;
    sqInt faces;
    sqInt handle;
    sqInt i;
    sqInt i1;
    sqInt mode;
    sqInt normals;
    sqInt ok;
    sqInt texCoords;
    sqInt vertices;
    float *vtxPtr;
    sqInt vtxSize;
    sqInt vtxSize1;

	if (!((methodArgumentCount()) == 7)) {
		return primitiveFail();
	}
	faces = stackValue(0);
	if (!(isWords(faces))) {
		return primitiveFail();
	}
	faceSize = slotSizeOf(faces);
	facePtr = firstIndexableField(faces);
	mode = stackIntegerValue(1);
	texCoords = stackValue(2);
	normals = stackValue(3);
	colors = stackValue(4);
	vertices = stackValue(5);
	handle = stackIntegerValue(6);
	loadClientStateverticescolorsnormalstexCoords(handle, vertices, colors, normals, texCoords);
	if (failed()) {
		return null;
	}
	if (doRangeChecks) {

		/* Verify the vertex data itself */

		/* begin checkVertexData: */
		vtxSize = slotSizeOf(vertices);
		vtxPtr = firstIndexableField(vertices);
		for (i = 0; i < vtxSize; i += 1) {
			f = vtxPtr[i];
			if (isnan(f - f)) {
				primitiveFail();
				goto l1;
			}
		}
	l1:	/* end checkVertexData: */;
		/* begin checkBoundsRange:faces:count: */
		vtxSize1 = (slotSizeOf(vertices)) / 3;
		for (i1 = 0; i1 < faceSize; i1 += 1) {
			if ((facePtr[i1]) > vtxSize1) {
				primitiveFail();
				goto l2;
			}
		}
	l2:	/* end checkBoundsRange:faces:count: */;
	}
	if (failed()) {
		return null;
	}
	ok = b3dDrawElements(handle, mode, faceSize, facePtr);
	if (!ok) {
		return primitiveFail();
	}
	if (!(failed())) {
		pop(methodArgumentCount());
	}
}


/*	Primitive. Setup non-VBO client state and call drawRangeElements in one go
	to avoid
	garbage collection to move the buffers underneith.
 */

EXPORT(sqInt)
primitiveDrawRangeElements(void)
{
    sqInt colors;
    float f;
    unsigned int *facePtr;
    sqInt faceSize;
    sqInt faces;
    sqInt handle;
    sqInt i;
    sqInt i1;
    sqInt maxIdx;
    sqInt minIdx;
    sqInt mode;
    sqInt normals;
    sqInt ok;
    sqInt texCoords;
    sqInt vertices;
    float *vtxPtr;
    sqInt vtxSize;
    sqInt vtxSize1;
    sqInt vtxSize2;

	if (!((methodArgumentCount()) == 9)) {
		return primitiveFail();
	}
	faces = stackValue(0);
	if (!(isWords(faces))) {
		return primitiveFail();
	}
	faceSize = slotSizeOf(faces);
	facePtr = firstIndexableField(faces);
	maxIdx = stackIntegerValue(1);
	minIdx = stackIntegerValue(2);
	mode = stackIntegerValue(3);
	texCoords = stackValue(4);
	normals = stackValue(5);
	colors = stackValue(6);
	vertices = stackValue(7);
	handle = stackIntegerValue(8);
	loadClientStateverticescolorsnormalstexCoords(handle, vertices, colors, normals, texCoords);
	if (failed()) {
		return null;
	}
	if (doRangeChecks) {

		/* Verify the vertex data itself */

		/* begin checkVertexData: */
		vtxSize1 = slotSizeOf(vertices);
		vtxPtr = firstIndexableField(vertices);
		for (i = 0; i < vtxSize1; i += 1) {
			f = vtxPtr[i];
			if (isnan(f - f)) {
				primitiveFail();
				goto l1;
			}
		}
	l1:	/* end checkVertexData: */;
		/* begin checkBoundsRange:faces:count: */
		vtxSize2 = (slotSizeOf(vertices)) / 3;
		for (i1 = 0; i1 < faceSize; i1 += 1) {
			if ((facePtr[i1]) > vtxSize2) {
				primitiveFail();
				goto l2;
			}
		}
	l2:	/* end checkBoundsRange:faces:count: */;
		vtxSize = (slotSizeOf(vertices)) / 3;
		if ((minIdx < 0)
		 || ((minIdx > maxIdx)
		 || (maxIdx > vtxSize))) {
			return primitiveFail();
		}
	}
	if (failed()) {
		return null;
	}
	ok = b3dDrawRangeElements(handle, mode, minIdx, maxIdx, faceSize,  facePtr);
	if (!ok) {
		return primitiveFail();
	}
	if (!(failed())) {
		pop(methodArgumentCount());
	}
}


/*	Primitive. Enable/disable draw (range) checks */

EXPORT(sqInt)
primitiveEnableDrawRangeChecks(void)
{
    sqInt enabled;

	if ((methodArgumentCount()) == 0) {
		pop(1);
		return pushBool(doRangeChecks);
	}
	if ((methodArgumentCount()) == 1) {
		enabled = booleanValueOf(stackValue(0));
		if (failed()) {
			return null;
		}
		doRangeChecks = enabled;
		return pop(1);
	}
}

EXPORT(sqInt)
primitiveFinishRenderer(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxFinishRenderer(handle);
	if (!result) {
		return primitiveFail();
	}
	return pop(1);
}

EXPORT(sqInt)
primitiveFlushRenderer(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxFlushRenderer(handle);
	if (!result) {
		return primitiveFail();
	}
	return pop(1);
}

EXPORT(sqInt)
primitiveGetIntProperty(void)
{
    sqInt handle;
    sqInt prop;
    sqInt result;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	prop = stackIntegerValue(0);
	handle = stackIntegerValue(1);
	result = b3dxGetIntProperty(handle, prop);
	pop(3);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveGetRendererColorMasks(void)
{
    sqInt array;
    sqInt arrayOop;
    sqInt handle;
    sqInt i;
    int masks[4];
    sqInt result;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	array = stackObjectValue(0);
	handle = stackIntegerValue(1);
	if (failed()) {
		return null;
	}
	if (!((fetchClassOf(array)) == (classArray()))) {
		return primitiveFail();
	}
	if (!((slotSizeOf(array)) == 4)) {
		return primitiveFail();
	}
	result = b3dxGetRendererColorMasks(handle, masks);
	if (!result) {
		return primitiveFail();
	}
	arrayOop = array;
	for (i = 0; i <= 3; i += 1) {
		pushRemappableOop(arrayOop);
		result = positive32BitIntegerFor(masks[i]);
		arrayOop = popRemappableOop();
		storePointerofObjectwithValue(i, arrayOop, result);
	}
	return pop(2);
}

EXPORT(sqInt)
primitiveGetRendererSurfaceDepth(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxGetRendererSurfaceDepth(handle);
	if (result < 0) {
		return primitiveFail();
	}
	pop(2);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveGetRendererSurfaceHandle(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxGetRendererSurfaceHandle(handle);
	if (result < 0) {
		return primitiveFail();
	}
	pop(2);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveGetRendererSurfaceHeight(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxGetRendererSurfaceHeight(handle);
	if (result < 0) {
		return primitiveFail();
	}
	pop(2);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveGetRendererSurfaceWidth(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxGetRendererSurfaceWidth(handle);
	if (result < 0) {
		return primitiveFail();
	}
	pop(2);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveIsOverlayRenderer(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxIsOverlayRenderer(handle);
	pop(2);
	return pushBool(result);
}

EXPORT(sqInt)
primitiveRendererVersion(void)
{
	if (!((methodArgumentCount()) == 0)) {
		return primitiveFail();
	}
	pop(1);
	return pushInteger(1);
}

EXPORT(sqInt)
primitiveRenderVertexBuffer(void)
{
    sqInt flags;
    sqInt handle;
    int *idxArray;
    sqInt idxCount;
    sqInt primType;
    sqInt result;
    sqInt texHandle;
    float *vtxArray;
    sqInt vtxCount;

	if (!((methodArgumentCount()) == 8)) {
		return primitiveFail();
	}
	idxCount = stackIntegerValue(0);
	vtxCount = stackIntegerValue(2);
	texHandle = stackIntegerValue(4);
	flags = stackIntegerValue(5);
	primType = stackIntegerValue(6);
	handle = stackIntegerValue(7);
	if (failed()) {
		return null;
	}
	vtxArray = stackPrimitiveVertexArrayofSize(3, vtxCount);
	idxArray = stackPrimitiveIndexArrayofSizevalidateforVertexSize(1, idxCount, 1, vtxCount);
	if ((vtxArray == null)
	 || ((idxArray == null)
	 || ((primType < 1)
	 || ((primType > 6)
	 || (failed()))))) {
		return primitiveFail();
	}
	result = b3dxRenderVertexBuffer(handle, primType, flags, texHandle, vtxArray, vtxCount, idxArray, idxCount);
	if (!result) {
		return primitiveFail();
	}
	return pop(8);
}


/*	Primitive. Set the buffer rectangle (e.g., the pixel area on screen) to
	use for this renderer.
	The viewport is positioned within the buffer rectangle.
 */

EXPORT(sqInt)
primitiveSetBufferRect(void)
{
    sqInt h;
    sqInt handle;
    sqInt result;
    sqInt w;
    sqInt x;
    sqInt y;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFail();
	}
	h = stackIntegerValue(0);
	w = stackIntegerValue(1);
	y = stackIntegerValue(2);
	x = stackIntegerValue(3);
	handle = stackIntegerValue(4);
	if (failed()) {
		return null;
	}
	result = b3dxSetBufferRect(handle, x, y, w, h);
	if (!result) {
		return primitiveFail();
	}
	return pop(5);
}

EXPORT(sqInt)
primitiveSetFog(void)
{
    double density;
    sqInt fogType;
    sqInt handle;
    sqInt result;
    sqInt rgba;
    double start;
    double stop;

	if (!((methodArgumentCount()) == 6)) {
		return primitiveFail();
	}
	rgba = positive32BitValueOf(stackValue(0));
	stop = floatValueOf(stackValue(1));
	start = floatValueOf(stackValue(2));
	density = floatValueOf(stackValue(3));
	fogType = stackIntegerValue(4);
	handle = stackIntegerValue(5);
	if (failed()) {
		return null;
	}
	result = b3dxSetFog(handle, fogType, density, start, stop, rgba);
	if (!result) {
		return primitiveFail();
	}
	return pop(6);
}

EXPORT(sqInt)
primitiveSetIntProperty(void)
{
    sqInt handle;
    sqInt prop;
    sqInt result;
    sqInt value;

	if (!((methodArgumentCount()) == 3)) {
		return primitiveFail();
	}
	value = stackIntegerValue(0);
	prop = stackIntegerValue(1);
	handle = stackIntegerValue(2);
	result = b3dxSetIntProperty(handle, prop, value);
	if (!result) {
		return primitiveFail();
	}
	return pop(3);
}

EXPORT(sqInt)
primitiveSetLights(void)
{
    sqInt handle;
    sqInt i;
    void*light;
    sqInt lightArray;
    sqInt lightCount;
    sqInt lightOop;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	lightArray = stackLightArrayValue(0);
	handle = stackIntegerValue(1);
	if (failed()) {
		return null;
	}
	if (!(b3dxDisableLights(handle))) {
		return primitiveFail();
	}
	if (lightArray == null) {
		return null;
	}

	/* For each enabled light source */

	lightCount = slotSizeOf(lightArray);
	for (i = 0; i < lightCount; i += 1) {
		/* begin fetchLightSource:ofObject: */
		lightOop = fetchPointerofObject(i, lightArray);
		light = firstIndexableField(lightOop);
		if (!(b3dxLoadLight(handle, i, light))) {
			return primitiveFail();
		}
	}
	return pop(2);
}

EXPORT(sqInt)
primitiveSetMaterial(void)
{
    sqInt handle;
    void*material;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	material = stackMaterialValue(0);
	handle = stackIntegerValue(1);
	if (!(b3dxLoadMaterial(handle, material))) {
		return primitiveFail();
	}
	return pop(2);
}


/*	Transform an entire vertex buffer using the supplied modelview and
	projection matrix.
 */

EXPORT(sqInt)
primitiveSetTransform(void)
{
    sqInt handle;
    float *modelViewMatrix;
    float *projectionMatrix;

	if (!((methodArgumentCount()) == 3)) {
		return primitiveFail();
	}
	projectionMatrix = stackMatrix(0);
	modelViewMatrix = stackMatrix(1);
	handle = stackIntegerValue(2);
	if (failed()) {
		return null;
	}
	b3dxSetTransform(handle, modelViewMatrix, projectionMatrix);
	return pop(3);
}

EXPORT(sqInt)
primitiveSetVerboseLevel(void)
{
    sqInt level;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	level = stackIntegerValue(0);
	result = b3dxSetVerboseLevel(level);
	pop(2);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveSetViewport(void)
{
    sqInt h;
    sqInt handle;
    sqInt result;
    sqInt w;
    sqInt x;
    sqInt y;

	if (!((methodArgumentCount()) == 5)) {
		return primitiveFail();
	}
	h = stackIntegerValue(0);
	w = stackIntegerValue(1);
	y = stackIntegerValue(2);
	x = stackIntegerValue(3);
	handle = stackIntegerValue(4);
	if (failed()) {
		return null;
	}
	result = b3dxSetViewport(handle, x, y, w, h);
	if (!result) {
		return primitiveFail();
	}
	return pop(5);
}

EXPORT(sqInt)
primitiveSwapRendererBuffers(void)
{
    sqInt handle;
    sqInt result;

	if (!((methodArgumentCount()) == 1)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	if (failed()) {
		return null;
	}
	result = b3dxSwapRendererBuffers(handle);
	if (!result) {
		return primitiveFail();
	}
	return pop(1);
}

EXPORT(sqInt)
primitiveTextureByteSex(void)
{
    sqInt handle;
    sqInt renderer;
    sqInt result;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	renderer = stackIntegerValue(1);
	if (failed()) {
		return null;
	}
	result = b3dxTextureByteSex(renderer, handle);
	if (result < 0) {
		return primitiveFail();
	}
	pop(3);
	return pushBool(result);
}

EXPORT(sqInt)
primitiveTextureDepth(void)
{
    sqInt handle;
    sqInt renderer;
    sqInt result;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	renderer = stackIntegerValue(1);
	if (failed()) {
		return null;
	}
	result = b3dxActualTextureDepth(renderer, handle);
	if (result < 0) {
		return primitiveFail();
	}
	pop(3);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveTextureGetColorMasks(void)
{
    sqInt array;
    sqInt arrayOop;
    sqInt handle;
    sqInt i;
    int masks[4];
    sqInt renderer;
    sqInt result;

	if (!((methodArgumentCount()) == 3)) {
		return primitiveFail();
	}
	array = stackObjectValue(0);
	handle = stackIntegerValue(1);
	renderer = stackIntegerValue(2);
	if (failed()) {
		return null;
	}
	if (!((fetchClassOf(array)) == (classArray()))) {
		return primitiveFail();
	}
	if (!((slotSizeOf(array)) == 4)) {
		return primitiveFail();
	}
	result = b3dxTextureColorMasks(renderer, handle, masks);
	if (!result) {
		return primitiveFail();
	}
	arrayOop = array;
	for (i = 0; i <= 3; i += 1) {
		pushRemappableOop(arrayOop);
		result = positive32BitIntegerFor(masks[i]);
		arrayOop = popRemappableOop();
		storePointerofObjectwithValue(i, arrayOop, result);
	}
	return pop(3);
}

EXPORT(sqInt)
primitiveTextureSurfaceHandle(void)
{
    sqInt handle;
    sqInt renderer;
    sqInt result;

	if (!((methodArgumentCount()) == 2)) {
		return primitiveFail();
	}
	handle = stackIntegerValue(0);
	renderer = stackIntegerValue(1);
	if (failed()) {
		return null;
	}
	result = b3dxTextureSurfaceHandle(renderer, handle);
	if (result < 0) {
		return primitiveFail();
	}
	pop(3);
	return pushInteger(result);
}

EXPORT(sqInt)
primitiveTextureUpload(void)
{
    sqInt bits;
    void*bitsPtr;
    sqInt d;
    sqInt form;
    sqInt h;
    sqInt handle;
    sqInt ppw;
    sqInt renderer;
    sqInt result;
    sqInt w;

	if (!((methodArgumentCount()) == 3)) {
		return primitiveFail();
	}
	form = stackValue(0);
	if (!((isPointers(form))
		 && ((slotSizeOf(form)) >= 4))) {
		return primitiveFail();
	}
	bits = fetchPointerofObject(0, form);
	w = fetchIntegerofObject(1, form);
	h = fetchIntegerofObject(2, form);
	d = fetchIntegerofObject(3, form);
	ppw = 32 / d;
	if (!(isWords(bits))) {
		return primitiveFail();
	}
	if (!((slotSizeOf(bits)) == ((((w + ppw) - 1) / ppw) * h))) {
		return primitiveFail();
	}
	bitsPtr = firstIndexableField(bits);
	handle = stackIntegerValue(1);
	renderer = stackIntegerValue(2);
	if (failed()) {
		return null;
	}
	result = b3dxUploadTexture(renderer, handle, w, h, d, bitsPtr);
	if (!result) {
		return primitiveFail();
	}
	return pop(3);
}


/*	Note: This is coded so that it can be run in Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		booleanValueOf = interpreterProxy->booleanValueOf;
		classArray = interpreterProxy->classArray;
		failed = interpreterProxy->failed;
		fetchClassOf = interpreterProxy->fetchClassOf;
		fetchIntegerofObject = interpreterProxy->fetchIntegerofObject;
		fetchPointerofObject = interpreterProxy->fetchPointerofObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		floatValueOf = interpreterProxy->floatValueOf;
		isArray = interpreterProxy->isArray;
		isPointers = interpreterProxy->isPointers;
		isWords = interpreterProxy->isWords;
		methodArgumentCount = interpreterProxy->methodArgumentCount;
		nilObject = interpreterProxy->nilObject;
		pop = interpreterProxy->pop;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		positive32BitValueOf = interpreterProxy->positive32BitValueOf;
		primitiveFail = interpreterProxy->primitiveFail;
		pushBool = interpreterProxy->pushBool;
		pushInteger = interpreterProxy->pushInteger;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		slotSizeOf = interpreterProxy->slotSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

EXPORT(sqInt)
shutdownModule(void)
{
	return b3dxShutdown();
}


/*	Load an Array of B3DPrimitiveLights from the given stack index */

static sqInt
stackLightArrayValue(sqInt stackIndex)
{
    sqInt array;
    sqInt arraySize;
    sqInt i;
    sqInt oop;

	array = stackObjectValue(stackIndex);
	if (array == null) {
		return null;
	}
	if (array == (nilObject())) {
		return null;
	}
	if (!(isArray(array))) {
		return primitiveFail();
	}
	arraySize = slotSizeOf(array);
	for (i = 0; i < arraySize; i += 1) {
		oop = fetchPointerofObject(i, array);
		if (!((isWords(oop))
			 && ((slotSizeOf(oop)) == 32))) {
			return primitiveFail();
		}
	}
	return array;
}


/*	Load a B3DMaterial from the given stack index */

static void *
stackMaterialValue(sqInt stackIndex)
{
    sqInt oop;

	oop = stackObjectValue(stackIndex);
	if (oop == null) {
		return null;
	}
	if (oop == (nilObject())) {
		return null;
	}
	if ((isWords(oop))
	 && ((slotSizeOf(oop)) == 17)) {
		return firstIndexableField(oop);
	}
	return null;
}


/*	Load a 4x4 transformation matrix from the interpreter stack.
	Return a pointer to the matrix data if successful, nil otherwise. */

static void*
stackMatrix(sqInt index)
{
    sqInt oop;

	oop = stackObjectValue(index);
	if (oop == null) {
		return null;
	}
	if ((isWords(oop))
	 && ((slotSizeOf(oop)) == 16)) {
		return firstIndexableField(oop);
	}
	return null;
}


/*	Load a primitive index array from the interpreter stack.
	If aBool is true then check that all the indexes are in the range
	(1,maxIndex). Return a pointer to the index data if successful, nil
	otherwise. 
 */

static void*
stackPrimitiveIndexArrayofSizevalidateforVertexSize(sqInt stackIndex, sqInt nItems, sqInt aBool, sqInt maxIndex)
{
    sqInt i;
    int *idxPtr;
    sqInt index;
    sqInt oop;
    sqInt oopSize;

	oop = stackObjectValue(stackIndex);
	if (oop == null) {
		return null;
	}
	if (!(isWords(oop))) {
		return null;
	}
	oopSize = slotSizeOf(oop);
	if (oopSize < nItems) {
		return null;
	}
	idxPtr = ((int *) (firstIndexableField(oop)));
	if (aBool) {
		for (i = 0; i < nItems; i += 1) {
			index = idxPtr[i];
			if ((index < 0)
			 || (index > maxIndex)) {
				return null;
			}
		}
	}
	return idxPtr;
}


/*	Load a primitive vertex array from the interpreter stack.
	Return a pointer to the vertex data if successful, nil otherwise. */

static void*
stackPrimitiveVertexArrayofSize(sqInt index, sqInt nItems)
{
    sqInt oop;
    sqInt oopSize;

	oop = stackObjectValue(index);
	if (oop == null) {
		return null;
	}
	if (isWords(oop)) {
		oopSize = slotSizeOf(oop);
		if (((oopSize >= nItems) * 16)
		 && ((oopSize % 16) == 0)) {
			return firstIndexableField(oop);
		}
	}
	return null;
}


/*	Load a primitive vertex from the interpreter stack.
	Return a pointer to the vertex data if successful, nil otherwise. */

static void*
stackPrimitiveVertex(sqInt index)
{
    sqInt oop;

	oop = stackObjectValue(index);
	if (oop == null) {
		return null;
	}
	if ((isWords(oop))
	 && ((slotSizeOf(oop)) == 16)) {
		return firstIndexableField(oop);
	}
	return null;
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* B3DAcceleratorPlugin_exports[][3] = {
	{"B3DAcceleratorPlugin", "getModuleName", (void*)getModuleName},
	{"B3DAcceleratorPlugin", "initialiseModule", (void*)initialiseModule},
	{"B3DAcceleratorPlugin", "primitiveAllocateTexture\000\000", (void*)primitiveAllocateTexture},
	{"B3DAcceleratorPlugin", "primitiveClearDepthBuffer\000\000", (void*)primitiveClearDepthBuffer},
	{"B3DAcceleratorPlugin", "primitiveClearViewport\000\000", (void*)primitiveClearViewport},
	{"B3DAcceleratorPlugin", "primitiveCompositeTexture\000\000", (void*)primitiveCompositeTexture},
	{"B3DAcceleratorPlugin", "primitiveCreateRenderer\000\000", (void*)primitiveCreateRenderer},
	{"B3DAcceleratorPlugin", "primitiveCreateRendererFlags\000\000", (void*)primitiveCreateRendererFlags},
	{"B3DAcceleratorPlugin", "primitiveDestroyRenderer\000\000", (void*)primitiveDestroyRenderer},
	{"B3DAcceleratorPlugin", "primitiveDestroyTexture\000\000", (void*)primitiveDestroyTexture},
	{"B3DAcceleratorPlugin", "primitiveDrawArrays\000\001", (void*)primitiveDrawArrays},
	{"B3DAcceleratorPlugin", "primitiveDrawElements\000\001", (void*)primitiveDrawElements},
	{"B3DAcceleratorPlugin", "primitiveDrawRangeElements\000\001", (void*)primitiveDrawRangeElements},
	{"B3DAcceleratorPlugin", "primitiveEnableDrawRangeChecks\000\377", (void*)primitiveEnableDrawRangeChecks},
	{"B3DAcceleratorPlugin", "primitiveFinishRenderer\000\000", (void*)primitiveFinishRenderer},
	{"B3DAcceleratorPlugin", "primitiveFlushRenderer\000\000", (void*)primitiveFlushRenderer},
	{"B3DAcceleratorPlugin", "primitiveGetIntProperty\000\000", (void*)primitiveGetIntProperty},
	{"B3DAcceleratorPlugin", "primitiveGetRendererColorMasks\000\000", (void*)primitiveGetRendererColorMasks},
	{"B3DAcceleratorPlugin", "primitiveGetRendererSurfaceDepth\000\000", (void*)primitiveGetRendererSurfaceDepth},
	{"B3DAcceleratorPlugin", "primitiveGetRendererSurfaceHandle\000\000", (void*)primitiveGetRendererSurfaceHandle},
	{"B3DAcceleratorPlugin", "primitiveGetRendererSurfaceHeight\000\000", (void*)primitiveGetRendererSurfaceHeight},
	{"B3DAcceleratorPlugin", "primitiveGetRendererSurfaceWidth\000\000", (void*)primitiveGetRendererSurfaceWidth},
	{"B3DAcceleratorPlugin", "primitiveIsOverlayRenderer\000\000", (void*)primitiveIsOverlayRenderer},
	{"B3DAcceleratorPlugin", "primitiveRendererVersion\000\377", (void*)primitiveRendererVersion},
	{"B3DAcceleratorPlugin", "primitiveRenderVertexBuffer\000\001", (void*)primitiveRenderVertexBuffer},
	{"B3DAcceleratorPlugin", "primitiveSetBufferRect\000\000", (void*)primitiveSetBufferRect},
	{"B3DAcceleratorPlugin", "primitiveSetFog\000\000", (void*)primitiveSetFog},
	{"B3DAcceleratorPlugin", "primitiveSetIntProperty\000\000", (void*)primitiveSetIntProperty},
	{"B3DAcceleratorPlugin", "primitiveSetLights\000\001", (void*)primitiveSetLights},
	{"B3DAcceleratorPlugin", "primitiveSetMaterial\000\000", (void*)primitiveSetMaterial},
	{"B3DAcceleratorPlugin", "primitiveSetTransform\000\000", (void*)primitiveSetTransform},
	{"B3DAcceleratorPlugin", "primitiveSetVerboseLevel\000\000", (void*)primitiveSetVerboseLevel},
	{"B3DAcceleratorPlugin", "primitiveSetViewport\000\000", (void*)primitiveSetViewport},
	{"B3DAcceleratorPlugin", "primitiveSwapRendererBuffers\000\000", (void*)primitiveSwapRendererBuffers},
	{"B3DAcceleratorPlugin", "primitiveTextureByteSex\000\000", (void*)primitiveTextureByteSex},
	{"B3DAcceleratorPlugin", "primitiveTextureDepth\000\000", (void*)primitiveTextureDepth},
	{"B3DAcceleratorPlugin", "primitiveTextureGetColorMasks\000\000", (void*)primitiveTextureGetColorMasks},
	{"B3DAcceleratorPlugin", "primitiveTextureSurfaceHandle\000\000", (void*)primitiveTextureSurfaceHandle},
	{"B3DAcceleratorPlugin", "primitiveTextureUpload\000\002", (void*)primitiveTextureUpload},
	{"B3DAcceleratorPlugin", "setInterpreter", (void*)setInterpreter},
	{"B3DAcceleratorPlugin", "shutdownModule\000\377", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#else /* ifdef SQ_BUILTIN_PLUGIN */

signed char primitiveAllocateTextureAccessorDepth = 0;
signed char primitiveClearDepthBufferAccessorDepth = 0;
signed char primitiveClearViewportAccessorDepth = 0;
signed char primitiveCompositeTextureAccessorDepth = 0;
signed char primitiveCreateRendererAccessorDepth = 0;
signed char primitiveCreateRendererFlagsAccessorDepth = 0;
signed char primitiveDestroyRendererAccessorDepth = 0;
signed char primitiveDestroyTextureAccessorDepth = 0;
signed char primitiveDrawArraysAccessorDepth = 1;
signed char primitiveDrawElementsAccessorDepth = 1;
signed char primitiveDrawRangeElementsAccessorDepth = 1;
signed char primitiveFinishRendererAccessorDepth = 0;
signed char primitiveFlushRendererAccessorDepth = 0;
signed char primitiveGetIntPropertyAccessorDepth = 0;
signed char primitiveGetRendererColorMasksAccessorDepth = 0;
signed char primitiveGetRendererSurfaceDepthAccessorDepth = 0;
signed char primitiveGetRendererSurfaceHandleAccessorDepth = 0;
signed char primitiveGetRendererSurfaceHeightAccessorDepth = 0;
signed char primitiveGetRendererSurfaceWidthAccessorDepth = 0;
signed char primitiveIsOverlayRendererAccessorDepth = 0;
signed char primitiveRenderVertexBufferAccessorDepth = 1;
signed char primitiveSetBufferRectAccessorDepth = 0;
signed char primitiveSetFogAccessorDepth = 0;
signed char primitiveSetIntPropertyAccessorDepth = 0;
signed char primitiveSetLightsAccessorDepth = 1;
signed char primitiveSetMaterialAccessorDepth = 0;
signed char primitiveSetTransformAccessorDepth = 0;
signed char primitiveSetVerboseLevelAccessorDepth = 0;
signed char primitiveSetViewportAccessorDepth = 0;
signed char primitiveSwapRendererBuffersAccessorDepth = 0;
signed char primitiveTextureByteSexAccessorDepth = 0;
signed char primitiveTextureDepthAccessorDepth = 0;
signed char primitiveTextureGetColorMasksAccessorDepth = 0;
signed char primitiveTextureSurfaceHandleAccessorDepth = 0;
signed char primitiveTextureUploadAccessorDepth = 2;

#endif /* ifdef SQ_BUILTIN_PLUGIN */
