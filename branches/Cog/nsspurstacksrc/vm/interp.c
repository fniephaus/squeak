/* Automatically generated by
	CCodeGeneratorGlobalStructure VMMaker.oscog-eem.1590 uuid: 02c40a2c-a23e-4e62-98c0-810aeeba31c8
   from
	StackInterpreter VMMaker.oscog-eem.1590 uuid: 02c40a2c-a23e-4e62-98c0-810aeeba31c8
 */
static char __buildInfo[] = "StackInterpreter VMMaker.oscog-eem.1590 uuid: 02c40a2c-a23e-4e62-98c0-810aeeba31c8 " __DATE__ ;
char *__interpBuildInfo = __buildInfo;



#if USE_GLOBAL_STRUCT
# define SQ_USE_GLOBAL_STRUCT 1
#else
# define SQ_USE_GLOBAL_STRUCT 0
#endif
#if USE_GLOBAL_STRUCT_REG 
# define SQ_USE_GLOBAL_STRUCT_REG 1
#else
# define SQ_USE_GLOBAL_STRUCT_REG 0
#endif

#include <stddef.h> /* for e.g. alloca */
#include <setjmp.h>
#include <wchar.h> /* for wint_t */
#include "sq.h"
#include "vmCallback.h"
#include "sqMemoryFence.h"
#include "dispdbg.h"
#include "sqMemoryAccess.h"


/* StackInterpreter class>>preambleCCode */
/* Disable Intel compiler inlining of warning which is used for breakpoints */
#pragma auto_inline off
sqInt warnpid, erroronwarn;
void
warning(char *s) { /* Print an error message but don't necessarily exit. */
	if (erroronwarn) error(s);
	if (warnpid)
		printf("\n%s pid %ld\n", s, (long)warnpid);
	else
		printf("\n%s\n", s);
}
void
warningat(char *s, int l) { /* ditto with line number. */
	/* use alloca to call warning so one does not have to remember to set two breakpoints... */
	char *sl = alloca(strlen(s) + 16);
	sprintf(sl, "%s %d", s, l);
	warning(sl);
}
#pragma auto_inline on

void
invalidCompactClassError(char *s) { /* Print a (compact) class index error message and exit. */
#if SPURVM
	printf("\nClass %s does not have the required class index\n", s);
#else
	printf("\nClass %s does not have the required compact class index\n", s);
#endif
	exit(-1);
}

/*
 * Define sigsetjmp and siglongjmp to be the most minimal setjmp/longjmp available on the platform.
 */
#if WIN32
# define sigsetjmp(jb,ssmf) setjmp(jb)
# define siglongjmp(jb,v) longjmp(jb,v)
#else
# define sigsetjmp(jb,ssmf) _setjmp(jb)
# define siglongjmp(jb,v) _longjmp(jb,v)
#endif

/* end StackInterpreter class>>preambleCCode */

typedef struct {
	usqInt	segStart;
	usqInt	segSize;
	sqInt	swizzle;
	usqInt	containsPinned;
	usqInt	savedSegSize;
	usqInt	lastFreeObject;
 } SpurSegmentInfo;


typedef struct {
	usqInt	start;
	usqInt	limit;
 } SpurNewSpaceSpace;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	first;
	usqInt	last;
 } SpurCircularBuffer;


typedef struct {
	usqInt	start;
	usqInt	limit;
	usqInt	top;
 } SpurContiguousObjStack;


typedef struct _StackPage {
	char *stackLimit;
	char *headSP;
	char *headFP;
	char *baseFP;
	char *baseAddress;
	char *realStackLimit;
	char *lastAddress;
	int	trace;
	struct _StackPage *nextPage;
	struct _StackPage *prevPage;
 } StackPage;

#define CogStackPage StackPage



/*** Constants ***/
#define AccessModifierPrivate 1
#define AccessModifierProtected 2
#define AccessModifierPublic 0
#define ActiveProcessIndex 1
#define AlternateHeaderHasPrimFlag 0x20000
#define AlternateHeaderNumLiteralsMask 0x7FFF
#define AltLongStoreBytecode 234
#define AtCacheFixedFields 4
#define AtCacheFmt 3
#define AtCacheMask 0x1C
#define AtCacheOop 1
#define AtCacheSize 2
#define AtCacheTotalSize 64
#define AtPutBase 32
#define BecameActiveClassFlag 8
#define BecameCompiledMethodFlag 2
#define BecamePointerObjectFlag 1
#define Byte0Mask 0xFF
#define Byte1Mask 0xFF00
#define Byte1Shift 8
#define Byte1ShiftNegated -8
#define Byte2Mask 0xFF0000
#define Byte3Mask 0xFF000000UL
#define Byte3Shift 24
#define Byte3ShiftNegated -24
#define CacheProbeMax 3
#define CharacterTable null
#define CharacterValueIndex 0
#define ClassAlien 52
#define ClassArray 7
#define ClassArrayCompactIndex 51
#define ClassBitmap 4
#define ClassBlockClosure 36
#define ClassBlockClosureCompactIndex 37
#define ClassByteArray 26
#define ClassByteString 6
#define ClassByteStringCompactIndex 52
#define ClassCharacter 19
#define ClassExternalAddress 43
#define ClassExternalData 45
#define ClassExternalFunction 46
#define ClassExternalLibrary 47
#define ClassExternalStructure 44
#define ClassFloat 9
#define ClassFloatCompactIndex 34
#define ClassLargeNegativeInteger 42
#define ClassLargeNegativeIntegerCompactIndex 32
#define ClassLargePositiveInteger 13
#define ClassLargePositiveIntegerCompactIndex 33
#define ClassMessage 15
#define ClassMessageCompactIndex 35
#define ClassMethodContext 10
#define ClassMethodContextCompactIndex 36
#define ClassMutex 39
#define ClassPoint 12
#define ClassSemaphore 18
#define ClassSmallInteger 5
#define ClassUnsafeAlien 54
#define ClosureFirstCopiedValueIndex 3
#define ClosureIndex 4
#define ClosureNumArgsIndex 2
#define ClosureOuterContextIndex 0
#define ClosureStartPCIndex 1
#define CompactionPassesForGC 2
#define CompactionPassesForSnapshot 3
#define ConstMinusOne 0xFFFFFFFFUL
#define ConstOne 3
#define ConstTwo 5
#define ConstZero 1
#define CrossedX 258
#define CtxtTempFrameStart 6
#define DumpStackOnLowSpace 0
#define EnclosingMixinIndex 3
#define EnclosingObjectIndex 4
#define EndOfRun 0x101
#if !defined(EnforceAccessControl) /* Allow EnforceAccessControl to be overridden on the compiler command line */
# define EnforceAccessControl 1
#endif
#define ExcessSignalsIndex 2
#define ExternalObjectsArray 38
#define ExtraRootsSize 2048
#define FailImbalancedPrimitives 0
#define FalseObject 1
#define FirstLinkIndex 0
#define FoxCallerContext 4
#define FoxCallerSavedIP 4
#define FoxFrameFlags -8
#define FoxMethod -4
#define FoxReceiver -16
#define FoxSavedFP 0
#define FoxThisContext -12
#define FrameSlots 6
#define GCModeBecome 8
#define GCModeFull 1
#define GCModeImageSegment 16
#define GCModeIncremental 4
#define GCModeNewSpace 2
#define HeaderIndex 0
#define InstanceSpecificationIndex 2
#define InstructionPointerIndex 1
#define KeyIndex 0
#define LargeContextBit 0x40000
#define LargeContextSlots 62
#define LastLinkIndex 1
#define LiteralStart 1
#define LongStoreBytecode 129
#define LookupRuleDynamicSuper 0x101
#define LookupRuleImplicit 0x100
#define LookupRuleMNU 259
#define LookupRuleOrdinary 258
#define MarkObjectsForEnumerationPrimitives 0
#define MarkOnTenure 5
#define MarkStackRootIndex 0x1000
#define MaxExternalPrimitiveTableSize 4096
#define MaxJumpBuf 32
#define MaxPrimitiveIndex 575
#define MaxQuickPrimitiveIndex 519
#define MaxRTRefCount 7
#define MessageArgumentsIndex 1
#define MessageLookupClassIndex 2
#define MessageSelectorIndex 0
#define MethodArrayIndex 1
#define MethodCacheClass 2
#define MethodCacheEntries 0x200
#define MethodCacheEntrySize 4
#define MethodCacheMask 0x7FC
#define MethodCacheMethod 3
#define MethodCachePrimFunction 4
#define MethodCacheSelector 1
#define MethodCacheSize 2048
#define MethodDictionaryIndex 1
#define MethodHeaderArgCountShift 25
#define MethodHeaderFlagBitPosition 29
#define MethodHeaderTempCountShift 19
#define MethodIndex 3
#define MillisecondClockMask 0x1FFFFFFF
#define MixinIndex 3
#define MournQueueRootIndex 4098
#define MULTIPLEBYTECODESETS 1
#define MyListIndex 3
#define NewspeakVM 1
#define NextLinkIndex 0
#define NilObject 0
#define NSMethodCacheActualReceiver 7
#define NSMethodCacheCallingMethod 3
#define NSMethodCacheClassTag 2
#define NSMethodCacheDepthOrLookupRule 4
#define NSMethodCacheMask 0xFF8
#define NSMethodCachePrimFunction 6
#define NSMethodCacheSelector 1
#define NSMethodCacheSize 4096
#define NSMethodCacheTargetMethod 5
#define ObjStackFixedSlots 4
#define ObjStackFreex 2
#define ObjStackLimit 0xFF8
#define ObjStackMyx 1
#define ObjStackNextx 3
#define ObjStackPageSlots 0xFFC
#define ObjStackTopx 0
#define OldBecameNewFlag 4
#define PrimErrBadArgument 3
#define PrimErrBadIndex 4
#define PrimErrBadMethod 12
#define PrimErrBadNumArgs 5
#define PrimErrBadReceiver 2
#define PrimErrGenericFailure 1
#define PrimErrInappropriate 6
#define PrimErrLimitExceeded 15
#define PrimErrNamedInternal 13
#define PrimErrNoCMemory 10
#define PrimErrNoMemory 9
#define PrimErrNotFound 11
#define PrimErrObjectIsPinned 16
#define PrimErrTableIndex 51
#define PrimErrUnsupported 7
#define PrimErrWritePastObject 17
#define PrimitiveExternalCallIndex 117
#define PrimNoErr 0
#define PriorityIndex 2
#define ProcessListsIndex 0
#define ProcessSignalingLowSpace 22
#define ReceiverIndex 5
#define RemapBufferSize 25
#define RememberedSetRootIndex 4099
#define SchedulerAssociation 3
#define SelectorAboutToReturn 48
#define SelectorCannotInterpret 34
#define SelectorCannotReturn 21
#define SelectorDoesNotUnderstand 20
#define SelectorInvokeCallback 53
#define SelectorMustBeBoolean 25
#define SelectorRunWithIn 49
#define SelectorStart 2
#define SelectorUnknownBytecode 57
#define SenderIndex 0
#define SistaVM 0
#define SmallContextSlots 22
#define SpecialSelectors 23
#define StackPageReachedButUntraced 1
#define StackPageTraced 2
#define StackPageTraceInvalid -1
#define StackPageUnreached 0
#define StackPointerIndex 2
#define SuperclassIndex 0
#define SuspendedContextIndex 1
#define TenureByAge 1
#define TenureByClass 2
#define TenureToShrinkRT 3
#define TheDisplay 14
#define TheFinalizationSemaphore 41
#define TheInputSemaphore null
#define TheInterruptSemaphore 30
#define TheLowSpaceSemaphore 17
#define TheTimerSemaphore 29
#define TopHashBit 0x200000
#define TopOopBit 0x80000000UL
#define TrueObject 2
#define V3PrimitiveBitsMask 0x200003FE
#define ValueIndex 1
#define WeaklingStackRootIndex 0x1001
#define XIndex 0
#define YIndex 1


/*** Function Prototypes ***/


#if !PRODUCTION && defined(PlatformNoDbgRegParms)
# define NoDbgRegParms PlatformNoDbgRegParms
#endif

#if !defined(NoDbgRegParms)
# define NoDbgRegParms /*empty*/
#endif



#if !defined(NeverInline)
# define NeverInline /*empty*/
#endif

extern sqInt interpret(void);
static sqInt NoDbgRegParms addressIsInPage(StackPage * self_in_addressIsInPage, char *address);
static sqInt NoDbgRegParms isFree(StackPage * self_in_isFree);
static void NoDbgRegParms freeStackPageNoAssert(StackPage *aPage);
static sqInt NoDbgRegParms freeStackPage(StackPage *aPage);
static void NoDbgRegParms markStackPageMostRecentlyUsed(StackPage *page);
static void NoDbgRegParms markStackPageNextMostRecentlyUsed(StackPage *page);
static StackPage * newStackPage(void);
static sqInt pageListIsWellFormed(void);
static StackPage * NoDbgRegParms stackPageAt(sqInt index);
static StackPage * NoDbgRegParms stackPageFor(void *pointer);
static double statAverageLivePagesWhenMapping(void);
extern char * cStringOrNullFor(sqInt oop);
extern sqInt failed(void);
static sqInt NoDbgRegParms isNegativeIntegerValueOf(sqInt oop);
static sqInt NoDbgRegParms magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative);
static usqLong NoDbgRegParms magnitude64BitValueOf(sqInt oop);
extern usqInt positive32BitValueOf(sqInt oop);
extern usqLong positive64BitValueOf(sqInt oop);
extern unsigned long positiveMachineIntegerValueOf(sqInt oop);
static void primitiveAdd(void);
EXPORT(void) primitiveAddLargeIntegers(void);
static void primitiveAdoptInstance(void);
EXPORT(void) primitiveAllInstances(void);
EXPORT(void) primitiveAllObjects(void);
static void primitiveArctan(void);
static void primitiveArrayBecome(void);
static void primitiveArrayBecomeOneWay(void);
static void primitiveArrayBecomeOneWayCopyHash(void);
static void primitiveAsCharacter(void);
static void primitiveAsFloat(void);
static void primitiveAt(void);
static void primitiveAtPut(void);
static void primitiveBeCursor(void);
static void primitiveBeDisplay(void);
static void primitiveBeep(void);
static void primitiveBehaviorHash(void);
static void primitiveBitAnd(void);
EXPORT(void) primitiveBitAndLargeIntegers(void);
static void primitiveBitOr(void);
EXPORT(void) primitiveBitOrLargeIntegers(void);
static void primitiveBitShift(void);
EXPORT(void) primitiveBitShiftLargeIntegers(void);
static void primitiveBitXor(void);
EXPORT(void) primitiveBitXorLargeIntegers(void);
static void primitiveBytesLeft(void);
static void primitiveCalloutToFFI(void);
static void primitiveChangeClass(void);
static void primitiveClass(void);
static void primitiveClearVMProfile(void);
static void primitiveClipboardText(void);
EXPORT(sqInt) primitiveClockLogAddresses(void);
static void primitiveClosureValue(void);
extern void primitiveClosureValueNoContextSwitch(void);
static void primitiveClosureValueWithArgs(void);
EXPORT(void) primitiveCompareBytes(void);
static void primitiveConstantFill(void);
static void primitiveControlVMProfiling(void);
static void primitiveCopyObject(void);
EXPORT(sqInt) primitiveCrashVM(void);
EXPORT(sqInt) primitiveDisablePowerManager(void);
static void primitiveDiv(void);
static void primitiveDivide(void);
EXPORT(void) primitiveDivideLargeIntegers(void);
EXPORT(void) primitiveDivLargeIntegers(void);
static void primitiveEnterCriticalSection(void);
static void primitiveEqual(void);
EXPORT(void) primitiveEqualLargeIntegers(void);
static void primitiveExitCriticalSection(void);
static void primitiveExitToDebugger(void);
static void primitiveExp(void);
static void primitiveExponent(void);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt primitiveFailureCode(void);
static void primitiveFetchNextMourner(void);
static void primitiveFloatAdd(void);
static void primitiveFloatAt(void);
static void primitiveFloatAtPut(void);
static void primitiveFloatDivide(void);
static void primitiveFloatEqual(void);
static void primitiveFloatGreaterOrEqual(void);
static void primitiveFloatGreaterThan(void);
static void primitiveFloatLessOrEqual(void);
static void primitiveFloatLessThan(void);
static void primitiveFloatMultiply(void);
static void primitiveFloatNotEqual(void);
static void primitiveFloatSubtract(void);
static void primitiveFlushCache(void);
static void primitiveFlushExternalPrimitives(void);
static void primitiveForceDisplayUpdate(void);
static void primitiveFormPrint(void);
static void primitiveFractionalPart(void);
static void primitiveGetAttribute(void);
EXPORT(sqInt) primitiveGetLogDirectory(void);
static void primitiveGetNextEvent(void);
EXPORT(sqInt) primitiveGetWindowLabel(void);
EXPORT(sqInt) primitiveGetWindowSize(void);
static void primitiveGreaterOrEqual(void);
EXPORT(void) primitiveGreaterOrEqualLargeIntegers(void);
static void primitiveGreaterThan(void);
EXPORT(void) primitiveGreaterThanLargeIntegers(void);
static void primitiveGrowMemoryByAtLeast(void);
EXPORT(sqInt) primitiveHeartbeatFrequency(void);
EXPORT(sqInt) primitiveHighResClock(void);
static void primitiveIdentical(void);
static void primitiveIdentityHash(void);
EXPORT(sqInt) primitiveImageFormatVersion(void);
static void primitiveImageName(void);
static void primitiveImmediateAsInteger(void);
static void primitiveInputSemaphore(void);
static void primitiveInputWord(void);
static void primitiveIntegerAt(void);
static void primitiveIntegerAtPut(void);
EXPORT(sqInt) primitiveInterruptChecksPerMSec(void);
static void primitiveInterruptSemaphore(void);
static void primitiveInvokeObjectAsMethod(void);
EXPORT(sqInt) primitiveIsBigEnder(void);
static void primitiveIsPinned(void);
EXPORT(sqInt) primitiveIsWindowObscured(void);
static void primitiveKbdNext(void);
static void primitiveKbdPeek(void);
static void primitiveLessOrEqual(void);
EXPORT(void) primitiveLessOrEqualLargeIntegers(void);
static void primitiveLessThan(void);
EXPORT(void) primitiveLessThanLargeIntegers(void);
static void primitiveListBuiltinModule(void);
static void primitiveListExternalModule(void);
static void primitiveLoadImageSegment(void);
static void primitiveLocalMicrosecondClock(void);
static void primitiveLogN(void);
static void primitiveLowSpaceSemaphore(void);
static void primitiveMakePoint(void);
static void primitiveMaxIdentityHash(void);
extern usqInt primitiveMethod(void);
static void primitiveMillisecondClock(void);
EXPORT(sqInt) primitiveMillisecondClockMask(void);
static void primitiveMod(void);
EXPORT(void) primitiveModLargeIntegers(void);
static void primitiveMouseButtons(void);
static void primitiveMousePoint(void);
static void primitiveMultiply(void);
EXPORT(void) primitiveMultiplyLargeIntegers(void);
static void primitiveNew(void);
static void primitiveNewMethod(void);
static void primitiveNewWithArg(void);
static void primitiveNextInstance(void);
static void primitiveNextObject(void);
static void primitiveNoop(void);
static void primitiveNotEqual(void);
EXPORT(void) primitiveNotEqualLargeIntegers(void);
static void primitiveNotIdentical(void);
static void primitiveObjectAt(void);
static void primitiveObjectAtPut(void);
EXPORT(sqInt) primitiveOriginalMillisecondClock(void);
EXPORT(sqInt) primitivePathToUsing(void);
static void primitivePerformInSuperclass(void);
static void primitivePerformWithArgs(void);
EXPORT(sqInt) primitiveProfilePrimitive(void);
EXPORT(sqInt) primitiveProfileSample(void);
EXPORT(sqInt) primitiveProfileSemaphore(void);
EXPORT(sqInt) primitiveProfileStart(void);
static void primitiveQuit(void);
static void primitiveQuo(void);
EXPORT(void) primitiveQuoLargeIntegers(void);
static void primitiveRelinquishProcessor(void);
EXPORT(void) primitiveRemLargeIntegers(void);
static void primitiveResume(void);
static void primitiveScanCharacters(void);
EXPORT(sqInt) primitiveScreenDepth(void);
static void primitiveScreenSize(void);
static void primitiveSecondsClock(void);
static void primitiveSetDisplayMode(void);
static void primitiveSetFullScreen(void);
static void primitiveSetInterruptKey(void);
EXPORT(sqInt) primitiveSetLogDirectory(void);
static void primitiveSetOrHasIdentityHash(void);
EXPORT(sqInt) primitiveSetWindowLabel(void);
EXPORT(sqInt) primitiveSetWindowSize(void);
static void primitiveShortAt(void);
static void primitiveShortAtPut(void);
static void primitiveShowDisplayRect(void);
static void primitiveSignal(void);
static void primitiveSignalAtBytesLeft(void);
static void primitiveSine(void);
static void primitiveSize(void);
static void primitiveSizeInBytes(void);
static void primitiveSizeInBytesOfInstance(void);
static void primitiveSnapshot(void);
static void primitiveSnapshotEmbedded(void);
static void primitiveSomeInstance(void);
static void primitiveSomeObject(void);
static void primitiveSpecialObjectsOop(void);
static void primitiveSquareRoot(void);
static void primitiveStoreImageSegment(void);
static void primitiveStringAt(void);
static void primitiveStringAtPut(void);
static void primitiveStringReplace(void);
static void primitiveSubtract(void);
EXPORT(void) primitiveSubtractLargeIntegers(void);
static void primitiveSuspend(void);
static void primitiveTestAndSetOwnershipOfCriticalSection(void);
static void primitiveTestDisplayDepth(void);
static void primitiveTimesTwoPower(void);
static void primitiveTruncated(void);
static void primitiveUnloadModule(void);
static void primitiveUpdateTimezone(void);
static void primitiveUTCMicrosecondClock(void);
EXPORT(sqInt) primitiveUtcWithOffset(void);
static void primitiveVMPath(void);
static void primitiveVMProfileSamplesInto(void);
static void primitiveWait(void);
static void primitiveYield(void);
extern sqInt signalNoResume(sqInt aSemaphore);
extern int signed32BitValueOf(sqInt oop);
extern sqLong signed64BitValueOf(sqInt oop);
extern long signedMachineIntegerValueOf(sqInt oop);
extern usqInt sizeOfAlienData(sqInt oop);
extern void * startOfAlienData(sqInt oop);
extern sqInt success(sqInt successBoolean);
static sqInt NoDbgRegParms initializeStacknumSlotspageSize(char *theStackPages, sqInt stackSlots, sqInt slotsPerPage);
static sqInt NoDbgRegParms pageIndexFor(void *pointer);
static sqInt NoDbgRegParms addressAfter(sqInt objOop);
static sqInt NoDbgRegParms allocateSlotsForPinningInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
static sqInt NoDbgRegParms allocateSlotsInOldSpacebytesformatclassIndex(sqInt numSlots, usqInt totalBytes, sqInt formatField, sqInt classIndex);
extern sqInt byteSwapped(sqInt w);
static usqInt NoDbgRegParms bytesInObject(sqInt objOop);
static sqInt NoDbgRegParms changeClassOfto(sqInt rcvr, sqInt argClass);
static double NoDbgRegParms dbgFloatValueOf(sqInt oop);
extern sqInt floatObjectOf(double aFloat);
extern double floatValueOf(sqInt oop);
static sqInt hasSixtyFourBitImmediates(void);
static sqInt NoDbgRegParms initFreeChunkWithBytesat(usqLong numBytes, sqInt address);
static void NoDbgRegParms initSegmentBridgeWithBytesat(usqLong numBytes, sqInt address);
extern sqInt instantiateClassindexableSize(sqInt classObj, usqInt nElements);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt oop);
extern sqInt isIntegerObject(sqInt oop);
extern sqInt isIntegerValue(sqInt intValue);
extern sqInt isMarked(sqInt objOop);
static sqInt NoDbgRegParms lengthOfformat(sqInt objOop, sqInt fmt);
static sqInt maxSlotsForAlloc(void);
static sqInt numFreeLists(void);
static sqInt NoDbgRegParms objectAfterlimit(sqInt objOop, sqInt limit);
static void NoDbgRegParms setIsMarkedOfto(sqInt objOop, sqInt aBoolean);
extern usqInt smallObjectBytesForSlots(sqInt numSlots);
static sqInt wordIndexableFormat(void);
static void NoDbgRegParms NeverInline addToEphemeronList(sqInt ephemeronCorpse);
static void NoDbgRegParms NeverInline addToWeakList(sqInt weakCorpse);
static sqInt allNewSpaceObjectsHaveZeroRTRefCount(void);
static sqInt allWeakSurvivorsOnWeakList(void);
static void NeverInline computeRefCountToShrinkRT(void);
static sqInt NoDbgRegParms copyAndForward(sqInt survivor);
static sqInt NoDbgRegParms NeverInline copyToOldSpacebytesformat(sqInt survivor, sqInt bytesInObject, sqInt formatOfSurvivor);
static sqInt NoDbgRegParms firstCorpse(sqInt headOfCorpseList);
static void growRememberedSet(void);
static sqInt NoDbgRegParms isInRememberedSet(sqInt objOop);
static sqInt NoDbgRegParms isMaybeOldScavengeSurvivor(sqInt oop);
static sqInt NoDbgRegParms isScavengeSurvivor(sqInt oop);
static sqInt NoDbgRegParms isonWeaklingList(sqInt oop, sqInt listHead);
static usqInt newSpaceCapacity(void);
static sqInt noUnfiredEphemeronsAtEndOfRememberedSet(void);
static void processEphemerons(void);
static void processWeaklings(void);
static sqInt NoDbgRegParms processWeakSurvivor(sqInt weakObj);
extern sqInt remember(sqInt objOop);
static void NoDbgRegParms scavengeFutureSurvivorSpaceStartingAt(sqInt initialAddress);
static void scavengeLoop(void);
static sqInt NoDbgRegParms scavengeReferentsOf(sqInt referrer);
static void NoDbgRegParms scavengeRememberedSetStartingAt(sqInt n);
static float scavengerTenuringThreshold(void);
static sqInt scavengeUnfiredEphemeronsOnEphemeronList(void);
static sqInt NoDbgRegParms accessibleObjectAfter(sqInt objOop);
static sqInt NoDbgRegParms NeverInline activeAndDeferredScan(sqInt anEphemeron);
static void NoDbgRegParms addFreeSubTree(sqInt freeTree);
extern sqInt addGCRoot(sqInt *varLoc);
extern sqInt addressCouldBeObj(sqInt address);
extern sqInt addressCouldBeOop(sqInt address);
static sqInt NoDbgRegParms addToFreeListbytes(sqInt freeChunk, sqInt chunkBytes);
static sqInt NoDbgRegParms addToFreeTreebytes(sqInt freeChunk, sqInt chunkBytes);
static sqInt NoDbgRegParms allInstancesOf(sqInt aClass);
static sqInt allObjects(void);
static sqInt allObjectsUnmarked(void);
static sqInt allOldMarkedWeakObjectsOnWeaklingStack(void);
static sqInt allocateLargestFreeChunk(void);
static sqInt NoDbgRegParms allocateNewSpaceSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static sqInt NoDbgRegParms allocateOldSpaceChunkOfBytes(usqInt chunkBytes);
extern sqInt allocatePinnedSlots(sqInt nSlots);
static sqInt allocationUnit(void);
static sqInt NoDbgRegParms allStrongSlotsOfWeaklingAreMarked(sqInt aWeakling);
static sqInt allUnscannedEphemeronsAreActive(void);
static sqInt arrayClassIndexPun(void);
extern sqInt arrayFormat(void);
static sqInt NoDbgRegParms becomeEffectFlagsFor(sqInt objOop);
extern sqInt becomewith(sqInt array1, sqInt array2);
static sqInt NoDbgRegParms becomewithtwoWaycopyHash(sqInt array1, sqInt array2, sqInt twoWayFlag, sqInt copyHashFlag);
extern void beRootIfOld(sqInt oop);
static sqInt bitsSetInFreeSpaceMaskForAllFreeLists(void);
static sqInt bridgeSize(void);
static sqInt byteFormatMask(void);
extern sqInt byteSizeOf(sqInt oop);
extern sqInt characterObjectOf(sqInt characterCode);
extern void characterTable(void);
extern sqInt characterValueOf(sqInt oop);
extern sqInt checkedLongAt(sqInt byteAddress);
static sqInt NoDbgRegParms checkHeapIntegrityclassIndicesShouldBeValid(sqInt excludeUnmarkedNewSpaceObjs, sqInt classIndicesShouldBeValid);
extern sqInt checkOkayOop(usqInt oop);
extern sqInt checkOopHasOkayClass(usqInt obj);
static sqInt NoDbgRegParms checkOopIntegritynamed(sqInt obj, char *name);
static sqInt NoDbgRegParms checkOopIntegritynamedindex(sqInt obj, char *name, sqInt i);
extern sqInt checkTraversableSortedFreeList(void);
extern sqInt classAlien(void);
extern sqInt classArray(void);
extern sqInt classAtIndex(sqInt classIndex);
static sqInt NoDbgRegParms classAtIndexput(sqInt classIndex, sqInt objOop);
extern sqInt classBitmap(void);
extern sqInt classByteArray(void);
extern sqInt classCharacter(void);
extern sqInt classExternalAddress(void);
extern sqInt classExternalData(void);
extern sqInt classExternalFunction(void);
extern sqInt classExternalLibrary(void);
extern sqInt classExternalStructure(void);
extern sqInt classFloat(void);
static sqInt classIndexFieldWidth(void);
extern sqInt classIndexOf(sqInt objOop);
extern sqInt classLargeNegativeInteger(void);
extern sqInt classLargePositiveInteger(void);
extern sqInt classOrNilAtIndex(sqInt classIndex);
extern sqInt classPoint(void);
extern sqInt classSemaphore(void);
extern sqInt classSmallInteger(void);
extern sqInt classString(void);
extern sqInt classTableMinorIndexMask(void);
extern sqInt classTablePageSize(void);
extern sqInt classTableRootObj(void);
static sqInt classTableRootSlots(void);
extern sqInt classTagForClass(sqInt classObj);
extern sqInt classUnsafeAlien(void);
static void clearLeakMapAndMapAccessibleObjects(void);
static sqInt NoDbgRegParms cloneInOldSpaceForPinning(sqInt objOop);
extern sqInt clone(sqInt objOop);
static void NeverInline compact(void);
extern sqInt compactClassIndexOf(sqInt objOop);
static sqInt NoDbgRegParms copyObjtoAddrstartAtstopAt(sqInt objOop, sqInt segAddr, sqInt segStart, sqInt endSeg);
extern void countMarkedAndUnmarkdObjects(sqInt printFlags);
static sqInt defaultEdenBytes(void);
static void NoDbgRegParms detachFreeObject(sqInt freeChunk);
extern sqInt displayObject(void);
static void NoDbgRegParms doScavenge(sqInt tenuringCriterion);
extern sqInt eeInstantiateClassIndexformatnumSlots(sqInt knownClassIndex, sqInt objFormat, sqInt numSlots);
static void eliminateAndFreeForwardersForPigCompact(void);
static void NoDbgRegParms emptyObjStack(sqInt objStack);
static sqInt NoDbgRegParms ensureBehaviorHash(sqInt aBehavior);
static sqInt NoDbgRegParms ensureRoomOnObjStackAt(sqInt objStackRootIndex);
static sqInt NoDbgRegParms enterIntoClassTable(sqInt aBehavior);
static sqInt ephemeronFormat(void);
static sqInt NoDbgRegParms existInstancesInNewSpaceOf(sqInt classObj);
static void NoDbgRegParms expungeFromClassTable(sqInt aBehavior);
extern sqInt falseObject(void);
extern sqInt fetchByteofObject(sqInt byteIndex, sqInt objOop);
static sqInt NoDbgRegParms NeverInline fetchClassOfNonImm(sqInt objOop);
extern sqInt fetchClassOf(sqInt oop);
static sqInt NoDbgRegParms fetchClassTagOfNonImm(sqInt obj);
extern sqInt fetchLong32ofObject(sqInt fieldIndex, sqInt oop);
static sqInt NoDbgRegParms fetchPointerofFreeChunk(sqInt fieldIndex, sqInt objOop);
extern sqInt fetchPointerofObject(sqInt fieldIndex, sqInt objOop);
static sqInt findLargestFreeChunk(void);
extern void findStringBeginningWith(char *aCString);
extern void findString(char *aCString);
static sqInt firstAccessibleObject(void);
static void * NoDbgRegParms firstFixedFieldOfMaybeImmediate(sqInt oop);
extern void * firstFixedField(sqInt objOop);
extern void * firstIndexableField(sqInt objOop);
extern sqInt fixedFieldsOfClassFormatMask(void);
static sqInt NoDbgRegParms fixedFieldsOfformatlength(sqInt objOop, sqInt fmt, sqInt wordLength);
static sqInt NoDbgRegParms NeverInline fixFollowedFieldofObjectwithInitialValue(sqInt fieldIndex, sqInt anObject, sqInt initialValue);
static sqInt NoDbgRegParms followFieldofObject(sqInt fieldIndex, sqInt anObject);
static sqInt NoDbgRegParms followForwardedInObjStackatIndex(sqInt objStack, sqInt objStackRootIndex);
extern sqInt followForwardedObjectFieldstoDepth(sqInt objOop, sqInt depth);
extern sqInt followForwarded(sqInt objOop);
static sqInt NoDbgRegParms followObjFieldofObject(sqInt fieldIndex, sqInt anObject);
extern sqInt formatOfClass(sqInt classPointer);
static sqInt NoDbgRegParms formatOf(sqInt objOop);
static sqInt forwardedFormat(void);
static sqInt freeChunkNextIndex(void);
static sqInt freeChunkParentIndex(void);
static sqInt NoDbgRegParms freeChunkWithBytesat(sqInt bytes, sqInt address);
static sqInt freeListHeadsEmpty(void);
static sqInt freeListsObj(void);
extern sqInt freeObject(sqInt objOop);
static void NeverInline freeUnmarkedObjectsAndSortAndCoalesceFreeSpaceForPigCompact(void);
extern usqLong NeverInline fullGC(void);
static float getHeapGrowthToSizeGCRatio(void);
static sqInt NoDbgRegParms goodContextSize(sqInt oop);
static sqInt NoDbgRegParms growOldSpaceByAtLeast(sqInt minAmmount);
extern usqLong headerForSlotsformatclassIndex(sqInt numSlots, sqInt formatField, sqInt classIndex);
static usqLong NoDbgRegParms headerForSlotshashformatclassIndex(sqInt numSlots, sqInt hash, sqInt formatField, sqInt classIndex);
static sqInt hiddenRootSlots(void);
static sqInt imageSegmentVersion(void);
extern void incrementalGC(void);
static void NoDbgRegParms inFreeTreeReplacewith(sqInt treeNode, sqInt newNode);
static sqInt NoDbgRegParms initialInstanceOf(sqInt classObj);
static void NoDbgRegParms initializeObjectMemory(sqInt bytesToShift);
extern void inOrderPrintFreeTreeprintList(sqInt freeChunk, sqInt printNextList);
extern sqInt instanceSizeOf(sqInt classObj);
static sqInt NoDbgRegParms instSpecOfClassFormat(sqInt classFormat);
static sqInt NoDbgRegParms instSpecOfClass(sqInt classPointer);
static sqInt NoDbgRegParms isAnyPointerFormat(sqInt format);
extern sqInt isArrayNonImm(sqInt oop);
extern sqInt isArray(sqInt oop);
extern sqInt isBytes(sqInt oop);
extern sqInt isCharacterObject(sqInt oop);
extern sqInt isCharacterValue(sqInt anInteger);
static sqInt NoDbgRegParms isClassAtUniqueIndex(sqInt aClass);
static sqInt NoDbgRegParms isCompiledMethodFormat(sqInt format);
extern sqInt isCompiledMethod(sqInt objOop);
static sqInt NoDbgRegParms isContextHeader(sqInt aHeader);
static sqInt NoDbgRegParms isContextNonImm(sqInt oop);
static sqInt NoDbgRegParms isContext(sqInt oop);
static sqInt NoDbgRegParms isEmptyObjStack(sqInt objStack);
static sqInt NoDbgRegParms isEnumerableObjectNoAssert(sqInt objOop);
static sqInt NoDbgRegParms isEnumerableObject(sqInt objOop);
static sqInt NoDbgRegParms isEphemeron(sqInt objOop);
static sqInt NoDbgRegParms isFixedSizePointerFormat(sqInt format);
static sqInt NoDbgRegParms isForwardedClassTag(sqInt classIndex);
extern sqInt isForwarded(sqInt objOop);
static sqInt NoDbgRegParms isFreeObject(sqInt objOop);
extern sqInt isImmediate(sqInt oop);
static sqInt NoDbgRegParms isInClassTable(sqInt objOop);
extern sqInt isIndexable(sqInt objOop);
static sqInt NoDbgRegParms isInEden(sqInt objOop);
static sqInt NoDbgRegParms isInFutureSpace(sqInt address);
extern sqInt isInMemory(sqInt address);
static sqInt NoDbgRegParms isInNewSpace(sqInt objOop);
extern sqInt isInOldSpace(sqInt address);
static sqInt NoDbgRegParms isInPastSpace(sqInt address);
extern sqInt isNonImmediate(sqInt oop);
extern sqInt isOldObject(sqInt objOop);
extern sqInt isOopCompiledMethod(sqInt oop);
extern sqInt isOopForwarded(sqInt oop);
extern sqInt isOopImmutable(sqInt oop);
extern sqInt isOopMutable(sqInt oop);
extern sqInt isPinned(sqInt objOop);
extern sqInt isPointers(sqInt oop);
static sqInt NoDbgRegParms isPureBitsFormat(sqInt format);
extern sqInt isReallyYoungObject(sqInt obj);
extern sqInt isReallyYoung(sqInt oop);
static sqInt NoDbgRegParms isRemembered(sqInt objOop);
static sqInt NoDbgRegParms isSegmentBridge(sqInt objOop);
extern sqInt isUnambiguouslyForwarder(sqInt objOop);
extern sqInt isValidClassTag(sqInt classIndex);
static sqInt NoDbgRegParms isValidFreeObject(sqInt objOop);
static sqInt NoDbgRegParms isValidObjStackAt(sqInt objStackRootIndex);
static sqInt NoDbgRegParms isValidObjStackPagemyIndex(sqInt objStackPage, sqInt myx);
static sqInt NoDbgRegParms isValidObjStackPagemyIndexfirstPage(sqInt objStackPage, sqInt myx, sqInt isFirstPage);
static sqInt NoDbgRegParms isValidObjStack(sqInt objStack);
static sqInt NoDbgRegParms isWeakFormat(sqInt format);
static sqInt NoDbgRegParms isWeakNonImm(sqInt objOop);
extern sqInt isWeak(sqInt oop);
extern sqInt isWordsOrBytes(sqInt oop);
extern sqInt isWords(sqInt oop);
extern sqInt isYoungObject(sqInt objOop);
extern sqInt isYoung(sqInt oop);
static sqInt NoDbgRegParms isinstanceOfcompactClassIndex(sqInt oop, sqInt classOop, sqInt compactClassIndex);
static sqInt NoDbgRegParms isonObjStack(sqInt oop, sqInt objStack);
static sqInt NoDbgRegParms keyOfEphemeron(sqInt objOop);
static sqInt NoDbgRegParms knownClassAtIndex(sqInt classIndex);
static sqInt lastClassIndexPun(void);
extern sqInt lastPointerOfWhileSwizzling(sqInt objOop);
extern sqInt lastPointerOf(sqInt objOop);
extern sqInt leakCheckBecome(void);
extern sqInt leakCheckFullGC(void);
extern sqInt leakCheckIncremental(void);
extern sqInt leakCheckNewSpaceGC(void);
static sqInt NoDbgRegParms lengthOfMaybeImmediate(sqInt oop);
extern sqInt lengthOf(sqInt objOop);
extern sqInt literalCountOfMethodHeader(sqInt header);
extern sqInt literalCountOf(sqInt methodPointer);
static sqInt NoDbgRegParms loadImageSegmentFromoutPointers(sqInt segmentWordArray, sqInt outPointerArray);
extern void longPrintInstancesOf(sqInt aClassOop);
extern void longPrintInstancesWithClassIndex(sqInt classIndex);
extern void longPrintReferencesTo(sqInt anOop);
static sqInt NoDbgRegParms mapOopsFromtooutPointersoutHashes(sqInt segStart, sqInt segAddr, sqInt outPointerArray, sqInt savedOutHashes);
static void NoDbgRegParms markAndTraceClassOf(sqInt objOop);
static void NoDbgRegParms markAndTraceObjStackandContents(sqInt stackOrNil, sqInt markAndTraceContents);
extern void markAndTrace(sqInt objOop);
static sqInt markInactiveEphemerons(void);
static void NoDbgRegParms NeverInline markObjects(sqInt objectsShouldBeUnmarkedAndUnmarkedClassesShouldBeExpunged);
static void markWeaklingsAndMarkAndFireEphemerons(void);
extern sqInt maybeSplObj(sqInt index);
static sqInt NoDbgRegParms methodHeaderOf(sqInt methodObj);
static sqInt NoDbgRegParms moveARunOfObjectsStartingAtupTo(usqInt startAddress, usqInt limit);
static sqInt newObjectHash(void);
static sqInt newSpaceIsEmpty(void);
extern usqInt nextInSortedFreeListLinkgiven(sqInt freeChunk, sqInt prevFree);
extern sqInt nilObject(void);
static void NeverInline nilUnmarkedWeaklingSlots(void);
static sqInt NoDbgRegParms noCheckClassAtIndex(sqInt classIndex);
static sqInt NoDbgRegParms noCheckPushonObjStack(sqInt objOop, sqInt objStack);
static sqInt NoDbgRegParms noFixupFollowFieldofObject(sqInt fieldIndex, sqInt anObject);
static sqInt NoDbgRegParms noInlineFollowForwarded(sqInt objOop);
extern sqInt nonIndexablePointerFormat(void);
static sqInt noUnscannedEphemerons(void);
static sqInt NoDbgRegParms numBytesOfBytes(sqInt objOop);
extern sqInt numBytesOf(sqInt objOop);
static sqInt numberOfForwarders(void);
extern sqInt numPointerSlotsOf(sqInt objOop);
static usqInt NoDbgRegParms numSlotsOfAny(sqInt objOop);
extern usqInt numSlotsOf(sqInt objOop);
static sqInt NoDbgRegParms numStrongSlotsOfInephemeral(sqInt objOop);
extern sqInt numStrongSlotsOfWeakling(sqInt objOop);
extern sqInt objectAfter(sqInt objOop);
extern sqInt objectBefore(sqInt objOop);
static sqInt NoDbgRegParms objectStartingAt(sqInt address);
extern sqInt obsoleteDontUseThisFetchWordofObject(sqInt fieldIndex, sqInt oop);
static sqInt NoDbgRegParms okayOop(sqInt signedOop);
extern sqInt pinObject(sqInt objOop);
static sqInt NoDbgRegParms popObjStack(sqInt objStack);
extern sqInt popRemappableOop(void);
static void NoDbgRegParms postBecomeScanClassTable(sqInt effectsFlags);
extern sqInt primitiveErrorTable(void);
extern void printForwarders(void);
extern void printFreeChunks(void);
extern void printFreeChunk(sqInt freeChunk);
static void NoDbgRegParms printFreeChunkprintAsTreeNode(sqInt freeChunk, sqInt printAsTreeNode);
extern void printFreeListHeads(void);
extern sqInt printFreeList(sqInt chunkOrIndex);
extern void printFreeTree(void);
static void NoDbgRegParms printFreeTreeChunk(sqInt chunkOrZero);
extern void printHeaderOf(sqInt objOop);
static void NoDbgRegParms printHeaderTypeOf(sqInt objOop);
extern void printInstancesOf(sqInt aClassOop);
extern void printInstancesWithClassIndex(sqInt classIndex);
extern void printInvalidClassTableEntries(void);
extern void printMethodReferencesTo(sqInt anOop);
extern void printObjectsFromto(sqInt startAddress, sqInt endAddress);
extern void printObjectsWithHash(sqInt hash);
static void NoDbgRegParms printObjStackPagemyIndexpageType(sqInt objStackPage, sqInt myx, sqInt pageType);
static void NoDbgRegParms printObjStackPagemyIndextag(sqInt objStackPage, sqInt myx, char *pageType);
extern void printObjStack(sqInt objStack);
extern void printOopsFromto(sqInt startAddress, sqInt endAddress);
extern void printReferencesTo(sqInt anOop);
extern void printSortedFreeList(void);
static sqInt NoDbgRegParms pushOnUnscannedEphemeronsStack(sqInt anEphemeron);
extern void pushRemappableOop(sqInt oop);
static sqInt NoDbgRegParms pushonObjStack(sqInt objOop, sqInt objStack);
static void NoDbgRegParms queueMourner(sqInt anEphemeronOrWeakArray);
static sqInt NoDbgRegParms rawHashBitsOf(sqInt objOop);
static void rebuildFreeListsForPigCompact(void);
extern sqInt remapObj(sqInt objOop);
extern sqInt removeGCRoot(sqInt *varLoc);
static void NoDbgRegParms restoreObjectsInsavedHashes(sqInt objArray, sqInt savedHashes);
static void NoDbgRegParms runLeakCheckerFor(sqInt gcModes);
static void NoDbgRegParms runLeakCheckerForexcludeUnmarkedNewSpaceObjsclassIndicesShouldBeValid(sqInt gcModes, sqInt excludeUnmarkedNewSpaceObjs, sqInt classIndicesShouldBeValid);
static void NoDbgRegParms scavengingGCTenuringIf(sqInt tenuringCriterion);
static sqInt NoDbgRegParms shortentoIndexableSize(sqInt objOop, sqInt indexableSize);
extern void shortPrintObjectsFromto(sqInt startAddress, sqInt endAddress);
extern sqInt shouldRemapObj(sqInt objOop);
extern sqInt shouldRemapOop(sqInt oop);
static usqInt NoDbgRegParms sizeOfFree(sqInt objOop);
static sqInt NoDbgRegParms sizeOfObjStack(sqInt objStack);
extern sqInt slotSizeOf(sqInt oop);
extern sqInt splObj(sqInt index);
static sqInt NoDbgRegParms startOfObject(sqInt objOop);
extern usqInt storeCheckBoundary(void);
static sqInt NoDbgRegParms storeImageSegmentIntooutPointersroots(sqInt segmentWordArray, sqInt outPointerArray, sqInt arrayOfRoots);
extern sqInt storePointerUncheckedofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt storePointerofObjectwithValue(sqInt fieldIndex, sqInt objOop, sqInt valuePointer);
extern sqInt stringForCString(const char *aCString);
static sqInt NoDbgRegParms sufficientSpaceAfterGC(sqInt numBytes);
static sqInt NoDbgRegParms swizzleObjStackAt(sqInt objStackRootIndex);
extern void tenuringIncrementalGC(void);
static sqInt NoDbgRegParms topOfObjStack(sqInt objStack);
extern sqInt topRemappableOop(void);
static usqInt totalFreeListBytes(void);
extern sqInt trueObject(void);
static void NoDbgRegParms unlinkSolitaryFreeTreeNode(sqInt freeTreeNode);
extern sqInt unpinObject(sqInt objOop);
static sqInt validClassTableHashes(void);
static sqInt validClassTableRootPages(void);
extern sqInt validFreeTree(void);
static const char * NoDbgRegParms validFreeTreeChunkparent(sqInt chunk, sqInt parent);
static sqInt validObjStacks(void);
extern sqInt vmEndianness(void);
static usqInt NoDbgRegParms segLimit(SpurSegmentInfo * self_in_segLimit);
static SpurSegmentInfo * NoDbgRegParms addSegmentOfSize(sqInt ammount);
static void NoDbgRegParms adjustSegmentSwizzlesBy(sqInt firstSegmentShift);
static sqInt allBridgesMarked(void);
static void allocateOrExtendSegmentInfos(void);
static sqInt NoDbgRegParms bridgeAt(sqInt segIndex);
static sqInt NoDbgRegParms bridgeFor(SpurSegmentInfo *aSegment);
static void NoDbgRegParms bridgeFromto(SpurSegmentInfo *aSegment, SpurSegmentInfo *nextSegmentOrNil);
static void checkSegments(void);
static void collapseSegmentsPostSwizzle(void);
static void * NoDbgRegParms firstGapOfSizeAtLeast(sqInt size);
static sqInt NoDbgRegParms isEmptySegment(SpurSegmentInfo *seg);
static sqInt NoDbgRegParms isInSegments(usqInt address);
static sqInt NoDbgRegParms isValidSegmentBridge(sqInt objOop);
static sqInt lastBridge(void);
static SpurSegmentInfo * NoDbgRegParms nextNonEmptySegmentAfter(sqInt i);
static void postSnapshot(void);
static void prepareForSnapshot(void);
static sqInt NoDbgRegParms readHeapFromImageFiledataBytes(sqImageFile f, sqInt numBytes);
EXPORT(SpurSegmentInfo *) segmentContainingObj(sqInt objOop);
static void NoDbgRegParms shrinkObjectMemory(usqInt delta);
static sqInt someSegmentContainsPinned(void);
static sqInt NoDbgRegParms swizzleObj(sqInt objOop);
static usqInt totalBytesInSegments(void);
static sqInt NoDbgRegParms writeImageSegmentsToFile(sqImageFile aBinaryStream);
static sqInt NoDbgRegParms writeSegmentnextSegmenttoFile(SpurSegmentInfo *segment, SpurSegmentInfo *nextSegment, sqImageFile aBinaryStream);
static sqInt NoDbgRegParms accessModifierOfMethod(sqInt methodObj);
extern sqInt activeProcess(void);
static void NoDbgRegParms addLastLinktoList(sqInt proc, sqInt aList);
static void NoDbgRegParms addNewMethodToCache(sqInt classObj);
static void NoDbgRegParms addNewMethodToNSCache(sqInt rule);
static sqInt NoDbgRegParms addressCouldBeClassObj(sqInt maybeClassObj);
static char * NoDbgRegParms allocateMemoryminimumimageFileheaderSize(sqInt heapSize, sqInt minimumMemory, sqImageFile fileStream, sqInt headerSize);
extern sqInt argumentCountOfClosure(sqInt closurePointer);
extern sqInt argumentCountOfMethodHeader(sqInt header);
extern sqInt argumentCountOf(sqInt methodPointer);
extern void * arrayValueOf(sqInt arrayOop);
static sqInt NoDbgRegParms asciiOfCharacter(sqInt characterObj);
extern void assertValidExecutionPointers(usqInt lip, char *lifp, char *lisp);
static void NoDbgRegParms assertValidExecutionPointersimbarline(usqInt lip, char *lfp, char *lsp, sqInt inInterpreter, sqInt ln);
extern sqInt booleanValueOf(sqInt obj);
EXPORT(sqInt) callbackEnter(sqInt *callbackID);
EXPORT(sqInt) callbackLeave(sqInt cbID);
extern sqInt canContextSwitchIfActivatingheader(sqInt theMethod, sqInt methodHeader);
extern sqInt characterForAscii(sqInt ascii);
extern sqInt checkAllAccessibleObjectsOkay(void);
static sqInt NoDbgRegParms checkCodeIntegrity(sqInt fullGCFlag);
static sqInt checkDeliveryOfLongRunningPrimitiveSignal(void);
extern sqInt checkedIntegerValueOf(sqInt intOop);
static sqInt checkForAndFollowForwardedPrimitiveState(void);
static sqInt NoDbgRegParms checkForEventsMayContextSwitch(sqInt mayContextSwitch);
static sqInt NoDbgRegParms checkImageVersionFromstartingAt(sqImageFile f, squeakFileOffsetType imageOffset);
static sqInt checkInterpreterIntegrity(void);
static sqInt NoDbgRegParms checkIsStillMarriedContextcurrentFP(sqInt aContext, char *currentFP);
static sqInt NoDbgRegParms checkOkayFields(sqInt oop);
extern sqInt checkOkayInterpreterObjects(sqInt writeBack);
static sqInt NoDbgRegParms checkOkayStackPage(StackPage *thePage);
static sqInt NoDbgRegParms checkOkayStackZone(sqInt writeBack);
static void NoDbgRegParms checkProfileTick(sqInt aPrimitiveMethod);
static sqInt checkStackIntegrity(void);
static sqInt NoDbgRegParms classNameOfIs(sqInt aClass, char *className);
static sqInt NoDbgRegParms contexthasSender(sqInt thisCntx, sqInt aContext);
static sqInt NoDbgRegParms contexthasValidInversePCMappingOfin(sqInt aContext, sqInt theIP, char *theFP);
extern sqInt copiedValueCountOfClosure(sqInt closurePointer);
extern sqInt copyBits(void);
extern sqInt copyBitsFromtoat(sqInt x0, sqInt x1, sqInt y);
static sqInt NoDbgRegParms NeverInline couldBeProcess(sqInt oop);
static void cr(void);
static void NoDbgRegParms createActualMessageTo(sqInt lookupClass);
static sqInt defaultNumStackPages(void);
static sqInt NoDbgRegParms displayBitsOfLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt divorceAllFrames(void);
static void NoDbgRegParms divorceFramesIn(StackPage *aStackPage);
static sqInt NoDbgRegParms doPrimitiveDivby(sqInt rcvr, sqInt arg);
static sqInt NoDbgRegParms doPrimitiveModby(sqInt rcvr, sqInt arg);
extern sqInt doSignalSemaphoreWithIndex(sqInt index);
static void dummyReferToProxy(void);
extern void dumpPrimTraceLog(void);
static sqInt NoDbgRegParms enclosingObjectAtwithObjectwithMixin(sqInt depth, sqInt methodReceiver, sqInt methodMixin);
static sqInt NoDbgRegParms ensureCallerContext(char *theFP);
static void NoDbgRegParms ensureImageFormatIsUpToDate(sqInt swapBytes);
static void NoDbgRegParms externalDivorceFrameandContext(char *theFP, sqInt ctxt);
static char * NoDbgRegParms externalEnsureIsBaseFrame(char *aFramePtr);
static sqInt NoDbgRegParms externalInstVarofContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms externalInstVarofContextput(sqInt index, sqInt maybeMarriedContext, sqInt anOop);
static sqInt externalQuickPrimitiveResponse(void);
static void failUnbalancedPrimitive(void);
extern void * fetchArrayofObject(sqInt fieldIndex, sqInt objectPointer);
extern double fetchFloatofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt fetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
static sqInt NoDbgRegParms fetchPointerofMarriedContext(sqInt offset, sqInt aContext);
static sqInt NoDbgRegParms fetchStackPointerOf(sqInt aContext);
static sqInt NoDbgRegParms findApplicationOfTargetMixinstartingAtBehavior(sqInt targetMixin, sqInt aBehavior);
static sqInt NoDbgRegParms findClassContainingMethodstartingAt(sqInt meth, sqInt classObj);
extern sqInt findClassOfMethodforReceiver(sqInt meth, sqInt rcvr);
static char * NoDbgRegParms findFrameAboveinPage(char *theFP, StackPage *thePage);
static sqInt NoDbgRegParms findHomeForContext(sqInt aContext);
static sqInt NoDbgRegParms findMethodWithPrimitiveFromContextUpToContext(sqInt primitive, sqInt senderContext, sqInt homeContext);
static sqInt NoDbgRegParms findNewMethodInClassTag(sqInt classTagArg);
extern sqInt findSelectorOfMethod(sqInt methArg);
static char * NoDbgRegParms findSPOfon(char *theFP, StackPage *thePage);
extern double floatArg(sqInt index);
static sqInt NoDbgRegParms flushExternalPrimitiveOf(sqInt methodObj);
static void flushMethodCache(void);
static void NoDbgRegParms followForwardedFrameContentsstackPointer(char *theFP, char *theSP);
static void NoDbgRegParms followForwardingPointersInStackZone(sqInt theBecomeEffectsFlags);
extern sqInt forceInterruptCheck(void);
extern void forceInterruptCheckFromHeartbeat(void);
static sqInt NoDbgRegParms frameCallerContext(char *theFP);
static char * NoDbgRegParms frameCallerFP(char *theFP);
static char * NoDbgRegParms frameCallerSavedIP(char *theFP);
static char * NoDbgRegParms frameCallerSP(char *theFP);
static sqInt NoDbgRegParms frameContext(char *theFP);
static sqInt NoDbgRegParms frameHasContext(char *theFP);
static sqInt NoDbgRegParms frameIsBlockActivation(char *theFP);
static sqInt NoDbgRegParms frameMethodObject(char *theFP);
static sqInt NoDbgRegParms frameMethod(char *theFP);
static sqInt NoDbgRegParms frameNumArgs(char *theFP);
static char * NoDbgRegParms frameOfMarriedContext(sqInt aContext);
static char * NoDbgRegParms frameReceiverLocation(char *theFP);
static sqInt NoDbgRegParms frameReceiver(char *theFP);
static void freeUntracedStackPages(void);
extern sqInt fullDisplayUpdate(void);
extern void (*functionPointerForinClass(sqInt primIdx,sqInt theClass))(void) ;
extern sqInt getCurrentBytecode(void);
extern sqInt getFullScreenFlag(void);
extern sqInt getInterruptKeycode(void);
extern sqInt getInterruptPending(void);
extern usqLong getNextWakeupUsecs(void);
extern sqInt getSavedWindowSize(void);
extern sqInt * getStackPointer(void);
extern sqInt getThisSessionID(void);
static sqInt NoDbgRegParms getWord32FromFileswap(sqImageFile aFile, sqInt swapFlag);
static sqInt NoDbgRegParms handleForwardedSelectorFaultFor(sqInt selectorOop);
static sqInt NoDbgRegParms handleForwardedSendFaultForTag(sqInt classTag);
static sqInt NoDbgRegParms handleSpecialSelectorSendFaultForfpsp(sqInt obj, char *theFP, char *theSP);
static void handleStackOverflow(void);
static sqInt NoDbgRegParms handleStackOverflowOrEventAllowContextSwitch(sqInt mayContextSwitch);
extern sqInt headerIndicatesAlternateBytecodeSet(sqInt methodHeader);
extern sqInt highBit(usqInt anUnsignedValue);
static sqInt NoDbgRegParms ifCurrentStackPageHasValidHeadPointers(StackPage *thePage);
static usqInt NoDbgRegParms iframeMethod(char *theFP);
extern void ifValidWriteBackStackPointersSaveTo(void *theCFP, void *theCSP, char **savedFPP, char **savedSPP);
static sqInt imageFormatVersion(void);
extern sqInt includesBehaviorThatOf(sqInt aClass, sqInt aSuperclass);
static sqInt NoDbgRegParms inlineLookupInNSMethodCacheSelclassTagmethodlookupRule(sqInt selector, sqInt classTag, sqInt callingMethod, sqInt lookupRule);
static sqInt NoDbgRegParms instructionPointerForFramecurrentFPcurrentIP(char *spouseFP, char *currentFP, sqInt instrPtr);
extern sqInt integerArg(sqInt index);
static sqInt interpreterAllocationReserveBytes(void);
extern void ioFilenamefromStringofLengthresolveAliases(char *aCharBuffer, char *aFilenameString, sqInt filenameLength, sqInt aBoolean);
static sqInt NoDbgRegParms isBaseFrame(char *theFP);
static sqInt NoDbgRegParms isEmptyList(sqInt aLinkedList);
extern sqInt isFloatObject(sqInt oop);
static sqInt NoDbgRegParms isFrameonPage(char *aFrame, StackPage *aPage);
static sqInt NoDbgRegParms isLiveContext(sqInt oop);
static sqInt NoDbgRegParms isMachineCodeFrame(char *theFP);
static sqInt NoDbgRegParms isMarriedOrWidowedContext(sqInt aContext);
static sqInt isPrimitiveFunctionPointerAnIndex(void);
extern sqInt isQuickPrimitiveIndex(sqInt anInteger);
extern sqInt isReadMediatedContextInstVarIndex(sqInt index);
static sqInt NoDbgRegParms isSingleContext(sqInt aContext);
static sqInt NoDbgRegParms isWidowedContextDuringGC(sqInt aOnceMarriedContext);
static sqInt NoDbgRegParms isWidowedContext(sqInt aOnceMarriedContext);
extern sqInt isWriteMediatedContextInstVarIndex(sqInt index);
extern sqInt isKindOfClass(sqInt oop, sqInt aClass);
extern sqInt isKindOf(sqInt oop, char *className);
extern sqInt isMemberOf(sqInt oop, char *className);
static sqInt NoDbgRegParms lengthOfNameOfClass(sqInt classOop);
extern sqInt literalofMethod(sqInt offset, sqInt methodPointer);
extern sqInt loadBitBltFrom(sqInt bb);
extern void loadInitialContext(void);
extern void longPrintOop(sqInt oop);
extern sqInt longStoreBytecodeForHeader(sqInt methodHeader);
static sqInt NoDbgRegParms lookupInMethodCacheSelclassTag(sqInt selector, sqInt classTag);
static sqInt NoDbgRegParms lookupLexicalfromrule(sqInt selector, sqInt mixin, sqInt rule);
static sqInt NoDbgRegParms lookupMethodInClass(sqInt class);
static sqInt lookupMNU(void);
static sqInt NoDbgRegParms lookupOrdinaryNoMNUEtcInClass(sqInt class);
static sqInt lookupOrdinarySend(void);
static sqInt NoDbgRegParms lookupProtectedstartingAtrule(sqInt selector, sqInt mixinApplication, sqInt rule);
extern sqInt lookupSelectorinClass(sqInt selector, sqInt class);
static StackPage * NoDbgRegParms makeBaseFrameFor(sqInt aContext);
extern sqInt makePointwithxValueyValue(sqInt xValue, sqInt yValue);
static void mapInterpreterOops(void);
static void NeverInline mapStackPages(void);
static sqInt NoDbgRegParms markAndTraceStackPages(sqInt fullGCFlag);
static void NoDbgRegParms markAndTraceStackPage(StackPage *thePage);
static void markAndTraceUntracedReachableStackPages(void);
static sqInt NoDbgRegParms marriedContextpointsTostackDeltaForCurrentFrame(sqInt spouseContext, sqInt anOop, sqInt stackDeltaForCurrentFrame);
static void NoDbgRegParms marryContextInNewStackPageAndInitializeInterpreterRegisters(sqInt aContext);
static sqInt NoDbgRegParms marryFrameSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms maybeSelectorOfMethod(sqInt methodObj);
extern sqInt methodArgumentCount(void);
extern sqInt methodArg(sqInt index);
extern sqInt methodClassAssociationOf(sqInt methodPointer);
extern sqInt methodClassOf(sqInt methodPointer);
static sqInt NoDbgRegParms methodHeaderIndicatesLargeFrame(sqInt methodHeader);
extern sqInt methodPrimitiveIndex(void);
extern sqInt methodReturnValue(sqInt oop);
extern sqInt methodUsesAlternateBytecodeSet(sqInt aMethodObj);
EXPORT(void) moduleUnloaded(char *aModuleName);
static char * NoDbgRegParms moveFramesInthroughtoPage(StackPage *oldPage, char *theFP, StackPage *newPage);
static char * NoDbgRegParms nameOfClass(sqInt classOop);
static sqInt NoDbgRegParms noInlineSigned32BitIntegerFor(sqInt integerValue);
static sqInt NoDbgRegParms noInlineTemporaryin(sqInt offset, char *theFP);
static sqInt NoDbgRegParms noInlineTemporaryinput(sqInt offset, char *theFP, sqInt valueOop);
static sqInt NoDbgRegParms noMarkedContextsOnPage(StackPage *thePage);
static sqInt NoDbgRegParms numSlotsOfMarriedContext(sqInt aContext);
static sqInt numStkPages(void);
static sqInt NoDbgRegParms objCouldBeClassObj(sqInt objOop);
extern sqInt objectArg(sqInt index);
extern sqInt penultimateLiteralOf(sqInt aMethodOop);
extern sqInt popStack(void);
extern sqInt pop(sqInt nItems);
extern void popthenPush(sqInt nItems, sqInt oop);
extern sqInt positive32BitIntegerFor(sqInt integerValue);
extern sqInt positive64BitIntegerFor(sqLong integerValue);
EXPORT(void) primitiveEventProcessingControl(void);
extern sqInt primitiveIndexOfMethodheader(sqInt theMethod, sqInt methodHeader);
extern sqInt primitiveIndexOf(sqInt methodPointer);
static void NoDbgRegParms printActivationNameForSelectorstartClass(sqInt aSelector, sqInt startClass);
static void NoDbgRegParms printActivationNameForreceiverisBlockfirstTemporary(sqInt aMethod, sqInt anObject, sqInt isBlock, sqInt maybeMessage);
extern void printAllStacks(void);
extern void printCallStack(void);
static sqInt NoDbgRegParms printCallStackFP(char *theFP);
extern sqInt printCallStackOf(sqInt aContextOrProcessOrFrame);
static sqInt NoDbgRegParms printCallStackOfcurrentFP(sqInt aContext, char *currFP);
extern void printChar(sqInt aByte);
static sqInt NoDbgRegParms printContextCallStackOf(sqInt aContext);
extern void printContext(sqInt aContext);
extern void printExternalHeadFrame(void);
static sqInt NoDbgRegParms printFrameAndCallersSPshort(char *theFP, char *theSP, sqInt printShort);
static void NoDbgRegParms printFrameFlagsForFP(char *theFP);
static void NoDbgRegParms printFrameOopat(char *name, char *address);
EXPORT(void) printFramesInPage(StackPage *thePage);
EXPORT(void) printFramesOnStackPageListInUse(void);
static void NoDbgRegParms printFrameThingandFrameat(char *name, char *theFP, char *address);
static void NoDbgRegParms printFrameThingat(char *name, char *address);
extern sqInt printFrame(char *theFP);
extern sqInt printFrameWithSP(char *theFP, char *theSP);
extern void printHex(sqInt n);
extern void printLikelyImplementorsOfSelector(sqInt selector);
extern void printMethodCache(void);
extern void printMethodCacheFor(sqInt thing);
extern void printMethodDictionaryOf(sqInt behavior);
extern void printMethodDictionary(sqInt dictionary);
static void NoDbgRegParms printNameOfClasscount(sqInt classOop, sqInt cnt);
static void NoDbgRegParms printNum(sqInt n);
static void NoDbgRegParms printOopShort(sqInt oop);
extern void printOop(sqInt oop);
extern void printProcessStack(sqInt aProcess);
extern sqInt printProcsOnList(sqInt procList);
extern sqInt printStackCallStackOf(sqInt aContextOrProcessOrFrame);
extern void printStackPageList(void);
extern void printStackPageListInUse(void);
extern void printStackPages(void);
extern void printStackPagesInUse(void);
static void NoDbgRegParms printStackPageuseCount(StackPage *page, sqInt n);
extern void printStackReferencesTo(sqInt oop);
static void NoDbgRegParms printStringOf(sqInt oop);
extern void print(char *s);
extern void pushBool(sqInt trueOrFalse);
static sqInt NoDbgRegParms pushedReceiverOrClosureOfFrame(char *theFP);
extern void pushFloat(double f);
extern sqInt pushInteger(sqInt integerValue);
extern void push(sqInt object);
static void NoDbgRegParms putLongtoFile(long aLong, sqImageFile aFile);
static void NoDbgRegParms putShorttoFile(short aShort, sqImageFile aFile);
static void NoDbgRegParms putToSleepyieldingIf(sqInt aProcess, sqInt yieldImplicitly);
static void NoDbgRegParms putWord32toFile(int aWord32, sqImageFile aFile);
static sqInt NoDbgRegParms quickFetchIntegerofObject(sqInt fieldIndex, sqInt objectPointer);
extern sqInt readableFormat(sqInt imageVersion);
extern size_t readImageFromFileHeapSizeStartingAt(sqImageFile f, usqInt desiredHeapSize, squeakFileOffsetType imageOffset);
EXPORT(sqInt) reestablishContextPriorToCallback(sqInt callbackContext);
static sqInt NoDbgRegParms removeFirstLinkOfList(sqInt aList);
static sqInt NoDbgRegParms resumepreemptedYieldingIf(sqInt aProcess, sqInt yieldImplicitly);
EXPORT(sqInt) returnAsThroughCallbackContext(sqInt returnTypeOop, VMCallbackContext *vmCallbackContext, sqInt callbackMethodContext);
static sqInt NoDbgRegParms reverseDisplayFromto(sqInt startIndex, sqInt endIndex);
static void NoDbgRegParms rewriteMethodCacheEntryForExternalPrimitiveToFunction(void (*localPrimAddress)(void));
static sqInt NoDbgRegParms roomToPushNArgs(sqInt n);
static sqInt NoDbgRegParms safeMethodClassOf(sqInt methodPointer);
static sqInt NoDbgRegParms saneFunctionPointerForFailureOfPrimIndex(sqInt primIndex);
EXPORT(sqInt) sendInvokeCallbackContext(VMCallbackContext *vmCallbackContext);
EXPORT(sqInt) sendInvokeCallbackStackRegistersJmpbuf(sqInt thunkPtr, sqInt stackPtr, sqInt regsPtr, sqInt jmpBufPtr);
extern void setBreakMNUSelector(char *aString);
extern void setBreakSelector(char *aString);
extern void setFullScreenFlag(sqInt value);
EXPORT(void (*setInterruptCheckChain(void (*aFunction)(void)))()) ;
extern void setInterruptKeycode(sqInt value);
extern void setInterruptPending(sqInt value);
extern void setNextWakeupUsecs(usqLong value);
extern void setSavedWindowSize(sqInt value);
static void setSignalLowSpaceFlagAndSaveProcess(void);
static void NoDbgRegParms setTraceFlagOnContextsFramesPageIfNeeded(sqInt aContext);
static sqInt NoDbgRegParms shortPrintContext(sqInt aContext);
static sqInt NoDbgRegParms shortPrintFrameAndCallers(char *theFP);
EXPORT(void) shortPrintFramesInPage(StackPage *thePage);
EXPORT(void) shortPrintFramesOnStackPageListInUse(void);
static sqInt NoDbgRegParms shortPrintFrame(char *theFP);
extern void shortPrintFrameAndNCallers(char *theFP, sqInt n);
static void NoDbgRegParms shortPrintOop(sqInt oop);
static sqInt NoDbgRegParms shortReversePrintFrameAndCallers(char *aFramePointer);
extern sqInt showDisplayBitsLeftTopRightBottom(sqInt aForm, sqInt l, sqInt t, sqInt r, sqInt b);
static sqInt signalExternalSemaphores(void);
extern sqInt signed32BitIntegerFor(sqInt integerValue);
extern sqInt signed64BitIntegerFor(sqLong integerValue);
extern sqInt sizeOfCallPrimitiveBytecode(sqInt methodHeader);
extern sqInt sizeOfLongStoreTempBytecode(sqInt methodHeader);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
static sqInt NoDbgRegParms snapshot(sqInt embedded);
static void space(void);
extern sqInt specialSelector(sqInt index);
static void NoDbgRegParms spurPostBecomeAction(sqInt theBecomeEffectsFlags);
extern double stackFloatValue(sqInt offset);
extern sqInt stackIntegerValue(sqInt offset);
static sqInt stackLimitBytes(void);
static sqInt stackLimitOffset(void);
extern sqInt stackObjectValue(sqInt offset);
static sqInt stackPageByteSize(void);
static sqInt stackPageHeadroom(void);
static sqInt NoDbgRegParms stackPointerForMaybeMarriedContext(sqInt aContext);
static sqInt NoDbgRegParms stackPointerIndexForFrame(char *theFP);
extern usqInt stackPositiveMachineIntegerValue(sqInt offset);
extern long stackSignedMachineIntegerValue(sqInt offset);
extern sqInt stackTop(void);
extern sqInt stackValue(sqInt offset);
extern sqInt startPCOfMethod(sqInt aCompiledMethod);
extern sqInt stObjectat(sqInt array, sqInt index);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt storeIntegerofObjectwithValue(sqInt fieldIndex, sqInt objectPointer, sqInt integerValue);
static char * NoDbgRegParms storeSenderOfFramewithValue(char *theFP, sqInt anOop);
extern sqInt stSizeOf(sqInt oop);
extern sqInt superclassOf(sqInt classPointer);
static sqInt NoDbgRegParms synchronousSignal(sqInt aSemaphore);
extern sqInt tempCountOf(sqInt methodPointer);
extern sqInt temporaryCountOfMethodHeader(sqInt header);
static void NoDbgRegParms transferTo(sqInt newProc);
static void NoDbgRegParms updateStateOfSpouseContextForFrameWithSP(char *theFP, char *theSP);
static sqInt NoDbgRegParms validInstructionPointerinFrame(usqInt anInstrPointer, char *fp);
extern sqInt validInstructionPointerinMethodframePointer(usqInt theInstrPointer, usqInt aMethod, char *fp);
static sqInt validStackPageBaseFrames(void);
static sqInt NoDbgRegParms validStackPageBaseFrame(StackPage *aPage);
static void NoDbgRegParms voidLongRunningPrimitive(char *reason);
static sqInt NoDbgRegParms voidVMStateForSnapshotFlushingExternalPrimitivesIf(sqInt flushExtPrims);
static sqInt wakeHighestPriority(void);
extern char * whereIs(sqInt anOop);
static sqInt NoDbgRegParms withSmallIntegerTags(char *value);
static sqInt writeImageFileIO(void);
static sqInt NoDbgRegParms cloneContext(sqInt aContext);
static sqInt NoDbgRegParms fieldOrSenderFPofContext(sqInt index, sqInt contextObj);
static sqInt NoDbgRegParms fieldofFrame(sqInt index, char *theFP);
static sqInt NoDbgRegParms isAppropriateForCopyObject(sqInt oop);
static void primitiveClone(void);
static void primitiveClosureCopyWithCopiedValues(void);
static void primitiveContextAt(void);
static void primitiveContextAtPut(void);
static void primitiveContextSize(void);
static void primitiveContextXray(void);
static void primitiveDeferDisplayUpdates(void);
static void primitiveDoNamedPrimitiveWithArgs(void);
static void primitiveDoPrimitiveWithArgs(void);
static void primitiveExecuteMethod(void);
static void primitiveExecuteMethodArgsArray(void);
static void primitiveExternalCall(void);
static void primitiveFindHandlerContext(void);
static void primitiveFindNextUnwindContext(void);
static void primitiveFlushCacheByMethod(void);
static void primitiveFlushCacheBySelector(void);
static void primitiveFullGC(void);
static void primitiveIncrementalGC(void);
static void primitiveInstVarAt(void);
static void primitiveInstVarAtPut(void);
EXPORT(sqInt) primitiveLongRunningPrimitive(void);
EXPORT(sqInt) primitiveLongRunningPrimitiveSemaphore(void);
static void primitiveObjectPointsTo(void);
static void primitivePerform(void);
static void primitivePin(void);
EXPORT(void) primitiveSetGCSemaphore(void);
static void primitiveSignalAtMilliseconds(void);
static void primitiveSignalAtUTCMicroseconds(void);
static void primitiveSlotAt(void);
static void primitiveSlotAtPut(void);
static void primitiveStoreStackp(void);
static void primitiveTerminateTo(void);
static void primitiveVMParameter(void);
EXPORT(void) primitiveVoidReceiver(void);
static void primitiveVoidVMState(void);
static void NoDbgRegParms pruneStackstackp(sqInt stack, sqInt stackp);
static void unmarkAfterPathTo(void);
static void unmarkAllFrames(void);

/*** Variables ***/
#if SQ_USE_GLOBAL_STRUCT
# define _iss /* define in-struct static as void */
static struct foo {
#else
# define _iss static
#endif
_iss char * stackPointer;
_iss sqInt primFailCode;
_iss usqInt method;
_iss usqInt freeStart;
_iss sqInt nilObj;
_iss StackPage * stackPage;
_iss sqInt argumentCount;
_iss sqInt specialObjectsOop;
_iss char * framePointer;
_iss sqInt bytecodeSetSelector;
_iss sqInt messageSelector;
_iss sqInt markStack;
_iss usqInt newMethod;
_iss usqInt instructionPointer;
_iss usqInt newSpaceLimit;
_iss sqInt needGCFlag;
_iss usqInt endOfMemory;
_iss sqInt weaklingStack;
_iss SpurSegmentInfo * segments;
_iss sqInt trueObj;
_iss sqInt lkupClassTag;
_iss sqInt falseObj;
_iss usqInt scavengeThreshold;
_iss sqInt hiddenRootsObj;
_iss usqInt totalFreeOldSpace;
_iss StackPage * pages;
_iss usqInt pastSpaceStart;
_iss sqInt numSegments;
_iss char * stackMemory;
_iss sqInt * freeLists;
_iss sqInt rememberedSetSize;
_iss sqInt classTableFirstPage;
_iss char * stackLimit;
_iss sqInt tempOop;
_iss sqInt * rememberedSet;
_iss sqInt remapBufferCount;
_iss sqInt bytesPerPage;
_iss sqInt localAbsentReceiver;
_iss usqInt freeListsMask;
_iss StackPage * mostRecentlyUsedPage;
_iss sqInt profileProcess;
_iss usqInt firstFreeChunk;
_iss sqInt profileMethod;
_iss SpurContiguousObjStack unscannedEphemerons;
_iss sqInt lkupClass;
_iss SpurNewSpaceSpace pastSpace;
_iss sqInt longRunningPrimitiveCheckMethod;
_iss sqInt longRunningPrimitiveCheckSemaphore;
_iss usqInt newSpaceStart;
_iss usqInt oldSpaceStart;
_iss sqInt profileSemaphore;
_iss sqInt numStackPages;
_iss sqInt tempOop2;
_iss sqInt numClassTablePages;
_iss sqInt classTableIndex;
_iss SpurNewSpaceSpace futureSpace;
_iss sqInt localAbsentReceiverOrZero;
_iss sqLong nextProfileTick;
_iss sqInt numRememberedEphemerons;
_iss sqInt jmpDepth;
_iss usqInt lastFreeChunk;
_iss SpurNewSpaceSpace eden;
_iss sqInt futureSurvivorStart;
_iss char * objStackInvalidBecause;
_iss sqInt becomeEffectsFlags;
_iss sqInt ephemeronList;
_iss usqInt freeOldSpaceStart;
_iss sqInt tenureThreshold;
_iss sqInt extraRootCount;
_iss sqInt growHeadroom;
_iss sqInt invalidObjStackPage;
_iss sqInt previousRememberedSetSize;
_iss sqInt classNameIndex;
_iss sqInt pendingFinalizationSignals;
_iss sqInt mournQueue;
_iss sqInt tenureCriterion;
_iss sqInt metaclassNumSlots;
_iss sqInt preemptionYields;
_iss usqLong nextWakeupUsecs;
_iss sqInt numSegInfos;
_iss sqInt highestRunnableProcessPriority;
_iss usqLong longRunningPrimitiveStartUsecs;
_iss usqLong longRunningPrimitiveStopUsecs;
_iss sqInt methodDictLinearSearchLimit;
_iss sqInt newFinalization;
_iss usqLong statCheckForEvents;
_iss usqLong statGCEndUsecs;
_iss sqInt weakList;
_iss sqInt externalPrimitiveTableFirstFreeIndex;
_iss sqInt thisClassIndex;
_iss sqInt firstSegmentSize;
_iss usqLong gcStartUsecs;
_iss usqInt lowSpaceThreshold;
_iss sqInt rememberedSetLimit;
_iss sqInt shrinkThreshold;
_iss usqLong statIOProcessEvents;
_iss sqInt imageHeaderFlags;
_iss sqInt lastHash;
_iss sqInt lastMethodCacheProbeWrite;
_iss sqInt longRunningPrimitiveCheckSequenceNumber;
_iss sqInt marking;
_iss usqInt memory;
_iss sqInt numCompactionPasses;
_iss sqInt scavengeInProgress;
_iss sqInt fullScreenFlag;
_iss float heapGrowthToSizeGCRatio;
_iss usqInt heapSizeAtPreviousGC;
_iss sqInt interruptKeycode;
_iss sqInt interruptPending;
_iss usqLong nextPollUsecs;
_iss sqInt rememberedSetRedZone;
_iss sqInt statCompactPassCount;
_iss usqLong statForceInterruptCheck;
_iss usqLong statFullGCUsecs;
_iss sqInt statFullGCs;
_iss sqInt statGrowMemory;
_iss usqLong statProcessSwitch;
_iss usqLong statScavengeGCUsecs;
_iss sqInt statScavenges;
_iss sqInt statShrinkMemory;
_iss usqLong statStackOverflow;
_iss usqLong statStackPageDivorce;
_iss sqInt statTenures;
_iss sqInt canSwizzle;
_iss sqInt extraFramesToMoveOnOverflow;
_iss sqInt gcSemaphoreIndex;
_iss sqInt globalSessionID;
_iss sqInt imageFloatsBigEndian;
_iss sqInt longRunningPrimitiveSignalUndelivered;
_iss sqInt maxExtSemTabSizeSet;
_iss sqInt savedWindowSize;
_iss sqInt signalLowSpace;
_iss sqInt statMarkCount;
_iss sqInt statMaxPageCountWhenMapping;
_iss sqInt statNumMaps;
_iss sqInt statPageCountWhenMappingSum;
_iss sqInt statRootTableCount;
_iss sqInt tenuringProportion;
_iss sqInt classByteArrayCompactIndex;
_iss usqLong longRunningPrimitiveGCUsecs;
_iss sqInt overflowLimit;
_iss StackPage * overflowedPage;
_iss sqInt refCountToShrinkRT;
_iss sqInt statCoalesces;
_iss usqLong statIGCDeltaUsecs;
_iss usqLong statIncrGCUsecs;
_iss sqInt statIncrGCs;
_iss sqInt statPendingFinalizationSignals;
_iss sqInt statRootTableOverflows;
_iss usqLong statSGCDeltaUsecs;
_iss sqInt statSpecialMarkCount;
_iss sqInt statSurvivorCount;
_iss sqInt tenuringClassIndex;
_iss sqInt the2ndUnknownShort;
_iss sqInt theUnknownShort;
_iss long methodCache[MethodCacheSize + 1 /* 2049 */];
_iss long nsMethodCache[NSMethodCacheSize + 1 /* 4097 */];
_iss sqInt atCache[AtCacheTotalSize + 1 /* 65 */];
_iss sqInt remapBuffer[RemapBufferSize + 1 /* 26 */];
_iss sqInt *extraRoots[ExtraRootsSize + 1 /* 2049 */];
_iss usqInt suspendedCallbacks[MaxJumpBuf + 1 /* 33 */];
_iss usqInt suspendedMethods[MaxJumpBuf + 1 /* 33 */];
_iss jmp_buf jmpBuf[MaxJumpBuf + 1 /* 33 */];
_iss unsigned long byteCount;
_iss SpurCircularBuffer highestObjects;
_iss sqInt preferredPinningSegment;
_iss usqLong statFGCDeltaUsecs;
#undef _iss
#if SQ_USE_GLOBAL_STRUCT
 } fum;
 #if SQ_USE_GLOBAL_STRUCT_REG
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* using a global reg pointer */
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT register struct foo * foo = &fum;
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT volatile register struct foo * foo = &fum;
#endif
# define GIV(interpreterInstVar) (foo->interpreterInstVar)
#else
# define DECL_MAYBE_SQ_GLOBAL_STRUCT /* oh, no mr bill! */
# define DECL_MAYBE_VOLATILE_SQ_GLOBAL_STRUCT /* oh no, mr bill! */
# define GIV(interpreterInstVar) interpreterInstVar
#endif
#if SQ_USE_GLOBAL_STRUCT
#if SQ_USE_GLOBAL_STRUCT_REG
#define fooxstr(s) foostr(s)
#define foostr(s)  #s
register struct foo * foo asm(fooxstr(USE_GLOBAL_STRUCT_REG));
#else
static struct foo * foo = &fum;
#endif
#endif
static void (*primitiveFunctionPointer)();
sqInt checkAllocFiller;
sqInt inIOProcessEvents;
sqInt desiredEdenBytes;
sqInt desiredNumStackPages;
sqInt extraVMMemory;
sqInt breakSelectorLength = MinSmallInteger;
sqInt checkForLeaks;
unsigned long maxOldSpaceSize;
void * showSurfaceFn;
sqInt deferDisplayUpdates;
struct VirtualMachine* interpreterProxy;
static void (*interruptCheckChain)(void) = 0;
char * breakSelector;
static void (*externalPrimitiveTable[MaxExternalPrimitiveTableSize + 1 /* 4097 */])(void);
static void (*primitiveTable[MaxPrimitiveIndex + 2 /* 577 */])(void) = {
	/* 0 */ (void (*)(void))0,
	/* 1 */ primitiveAdd,
	/* 2 */ primitiveSubtract,
	/* 3 */ primitiveLessThan,
	/* 4 */ primitiveGreaterThan,
	/* 5 */ primitiveLessOrEqual,
	/* 6 */ primitiveGreaterOrEqual,
	/* 7 */ primitiveEqual,
	/* 8 */ primitiveNotEqual,
	/* 9 */ primitiveMultiply,
	/* 10 */ primitiveDivide,
	/* 11 */ primitiveMod,
	/* 12 */ primitiveDiv,
	/* 13 */ primitiveQuo,
	/* 14 */ primitiveBitAnd,
	/* 15 */ primitiveBitOr,
	/* 16 */ primitiveBitXor,
	/* 17 */ primitiveBitShift,
	/* 18 */ primitiveMakePoint,
	/* 19 */ (void (*)(void))0,
	/* 20 */ primitiveRemLargeIntegers,
	/* 21 */ primitiveAddLargeIntegers,
	/* 22 */ primitiveSubtractLargeIntegers,
	/* 23 */ primitiveLessThanLargeIntegers,
	/* 24 */ primitiveGreaterThanLargeIntegers,
	/* 25 */ primitiveLessOrEqualLargeIntegers,
	/* 26 */ primitiveGreaterOrEqualLargeIntegers,
	/* 27 */ primitiveEqualLargeIntegers,
	/* 28 */ primitiveNotEqualLargeIntegers,
	/* 29 */ primitiveMultiplyLargeIntegers,
	/* 30 */ primitiveDivideLargeIntegers,
	/* 31 */ primitiveModLargeIntegers,
	/* 32 */ primitiveDivLargeIntegers,
	/* 33 */ primitiveQuoLargeIntegers,
	/* 34 */ primitiveBitAndLargeIntegers,
	/* 35 */ primitiveBitOrLargeIntegers,
	/* 36 */ primitiveBitXorLargeIntegers,
	/* 37 */ primitiveBitShiftLargeIntegers,
	/* 38 */ primitiveFloatAt,
	/* 39 */ primitiveFloatAtPut,
	/* 40 */ primitiveAsFloat,
	/* 41 */ primitiveFloatAdd,
	/* 42 */ primitiveFloatSubtract,
	/* 43 */ primitiveFloatLessThan,
	/* 44 */ primitiveFloatGreaterThan,
	/* 45 */ primitiveFloatLessOrEqual,
	/* 46 */ primitiveFloatGreaterOrEqual,
	/* 47 */ primitiveFloatEqual,
	/* 48 */ primitiveFloatNotEqual,
	/* 49 */ primitiveFloatMultiply,
	/* 50 */ primitiveFloatDivide,
	/* 51 */ primitiveTruncated,
	/* 52 */ primitiveFractionalPart,
	/* 53 */ primitiveExponent,
	/* 54 */ primitiveTimesTwoPower,
	/* 55 */ primitiveSquareRoot,
	/* 56 */ primitiveSine,
	/* 57 */ primitiveArctan,
	/* 58 */ primitiveLogN,
	/* 59 */ primitiveExp,
	/* 60 */ primitiveAt,
	/* 61 */ primitiveAtPut,
	/* 62 */ primitiveSize,
	/* 63 */ primitiveStringAt,
	/* 64 */ primitiveStringAtPut,
	/* 65 */ (void (*)(void))0,
	/* 66 */ (void (*)(void))0,
	/* 67 */ (void (*)(void))0,
	/* 68 */ primitiveObjectAt,
	/* 69 */ primitiveObjectAtPut,
	/* 70 */ primitiveNew,
	/* 71 */ primitiveNewWithArg,
	/* 72 */ primitiveArrayBecomeOneWay,
	/* 73 */ primitiveInstVarAt,
	/* 74 */ primitiveInstVarAtPut,
	/* 75 */ primitiveIdentityHash,
	/* 76 */ primitiveStoreStackp,
	/* 77 */ primitiveSomeInstance,
	/* 78 */ primitiveNextInstance,
	/* 79 */ primitiveNewMethod,
	/* 80 */ (void (*)(void))0,
	/* 81 */ (void (*)(void))0,
	/* 82 */ (void (*)(void))0,
	/* 83 */ primitivePerform,
	/* 84 */ primitivePerformWithArgs,
	/* 85 */ primitiveSignal,
	/* 86 */ primitiveWait,
	/* 87 */ primitiveResume,
	/* 88 */ primitiveSuspend,
	/* 89 */ primitiveFlushCache,
	/* 90 */ primitiveMousePoint,
	/* 91 */ primitiveTestDisplayDepth,
	/* 92 */ primitiveSetDisplayMode,
	/* 93 */ primitiveInputSemaphore,
	/* 94 */ primitiveGetNextEvent,
	/* 95 */ primitiveInputWord,
	/* 96 */ (void (*)(void))0,
	/* 97 */ primitiveSnapshot,
	/* 98 */ primitiveStoreImageSegment,
	/* 99 */ primitiveLoadImageSegment,
	/* 100 */ primitivePerformInSuperclass,
	/* 101 */ primitiveBeCursor,
	/* 102 */ primitiveBeDisplay,
	/* 103 */ primitiveScanCharacters,
	/* 104 */ (void (*)(void))0,
	/* 105 */ primitiveStringReplace,
	/* 106 */ primitiveScreenSize,
	/* 107 */ primitiveMouseButtons,
	/* 108 */ primitiveKbdNext,
	/* 109 */ primitiveKbdPeek,
	/* 110 */ primitiveIdentical,
	/* 111 */ primitiveClass,
	/* 112 */ primitiveBytesLeft,
	/* 113 */ primitiveQuit,
	/* 114 */ primitiveExitToDebugger,
	/* 115 */ primitiveChangeClass,
	/* 116 */ primitiveFlushCacheByMethod,
	/* 117 */ primitiveExternalCall,
	/* 118 */ primitiveDoPrimitiveWithArgs,
	/* 119 */ primitiveFlushCacheBySelector,
	/* 120 */ primitiveCalloutToFFI,
	/* 121 */ primitiveImageName,
	/* 122 */ primitiveNoop,
	/* 123 */ (void (*)(void))0,
	/* 124 */ primitiveLowSpaceSemaphore,
	/* 125 */ primitiveSignalAtBytesLeft,
	/* 126 */ primitiveDeferDisplayUpdates,
	/* 127 */ primitiveShowDisplayRect,
	/* 128 */ primitiveArrayBecome,
	/* 129 */ primitiveSpecialObjectsOop,
	/* 130 */ primitiveFullGC,
	/* 131 */ primitiveIncrementalGC,
	/* 132 */ primitiveObjectPointsTo,
	/* 133 */ primitiveSetInterruptKey,
	/* 134 */ primitiveInterruptSemaphore,
	/* 135 */ primitiveMillisecondClock,
	/* 136 */ primitiveSignalAtMilliseconds,
	/* 137 */ primitiveSecondsClock,
	/* 138 */ primitiveSomeObject,
	/* 139 */ primitiveNextObject,
	/* 140 */ primitiveBeep,
	/* 141 */ primitiveClipboardText,
	/* 142 */ primitiveVMPath,
	/* 143 */ primitiveShortAt,
	/* 144 */ primitiveShortAtPut,
	/* 145 */ primitiveConstantFill,
	/* 146 */ (void (*)(void))0,
	/* 147 */ (void (*)(void))0,
	/* 148 */ primitiveClone,
	/* 149 */ primitiveGetAttribute,
	/* 150 */ (void (*)(void))0,
	/* 151 */ (void (*)(void))0,
	/* 152 */ (void (*)(void))0,
	/* 153 */ (void (*)(void))0,
	/* 154 */ (void (*)(void))0,
	/* 155 */ (void (*)(void))0,
	/* 156 */ (void (*)(void))0,
	/* 157 */ (void (*)(void))0,
	/* 158 */ (void (*)(void))0,
	/* 159 */ (void (*)(void))0,
	/* 160 */ primitiveAdoptInstance,
	/* 161 */ primitiveSetOrHasIdentityHash,
	/* 162 */ (void (*)(void))0,
	/* 163 */ (void (*)(void))0,
	/* 164 */ (void (*)(void))0,
	/* 165 */ primitiveIntegerAt,
	/* 166 */ primitiveIntegerAtPut,
	/* 167 */ primitiveYield,
	/* 168 */ primitiveCopyObject,
	/* 169 */ primitiveNotIdentical,
	/* 170 */ primitiveAsCharacter,
	/* 171 */ primitiveImmediateAsInteger,
	/* 172 */ primitiveFetchNextMourner,
	/* 173 */ primitiveSlotAt,
	/* 174 */ primitiveSlotAtPut,
	/* 175 */ primitiveBehaviorHash,
	/* 176 */ primitiveMaxIdentityHash,
	/* 177 */ primitiveAllInstances,
	/* 178 */ primitiveAllObjects,
	/* 179 */ (void (*)(void))0,
	/* 180 */ primitiveGrowMemoryByAtLeast,
	/* 181 */ primitiveSizeInBytesOfInstance,
	/* 182 */ primitiveSizeInBytes,
	/* 183 */ primitiveIsPinned,
	/* 184 */ primitivePin,
	/* 185 */ primitiveExitCriticalSection,
	/* 186 */ primitiveEnterCriticalSection,
	/* 187 */ primitiveTestAndSetOwnershipOfCriticalSection,
	/* 188 */ primitiveExecuteMethodArgsArray,
	/* 189 */ primitiveExecuteMethod,
	/* 190 */ (void (*)(void))0,
	/* 191 */ (void (*)(void))0,
	/* 192 */ (void (*)(void))0,
	/* 193 */ (void (*)(void))0,
	/* 194 */ (void (*)(void))0,
	/* 195 */ primitiveFindNextUnwindContext,
	/* 196 */ primitiveTerminateTo,
	/* 197 */ primitiveFindHandlerContext,
	/* 198 */ (void (*)(void))0,
	/* 199 */ (void (*)(void))0,
	/* 200 */ primitiveClosureCopyWithCopiedValues,
	/* 201 */ primitiveClosureValue,
	/* 202 */ primitiveClosureValue,
	/* 203 */ primitiveClosureValue,
	/* 204 */ primitiveClosureValue,
	/* 205 */ primitiveClosureValue,
	/* 206 */ primitiveClosureValueWithArgs,
	/* 207 */ (void (*)(void))0,
	/* 208 */ (void (*)(void))0,
	/* 209 */ (void (*)(void))0,
	/* 210 */ primitiveContextAt,
	/* 211 */ primitiveContextAtPut,
	/* 212 */ primitiveContextSize,
	/* 213 */ primitiveContextXray,
	/* 214 */ primitiveVoidVMState,
	/* 215 */ primitiveFlushCacheByMethod,
	/* 216 */ (void (*)(void))0,
	/* 217 */ (void (*)(void))0,
	/* 218 */ primitiveDoNamedPrimitiveWithArgs,
	/* 219 */ (void (*)(void))0,
	/* 220 */ (void (*)(void))0,
	/* 221 */ primitiveClosureValueNoContextSwitch,
	/* 222 */ primitiveClosureValueNoContextSwitch,
	/* 223 */ (void (*)(void))0,
	/* 224 */ (void (*)(void))0,
	/* 225 */ (void (*)(void))0,
	/* 226 */ (void (*)(void))0,
	/* 227 */ (void (*)(void))0,
	/* 228 */ (void (*)(void))0,
	/* 229 */ (void (*)(void))0,
	/* 230 */ primitiveRelinquishProcessor,
	/* 231 */ primitiveForceDisplayUpdate,
	/* 232 */ primitiveFormPrint,
	/* 233 */ primitiveSetFullScreen,
	/* 234 */ (void (*)(void))0,
	/* 235 */ (void (*)(void))0,
	/* 236 */ (void (*)(void))0,
	/* 237 */ (void (*)(void))0,
	/* 238 */ (void (*)(void))0,
	/* 239 */ (void (*)(void))0,
	/* 240 */ primitiveUTCMicrosecondClock,
	/* 241 */ primitiveLocalMicrosecondClock,
	/* 242 */ primitiveSignalAtUTCMicroseconds,
	/* 243 */ primitiveUpdateTimezone,
	/* 244 */ (void (*)(void))0,
	/* 245 */ (void (*)(void))0,
	/* 246 */ (void (*)(void))0,
	/* 247 */ primitiveSnapshotEmbedded,
	/* 248 */ (void (*)(void))0,
	/* 249 */ primitiveArrayBecomeOneWayCopyHash,
	/* 250 */ primitiveClearVMProfile,
	/* 251 */ primitiveControlVMProfiling,
	/* 252 */ primitiveVMProfileSamplesInto,
	/* 253 */ (void (*)(void))0,
	/* 254 */ primitiveVMParameter,
	/* 255 */ (void (*)(void))0,
	/* 256 */ (void (*)(void))256,
	/* 257 */ (void (*)(void))257,
	/* 258 */ (void (*)(void))258,
	/* 259 */ (void (*)(void))259,
	/* 260 */ (void (*)(void))260,
	/* 261 */ (void (*)(void))261,
	/* 262 */ (void (*)(void))262,
	/* 263 */ (void (*)(void))263,
	/* 264 */ (void (*)(void))264,
	/* 265 */ (void (*)(void))265,
	/* 266 */ (void (*)(void))266,
	/* 267 */ (void (*)(void))267,
	/* 268 */ (void (*)(void))268,
	/* 269 */ (void (*)(void))269,
	/* 270 */ (void (*)(void))270,
	/* 271 */ (void (*)(void))271,
	/* 272 */ (void (*)(void))272,
	/* 273 */ (void (*)(void))273,
	/* 274 */ (void (*)(void))274,
	/* 275 */ (void (*)(void))275,
	/* 276 */ (void (*)(void))276,
	/* 277 */ (void (*)(void))277,
	/* 278 */ (void (*)(void))278,
	/* 279 */ (void (*)(void))279,
	/* 280 */ (void (*)(void))280,
	/* 281 */ (void (*)(void))281,
	/* 282 */ (void (*)(void))282,
	/* 283 */ (void (*)(void))283,
	/* 284 */ (void (*)(void))284,
	/* 285 */ (void (*)(void))285,
	/* 286 */ (void (*)(void))286,
	/* 287 */ (void (*)(void))287,
	/* 288 */ (void (*)(void))288,
	/* 289 */ (void (*)(void))289,
	/* 290 */ (void (*)(void))290,
	/* 291 */ (void (*)(void))291,
	/* 292 */ (void (*)(void))292,
	/* 293 */ (void (*)(void))293,
	/* 294 */ (void (*)(void))294,
	/* 295 */ (void (*)(void))295,
	/* 296 */ (void (*)(void))296,
	/* 297 */ (void (*)(void))297,
	/* 298 */ (void (*)(void))298,
	/* 299 */ (void (*)(void))299,
	/* 300 */ (void (*)(void))300,
	/* 301 */ (void (*)(void))301,
	/* 302 */ (void (*)(void))302,
	/* 303 */ (void (*)(void))303,
	/* 304 */ (void (*)(void))304,
	/* 305 */ (void (*)(void))305,
	/* 306 */ (void (*)(void))306,
	/* 307 */ (void (*)(void))307,
	/* 308 */ (void (*)(void))308,
	/* 309 */ (void (*)(void))309,
	/* 310 */ (void (*)(void))310,
	/* 311 */ (void (*)(void))311,
	/* 312 */ (void (*)(void))312,
	/* 313 */ (void (*)(void))313,
	/* 314 */ (void (*)(void))314,
	/* 315 */ (void (*)(void))315,
	/* 316 */ (void (*)(void))316,
	/* 317 */ (void (*)(void))317,
	/* 318 */ (void (*)(void))318,
	/* 319 */ (void (*)(void))319,
	/* 320 */ (void (*)(void))320,
	/* 321 */ (void (*)(void))321,
	/* 322 */ (void (*)(void))322,
	/* 323 */ (void (*)(void))323,
	/* 324 */ (void (*)(void))324,
	/* 325 */ (void (*)(void))325,
	/* 326 */ (void (*)(void))326,
	/* 327 */ (void (*)(void))327,
	/* 328 */ (void (*)(void))328,
	/* 329 */ (void (*)(void))329,
	/* 330 */ (void (*)(void))330,
	/* 331 */ (void (*)(void))331,
	/* 332 */ (void (*)(void))332,
	/* 333 */ (void (*)(void))333,
	/* 334 */ (void (*)(void))334,
	/* 335 */ (void (*)(void))335,
	/* 336 */ (void (*)(void))336,
	/* 337 */ (void (*)(void))337,
	/* 338 */ (void (*)(void))338,
	/* 339 */ (void (*)(void))339,
	/* 340 */ (void (*)(void))340,
	/* 341 */ (void (*)(void))341,
	/* 342 */ (void (*)(void))342,
	/* 343 */ (void (*)(void))343,
	/* 344 */ (void (*)(void))344,
	/* 345 */ (void (*)(void))345,
	/* 346 */ (void (*)(void))346,
	/* 347 */ (void (*)(void))347,
	/* 348 */ (void (*)(void))348,
	/* 349 */ (void (*)(void))349,
	/* 350 */ (void (*)(void))350,
	/* 351 */ (void (*)(void))351,
	/* 352 */ (void (*)(void))352,
	/* 353 */ (void (*)(void))353,
	/* 354 */ (void (*)(void))354,
	/* 355 */ (void (*)(void))355,
	/* 356 */ (void (*)(void))356,
	/* 357 */ (void (*)(void))357,
	/* 358 */ (void (*)(void))358,
	/* 359 */ (void (*)(void))359,
	/* 360 */ (void (*)(void))360,
	/* 361 */ (void (*)(void))361,
	/* 362 */ (void (*)(void))362,
	/* 363 */ (void (*)(void))363,
	/* 364 */ (void (*)(void))364,
	/* 365 */ (void (*)(void))365,
	/* 366 */ (void (*)(void))366,
	/* 367 */ (void (*)(void))367,
	/* 368 */ (void (*)(void))368,
	/* 369 */ (void (*)(void))369,
	/* 370 */ (void (*)(void))370,
	/* 371 */ (void (*)(void))371,
	/* 372 */ (void (*)(void))372,
	/* 373 */ (void (*)(void))373,
	/* 374 */ (void (*)(void))374,
	/* 375 */ (void (*)(void))375,
	/* 376 */ (void (*)(void))376,
	/* 377 */ (void (*)(void))377,
	/* 378 */ (void (*)(void))378,
	/* 379 */ (void (*)(void))379,
	/* 380 */ (void (*)(void))380,
	/* 381 */ (void (*)(void))381,
	/* 382 */ (void (*)(void))382,
	/* 383 */ (void (*)(void))383,
	/* 384 */ (void (*)(void))384,
	/* 385 */ (void (*)(void))385,
	/* 386 */ (void (*)(void))386,
	/* 387 */ (void (*)(void))387,
	/* 388 */ (void (*)(void))388,
	/* 389 */ (void (*)(void))389,
	/* 390 */ (void (*)(void))390,
	/* 391 */ (void (*)(void))391,
	/* 392 */ (void (*)(void))392,
	/* 393 */ (void (*)(void))393,
	/* 394 */ (void (*)(void))394,
	/* 395 */ (void (*)(void))395,
	/* 396 */ (void (*)(void))396,
	/* 397 */ (void (*)(void))397,
	/* 398 */ (void (*)(void))398,
	/* 399 */ (void (*)(void))399,
	/* 400 */ (void (*)(void))400,
	/* 401 */ (void (*)(void))401,
	/* 402 */ (void (*)(void))402,
	/* 403 */ (void (*)(void))403,
	/* 404 */ (void (*)(void))404,
	/* 405 */ (void (*)(void))405,
	/* 406 */ (void (*)(void))406,
	/* 407 */ (void (*)(void))407,
	/* 408 */ (void (*)(void))408,
	/* 409 */ (void (*)(void))409,
	/* 410 */ (void (*)(void))410,
	/* 411 */ (void (*)(void))411,
	/* 412 */ (void (*)(void))412,
	/* 413 */ (void (*)(void))413,
	/* 414 */ (void (*)(void))414,
	/* 415 */ (void (*)(void))415,
	/* 416 */ (void (*)(void))416,
	/* 417 */ (void (*)(void))417,
	/* 418 */ (void (*)(void))418,
	/* 419 */ (void (*)(void))419,
	/* 420 */ (void (*)(void))420,
	/* 421 */ (void (*)(void))421,
	/* 422 */ (void (*)(void))422,
	/* 423 */ (void (*)(void))423,
	/* 424 */ (void (*)(void))424,
	/* 425 */ (void (*)(void))425,
	/* 426 */ (void (*)(void))426,
	/* 427 */ (void (*)(void))427,
	/* 428 */ (void (*)(void))428,
	/* 429 */ (void (*)(void))429,
	/* 430 */ (void (*)(void))430,
	/* 431 */ (void (*)(void))431,
	/* 432 */ (void (*)(void))432,
	/* 433 */ (void (*)(void))433,
	/* 434 */ (void (*)(void))434,
	/* 435 */ (void (*)(void))435,
	/* 436 */ (void (*)(void))436,
	/* 437 */ (void (*)(void))437,
	/* 438 */ (void (*)(void))438,
	/* 439 */ (void (*)(void))439,
	/* 440 */ (void (*)(void))440,
	/* 441 */ (void (*)(void))441,
	/* 442 */ (void (*)(void))442,
	/* 443 */ (void (*)(void))443,
	/* 444 */ (void (*)(void))444,
	/* 445 */ (void (*)(void))445,
	/* 446 */ (void (*)(void))446,
	/* 447 */ (void (*)(void))447,
	/* 448 */ (void (*)(void))448,
	/* 449 */ (void (*)(void))449,
	/* 450 */ (void (*)(void))450,
	/* 451 */ (void (*)(void))451,
	/* 452 */ (void (*)(void))452,
	/* 453 */ (void (*)(void))453,
	/* 454 */ (void (*)(void))454,
	/* 455 */ (void (*)(void))455,
	/* 456 */ (void (*)(void))456,
	/* 457 */ (void (*)(void))457,
	/* 458 */ (void (*)(void))458,
	/* 459 */ (void (*)(void))459,
	/* 460 */ (void (*)(void))460,
	/* 461 */ (void (*)(void))461,
	/* 462 */ (void (*)(void))462,
	/* 463 */ (void (*)(void))463,
	/* 464 */ (void (*)(void))464,
	/* 465 */ (void (*)(void))465,
	/* 466 */ (void (*)(void))466,
	/* 467 */ (void (*)(void))467,
	/* 468 */ (void (*)(void))468,
	/* 469 */ (void (*)(void))469,
	/* 470 */ (void (*)(void))470,
	/* 471 */ (void (*)(void))471,
	/* 472 */ (void (*)(void))472,
	/* 473 */ (void (*)(void))473,
	/* 474 */ (void (*)(void))474,
	/* 475 */ (void (*)(void))475,
	/* 476 */ (void (*)(void))476,
	/* 477 */ (void (*)(void))477,
	/* 478 */ (void (*)(void))478,
	/* 479 */ (void (*)(void))479,
	/* 480 */ (void (*)(void))480,
	/* 481 */ (void (*)(void))481,
	/* 482 */ (void (*)(void))482,
	/* 483 */ (void (*)(void))483,
	/* 484 */ (void (*)(void))484,
	/* 485 */ (void (*)(void))485,
	/* 486 */ (void (*)(void))486,
	/* 487 */ (void (*)(void))487,
	/* 488 */ (void (*)(void))488,
	/* 489 */ (void (*)(void))489,
	/* 490 */ (void (*)(void))490,
	/* 491 */ (void (*)(void))491,
	/* 492 */ (void (*)(void))492,
	/* 493 */ (void (*)(void))493,
	/* 494 */ (void (*)(void))494,
	/* 495 */ (void (*)(void))495,
	/* 496 */ (void (*)(void))496,
	/* 497 */ (void (*)(void))497,
	/* 498 */ (void (*)(void))498,
	/* 499 */ (void (*)(void))499,
	/* 500 */ (void (*)(void))500,
	/* 501 */ (void (*)(void))501,
	/* 502 */ (void (*)(void))502,
	/* 503 */ (void (*)(void))503,
	/* 504 */ (void (*)(void))504,
	/* 505 */ (void (*)(void))505,
	/* 506 */ (void (*)(void))506,
	/* 507 */ (void (*)(void))507,
	/* 508 */ (void (*)(void))508,
	/* 509 */ (void (*)(void))509,
	/* 510 */ (void (*)(void))510,
	/* 511 */ (void (*)(void))511,
	/* 512 */ (void (*)(void))512,
	/* 513 */ (void (*)(void))513,
	/* 514 */ (void (*)(void))514,
	/* 515 */ (void (*)(void))515,
	/* 516 */ (void (*)(void))516,
	/* 517 */ (void (*)(void))517,
	/* 518 */ (void (*)(void))518,
	/* 519 */ (void (*)(void))519,
	/* 520 */ (void (*)(void))0,
	/* 521 */ (void (*)(void))0,
	/* 522 */ (void (*)(void))0,
	/* 523 */ (void (*)(void))0,
	/* 524 */ (void (*)(void))0,
	/* 525 */ (void (*)(void))0,
	/* 526 */ (void (*)(void))0,
	/* 527 */ (void (*)(void))0,
	/* 528 */ (void (*)(void))0,
	/* 529 */ (void (*)(void))0,
	/* 530 */ (void (*)(void))0,
	/* 531 */ (void (*)(void))0,
	/* 532 */ (void (*)(void))0,
	/* 533 */ (void (*)(void))0,
	/* 534 */ (void (*)(void))0,
	/* 535 */ (void (*)(void))0,
	/* 536 */ (void (*)(void))0,
	/* 537 */ (void (*)(void))0,
	/* 538 */ (void (*)(void))0,
	/* 539 */ (void (*)(void))0,
	/* 540 */ (void (*)(void))0,
	/* 541 */ (void (*)(void))0,
	/* 542 */ (void (*)(void))0,
	/* 543 */ (void (*)(void))0,
	/* 544 */ (void (*)(void))0,
	/* 545 */ (void (*)(void))0,
	/* 546 */ (void (*)(void))0,
	/* 547 */ (void (*)(void))0,
	/* 548 */ (void (*)(void))0,
	/* 549 */ (void (*)(void))0,
	/* 550 */ (void (*)(void))0,
	/* 551 */ (void (*)(void))0,
	/* 552 */ (void (*)(void))0,
	/* 553 */ (void (*)(void))0,
	/* 554 */ (void (*)(void))0,
	/* 555 */ (void (*)(void))0,
	/* 556 */ (void (*)(void))0,
	/* 557 */ (void (*)(void))0,
	/* 558 */ (void (*)(void))0,
	/* 559 */ (void (*)(void))0,
	/* 560 */ (void (*)(void))0,
	/* 561 */ (void (*)(void))0,
	/* 562 */ (void (*)(void))0,
	/* 563 */ (void (*)(void))0,
	/* 564 */ (void (*)(void))0,
	/* 565 */ (void (*)(void))0,
	/* 566 */ (void (*)(void))0,
	/* 567 */ (void (*)(void))0,
	/* 568 */ (void (*)(void))0,
	/* 569 */ (void (*)(void))0,
	/* 570 */ primitiveFlushExternalPrimitives,
	/* 571 */ primitiveUnloadModule,
	/* 572 */ primitiveListBuiltinModule,
	/* 573 */ primitiveListExternalModule,
	/* 574 */ (void (*)(void))0,
	/* 575 */ (void (*)(void))0,
 0 };
char expensiveAsserts = 0;
const char *interpreterVersion = "Newspeak Virtual Machine StackInterpreterPrimitives_VMMaker.oscog-eem.1590";
volatile int sendTrace;
sqInt suppressHeartbeatFlag;


/*** Macros ***/
#define mostRecentlyUsedPage() GIV(mostRecentlyUsedPage)
#define stackPageAtpages(index,pages) ((pages) + (index))
#define statMaxPageCountWhenMapping() GIV(statMaxPageCountWhenMapping)
#define pageIndexForstackMemorybytesPerPage(pointer,stackmem,pageByteSize) (((char *)(pointer) - (stackmem) - 1) / (pageByteSize))
#define numTagBits() 2
#define shiftForWord() 2
#define tagMask() 0x3
#define wordSize() 4
#define eden() GIV(eden)
#define futureSpace() GIV(futureSpace)
#define futureSurvivorStart() GIV(futureSurvivorStart)
#define pastSpace() GIV(pastSpace)
#define rememberedSetLimit() GIV(rememberedSetLimit)
#define rememberedSetSize() GIV(rememberedSetSize)
#define characterTag() 2
#define classIndexMask() 0x3FFFFF
#define classTableMajorIndexShift() 10
#define endOfMemory() GIV(endOfMemory)
#define firstByteFormat() 16
#define firstCompiledMethodFormat() 24
#define firstLongFormat() 10
#define firstShortFormat() 12
#define fixedFieldsFieldWidth() 16
#define formatMask() 0x1F
#define formatShift() 24
#define freeStart() GIV(freeStart)
#define identityHashFullWordShift() 32
#define identityHashHalfWordMask() 0x3FFFFF
#define indexablePointersFormat() 3
#define isForwardedObjectClassIndexPun() 8
#define maxOldSpaceSize() maxOldSpaceSize
#define memory() GIV(memory)
#define newSpaceLimit() GIV(newSpaceLimit)
#define numSlotsFullShift() 56
#define numSlotsHalfShift() 24
#define numSlotsMask() 0xFF
#define oldSpaceStart() GIV(oldSpaceStart)
#define remapBufferCount() GIV(remapBufferCount)
#define rememberedBitShift() 29
#define rootTableCapacity() GIV(rememberedSetLimit)
#define rootTableCount() GIV(rememberedSetSize)
#define sixtyFourBitIndexableFormat() 9
#define startOfMemory() GIV(memory)
#define weakArrayFormat() 4
#define numSegments() GIV(numSegments)
#define alternateHeaderNumLiteralsMask() 0x7FFF
#define checkAllocFiller() GIV(checkAllocFiller)
#define dispatchFunctionPointer(aFunctionPointer) (aFunctionPointer)()
#define flush() fflush(stdout)
#define printFloat(f) printf("%g", f)
#define stackPageFrameBytes() (256 * BytesPerWord)
#define allocatype(numElements, elementType) alloca((numElements)*sizeof(elementType))
#define numElementsIn(anArray) (sizeof(anArray)/sizeof(anArray[0]))
#define oopisGreaterThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) >= (usqInt)(otherOop))
#define oopisGreaterThanOrEqualToandLessThanOrEqualTo(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) <= (usqInt)(limitOop))
#define oopisGreaterThanOrEqualToandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) >= (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisGreaterThan(anOop,otherOop) ((usqInt)(anOop) > (usqInt)(otherOop))
#define oopisGreaterThanandLessThan(anOop,baseOop,limitOop) ((usqInt)(anOop) > (usqInt)(baseOop) && (usqInt)(anOop) < (usqInt)(limitOop))
#define oopisLessThanOrEqualTo(anOop,otherOop) ((usqInt)(anOop) <= (usqInt)(otherOop))
#define oopisLessThan(anOop,otherOop) ((usqInt)(anOop) < (usqInt)(otherOop))



/*	This is the main interpreter loop. It normally loops forever, fetching and
	executing bytecodes. When running in the context of a browser plugin VM,
	however, it must return control to the browser periodically. This should
	done only when the state of the currently running Squeak thread is safely
	stored in the object heap. Since this is the case at the moment that a
	check for interrupts is performed, that is when we return to the browser
	if it is time to do so. Interrupt checks happen quite frequently.
 */
/*	If stacklimit is zero then the stack pages have not been initialized. */

	/* StackInterpreter>>#interpret */
sqInt
interpret(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt currentBytecode;
    sqInt extA;
    sqInt extB;
    char * localFP;
    char * localIP;
    sqInt localReturnValue;
    char * localSP;
    sqInt stackPageBytes;
    sqInt stackPagesBytes;
    void *theStackMemory;

	if (GIV(stackLimit) == 0) {
		/* begin initStackPagesAndInterpret */
		stackPageBytes = stackPageByteSize();
		/* begin computeStackZoneSize */
		stackPagesBytes = (GIV(numStackPages) * ((sizeof(CogStackPage)) + (stackPageByteSize()))) + BytesPerWord;
		theStackMemory = alloca(stackPagesBytes);
		memset(theStackMemory, 0, stackPagesBytes);
		initializeStacknumSlotspageSize(theStackMemory, stackPagesBytes / BytesPerWord, stackPageBytes / BytesPerWord);
		loadInitialContext();
		ioInitHeartbeat();
		interpret();
		return null;
	}
	browserPluginInitialiseIfNeeded();
	/* begin internalizeIPandSP */
	localIP = pointerForOop(GIV(instructionPointer));
	localSP = pointerForOop(GIV(stackPointer));
	localFP = pointerForOop(GIV(framePointer));
	/* begin fetchNextBytecode */
	currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

	/* begin initExtensions */
	extA = (extB = 0);

	while (1) {
		bytecodeDispatchDebugHook();

		VM_LABEL(bytecodeDispatch);
		switch (currentBytecode) {
		case 0:
		case 256: /*0*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize)));
			}
			break;
		case 1:
		case 257: /*1*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 4 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 2:
		case 258: /*2*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 8 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 3:
		case 259: /*3*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 12 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 4:
		case 260: /*4*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 16 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 5:
		case 261: /*5*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 20 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 6:
		case 262: /*6*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 24 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 7:
		case 263: /*7*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 28 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 8:
		case 264: /*8*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 32 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 9:
		case 265: /*9*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 36 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 10:
		case 266: /*10*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 40 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 11:
		case 267: /*11*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 44 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 12:
		case 268: /*12*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 48 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 13:
		case 269: /*13*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 52 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 14:
		case 270: /*14*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 56 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 15:
		case 271: /*15*/
			/* pushReceiverVariableBytecode */
			{
				VM_LABEL(pushReceiverVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushReceiverVariable: */
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + 60 /* (currentBytecode bitAnd: 15) << self shiftForWord */));
			}
			break;
		case 16:
		case 320: /*64*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (0 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 17:
		case 321: /*65*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (1 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 18:
		case 322: /*66*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (2 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 19:
		case 323: /*67*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (3 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 20:
		case 324: /*68*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (4 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 21:
		case 325: /*69*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (5 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 22:
		case 326: /*70*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (6 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 23:
		case 327: /*71*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (7 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 24:
		case 328: /*72*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (8 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 8 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 25:
		case 329: /*73*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (9 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 9 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 26:
		case 330: /*74*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (10 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 10 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 27:
		case 331: /*75*/
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (11 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 11 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 28:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (12 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 12 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 29:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (13 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 13 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 30:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (14 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 14 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 31:
			/* pushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt object;

				VM_LABEL(pushTemporaryVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushTemporaryVariable: */
				/* begin internalPush: */
				object = (15 /* currentBytecode bitAnd: 15 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 15 /* currentBytecode bitAnd: 15 */) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 32:
		case 288: /*32*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 4 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 33:
		case 289: /*33*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 34:
		case 290: /*34*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 12 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 35:
		case 291: /*35*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 36:
		case 292: /*36*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 20 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 37:
		case 293: /*37*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 38:
		case 294: /*38*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 28 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 39:
		case 295: /*39*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 40:
		case 296: /*40*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 36 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 41:
		case 297: /*41*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 42:
		case 298: /*42*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 44 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 43:
		case 299: /*43*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 44:
		case 300: /*44*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 52 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 45:
		case 301: /*45*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 46:
		case 302: /*46*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 60 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 47:
		case 303: /*47*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 48:
		case 304: /*48*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode16);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 68 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 49:
		case 305: /*49*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode17);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 50:
		case 306: /*50*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode18);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 76 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 51:
		case 307: /*51*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode19);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 52:
		case 308: /*52*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode20);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 84 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 53:
		case 309: /*53*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode21);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 54:
		case 310: /*54*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode22);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 92 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 55:
		case 311: /*55*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode23);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 56:
		case 312: /*56*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode24);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 100 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 57:
		case 313: /*57*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode25);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 58:
		case 314: /*58*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode26);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 108 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 59:
		case 315: /*59*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode27);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 60:
		case 316: /*60*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode28);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 116 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 61:
		case 317: /*61*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode29);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 62:
		case 318: /*62*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode30);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 0x7C /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 63:
		case 319: /*63*/
			/* pushLiteralConstantBytecode */
			{
				sqInt object;

				VM_LABEL(pushLiteralConstantBytecode31);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 64:
		case 272: /*16*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 4 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 65:
		case 273: /*17*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 8 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 66:
		case 274: /*18*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 12 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 67:
		case 275: /*19*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 16 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 68:
		case 276: /*20*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 20 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 69:
		case 277: /*21*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 24 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 70:
		case 278: /*22*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 28 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 71:
		case 279: /*23*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 32 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 72:
		case 280: /*24*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 36 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 73:
		case 281: /*25*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode9);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 40 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 74:
		case 282: /*26*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode10);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 44 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 75:
		case 283: /*27*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode11);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 48 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 76:
		case 284: /*28*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode12);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 52 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 77:
		case 285: /*29*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode13);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 56 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 78:
		case 286: /*30*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode14);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 60 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 79:
		case 287: /*31*/
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode15);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 64 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 80:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode16);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 68 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 81:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode17);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 72 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 82:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode18);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 76 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 83:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode19);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 80 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 84:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode20);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 84 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 85:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode21);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 88 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 86:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode22);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 92 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 87:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode23);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 96 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 88:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode24);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 100 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 89:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode25);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 104 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 90:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode26);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 108 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 91:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode27);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 112 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 92:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode28);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 116 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 93:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode29);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 120 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 94:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode30);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 0x7C /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 95:
			/* pushLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(pushLiteralVariableBytecode31);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + 128 /* ((currentBytecode bitAnd: 31) + LiteralStart) << self shiftForWord */);
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + 4 /* ValueIndex << self shiftForWord */));

			}
			break;
		case 96:
		case 97:
		case 98:
		case 99:
		case 100:
		case 101:
		case 102:
		case 103:
		case 432: /*176*/
		case 433: /*177*/
		case 434: /*178*/
		case 435: /*179*/
		case 436: /*180*/
		case 437: /*181*/
		case 438: /*182*/
		case 439: /*183*/
			/* storeAndPopReceiverVariableBytecode */
			{
				sqInt rcvr;
				sqInt top;

				VM_LABEL(storeAndPopReceiverVariableBytecode);
				rcvr = longAt(localFP + FoxReceiver);
				top = longAtPointer(localSP);
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				if (isOldObject(rcvr)) {

					/* most stores into young objects */

					if (((top & (tagMask())) == 0)
					 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(rcvr);
						}
					}
				}
				longAtput((rcvr + BaseHeaderSize) + ((currentBytecode & 7) << (shiftForWord())), top);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 104:
		case 440: /*184*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (0 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 105:
		case 441: /*185*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode1);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (1 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 1 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 106:
		case 442: /*186*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode2);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (2 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 2 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 107:
		case 443: /*187*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode3);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (3 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 3 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 108:
		case 444: /*188*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode4);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (4 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 4 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 109:
		case 445: /*189*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode5);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (5 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 5 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 110:
		case 446: /*190*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode6);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (6 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 6 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 111:
		case 447: /*191*/
			/* storeAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;

				VM_LABEL(storeAndPopTemporaryVariableBytecode7);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (7 /* currentBytecode bitAnd: 7 */ < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - 7 /* currentBytecode bitAnd: 7 */) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 112:
		case 332: /*76*/
			/* pushReceiverBytecode */
			{
				VM_LABEL(pushReceiverBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt(localFP + FoxReceiver));
			}
			break;
		case 113:
			/* pushConstantTrueBytecode */
			{
				VM_LABEL(pushConstantTrueBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
			break;
		case 114:
			/* pushConstantFalseBytecode */
			{
				VM_LABEL(pushConstantFalseBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
			break;
		case 115:
			/* pushConstantNilBytecode */
			{
				VM_LABEL(pushConstantNilBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
			}
			break;
		case 116:
			/* pushConstantMinusOneBytecode */
			{
				VM_LABEL(pushConstantMinusOneBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstMinusOne);
			}
			break;
		case 117:
		case 334: /*78*/
			/* pushConstantZeroBytecode */
			{
				VM_LABEL(pushConstantZeroBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstZero);
			}
			break;
		case 118:
		case 335: /*79*/
			/* pushConstantOneBytecode */
			{
				VM_LABEL(pushConstantOneBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstOne);
			}
			break;
		case 119:
			/* pushConstantTwoBytecode */
			{
				VM_LABEL(pushConstantTwoBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ConstTwo);
			}
			break;
		case 120:
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver);
				localReturnValue = longAt(localFP + FoxReceiver);
				/* goto commonReturn */
			}
			
		commonReturn:
			/* commonReturn */
			{
				char *callerFP;
				sqInt closure;
				sqInt contextToReturnTo;
				sqInt ctxtOrNilOrZero;
				sqInt currentCtx;
				char *frameToReturnTo;
				sqInt home;
				sqInt index;
				sqInt index1;
				StackPage *newPage;
				sqInt nextCntx;
				sqInt objOop;
				sqInt objOop1;
				sqInt onSamePage;
				sqInt ourContext;
				sqInt ourContext1;
				sqInt ourContext2;
				sqInt senderContext;
				sqInt senderOop;
				sqInt senderOop1;
				sqInt senderOop2;
				char *theFP;
				char *theFP1;
				char *theFP2;
				char *theFPAbove;
				sqInt theMethod;
				sqInt theMethod1;
				StackPage *thePage;
				StackPage *thePage1;
				char *theSP;
				sqInt unwindContextOrNilOrZero;

				VM_LABEL(commonReturn);
				
				/* If this is a method simply return to the  sender/caller. */

				frameToReturnTo = 0;
				if (!((byteAt((localFP + FoxFrameFlags) + 3)) != 0)) {
					goto commonCallerReturn;
					goto l226;
				}
				closure = longAt(localFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((localFP + FoxFrameFlags) + 1)) << (shiftForWord()))));

				/* Walk the closure's lexical chain to find the context or frame to return from (home). */

				home = null;
				while (closure != GIV(nilObj)) {
					/* begin followField:ofObject: */
					objOop = longAt((closure + BaseHeaderSize) + (ClosureOuterContextIndex << (shiftForWord())));
					if (((objOop & (tagMask())) == 0)
					 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, closure, objOop);
					}
					home = objOop;
					/* begin followField:ofObject: */
					objOop1 = longAt((home + BaseHeaderSize) + (ClosureIndex << (shiftForWord())));
					if (((objOop1 & (tagMask())) == 0)
					 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						objOop1 = fixFollowedFieldofObjectwithInitialValue(ClosureIndex, home, objOop1);
					}
					closure = objOop1;
				}
				/* begin writeBackHeadFramePointers */
				assert(GIV(stackPage) == (mostRecentlyUsedPage()));
				/* begin setHeadFP:andSP:inPage: */
				assert(localSP < localFP);
				assert((localSP < ((GIV(stackPage)->baseAddress)))
				 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
				assert((localFP < ((GIV(stackPage)->baseAddress)))
				 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
				(GIV(stackPage)->headFP = localFP);
				(GIV(stackPage)->headSP = localSP);
				assert(pageListIsWellFormed());
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin findUnwindThroughContext: */

				/* Since nothing changes we don't need to internalize. */

				onSamePage = ((((longAt((home + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
				 && (!(isWidowedContext(home))))
				 && ((pageIndexForstackMemorybytesPerPage(GIV(framePointer), GIV(stackMemory), GIV(bytesPerPage))) == (pageIndexFor(frameOfMarriedContext(home))));
				/* begin findMethodWithPrimitive:FromFP:UpToContext: */
				theFP2 = GIV(framePointer);
				theFPAbove = GIV(framePointer);
				do {
					if (((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0)
					 && (home == (longAt(theFP2 + FoxThisContext)))) {
						ctxtOrNilOrZero = 0;
						goto l227;
					}
					if (!((byteAt((theFP2 + FoxFrameFlags) + 3)) != 0)) {
						theMethod1 = longAt(theFP2 + FoxMethod);
						if ((primitiveIndexOfMethodheader(theMethod1, methodHeaderOf(theMethod1))) == 198) {
							if (theFP2 == theFPAbove) {
								theSP = findSPOfon(theFP2, stackPageFor(theFP2));
							}
							else {
								/* begin frameCallerStackPointer: */
								assert(!(isBaseFrame(theFPAbove)));
								theSP = (theFPAbove + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((theFPAbove + FoxFrameFlags) + 1)) << (shiftForWord())))) + BytesPerWord;
							}
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((theFP2 + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(theFP2)));
								ctxtOrNilOrZero = longAt(theFP2 + FoxThisContext);
								goto l227;
							}
							ctxtOrNilOrZero = marryFrameSP(theFP2, theSP);
							goto l227;
						}
					}
					theFPAbove = theFP2;
					/* begin frameCallerFP: */
					theFP2 = pointerForOop(longAt(theFP2 + FoxSavedFP));
				} while(theFP2 != 0);
				senderContext = longAt(theFPAbove + FoxCallerContext);
				if (!(((senderContext & (tagMask())) == 0)
					 && (((longAt(senderContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
					ctxtOrNilOrZero = GIV(nilObj);
					goto l227;
				}
				ctxtOrNilOrZero = findMethodWithPrimitiveFromContextUpToContext(198, senderContext, home);
			l227:	/* end findMethodWithPrimitive:FromFP:UpToContext: */;
				assert(!((onSamePage
 && (ctxtOrNilOrZero == (nilObject())))));
				if (ctxtOrNilOrZero == 0) {
					theMethod = longAt((home + BaseHeaderSize) + (MethodIndex << (shiftForWord())));
					if ((primitiveIndexOfMethodheader(theMethod, methodHeaderOf(theMethod))) == 198) {
						unwindContextOrNilOrZero = home;
						goto l230;
					}
					unwindContextOrNilOrZero = 0;
					goto l230;
				}
				if (!(onSamePage
					 || (ctxtOrNilOrZero == GIV(nilObj)))) {
					if ((findMethodWithPrimitiveFromContextUpToContext(0, ctxtOrNilOrZero, home)) == GIV(nilObj)) {
						unwindContextOrNilOrZero = GIV(nilObj);
						goto l230;
					}
				}
				unwindContextOrNilOrZero = ctxtOrNilOrZero;
			l230:	/* end findUnwindThroughContext: */;
				if (unwindContextOrNilOrZero == GIV(nilObj)) {

					/* error: can't find home on chain; cannot return */

					/* begin internalCannotReturn: */
					/* begin ensureFrameIsMarried:SP: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext = longAt(localFP + FoxThisContext);
						goto l229;
					}
					ourContext = marryFrameSP(localFP, localSP);
				l229:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << (shiftForWord())));
					GIV(argumentCount) = 1;
					goto normalSend;
					goto l226;
				}
				if (unwindContextOrNilOrZero != 0) {
					/* begin internalAboutToReturn:through: */
					/* begin ensureFrameIsMarried:SP: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						ourContext1 = longAt(localFP + FoxThisContext);
						goto l232;
					}
					ourContext1 = marryFrameSP(localFP, localSP);
				l232:	/* end ensureFrameIsMarried:SP: */;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), ourContext1);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localReturnValue);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), unwindContextOrNilOrZero);
					GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorAboutToReturn << (shiftForWord())));
					GIV(argumentCount) = 2;
					goto normalSend;
					goto l226;
				}
				contextToReturnTo = null;
				if (((longAt((home + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1)) {
					assert(checkIsStillMarriedContextcurrentFP(home, localFP));
					/* begin frameOfMarriedContext: */
					senderOop = longAt((home + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1);
					if ((longAt(theFP + FoxSavedFP)) == 0) {
						contextToReturnTo = longAt(theFP + FoxCallerContext);
					}
					else {
						/* begin frameCallerFP: */
						frameToReturnTo = pointerForOop(longAt(theFP + FoxSavedFP));
					}
				}
				else {
					contextToReturnTo = longAt((home + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
					if ((((contextToReturnTo & (tagMask())) == 0)
					 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex))
					 && (((longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))) {
						assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
						/* begin frameOfMarriedContext: */
						senderOop1 = longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
						/* begin withoutSmallIntegerTags: */
						assert((senderOop1 & 1));
						frameToReturnTo = pointerForOop(senderOop1 - 1);
						contextToReturnTo = null;
					}
				}
				if (contextToReturnTo != null) {
					/* begin establishFrameForContextToReturnTo: */
					if (!(((contextToReturnTo & (tagMask())) == 0)
						 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
						frameToReturnTo = 0;
						goto l231;
					}
					if (((longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1)) {
						if (isWidowedContext(contextToReturnTo)) {

							/* error: home's sender is dead; cannot return */

							frameToReturnTo = 0;
							goto l231;
						}
						/* begin frameOfMarriedContext: */
						senderOop2 = longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
						/* begin withoutSmallIntegerTags: */
						assert((senderOop2 & 1));
						frameToReturnTo = pointerForOop(senderOop2 - 1);
						goto l231;
					}
					if (!(((longAt((contextToReturnTo + BaseHeaderSize) + (InstructionPointerIndex << (shiftForWord())))) & 1))) {
						frameToReturnTo = 0;
						goto l231;
					}
					thePage1 = makeBaseFrameFor(contextToReturnTo);
					markStackPageMostRecentlyUsed(thePage1);
					frameToReturnTo = (thePage1->baseFP);
				l231:	/* end establishFrameForContextToReturnTo: */;
					if (frameToReturnTo == 0) {

						/* error: home's sender is dead; cannot return */

						/* begin internalCannotReturn: */
						/* begin ensureFrameIsMarried:SP: */
						if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(localFP)));
							ourContext2 = longAt(localFP + FoxThisContext);
							goto l228;
						}
						ourContext2 = marryFrameSP(localFP, localSP);
					l228:	/* end ensureFrameIsMarried:SP: */;
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), ourContext2);
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), localReturnValue);
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << (shiftForWord())));
						GIV(argumentCount) = 1;
						goto normalSend;
						goto l226;
					}
				}
				assert(pageListIsWellFormed());
				/* begin stackPageFor: */
				/* begin stackPageAt: */
				index1 = pageIndexForstackMemorybytesPerPage(frameToReturnTo, GIV(stackMemory), GIV(bytesPerPage));
				newPage = stackPageAtpages(index1, GIV(pages));
				if (newPage != GIV(stackPage)) {
					currentCtx = longAt(((GIV(stackPage)->baseFP)) + FoxCallerContext);
					freeStackPage(GIV(stackPage));
					while (1) {
						assert(isContext(currentCtx));
						if ((((longAt((currentCtx + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
						 && ((stackPageFor((theFP = frameOfMarriedContext(currentCtx)))) == newPage)) break;
						if (((longAt((currentCtx + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1)) {
							/* begin stackPageFor: */
							/* begin stackPageAt: */
							index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
							thePage = stackPageAtpages(index, GIV(pages));
							if (theFP != ((thePage->headFP))) {

								/* Since we've just deallocated a page we know that newStackPage won't deallocate an existing one. */

								moveFramesInthroughtoPage(thePage, findFrameAboveinPage(theFP, thePage), newStackPage());
							}
							/* begin frameCallerContext: */
							theFP1 = (thePage->baseFP);
							currentCtx = longAt(theFP1 + FoxCallerContext);
							freeStackPage(thePage);
						}
						else {
							nextCntx = longAt((currentCtx + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
							/* begin markContextAsDead: */
							assert(isContext(currentCtx));
							/* begin storePointerUnchecked:ofObject:withValue: */
							assert(!(isForwarded(currentCtx)));
							longAtput((currentCtx + BaseHeaderSize) + (SenderIndex << (shiftForWord())), GIV(nilObj));
							/* begin storePointerUnchecked:ofObject:withValue: */
							assert(!(isForwarded(currentCtx)));
							longAtput((currentCtx + BaseHeaderSize) + (InstructionPointerIndex << (shiftForWord())), GIV(nilObj));
							currentCtx = nextCntx;
						}
					}
					/* begin setStackPageAndLimit: */
					assert(newPage != 0);
					GIV(stackPage) = newPage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(newPage);
					localSP = (GIV(stackPage)->headSP);
					localFP = (GIV(stackPage)->headFP);
				}
				if (localFP == frameToReturnTo) {

					/* pop the saved IP, push the return value and continue. */

					localIP = pointerForOop(longAtPointer(localSP));
				}
				else {
					do {
						callerFP = localFP;
						/* begin frameCallerFP: */
						localFP = pointerForOop(longAt(localFP + FoxSavedFP));
					} while(localFP != frameToReturnTo);
					/* begin frameCallerSavedIP: */
					localIP = pointerForOop(longAt(callerFP + FoxCallerSavedIP));
					localSP = (frameCallerSP(callerFP)) - BytesPerWord;
				}
				/* begin maybeReturnToMachineCodeFrame */
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
					? 256
					: 0);

				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				longAtPointerput(localSP, localReturnValue);
			}
		l226:	/* end case */;
			break;
		case 121:
			/* returnTrue */
			{
				VM_LABEL(returnTrue);
				localReturnValue = GIV(trueObj);
				goto commonReturn;
			}
			break;
		case 122:
			/* returnFalse */
			{
				VM_LABEL(returnFalse);
				localReturnValue = GIV(falseObj);
				goto commonReturn;
			}
			break;
		case 123:
			/* returnNil */
			{
				VM_LABEL(returnNil);
				localReturnValue = GIV(nilObj);
				goto commonReturn;
			}
			break;
		case 124:
		case 473: /*217*/
			/* returnTopFromMethod */
			{
				VM_LABEL(returnTopFromMethod);
				localReturnValue = longAtPointer(localSP);
				goto commonReturn;
			}
			break;
		case 125:
			/* returnTopFromBlock */
			{
				VM_LABEL(returnTopFromBlock);
				localReturnValue = longAtPointer(localSP);
				/* goto commonCallerReturn */
			}
			
		commonCallerReturn:
			/* commonCallerReturn */
			{
				char *callerFP;
				char *callersFPOrNull;
				sqInt contextToReturnTo;
				char *fp;
				char *frameAbove;
				sqInt index;
				sqInt isAContext;
				sqInt ourContext;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				char *theSP;

				VM_LABEL(commonCallerReturn);
				/* begin frameCallerFP: */
				callersFPOrNull = pointerForOop(longAt(localFP + FoxSavedFP));
				if (callersFPOrNull == 0) {

					/* baseFrame */

					assert(localFP == ((GIV(stackPage)->baseFP)));
					/* begin baseFrameReturn */
					contextToReturnTo = longAt(localFP + FoxCallerContext);
					isAContext = ((contextToReturnTo & (tagMask())) == 0)
					 && (((longAt(contextToReturnTo)) & (classIndexMask())) == ClassMethodContextCompactIndex);
					if (isAContext
					 && ((((longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
					 && (!(isWidowedContext(contextToReturnTo))))) {
						/* begin frameOfMarriedContext: */
						senderOop = longAt((contextToReturnTo + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
						/* begin withoutSmallIntegerTags: */
						assert((senderOop & 1));
						theFP = pointerForOop(senderOop - 1);
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						index = pageIndexForstackMemorybytesPerPage(theFP, GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index, GIV(pages));
						if (theFP == ((thePage->headFP))) {
							theSP = (thePage->headSP);
							freeStackPageNoAssert(GIV(stackPage));
						}
						else {

							/* Returning to some interior frame, presumably because of a sender assignment.
							   Move the frames above to another page (they may be in use, e.g. via coroutining).
							   Make the interior frame the top frame. */

							/* begin findFrameAbove:inPage: */
							fp = (thePage->headFP);
							if (fp == theFP) {
								frameAbove = 0;
								goto l234;
							}
							while (((callerFP = frameCallerFP(fp))) != 0) {
								if (callerFP == theFP) {
									frameAbove = fp;
									goto l234;
								}
								fp = callerFP;
							}
							error("did not find theFP in stack page");
							frameAbove = 0;
						l234:	/* end findFrameAbove:inPage: */;
							moveFramesInthroughtoPage(thePage, frameAbove, GIV(stackPage));
							theFP = (thePage->headFP);
							theSP = (thePage->headSP);
						}
					}
					else {
						if (!(isAContext
							 && (((longAt((contextToReturnTo + BaseHeaderSize) + (InstructionPointerIndex << (shiftForWord())))) & 1)))) {
							/* begin internalCannotReturn: */
							/* begin ensureFrameIsMarried:SP: */
							if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(localFP)));
								ourContext = longAt(localFP + FoxThisContext);
								goto l235;
							}
							ourContext = marryFrameSP(localFP, localSP);
						l235:	/* end ensureFrameIsMarried:SP: */;
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), ourContext);
							/* begin internalPush: */
							longAtPointerput((localSP -= BytesPerOop), localReturnValue);
							GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorCannotReturn << (shiftForWord())));
							GIV(argumentCount) = 1;
							goto normalSend;
							/* return self */
							goto l233;
						}
						thePage = makeBaseFrameFor(contextToReturnTo);
						theFP = (thePage->headFP);
						theSP = (thePage->headSP);
						freeStackPageNoAssert(GIV(stackPage));
					}
					/* begin setStackPageAndLimit: */
					assert(thePage != 0);
					GIV(stackPage) = thePage;
					if (GIV(stackLimit) != (((char *) (((usqInt) -1))))) {
						GIV(stackLimit) = (GIV(stackPage)->stackLimit);
					}
					markStackPageMostRecentlyUsed(thePage);
					assert((stackPageFor(theFP)) == GIV(stackPage));
					localSP = theSP;
					localFP = theFP;
					/* begin setMethod: */
					GIV(method) = longAt(localFP + FoxMethod);
					assert(isOopCompiledMethod(GIV(method)));
					GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
						? 256
						: 0);

					localIP = pointerForOop(longAtPointer(localSP));
					longAtPointerput(localSP, localReturnValue);
					assert(checkIsStillMarriedContextcurrentFP(contextToReturnTo, localFP));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l233;
				}
				/* begin frameCallerSavedIP: */
				localIP = pointerForOop(longAt(localFP + FoxCallerSavedIP));
				localSP = localFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((localFP + FoxFrameFlags) + 1)) << (shiftForWord())));
				localFP = callersFPOrNull;
				/* begin setMethod: */
				GIV(method) = longAt(localFP + FoxMethod);
				assert(isOopCompiledMethod(GIV(method)));
				GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
					? 256
					: 0);

				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				longAtPointerput(localSP, localReturnValue);
			}
		l233:	/* end case */;
			break;
		case 126:
		case 127:
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode);
				/* goto respondToUnknownBytecode */
			}
			
		respondToUnknownBytecode:
			/* respondToUnknownBytecode */
			{
				sqInt ourContext;

				VM_LABEL(respondToUnknownBytecode);
				GIV(messageSelector) = (SelectorUnknownBytecode < (numSlotsOf(GIV(specialObjectsOop)))
					? longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorUnknownBytecode << (shiftForWord())))
					: 0);
				if ((GIV(messageSelector) == null)
				 || (GIV(messageSelector) == GIV(nilObj))) {
					error("Unknown bytecode");
				}
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l236;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l236:	/* end ensureFrameIsMarried:SP: */;
				localIP -= 1;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 128:
			/* extendedPushBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt object;
				sqInt object1;
				sqInt object2;
				sqInt objOop;
				sqInt referent;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedPushBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin pushReceiverVariable: */
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt(((longAt(localFP + FoxReceiver)) + BaseHeaderSize) + (variableIndex << (shiftForWord()))));
					goto l1;
				}
				if (variableType == 1) {
					/* begin pushTemporaryVariable: */
					/* begin internalPush: */
					object1 = (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
						? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord))
						: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord)));
					longAtPointerput((localSP -= BytesPerOop), object1);
					goto l1;
				}
				if (variableType == 2) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << (shiftForWord())));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l1;
				}
				if (variableType == 3) {
					/* begin pushLiteralVariable: */
					
					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */

					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << (shiftForWord())));
					if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar));
						referent = longAt((litVar + BaseHeaderSize) + (0 << (shiftForWord())));
						while (((referent & (tagMask())) == 0)
						 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent = longAt((referent + BaseHeaderSize) + (0 << (shiftForWord())));
						}
						litVar = referent;
					}
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + (ValueIndex << (shiftForWord()))));

					goto l1;
				}
			}
		l1:	/* end case */;
			break;
		case 129:
			/* extendedStoreBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt objOop;
				sqInt referent;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					objOop = longAt(localFP + FoxReceiver);
					assert(!(isForwarded(objOop)));
					if (isOldObject(objOop)) {

						/* most stores into young objects */

						if ((((longAtPointer(localSP)) & (tagMask())) == 0)
						 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(objOop);
							}
						}
					}
					longAtput((objOop + BaseHeaderSize) + (variableIndex << (shiftForWord())), longAtPointer(localSP));
					goto l2;
				}
				if (variableType == 1) {
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					goto l2;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << (shiftForWord())));
					if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar));
						referent = longAt((litVar + BaseHeaderSize) + (0 << (shiftForWord())));
						while (((referent & (tagMask())) == 0)
						 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent = longAt((referent + BaseHeaderSize) + (0 << (shiftForWord())));
						}
						litVar = referent;
					}
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar)));
					if (isOldObject(litVar)) {

						/* most stores into young objects */

						if ((((longAtPointer(localSP)) & (tagMask())) == 0)
						 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(litVar);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (ValueIndex << (shiftForWord())), longAtPointer(localSP));
					goto l2;
				}
				error("illegal store");
			}
		l2:	/* end case */;
			break;
		case 130:
			/* extendedStoreAndPopBytecode */
			{
				sqInt descriptor;
				sqInt frameNumArgs;
				sqInt litVar;
				sqInt objOop;
				sqInt referent;
				sqInt variableIndex;
				sqInt variableType;

				VM_LABEL(extendedStoreAndPopBytecode);
				/* begin extendedStoreBytecode */
				descriptor = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				variableType = (((usqInt) descriptor) >> 6) & 3;
				variableIndex = descriptor & 0x3F;
				if (variableType == 0) {
					/* begin storePointer:ofObject:withValue: */
					objOop = longAt(localFP + FoxReceiver);
					assert(!(isForwarded(objOop)));
					if (isOldObject(objOop)) {

						/* most stores into young objects */

						if ((((longAtPointer(localSP)) & (tagMask())) == 0)
						 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(objOop))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(objOop);
							}
						}
					}
					longAtput((objOop + BaseHeaderSize) + (variableIndex << (shiftForWord())), longAtPointer(localSP));
					goto l3;
				}
				if (variableType == 1) {
					if (variableIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
						longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					else {
						longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - variableIndex) * BytesPerWord), longAtPointer(localSP));
					}
					goto l3;
				}
				if (variableType == 3) {
					/* begin storeLiteralVariable:withValue: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << (shiftForWord())));
					if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar));
						referent = longAt((litVar + BaseHeaderSize) + (0 << (shiftForWord())));
						while (((referent & (tagMask())) == 0)
						 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent = longAt((referent + BaseHeaderSize) + (0 << (shiftForWord())));
						}
						litVar = referent;
					}
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar)));
					if (isOldObject(litVar)) {

						/* most stores into young objects */

						if ((((longAtPointer(localSP)) & (tagMask())) == 0)
						 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(litVar);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (ValueIndex << (shiftForWord())), longAtPointer(localSP));
					goto l3;
				}
				error("illegal store");
			l3:	/* end extendedStoreBytecode */;
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 131:
			/* singleExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((descriptor & 0x1F) + LiteralStart) << (shiftForWord())));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto normalSend */
			}
			
		normalSend:
			/* normalSend */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(normalSend);
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? ((tagBits & 1) != 0
							? 1
							: tagBits)
					: (longAt(rcvr)) & (classIndexMask()));
				assert(GIV(lkupClassTag) != (nilObject()));
				
			commonSendOrdinary:
				/* commonSendOrdinary */
				{
					sqInt classTablePage;
					sqInt errorCode;
					sqInt fieldIndex;
					sqInt fieldIndex1;
					sqInt hash1;
					sqInt i;
					sqInt localPrimIndex;
					sqInt methodHeader;
					sqInt nArgs;
					sqInt numTemps;
					usqInt object;
					sqInt probe1;
					sqInt rcvr;
					char *savedFramePointer;
					char *savedStackPointer;
					sqInt succeeded;
					sqInt table;

					VM_LABEL(commonSendOrdinary);
					nArgs = 0;
					savedFramePointer = 0;
					savedStackPointer = 0;
					/* begin sendBreakpoint:receiver: */
					sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
					
					/* begin internalFindNewMethodOrdinary */

					/* shift drops two low-order zeros from addresses */

					hash1 = GIV(messageSelector) ^ GIV(lkupClassTag);

					/* first probe */

					probe1 = hash1 & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == GIV(lkupClassTag))) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l238;
					}

					/* second probe */

					probe1 = (((usqInt) hash1) >> 1) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == GIV(lkupClassTag))) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l238;
					}
					probe1 = (((usqInt) hash1) >> 2) & MethodCacheMask;
					if (((GIV(methodCache)[probe1 + MethodCacheSelector]) == GIV(messageSelector))
					 && ((GIV(methodCache)[probe1 + MethodCacheClass]) == GIV(lkupClassTag))) {
						GIV(newMethod) = GIV(methodCache)[probe1 + MethodCacheMethod];
						primitiveFunctionPointer = ((void (*)()) (GIV(methodCache)[probe1 + MethodCachePrimFunction]));
						goto l238;
					}
					/* end inlineLookupInMethodCacheSel:classTag:; fall through */
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
					 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
						if (((GIV(messageSelector) & (tagMask())) == 0)
						 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
						}
						if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
							GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
						}
						if (lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag))) {
							goto l237;
						}
					}
					/* begin classAtIndex: */
					assert((GIV(lkupClassTag) <= (tagMask()))
					 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
					/* begin fetchPointer:ofObject: */
					fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
					classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (fieldIndex << (shiftForWord())));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l241;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex1 = GIV(lkupClassTag) & ((1 << (classTableMajorIndexShift())) - 1);
					GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (fieldIndex1 << (shiftForWord())));
				l241:	/* end classAtIndex: */;
					lookupOrdinarySend();

					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToCache(GIV(lkupClass));
				l238:	;
				l237:	/* end internalFindNewMethodOrdinary */;
					/* begin internalExecuteNewMethod */
					if (primitiveFunctionPointer != 0) {
						if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
							/* begin internalQuickPrimitiveResponse */
							assert(isPrimitiveFunctionPointerAnIndex());
							localPrimIndex = ((sqInt) primitiveFunctionPointer);
							assert((localPrimIndex > 0xFF)
							 && (localPrimIndex < 520));
							if (localPrimIndex >= 264) {
								/* begin internalStackTopPut: */
								longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + ((localPrimIndex - 264) << (shiftForWord()))));
								goto l242;
							}
							if (localPrimIndex == 256) {
								goto l242;
							}
							if (localPrimIndex == 257) {
								longAtPointerput(localSP, GIV(trueObj));
								goto l242;
							}
							if (localPrimIndex == 258) {
								longAtPointerput(localSP, GIV(falseObj));
								goto l242;
							}
							if (localPrimIndex == 259) {
								longAtPointerput(localSP, GIV(nilObj));
								goto l242;
							}
							longAtPointerput(localSP, (((localPrimIndex - 261) << 1) | 1));
						l242:	/* end internalQuickPrimitiveResponse */;
							goto l239;
						}
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						/* begin slowPrimitiveResponse */
						assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
						assert((remapBufferCount()) == 0);
						
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
						/* begin maybeRetryFailureDueToForwarding */
						if (GIV(primFailCode)
						 && (checkForAndFollowForwardedPrimitiveState())) {
							/* begin initPrimCall */
							GIV(primFailCode) = 0;
							dispatchFunctionPointer(primitiveFunctionPointer);
						}
						/* begin maybeFailForLastObjectOverwrite */
						if (checkAllocFiller) {
							if (((freeStart()) < GIV(scavengeThreshold))
							 && ((longAt(freeStart())) != (freeStart()))) {
								GIV(primFailCode) = PrimErrWritePastObject;
							}
						}
						
						if (GIV(nextProfileTick) > 0) {
							checkProfileTick(GIV(newMethod));
						}
						succeeded = !GIV(primFailCode);
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
						if (succeeded) {
							browserPluginReturnIfNeeded();
							goto l239;
						}
					}
					/* begin internalActivateNewMethod */
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(GIV(newMethod)));
					methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
					numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
					assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

					/* could new rcvr be set at point of send? */

					rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(!(isOopForwarded(rcvr)));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localIP);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), localFP);
					localFP = localSP;
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
					/* begin setMethod:methodHeader: */
					GIV(method) = GIV(newMethod);
					assert(isOopCompiledMethod(GIV(method)));
					assert((methodHeaderOf(GIV(method))) == methodHeader);
					GIV(bytecodeSetSelector) = ((((sqInt) methodHeader)) < 0
						? 256
						: 0);

					/* begin internalPush: */
					object = (VMBIGENDIAN
						? ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
						: ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << 8)) + (0)) + (0));
					longAtPointerput((localSP -= BytesPerOop), object);
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), rcvr);
					for (i = (GIV(argumentCount) + 1); i <= numTemps; i += 1) {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
					}
					localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
					if (methodHeader & AlternateHeaderHasPrimFlag) {

						/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
						   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

						localIP += 3;
						if (GIV(primFailCode) != 0) {
							if ((byteAt(localIP + 1)) == (((((sqInt) methodHeader)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode))) {
								/* begin getErrorObjectFromPrimFailCode */
								if (GIV(primFailCode) > 0) {
									table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << (shiftForWord())));
									if (GIV(primFailCode) <= (numSlotsOf(table))) {
										errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << (shiftForWord())));
										goto l240;
									}
								}
								errorCode = ((GIV(primFailCode) << 1) | 1);
							l240:	/* end getErrorObjectFromPrimFailCode */;
								longAtPointerput(localSP, errorCode);
							}
							GIV(primFailCode) = 0;
						}
					}
					assert((frameNumArgs(localFP)) == GIV(argumentCount));
					assert(!(frameIsBlockActivation(localFP)));
					assert(!(frameHasContext(localFP)));
					if (localSP < GIV(stackLimit)) {
						/* begin externalizeIPandSP */
						GIV(instructionPointer) = oopForPointer(localIP);
						GIV(stackPointer) = localSP;
						GIV(framePointer) = localFP;
						handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
						/* begin internalizeIPandSP */
						localIP = pointerForOop(GIV(instructionPointer));
						localSP = pointerForOop(GIV(stackPointer));
						localFP = pointerForOop(GIV(framePointer));
					}
				l239:	/* end internalExecuteNewMethod */;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
			}
			break;
		case 132:
			/* doubleExtendedDoAnythingBytecode */
			{
				sqInt byte2;
				sqInt byte3;
				char *callerFP;
				sqInt index1;
				sqInt litVar;
				sqInt litVar1;
				sqInt object;
				sqInt object1;
				sqInt object2;
				sqInt objOop;
				sqInt onCurrentPage;
				sqInt opType;
				sqInt rcvr;
				sqInt rcvr1;
				sqInt referent;
				sqInt referent1;
				sqInt senderOop;
				sqInt senderOop1;
				char *spouseFP;
				char *theFP;
				StackPage *thePage;
				char *theSP;
				sqInt top;

				VM_LABEL(doubleExtendedDoAnythingBytecode);
				byte2 = byteAtPointer(++localIP);
				byte3 = byteAtPointer(++localIP);
				opType = ((usqInt) byte2) >> 5;
				if (opType == 0) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << (shiftForWord())));
					GIV(argumentCount) = byte2 & 0x1F;
					goto normalSend;
					goto l4;
				}
				if (opType == 1) {
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << (shiftForWord())));
					GIV(argumentCount) = byte2 & 0x1F;
					goto superclassSend;
					goto l4;
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (opType == 2) {
					/* begin pushMaybeContextReceiverVariable: */
					rcvr1 = longAt(localFP + FoxReceiver);
					if ((byte3 <= StackPointerIndex)
					 && (((longAt(rcvr1)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
						/* begin internalPush: */
						/* begin instVar:ofContext: */
						assert(byte3 < MethodIndex);
						assert(isContext(rcvr1));
						if (!(((longAt((rcvr1 + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))) {
							object1 = longAt((rcvr1 + BaseHeaderSize) + (byte3 << (shiftForWord())));
							goto l6;
						}
						/* begin writeBackHeadFramePointers */
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						/* begin setHeadFP:andSP:inPage: */
						assert(localSP < localFP);
						assert((localSP < ((GIV(stackPage)->baseAddress)))
						 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
						assert((localFP < ((GIV(stackPage)->baseAddress)))
						 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
						(GIV(stackPage)->headFP = localFP);
						(GIV(stackPage)->headSP = localSP);
						assert(pageListIsWellFormed());
						if (isWidowedContext(rcvr1)) {
							object1 = longAt((rcvr1 + BaseHeaderSize) + (byte3 << (shiftForWord())));
							goto l6;
						}
						/* begin frameOfMarriedContext: */
						senderOop1 = longAt((rcvr1 + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
						/* begin withoutSmallIntegerTags: */
						assert((senderOop1 & 1));
						spouseFP = pointerForOop(senderOop1 - 1);
						if (byte3 == SenderIndex) {
							/* begin ensureCallerContext: */
							/* begin frameCallerFP: */
							callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
							if (callerFP == 0) {

								/* base frame, context in saved ip slot (or base of stack in Cog) */

								object1 = longAt(spouseFP + FoxCallerContext);
								goto l6;
							}
							/* begin ensureFrameIsMarried:SP: */
							/* begin frameCallerStackPointer: */
							assert(!(isBaseFrame(spouseFP)));
							theSP = (spouseFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((spouseFP + FoxFrameFlags) + 1)) << (shiftForWord())))) + BytesPerWord;
							if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
								assert(isContext(frameContext(callerFP)));
								object1 = longAt(callerFP + FoxThisContext);
								goto l6;
							}
							object1 = marryFrameSP(callerFP, theSP);
							goto l6;
						}
						if (byte3 == StackPointerIndex) {
							assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(rcvr1)));
							object1 = (((stackPointerIndexForFrame(spouseFP)) << 1) | 1);
							goto l6;
						}
						if (byte3 == InstructionPointerIndex) {
							object1 = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
							goto l6;
						}
						error("bad index");
						object1 = 0;
					l6:	/* end instVar:ofContext: */;
						longAtPointerput((localSP -= BytesPerOop), object1);
					}
					else {
						/* begin internalPush: */
						longAtPointerput((localSP -= BytesPerOop), longAt((rcvr1 + BaseHeaderSize) + (byte3 << (shiftForWord()))));
					}
					goto l4;
				}
				if (opType == 3) {
					/* begin pushLiteralConstant: */
					/* begin internalPush: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					object = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << (shiftForWord())));
					longAtPointerput((localSP -= BytesPerOop), object);
					goto l4;
				}
				if (opType == 4) {
					/* begin pushLiteralVariable: */
					
					/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
					   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
					   all methods in the stack zone, and the entire method on return, and global variables are relatively
					   rare; in my work image 8.7% of literals are globals). */

					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar1 = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << (shiftForWord())));
					if (((longAt(litVar1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar1));
						referent1 = longAt((litVar1 + BaseHeaderSize) + (0 << (shiftForWord())));
						while (((referent1 & (tagMask())) == 0)
						 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent1 = longAt((referent1 + BaseHeaderSize) + (0 << (shiftForWord())));
						}
						litVar1 = referent1;
					}
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((litVar1 + BaseHeaderSize) + (ValueIndex << (shiftForWord()))));

					goto l4;
				}
				top = longAtPointer(localSP);
				if (opType == 7) {
					/* begin storeLiteralVariable:withValue: */
					/* begin literal: */
					assert(GIV(method) == (iframeMethod(localFP)));
					litVar = longAt((GIV(method) + BaseHeaderSize) + ((byte3 + LiteralStart) << (shiftForWord())));
					if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
						/* begin followForwarded: */
						assert(isUnambiguouslyForwarder(litVar));
						referent = longAt((litVar + BaseHeaderSize) + (0 << (shiftForWord())));
						while (((referent & (tagMask())) == 0)
						 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							referent = longAt((referent + BaseHeaderSize) + (0 << (shiftForWord())));
						}
						litVar = referent;
					}
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(litVar)));
					if (isOldObject(litVar)) {

						/* most stores into young objects */

						if (((top & (tagMask())) == 0)
						 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(litVar);
							}
						}
					}
					longAtput((litVar + BaseHeaderSize) + (ValueIndex << (shiftForWord())), top);
					goto l4;
				}
				if (opType == 6) {
					/* begin internalPop: */
					localSP += 1 * BytesPerOop;
				}
				/* begin storeMaybeContextReceiverVariable:withValue: */
				rcvr = longAt(localFP + FoxReceiver);
				if ((byte3 <= ReceiverIndex)
				 && ((((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && (((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(rcvr));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
						 && (!(isWidowedContext(rcvr))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(rcvr)));
						if (isOldObject(rcvr)) {

							/* most stores into young objects */

							if (((top & (tagMask())) == 0)
							 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(rcvr);
								}
							}
						}
						longAtput((rcvr + BaseHeaderSize) + (byte3 << (shiftForWord())), top);
						if (byte3 == StackPointerIndex) {
							/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
						}
						goto l5;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1);
					if (byte3 == SenderIndex) {
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						index1 = pageIndexForstackMemorybytesPerPage(((void *) theFP), GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, top);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l5;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, rcvr);
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */

						if (((top & (tagMask())) == 0)
						 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (byte3 << (shiftForWord())), top);
					if (byte3 == StackPointerIndex) {
						/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l5:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */

						if (((top & (tagMask())) == 0)
						 && (oopisLessThan(top, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (byte3 << (shiftForWord())), top);
				}
			}
		l4:	/* end case */;
			break;
		case 133:
			/* singleExtendedSuperBytecode */
			{
				sqInt descriptor;

				VM_LABEL(singleExtendedSuperBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((descriptor & 0x1F) + LiteralStart) << (shiftForWord())));
				GIV(argumentCount) = ((usqInt) descriptor) >> 5;
				/* goto superclassSend */
			}
			
		superclassSend:
			/* superclassSend */
			{
				sqInt aValue;
				sqInt classPointer;
				sqInt err;
				sqInt err1;
				sqInt hash;
				sqInt hash1;
				sqInt objOop;
				sqInt objOop1;
				sqInt referent;
				sqInt superclass;

				VM_LABEL(superclassSend);
				/* begin superclassOf: */
				classPointer = methodClassOf(GIV(method));
				/* begin followField:ofObject: */
				objOop = longAt((classPointer + BaseHeaderSize) + (SuperclassIndex << (shiftForWord())));
				if (((objOop & (tagMask())) == 0)
				 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, classPointer, objOop);
				}
				superclass = objOop;
				/* begin ensureBehaviorHash: */
				assert(addressCouldBeClassObj(superclass));
				if (((hash = (long32At(superclass + 4)) & (identityHashHalfWordMask()))) != 0) {
				}
				else {
					if (objCouldBeClassObj(superclass)) {
						if (((err = enterIntoClassTable(superclass))) != 0) {
							-err;
						}
						else {
							(long32At(superclass + 4)) & (identityHashHalfWordMask());
						}
					}
					else {
						-PrimErrBadReceiver;
					}
				}
				/* begin classTagForClass: */
				assert(addressCouldBeClassObj(superclass));
				/* begin ensureBehaviorHash: */
				assert(addressCouldBeClassObj(superclass));
				GIV(lkupClassTag) = (((hash1 = (long32At(superclass + 4)) & (identityHashHalfWordMask()))) != 0
					? hash1
					: (objCouldBeClassObj(superclass)
							? (((err1 = enterIntoClassTable(superclass))) != 0
									? -err1
									: (long32At(superclass + 4)) & (identityHashHalfWordMask()))
							: -PrimErrBadReceiver));
				/* begin ensureReceiverUnforwarded */
				if ((((longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop))) & (tagMask())) == 0)
				 && (((longAt(longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					/* begin internalStackValue:put: */
					/* begin followForwarded: */
					objOop1 = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
					assert(isUnambiguouslyForwarder(objOop1));
					referent = longAt((objOop1 + BaseHeaderSize) + (0 << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0 << (shiftForWord())));
					}
					aValue = referent;
					longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), aValue);
				}
				assert(GIV(lkupClassTag) != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 134:
			/* secondExtendedSendBytecode */
			{
				sqInt descriptor;

				VM_LABEL(secondExtendedSendBytecode);
				descriptor = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((descriptor & 0x3F) + LiteralStart) << (shiftForWord())));
				GIV(argumentCount) = ((usqInt) descriptor) >> 6;
				goto normalSend;
			}
			break;
		case 135:
		case 476: /*220*/
			/* popStackBytecode */
			{
				VM_LABEL(popStackBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 136:
		case 475: /*219*/
			/* duplicateTopBytecode */
			{
				sqInt object;

				VM_LABEL(duplicateTopBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				object = longAtPointer(localSP);
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 137:
			/* pushActiveContextBytecode */
			{
				sqInt ourContext;

				VM_LABEL(pushActiveContextBytecode);
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					ourContext = longAt(localFP + FoxThisContext);
					goto l7;
				}
				ourContext = marryFrameSP(localFP, localSP);
			l7:	/* end ensureFrameIsMarried:SP: */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ourContext);
			}
			break;
		case 138:
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				usqInt newObj;
				usqInt numBytes;
				sqInt popValues;
				sqInt size;

				VM_LABEL(pushNewArrayBytecode);
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((size >= 0)
				 && (ClassArrayCompactIndex != 0));
				assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(size < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((size <= 1
	? 8
	: (size + (size & 1)) * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						array = 0;
						goto l8;
					}
				}
				long64Atput(newObj, (((((usqLong) size)) << (numSlotsFullShift())) + (2 << (formatShift()))) + ClassArrayCompactIndex);
				GIV(freeStart) += numBytes;
				array = newObj;
			l8:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */

						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + BaseHeaderSize) + (i << (shiftForWord())), longAtPointer(localSP + (((size - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + BaseHeaderSize) + (i << (shiftForWord())), GIV(nilObj));
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 139:
			/* callPrimitiveBytecode */
			{
				sqInt header;

				VM_LABEL(callPrimitiveBytecode);
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(method)));
				header = longAt((GIV(method) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
				if ((header & AlternateHeaderHasPrimFlag)
				 && ((((sqInt)localIP)) == ((GIV(method) + ((LiteralStart + (literalCountOfMethodHeader(header))) * BytesPerOop)) + BaseHeaderSize))) {
					localIP = (localIP + (3)) - 1;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l9;
				}
				else {
					goto respondToUnknownBytecode;
					goto l9;
				}

			}
		l9:	/* end case */;
			break;
		case 140:
		case 506: /*250*/
			/* pushRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(pushRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin pushRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((tempVector + BaseHeaderSize) + (remoteTempIndex << (shiftForWord()))));
			}
			break;
		case 141:
		case 507: /*251*/
			/* storeRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeRemoteTempLongBytecode);
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(tempVector)));
				if (isOldObject(tempVector)) {

					/* most stores into young objects */

					if ((((longAtPointer(localSP)) & (tagMask())) == 0)
					 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(tempVector))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(tempVector);
						}
					}
				}
				longAtput((tempVector + BaseHeaderSize) + (remoteTempIndex << (shiftForWord())), longAtPointer(localSP));
			}
			break;
		case 142:
		case 508: /*252*/
			/* storeAndPopRemoteTempLongBytecode */
			{
				sqInt frameNumArgs;
				sqInt remoteTempIndex;
				sqInt tempVector;
				sqInt tempVectorIndex;

				VM_LABEL(storeAndPopRemoteTempLongBytecode);
				/* begin storeRemoteTempLongBytecode */
				remoteTempIndex = byteAtPointer(++localIP);
				tempVectorIndex = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin storeRemoteTemp:inVectorAt: */
				tempVector = (tempVectorIndex < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - tempVectorIndex) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - tempVectorIndex) * BytesPerWord)));
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(tempVector)));
				if (isOldObject(tempVector)) {

					/* most stores into young objects */

					if ((((longAtPointer(localSP)) & (tagMask())) == 0)
					 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(tempVector))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(tempVector);
						}
					}
				}
				longAtput((tempVector + BaseHeaderSize) + (remoteTempIndex << (shiftForWord())), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 143:
			/* pushClosureCopyCopiedValuesBytecode */
			{
				sqInt blockSize;
				sqInt classObj;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				sqInt knownClassIndex;
				sqInt newClosure;
				sqInt newClosure1;
				usqInt newObj;
				usqInt newObj1;
				sqInt numArgs;
				sqInt numArgsNumCopied;
				usqInt numBytes;
				usqInt numBytes1;
				sqInt numCopied;
				sqInt numSlots;
				sqInt numSlots1;
				sqInt objFormat;
				sqInt objFormat1;

				VM_LABEL(pushClosureCopyCopiedValuesBytecode);
				numArgsNumCopied = byteAtPointer(++localIP);
				numArgs = numArgsNumCopied & 15;

				/* Split blockSize := (self fetchByte * 256) + self fetchByte. into two because evaluation order in C is undefined. */

				numCopied = ((usqInt) numArgsNumCopied >> 4);
				blockSize = (byteAtPointer(++localIP)) << 8;
				blockSize += byteAtPointer(++localIP);
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l11;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
			l11:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				objFormat = indexablePointersFormat();
				numSlots = ClosureFirstCopiedValueIndex + numCopied;
				assert((numSlots >= 0)
				 && (ClassBlockClosureCompactIndex != 0));
				assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l12;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
			l12:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureOuterContextIndex << (shiftForWord())), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureStartPCIndex << (shiftForWord())), ((initialIP << 1) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureNumArgsIndex << (shiftForWord())), ((numArgs << 1) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */

						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(newClosure)));
						longAtput((newClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << (shiftForWord())), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 144:
		case 448: /*192*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump);
				/* begin jump: */
				offset = 1 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 145:
		case 449: /*193*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump1);
				/* begin jump: */
				offset = 2 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 146:
		case 450: /*194*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump2);
				/* begin jump: */
				offset = 3 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 147:
		case 451: /*195*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump3);
				/* begin jump: */
				offset = 4 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 148:
		case 452: /*196*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump4);
				/* begin jump: */
				offset = 5 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 149:
		case 453: /*197*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump5);
				/* begin jump: */
				offset = 6 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 150:
		case 454: /*198*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump6);
				/* begin jump: */
				offset = 7 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 151:
		case 455: /*199*/
			/* shortUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(shortUnconditionalJump7);
				/* begin jump: */
				offset = 8 /* (currentBytecode bitAnd: 7) + 1 */;
				localIP = (localIP + offset) + 1;
				currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 152:
		case 153:
		case 154:
		case 155:
		case 156:
		case 157:
		case 158:
		case 159:
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l13;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l13:	/* end jumplfFalseBy: */;
			}
			break;
		case 160:
		case 161:
		case 162:
		case 163:
		case 164:
		case 165:
		case 166:
		case 167:
			/* longUnconditionalJump */
			{
				sqInt offset;

				VM_LABEL(longUnconditionalJump);
				offset = (((currentBytecode & 7) - 4) * 256) + (byteAtPointer(++localIP));
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 168:
		case 169:
		case 170:
		case 171:
			/* longJumpIfTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfTrue);
				/* begin jumplfTrueBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l14;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l14:	/* end jumplfTrueBy: */;
			}
			break;
		case 172:
		case 173:
		case 174:
		case 175:
			/* longJumpIfFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(longJumpIfFalse);
				/* begin jumplfFalseBy: */
				offset = ((currentBytecode & 3) * 256) + (byteAtPointer(++localIP));
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l15;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l15:	/* end jumplfFalseBy: */;
			}
			break;
		case 176:
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimAdd);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((((sqInt)(result ^ (result << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l16;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l18;
					}
					/* begin floatValueOf: */
					isFloat = ((rcvr & (tagMask())) == 0)
					 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
						rcvr1 = result1;
						goto l17;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l17:	/* end floatValueOf: */;
				l18:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l20;
					}
					/* begin floatValueOf: */
					isFloat1 = ((arg & (tagMask())) == 0)
					 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
						arg1 = result2;
						goto l19;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l19:	/* end floatValueOf: */;
				l20:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l16;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((0 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l16:	/* end case */;
			break;
		case 177:
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimSubtract);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((((sqInt)(result ^ (result << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l21;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l23;
					}
					/* begin floatValueOf: */
					isFloat = ((rcvr & (tagMask())) == 0)
					 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
						rcvr1 = result1;
						goto l22;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l22:	/* end floatValueOf: */;
				l23:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l25;
					}
					/* begin floatValueOf: */
					isFloat1 = ((arg & (tagMask())) == 0)
					 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
						arg1 = result2;
						goto l24;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l24:	/* end floatValueOf: */;
				l25:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l21;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((1 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l21:	/* end case */;
			break;
		case 178:
			/* bytecodePrimLessThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheat: */
					if (rcvr < arg) {
						/* goto booleanCheatTrue */
					}
					else {
						goto booleanCheatFalse;
					}
					goto l26;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l28;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l27;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l27:	/* end floatValueOf: */;
			l28:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l30;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l29;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l29:	/* end floatValueOf: */;
			l30:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l26;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((2 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l26:	/* end case */;
			
		booleanCheatTrue:
			/* booleanCheatTrue */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrue);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 173)
				 && (bytecode > 151)) {
					if (bytecode < 160) {

						/* short jumpIfFalse 152 - 159 */

						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l243;
					}
					if (bytecode == 172) {

						/* long jumpIfFalse */

						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l243;
					}
					if (bytecode > 167) {

						/* long jumpIfTrue 168 - 171 */

						offset = ((bytecode - 168) << 8) + (byteAtPointer(++localIP));
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

						goto l243;
					}
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
		l243:	/* end case */;
			break;
		case 179:
			/* bytecodePrimGreaterThan */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterThan);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheat: */
					if (rcvr > arg) {
						goto booleanCheatTrue;
					}
					else {
						/* goto booleanCheatFalse */
					}
					goto l31;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l33;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l32;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l32:	/* end floatValueOf: */;
			l33:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l35;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l34;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l34:	/* end floatValueOf: */;
			l35:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l31;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((3 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l31:	/* end case */;
			
		booleanCheatFalse:
			/* booleanCheatFalse */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalse);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 160)
				 && (bytecode > 151)) {

					/* short jumpIfFalse */

					/* begin jump: */
					localIP = (localIP + (bytecode - 151)) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

					goto l244;
				}
				if (bytecode == 172) {

					/* long jumpIfFalse */

					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

					goto l244;
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
		l244:	/* end case */;
			break;
		case 180:
			/* bytecodePrimLessOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheat: */
					if (rcvr <= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l36;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l38;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l37;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l37:	/* end floatValueOf: */;
			l38:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l40;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l39;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l39:	/* end floatValueOf: */;
			l40:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l36;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((4 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l36:	/* end case */;
			break;
		case 181:
			/* bytecodePrimGreaterOrEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterOrEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheat: */
					if (rcvr >= arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l41;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l43;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l42;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l42:	/* end floatValueOf: */;
			l43:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l45;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l44;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l44:	/* end floatValueOf: */;
			l45:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l41;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((5 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l41:	/* end case */;
			break;
		case 182:
			/* bytecodePrimEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr == arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l46;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l48;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l47;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l47:	/* end floatValueOf: */;
			l48:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l50;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l49;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l49:	/* end floatValueOf: */;
			l50:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l46;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((6 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l46:	/* end case */;
			break;
		case 183:
			/* bytecodePrimNotEqual */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimNotEqual);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheat: */
					if (rcvr != arg) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l51;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l53;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l52;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l52:	/* end floatValueOf: */;
			l53:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l55;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l54;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l54:	/* end floatValueOf: */;
			l55:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheat: */
					if (!aBool) {
						goto booleanCheatTrue;
					}
					else {
						goto booleanCheatFalse;
					}
					goto l51;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((7 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l51:	/* end case */;
			break;
		case 184:
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimMultiply);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					result = rcvr * arg;
					if ((arg == 0)
					 || (((result / arg) == rcvr)
					 && ((((sqInt)(result ^ (result << 1)))) >= 0))) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l56;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l58;
					}
					/* begin floatValueOf: */
					isFloat = ((rcvr & (tagMask())) == 0)
					 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
						rcvr1 = result1;
						goto l57;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l57:	/* end floatValueOf: */;
				l58:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l60;
					}
					/* begin floatValueOf: */
					isFloat1 = ((arg & (tagMask())) == 0)
					 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
						arg1 = result2;
						goto l59;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l59:	/* end floatValueOf: */;
				l60:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l56;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((8 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l56:	/* end case */;
			break;
		case 185:
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimDivide);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */

						result = rcvr / arg;
						if ((((sqInt)(result ^ (result << 1)))) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
							/* begin fetchNextBytecode */
							currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

							goto l61;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l63;
					}
					/* begin floatValueOf: */
					isFloat = ((rcvr & (tagMask())) == 0)
					 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
						rcvr1 = result1;
						goto l62;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l62:	/* end floatValueOf: */;
				l63:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l65;
					}
					/* begin floatValueOf: */
					isFloat1 = ((arg & (tagMask())) == 0)
					 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
						arg1 = result2;
						goto l64;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l64:	/* end floatValueOf: */;
				l65:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */

						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l61;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((9 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l61:	/* end case */;
			break;
		case 186:
			/* bytecodePrimMod */
			{
				sqInt mod;

				VM_LABEL(bytecodePrimMod);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((mod << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l66;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((10 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l66:	/* end case */;
			break;
		case 187:
			/* bytecodePrimMakePoint */
			{
				VM_LABEL(bytecodePrimMakePoint);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveMakePoint();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l67;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((11 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l67:	/* end case */;
			break;
		case 188:
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt newLargeInteger;
				usqInt newObj;
				usqInt numBytes;
				sqInt objFormat;
				sqInt shifted;
				char *sp;

				VM_LABEL(bytecodePrimBitShift);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((integerArgument & 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l72;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = positive32BitValueOf(integerReceiver);

				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 1))) >= 0) {

						/* Left shift -- must fail bits would be lost */

						if (!(integerArgument <= 0x1F)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l72;
						}
						shifted = integerReceiver << integerArgument;
						
						if (!(integerReceiver == (((usqInt) shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l72;
						}
					}
					else {

						/* Right shift -- OK to lose bits */

						if (!(integerArgument >= (-0x1F))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l72;
						}
						shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
					}
					/* begin positive32BitIntegerFor: */
					/* begin maybeInlinePositive32BitIntegerFor: */
					assert(!((hasSixtyFourBitImmediates())));
					if (((((sqInt)shifted)) >= 0)
					 && ((((sqInt)(shifted ^ (shifted << 1)))) >= 0)) {
						shifted = ((shifted << 1) | 1);
						goto l71;
					}
					/* begin eeInstantiateSmallClassIndex:format:numSlots: */
					objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
					assert(ClassLargePositiveIntegerCompactIndex != 0);
					assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
					/* begin allocateSmallNewSpaceSlots:format:classIndex: */
					assert(1 < (numSlotsMask()));
					newObj = GIV(freeStart);
					numBytes = BaseHeaderSize + (8);
					assert((numBytes % (allocationUnit())) == 0);
					assert((newObj % (allocationUnit())) == 0);
					if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
						if (!GIV(needGCFlag)) {
							/* begin scheduleScavenge */
							GIV(needGCFlag) = 1;
							forceInterruptCheck();
						}
						if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
							error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
							newLargeInteger = 0;
							goto l69;
						}
					}
					long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
					GIV(freeStart) += numBytes;
					newLargeInteger = newObj;
				l69:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
					
#          if VMBIGENDIAN
					byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) shifted) >> 24) & 0xFF);
					byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) shifted) >> 16) & 0xFF);
					byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) shifted) >> 8) & 0xFF);
					byteAtput((newLargeInteger + BaseHeaderSize), shifted & 0xFF);

#          else /* VMBIGENDIAN */
					long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), shifted);

#          endif /* VMBIGENDIAN */

					shifted = newLargeInteger;
				l71:	/* end maybeInlinePositive32BitIntegerFor: */;
					goto l70;

				l70:	/* end positive32BitIntegerFor: */;

					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
			l72:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l68;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((12 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l68:	/* end case */;
			break;
		case 189:
			/* bytecodePrimDiv */
			{
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((quotient << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l73;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((13 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l73:	/* end case */;
			break;
		case 190:
			/* bytecodePrimBitAnd */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg & rcvr);
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l74;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l74;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((14 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l74:	/* end case */;
			break;
		case 191:
			/* bytecodePrimBitOr */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg | rcvr);
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l75;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l75;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((15 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l75:	/* end case */;
			break;
		case 192:
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt index1;
				sqInt newLargeInteger;
				usqInt newObj;
				usqInt numBytes;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots21;
				usqInt numSlots3;
				usqInt numSlots31;
				usqInt numSlots4;
				sqInt objFormat;
				sqInt objOop;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				sqInt result1;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;

				VM_LABEL(bytecodePrimAt);
				result = 0;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && ((index & 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */

					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						GIV(lkupClassTag) = (longAt(rcvr)) & (classIndexMask());
						/* begin fetchPointer:ofObject: */
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((16 * 2) << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag)))) {
							GIV(argumentCount) = 1;
							goto commonSendOrdinary;
							goto l76;
						}
						if (primitiveFunctionPointer == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = long64At(rcvr);
							fmt1 = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
							if ((fmt1 == (indexablePointersFormat()))
							 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */

								GIV(primFailCode) = PrimErrBadReceiver;
								goto l85;
							}
							/* begin lengthOf:format: */
							/* begin numSlotsOfAny: */
							numSlots3 = byteAt(rcvr + 7);
							numSlots1 = (numSlots3 == (numSlotsMask())
								? longAt(rcvr - BaseHeaderSize)
								: numSlots3);
							if (fmt1 <= 5) {
								totalLength = numSlots1;
								goto l86;
							}
							if (fmt1 >= (firstByteFormat())) {

								/* bytes, including CompiledMethod */

								totalLength = (numSlots1 << (shiftForWord())) - (fmt1 & 7);
								goto l86;
							}
							if (fmt1 >= (firstShortFormat())) {
								totalLength = (numSlots1 << ((shiftForWord()) - 1)) - (fmt1 & 3);
								goto l86;
							}
							if (fmt1 >= (firstLongFormat())) {
								totalLength = (numSlots1 << ((shiftForWord()) - 2)) - (fmt1 & 1);
								goto l86;
							}
							if (fmt1 == (sixtyFourBitIndexableFormat())) {
								totalLength = ((usqInt) numSlots1) >> 1;
								goto l86;
							}
							totalLength = 0;
						l86:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt1 >= (sixtyFourBitIndexableFormat()))
							 || (fmt1 == 2)) {
								fixedFields1 = 0;
								goto l82;
							}
							if (fmt1 < 2) {
								fixedFields1 = totalLength;
								goto l82;
							}
							class = fetchClassOfNonImm(rcvr);
							/* begin fixedFieldsOfClassFormat: */
							fixedFields1 = (((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1)) & ((1 << (fixedFieldsFieldWidth())) - 1);
						l82:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt1;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields1);
						l85:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr1 = long64At(rcvr);
								fmt2 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
								/* begin lengthOf:format: */
								/* begin numSlotsOfAny: */
								numSlots21 = byteAt(rcvr + 7);
								numSlots4 = (numSlots21 == (numSlotsMask())
									? longAt(rcvr - BaseHeaderSize)
									: numSlots21);
								if (fmt2 <= 5) {
									totalLength1 = numSlots4;
									goto l77;
								}
								if (fmt2 >= (firstByteFormat())) {

									/* bytes, including CompiledMethod */

									totalLength1 = (numSlots4 << (shiftForWord())) - (fmt2 & 7);
									goto l77;
								}
								if (fmt2 >= (firstShortFormat())) {
									totalLength1 = (numSlots4 << ((shiftForWord()) - 1)) - (fmt2 & 3);
									goto l77;
								}
								if (fmt2 >= (firstLongFormat())) {
									totalLength1 = (numSlots4 << ((shiftForWord()) - 2)) - (fmt2 & 1);
									goto l77;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat())) {
									totalLength1 = ((usqInt) numSlots4) >> 1;
									goto l77;
								}
								totalLength1 = 0;
							l77:	/* end lengthOf:format: */;
								fixedFields2 = 0;

								/* special flag for strings */

								fmt2 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt2;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields2;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields2);
							l80:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSendOrdinary;
								goto l76;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						index1 = (index >> 1);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1))
						 && (oopisLessThanOrEqualTo(index1, stSize))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								result = longAt((rcvr + BaseHeaderSize) + (((index1 + fixedFields) - 1) << (shiftForWord())));
								goto l79;
							}
							if (fmt < (firstByteFormat())) {

								/* Bitmap */

								result1 = long32At((rcvr + BaseHeaderSize) + ((index1 - 1) << 2));
								/* begin positive32BitIntegerFor: */
								/* begin maybeInlinePositive32BitIntegerFor: */
								assert(!((hasSixtyFourBitImmediates())));
								if (((((sqInt)result1)) >= 0)
								 && ((((sqInt)(result1 ^ (result1 << 1)))) >= 0)) {
									result = ((result1 << 1) | 1);
									goto l83;
								}
								/* begin eeInstantiateSmallClassIndex:format:numSlots: */
								objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
								assert(ClassLargePositiveIntegerCompactIndex != 0);
								assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
								/* begin allocateSmallNewSpaceSlots:format:classIndex: */
								assert(1 < (numSlotsMask()));
								newObj = GIV(freeStart);
								numBytes = BaseHeaderSize + (8);
								assert((numBytes % (allocationUnit())) == 0);
								assert((newObj % (allocationUnit())) == 0);
								if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
									if (!GIV(needGCFlag)) {
										/* begin scheduleScavenge */
										GIV(needGCFlag) = 1;
										forceInterruptCheck();
									}
									if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
										error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
										newLargeInteger = 0;
										goto l87;
									}
								}
								long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
								GIV(freeStart) += numBytes;
								newLargeInteger = newObj;
							l87:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
								
#                if VMBIGENDIAN
								byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) result1) >> 24) & 0xFF);
								byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) result1) >> 16) & 0xFF);
								byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) result1) >> 8) & 0xFF);
								byteAtput((newLargeInteger + BaseHeaderSize), result1 & 0xFF);

#                else /* VMBIGENDIAN */
								long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), result1);

#                endif /* VMBIGENDIAN */

								result = newLargeInteger;
							l83:	/* end maybeInlinePositive32BitIntegerFor: */;
								goto l79;

							}
							if (fmt >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* String */
								/* Spur supports the String at:[put:] primitives on WideString */

								if ((fmt - 32) < (firstByteFormat())) {
									result1 = long32At((rcvr + BaseHeaderSize) + ((index1 - 1) << 2));
								}
								else {
									result1 = byteAt((rcvr + BaseHeaderSize) + (index1 - 1));
								}
								result = (result1 << (numTagBits())) + (characterTag());

								goto l79;
							}
							else {
								if ((fmt < (firstCompiledMethodFormat()))
								 || (index1 >= ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((byteAt((rcvr + BaseHeaderSize) + (index1 - 1))) << 1) | 1);
									goto l79;
								}
							}
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
					l79:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), result);
						goto l76;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((16 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l76:	/* end case */;
			break;
		case 193:
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt isCharacter;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots21;
				usqInt numSlots3;
				usqInt numSlots31;
				usqInt numSlots4;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;
				sqInt valToPut;
				sqInt value;

				VM_LABEL(bytecodePrimAtPut);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && ((index & 1))) {

					/* Index into atPutCache */

					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						GIV(lkupClassTag) = (longAt(rcvr)) & (classIndexMask());
						/* begin fetchPointer:ofObject: */
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((17 * 2) << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag)))) {
							GIV(argumentCount) = 2;
							goto commonSendOrdinary;
							goto l88;
						}
						if (primitiveFunctionPointer == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = long64At(rcvr);
							fmt1 = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
							if ((fmt1 == (indexablePointersFormat()))
							 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */

								GIV(primFailCode) = PrimErrBadReceiver;
								goto l96;
							}
							/* begin lengthOf:format: */
							/* begin numSlotsOfAny: */
							numSlots3 = byteAt(rcvr + 7);
							numSlots1 = (numSlots3 == (numSlotsMask())
								? longAt(rcvr - BaseHeaderSize)
								: numSlots3);
							if (fmt1 <= 5) {
								totalLength = numSlots1;
								goto l97;
							}
							if (fmt1 >= (firstByteFormat())) {

								/* bytes, including CompiledMethod */

								totalLength = (numSlots1 << (shiftForWord())) - (fmt1 & 7);
								goto l97;
							}
							if (fmt1 >= (firstShortFormat())) {
								totalLength = (numSlots1 << ((shiftForWord()) - 1)) - (fmt1 & 3);
								goto l97;
							}
							if (fmt1 >= (firstLongFormat())) {
								totalLength = (numSlots1 << ((shiftForWord()) - 2)) - (fmt1 & 1);
								goto l97;
							}
							if (fmt1 == (sixtyFourBitIndexableFormat())) {
								totalLength = ((usqInt) numSlots1) >> 1;
								goto l97;
							}
							totalLength = 0;
						l97:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt1 >= (sixtyFourBitIndexableFormat()))
							 || (fmt1 == 2)) {
								fixedFields1 = 0;
								goto l94;
							}
							if (fmt1 < 2) {
								fixedFields1 = totalLength;
								goto l94;
							}
							class = fetchClassOfNonImm(rcvr);
							/* begin fixedFieldsOfClassFormat: */
							fixedFields1 = (((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1)) & ((1 << (fixedFieldsFieldWidth())) - 1);
						l94:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt1;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields1);
						l96:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr1 = long64At(rcvr);
								fmt2 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
								/* begin lengthOf:format: */
								/* begin numSlotsOfAny: */
								numSlots21 = byteAt(rcvr + 7);
								numSlots4 = (numSlots21 == (numSlotsMask())
									? longAt(rcvr - BaseHeaderSize)
									: numSlots21);
								if (fmt2 <= 5) {
									totalLength1 = numSlots4;
									goto l89;
								}
								if (fmt2 >= (firstByteFormat())) {

									/* bytes, including CompiledMethod */

									totalLength1 = (numSlots4 << (shiftForWord())) - (fmt2 & 7);
									goto l89;
								}
								if (fmt2 >= (firstShortFormat())) {
									totalLength1 = (numSlots4 << ((shiftForWord()) - 1)) - (fmt2 & 3);
									goto l89;
								}
								if (fmt2 >= (firstLongFormat())) {
									totalLength1 = (numSlots4 << ((shiftForWord()) - 2)) - (fmt2 & 1);
									goto l89;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat())) {
									totalLength1 = ((usqInt) numSlots4) >> 1;
									goto l89;
								}
								totalLength1 = 0;
							l89:	/* end lengthOf:format: */;
								fixedFields2 = 0;

								/* special flag for strings */

								fmt2 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt2;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields2;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields2);
							l92:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSendOrdinary;
								goto l88;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo((index >> 1), 1))
						 && (oopisLessThanOrEqualTo((index >> 1), stSize))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								assert(!(isForwarded(rcvr)));
								if (isOldObject(rcvr)) {

									/* most stores into young objects */

									if (((value & (tagMask())) == 0)
									 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
										/* begin possibleRootStoreInto: */
										if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
											remember(rcvr);
										}
									}
								}
								longAtput((rcvr + BaseHeaderSize) + (((((index >> 1)) + fixedFields) - 1) << (shiftForWord())), value);
								goto l91;
							}
							if (fmt < (firstByteFormat())) {

								/* Bitmap */

								valToPut = positive32BitValueOf(value);
								if (!GIV(primFailCode)) {
									long32Atput((rcvr + BaseHeaderSize) + ((((index >> 1)) - 1) << 2), valToPut);
									goto l91;
								}
								GIV(primFailCode) = PrimErrBadArgument;
								goto l91;
							}
							if (fmt >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */

								isCharacter = (value & (tagMask())) == 2;
								if (!isCharacter) {
									GIV(primFailCode) = PrimErrBadArgument;
									goto l91;
								}
								valToPut = ((usqInt) (((usqInt)value))) >> (numTagBits());

								if ((fmt - 32) < (firstByteFormat())) {
									long32Atput((rcvr + BaseHeaderSize) + ((((index >> 1)) - 1) << 2), valToPut);
									goto l91;
								}
							}
							else {
								if ((fmt >= (firstCompiledMethodFormat()))
								 && (((index >> 1)) < ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									GIV(primFailCode) = PrimErrBadIndex;
									goto l91;
								}
								valToPut = ((value & 1)
									? (value >> 1)
									: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								GIV(primFailCode) = PrimErrBadArgument;
								goto l91;
							}
							byteAtput((rcvr + BaseHeaderSize) + (((index >> 1)) - 1), valToPut);
							goto l91;
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
					l91:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (3 - 1) * BytesPerOop), value);
						goto l88;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((17 * 2) << (shiftForWord())));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
		l88:	/* end case */;
			break;
		case 194:
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt fmt;
				sqInt fmt1;
				sqInt isArray;
				sqInt isString;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				sqInt rcvr;
				sqInt sz;

				VM_LABEL(bytecodePrimSize);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */

				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isString = 0;
					goto l99;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l99;

			l99:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf:format: */
					fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots1 = byteAt(rcvr + 7);
					numSlots = (numSlots1 == (numSlotsMask())
						? longAt(rcvr - BaseHeaderSize)
						: numSlots1);
					if (fmt <= 5) {
						sz = numSlots;
						goto l100;
					}
					if (fmt >= (firstByteFormat())) {

						/* bytes, including CompiledMethod */

						sz = (numSlots << (shiftForWord())) - (fmt & 7);
						goto l100;
					}
					if (fmt >= (firstShortFormat())) {
						sz = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
						goto l100;
					}
					if (fmt >= (firstLongFormat())) {
						sz = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
						goto l100;
					}
					if (fmt == (sixtyFourBitIndexableFormat())) {
						sz = ((usqInt) numSlots) >> 1;
						goto l100;
					}
					sz = 0;
				l100:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l98;
				}
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isArray = 0;
					goto l101;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex1 = (longAt(rcvr)) & (classIndexMask());
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l101;

			l101:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf:format: */
					fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots11 = byteAt(rcvr + 7);
					numSlots2 = (numSlots11 == (numSlotsMask())
						? longAt(rcvr - BaseHeaderSize)
						: numSlots11);
					if (fmt1 <= 5) {
						sz = numSlots2;
						goto l102;
					}
					if (fmt1 >= (firstByteFormat())) {

						/* bytes, including CompiledMethod */

						sz = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
						goto l102;
					}
					if (fmt1 >= (firstShortFormat())) {
						sz = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
						goto l102;
					}
					if (fmt1 >= (firstLongFormat())) {
						sz = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
						goto l102;
					}
					if (fmt1 == (sixtyFourBitIndexableFormat())) {
						sz = ((usqInt) numSlots2) >> 1;
						goto l102;
					}
					sz = 0;
				l102:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l98;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((18 * 2) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l98:	/* end case */;
			break;
		case 195:
		case 355: /*99*/
			/* bytecodePrimNext */
			{
				VM_LABEL(bytecodePrimNext);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((19 * 2) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((19 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord()))))) >> 1);
				goto normalSend;
			}
			break;
		case 196:
		case 356: /*100*/
			/* bytecodePrimNextPut */
			{
				VM_LABEL(bytecodePrimNextPut);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((20 * 2) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((20 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord()))))) >> 1);
				goto normalSend;
			}
			break;
		case 197:
		case 357: /*101*/
			/* bytecodePrimAtEnd */
			{
				VM_LABEL(bytecodePrimAtEnd);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((21 * 2) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((21 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord()))))) >> 1);
				goto normalSend;
			}
			break;
		case 198:
			/* bytecodePrimIdentical */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdentical);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP);
				}
				/* begin booleanCheat: */
				if (rcvr == arg) {
					goto booleanCheatTrue;
				}
				else {
					goto booleanCheatFalse;
				}
			}
			break;
		case 199:
		case 359: /*103*/
			/* bytecodePrimClass */
			{
				sqInt aValue;
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(bytecodePrimClass);
				rcvr = longAtPointer(localSP);
				if (((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				/* begin internalStackTopPut: */
				aValue = (((tagBits = rcvr & (tagMask()))) != 0
					? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (tagBits << (shiftForWord())))
					: fetchClassOfNonImm(rcvr));
				longAtPointerput(localSP, aValue);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 200:
		case 360: /*104*/
			/* bytecodePrimSpecialSelector24 */
			{
				VM_LABEL(bytecodePrimSpecialSelector24);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((24 * 2) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((24 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord()))))) >> 1);
				goto normalSend;
			}
			break;
		case 201:
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isBlock = 0;
					goto l104;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l104;

			l104:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l103;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((25 * 2) << (shiftForWord())));
				goto normalSend;
			}
		l103:	/* end case */;
			break;
		case 202:
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isBlock = 0;
					goto l106;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l106;

			l106:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l105;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((26 * 2) << (shiftForWord())));
				goto normalSend;
			}
		l105:	/* end case */;
			break;
		case 203:
		case 363: /*107*/
			/* bytecodePrimDo */
			{
				VM_LABEL(bytecodePrimDo);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((27 * 2) << (shiftForWord())));
				GIV(argumentCount) = ((fetchPointerofObject((27 * 2) + 1, longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord()))))) >> 1);
				goto normalSend;
			}
			break;
		case 204:
		case 364: /*108*/
			/* bytecodePrimNew */
			{
				VM_LABEL(bytecodePrimNew);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((28 * 2) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
			break;
		case 205:
		case 365: /*109*/
			/* bytecodePrimNewWithArg */
			{
				VM_LABEL(bytecodePrimNewWithArg);
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((29 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
			break;
		case 206:
			/* bytecodePrimPointX */
			{
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & (tagMask())) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (XIndex << (shiftForWord()))));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l107;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((30 * 2) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l107:	/* end case */;
			break;
		case 207:
			/* bytecodePrimPointY */
			{
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & (tagMask())) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (YIndex << (shiftForWord()))));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l108;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((0x1F * 2) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l108:	/* end case */;
			break;
		case 208:
		case 209:
		case 210:
		case 211:
		case 212:
		case 213:
		case 214:
		case 215:
		case 216:
		case 217:
		case 218:
		case 219:
		case 220:
		case 221:
		case 222:
		case 223:
		case 368: /*112*/
		case 369: /*113*/
		case 370: /*114*/
		case 371: /*115*/
		case 372: /*116*/
		case 373: /*117*/
		case 374: /*118*/
		case 375: /*119*/
		case 376: /*120*/
		case 377: /*121*/
		case 378: /*122*/
		case 379: /*123*/
		case 380: /*124*/
		case 381: /*125*/
		case 382: /*126*/
		case 383: /*127*/
			/* sendLiteralSelector0ArgsBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector0ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << (shiftForWord())));
				GIV(argumentCount) = 0;
				rcvr = longAtPointer(localSP + (0 * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? ((tagBits & 1) != 0
							? 1
							: tagBits)
					: (longAt(rcvr)) & (classIndexMask()));
				assert(GIV(lkupClassTag) != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 224:
		case 225:
		case 226:
		case 227:
		case 228:
		case 229:
		case 230:
		case 231:
		case 232:
		case 233:
		case 234:
		case 235:
		case 236:
		case 237:
		case 238:
		case 239:
		case 384: /*128*/
		case 385: /*129*/
		case 386: /*130*/
		case 387: /*131*/
		case 388: /*132*/
		case 389: /*133*/
		case 390: /*134*/
		case 391: /*135*/
		case 392: /*136*/
		case 393: /*137*/
		case 394: /*138*/
		case 395: /*139*/
		case 396: /*140*/
		case 397: /*141*/
		case 398: /*142*/
		case 399: /*143*/
			/* sendLiteralSelector1ArgBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector1ArgBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << (shiftForWord())));
				GIV(argumentCount) = 1;
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? ((tagBits & 1) != 0
							? 1
							: tagBits)
					: (longAt(rcvr)) & (classIndexMask()));
				assert(GIV(lkupClassTag) != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 240:
		case 241:
		case 242:
		case 243:
		case 244:
		case 245:
		case 246:
		case 247:
		case 248:
		case 249:
		case 250:
		case 251:
		case 252:
		case 253:
		case 254:
		case 255:
		case 400: /*144*/
		case 401: /*145*/
		case 402: /*146*/
		case 403: /*147*/
		case 404: /*148*/
		case 405: /*149*/
		case 406: /*150*/
		case 407: /*151*/
		case 408: /*152*/
		case 409: /*153*/
		case 410: /*154*/
		case 411: /*155*/
		case 412: /*156*/
		case 413: /*157*/
		case 414: /*158*/
		case 415: /*159*/
			/* sendLiteralSelector2ArgsBytecode */
			{
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(sendLiteralSelector2ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << (shiftForWord())));
				GIV(argumentCount) = 2;
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? ((tagBits & 1) != 0
							? 1
							: tagBits)
					: (longAt(rcvr)) & (classIndexMask()));
				assert(GIV(lkupClassTag) != (nilObject()));
				goto commonSendOrdinary;
			}
			break;
		case 333: /*77*/
			/* extPushPseudoVariableOrOuterBytecode */
			{
				sqInt context;
				sqInt thing;

				VM_LABEL(extPushPseudoVariableOrOuterBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				
				switch (extB) {
				case 0:
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
					goto l109;

					break;
				case 1:
					thing = GIV(trueObj);

					break;
				case 2:
					thing = GIV(nilObj);

					break;
				case 3:
					/* begin ensureFrameIsMarried:SP: */
					if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
						assert(isContext(frameContext(localFP)));
						context = longAt(localFP + FoxThisContext);
						goto l110;
					}
					context = marryFrameSP(localFP, localSP);
				l110:	/* end ensureFrameIsMarried:SP: */;
					thing = context;

					break;
				default:
					thing = (extB < 0
						? enclosingObjectAtwithObjectwithMixin(0 - extB, longAt(localFP + FoxReceiver), methodClassOf(GIV(method)))
						: (error("undefined extension for extPushPseudoVariableOrOuter"),
							GIV(nilObj)));

				}
				extB = 0;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), thing);
			}
		l109:	/* end case */;
			break;
		case 336: /*80*/
			/* bytecodePrimAdd */
			{
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimAdd1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) + ((arg >> 1));
					if ((((sqInt)(result ^ (result << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l111;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatAdd:toArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l113;
					}
					/* begin floatValueOf: */
					isFloat = ((rcvr & (tagMask())) == 0)
					 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
						rcvr1 = result1;
						goto l112;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l112:	/* end floatValueOf: */;
				l113:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l115;
					}
					/* begin floatValueOf: */
					isFloat1 = ((arg & (tagMask())) == 0)
					 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
						arg1 = result2;
						goto l114;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l114:	/* end floatValueOf: */;
				l115:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 + arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l111;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((0 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l111:	/* end case */;
			break;
		case 337: /*81*/
			/* bytecodePrimSubtract */
			{
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimSubtract1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					result = ((rcvr >> 1)) - ((arg >> 1));
					if ((((sqInt)(result ^ (result << 1)))) >= 0) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l116;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatSubtract:fromArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l118;
					}
					/* begin floatValueOf: */
					isFloat = ((rcvr & (tagMask())) == 0)
					 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
						rcvr1 = result1;
						goto l117;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l117:	/* end floatValueOf: */;
				l118:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l120;
					}
					/* begin floatValueOf: */
					isFloat1 = ((arg & (tagMask())) == 0)
					 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
						arg1 = result2;
						goto l119;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l119:	/* end floatValueOf: */;
				l120:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 - arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l116;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((1 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l116:	/* end case */;
			break;
		case 338: /*82*/
			/* bytecodePrimLessThanV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessThanV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheatV4: */
					if (rcvr < arg) {
						/* goto booleanCheatTrueV4 */
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l121;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLess:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l123;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l122;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l122:	/* end floatValueOf: */;
			l123:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l125;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l124;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l124:	/* end floatValueOf: */;
			l125:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 < arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l121;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((2 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l121:	/* end case */;
			
		booleanCheatTrueV4:
			/* booleanCheatTrueV4 */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatTrueV4);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if (bytecode >= 208) {
					if (bytecode <= 215) {

						/* short jumpIfFalse 208 - 215 */

						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l245;
					}
					if (bytecode == 244) {

						/* long jumpIfFalse */

						byteAtPointer(++localIP);
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l245;
					}
					if (bytecode == 243) {

						/* long jumpIfTrue 243 */

						offset = byteAtPointer(++localIP);
						/* begin jump: */
						localIP = (localIP + offset) + 1;
						currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

						goto l245;
					}
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(trueObj));
			}
		l245:	/* end case */;
			break;
		case 339: /*83*/
			/* bytecodePrimGreaterThanV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterThanV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheatV4: */
					if (rcvr > arg) {
						goto booleanCheatTrueV4;
					}
					else {
						/* goto booleanCheatFalseV4 */
					}
					goto l126;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreater:thanArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l128;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l127;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l127:	/* end floatValueOf: */;
			l128:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l130;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l129;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l129:	/* end floatValueOf: */;
			l130:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 > arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l126;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((3 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l126:	/* end case */;
			
		booleanCheatFalseV4:
			/* booleanCheatFalseV4 */
			{
				sqInt bytecode;
				sqInt offset;

				VM_LABEL(booleanCheatFalseV4);
				
				/* assume next bytecode is jumpIfFalse (99%) */

				bytecode = byteAtPointer(++localIP);
				/* begin internalPop: */
				localSP += 2 * BytesPerOop;
				if ((bytecode < 216)
				 && (bytecode > 207)) {

					/* short jumpIfFalse */

					/* begin jump: */
					localIP = (localIP + (bytecode - 207)) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

					goto l246;
				}
				if (bytecode == 244) {

					/* long jumpIfFalse */

					offset = byteAtPointer(++localIP);
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

					goto l246;
				}
				currentBytecode = bytecode + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(falseObj));
			}
		l246:	/* end case */;
			break;
		case 340: /*84*/
			/* bytecodePrimLessOrEqualV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimLessOrEqualV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheatV4: */
					if (rcvr <= arg) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l131;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatLessOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l133;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l132;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l132:	/* end floatValueOf: */;
			l133:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l135;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l134;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l134:	/* end floatValueOf: */;
			l135:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 <= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l131;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((4 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l131:	/* end case */;
			break;
		case 341: /*85*/
			/* bytecodePrimGreaterOrEqualV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimGreaterOrEqualV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {

					/* The C code can avoid detagging since tagged integers are still signed.
					   But this means the simulator must override to do detagging. */

					/* begin booleanCheatV4: */
					if (rcvr >= arg) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l136;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatGreaterOrEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l138;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l137;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l137:	/* end floatValueOf: */;
			l138:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l140;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l139;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l139:	/* end floatValueOf: */;
			l140:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 >= arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l136;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((5 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l136:	/* end case */;
			break;
		case 342: /*86*/
			/* bytecodePrimEqualV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimEqualV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheatV4: */
					if (rcvr == arg) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l141;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l143;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l142;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l142:	/* end floatValueOf: */;
			l143:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l145;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l144;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l144:	/* end floatValueOf: */;
			l145:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l141;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((6 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l141:	/* end case */;
			break;
		case 343: /*87*/
			/* bytecodePrimNotEqualV4 */
			{
				sqInt aBool;
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				double result;
				double result1;

				VM_LABEL(bytecodePrimNotEqualV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					/* begin booleanCheatV4: */
					if (rcvr != arg) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l146;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin primitiveFloatEqual:toArg: */
				/* begin loadFloatOrIntFrom: */
				if ((rcvr & 1)) {
					rcvr1 = ((double) ((rcvr >> 1)) );
					goto l148;
				}
				/* begin floatValueOf: */
				isFloat = ((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat) {
					;
					fetchFloatAtinto(rcvr + BaseHeaderSize, result);
					rcvr1 = result;
					goto l147;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				rcvr1 = 0.0;
			l147:	/* end floatValueOf: */;
			l148:	/* end loadFloatOrIntFrom: */;
				/* begin loadFloatOrIntFrom: */
				if ((arg & 1)) {
					arg1 = ((double) ((arg >> 1)) );
					goto l150;
				}
				/* begin floatValueOf: */
				isFloat1 = ((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
				if (isFloat1) {
					;
					fetchFloatAtinto(arg + BaseHeaderSize, result1);
					arg1 = result1;
					goto l149;
				}
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				arg1 = 0.0;
			l149:	/* end floatValueOf: */;
			l150:	/* end loadFloatOrIntFrom: */;
				aBool = rcvr1 == arg1;
				if (!GIV(primFailCode)) {
					/* begin booleanCheatV4: */
					if (!aBool) {
						goto booleanCheatTrueV4;
					}
					else {
						goto booleanCheatFalseV4;
					}
					goto l146;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((7 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l146:	/* end case */;
			break;
		case 344: /*88*/
			/* bytecodePrimMultiply */
			{
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimMultiply1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					result = rcvr * arg;
					if ((arg == 0)
					 || (((result / arg) == rcvr)
					 && ((((sqInt)(result ^ (result << 1)))) >= 0))) {
						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l151;
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatMultiply:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l153;
					}
					/* begin floatValueOf: */
					isFloat = ((rcvr & (tagMask())) == 0)
					 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
						rcvr1 = result1;
						goto l152;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l152:	/* end floatValueOf: */;
				l153:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l155;
					}
					/* begin floatValueOf: */
					isFloat1 = ((arg & (tagMask())) == 0)
					 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
						arg1 = result2;
						goto l154;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l154:	/* end floatValueOf: */;
				l155:	/* end loadFloatOrIntFrom: */;
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 * arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l151;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((8 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l151:	/* end case */;
			break;
		case 345: /*89*/
			/* bytecodePrimDivide */
			{
				sqInt arg;
				double arg1;
				sqInt isFloat;
				sqInt isFloat1;
				sqInt rcvr;
				double rcvr1;
				sqInt result;
				double result1;
				double result2;
				char *sp;

				VM_LABEL(bytecodePrimDivide1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & arg) & 1) != 0) {
					rcvr = (rcvr >> 1);
					arg = (arg >> 1);
					if ((arg != 0)
					 && ((rcvr % arg) == 0)) {

						/* generates C / operation */

						result = rcvr / arg;
						if ((((sqInt)(result ^ (result << 1)))) >= 0) {
							/* begin internalPop:thenPush: */
							longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((result << 1) | 1));
							/* begin fetchNextBytecode */
							currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

							goto l156;
						}
					}
				}
				else {
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin primitiveFloatDivide:byArg: */
					/* begin loadFloatOrIntFrom: */
					if ((rcvr & 1)) {
						rcvr1 = ((double) ((rcvr >> 1)) );
						goto l158;
					}
					/* begin floatValueOf: */
					isFloat = ((rcvr & (tagMask())) == 0)
					 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat) {
						;
						fetchFloatAtinto(rcvr + BaseHeaderSize, result1);
						rcvr1 = result1;
						goto l157;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					rcvr1 = 0.0;
				l157:	/* end floatValueOf: */;
				l158:	/* end loadFloatOrIntFrom: */;
					/* begin loadFloatOrIntFrom: */
					if ((arg & 1)) {
						arg1 = ((double) ((arg >> 1)) );
						goto l160;
					}
					/* begin floatValueOf: */
					isFloat1 = ((arg & (tagMask())) == 0)
					 && (((longAt(arg)) & (classIndexMask())) == ClassFloatCompactIndex);
					if (isFloat1) {
						;
						fetchFloatAtinto(arg + BaseHeaderSize, result2);
						arg1 = result2;
						goto l159;
					}
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					arg1 = 0.0;
				l159:	/* end floatValueOf: */;
				l160:	/* end loadFloatOrIntFrom: */;
					/* begin success: */
					if (!(arg1 != 0.0)) {

						/* Don't overwrite an error code that has already been set. */

						if (!GIV(primFailCode)) {
							GIV(primFailCode) = 1;
						}
					}
					if (!GIV(primFailCode)) {
						/* begin pop:thenPushFloat: */
						longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr1 / arg1));
						GIV(stackPointer) = sp;
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l156;
					}
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((9 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l156:	/* end case */;
			break;
		case 346: /*90*/
			/* bytecodePrimMod */
			{
				sqInt mod;

				VM_LABEL(bytecodePrimMod1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				mod = doPrimitiveModby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((mod << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l161;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((10 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l161:	/* end case */;
			break;
		case 347: /*91*/
			/* bytecodePrimMakePoint */
			{
				VM_LABEL(bytecodePrimMakePoint1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveMakePoint();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l162;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((11 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l162:	/* end case */;
			break;
		case 348: /*92*/
			/* bytecodePrimBitShift */
			{
				sqInt integerArgument;
				sqInt integerReceiver;
				sqInt newLargeInteger;
				usqInt newObj;
				usqInt numBytes;
				sqInt objFormat;
				sqInt shifted;
				char *sp;

				VM_LABEL(bytecodePrimBitShift1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin primitiveBitShift */
				integerArgument = longAt(GIV(stackPointer));
				if (!((integerArgument & 1))) {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
					goto l167;
				}
				integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
				integerReceiver = positive32BitValueOf(integerReceiver);

				if (!GIV(primFailCode)) {
					if (((integerArgument = (integerArgument >> 1))) >= 0) {

						/* Left shift -- must fail bits would be lost */

						if (!(integerArgument <= 0x1F)) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l167;
						}
						shifted = integerReceiver << integerArgument;
						
						if (!(integerReceiver == (((usqInt) shifted) >> integerArgument))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l167;
						}
					}
					else {

						/* Right shift -- OK to lose bits */

						if (!(integerArgument >= (-0x1F))) {
							/* begin primitiveFail */
							if (!GIV(primFailCode)) {
								GIV(primFailCode) = 1;
							}
							goto l167;
						}
						shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
					}
					/* begin positive32BitIntegerFor: */
					/* begin maybeInlinePositive32BitIntegerFor: */
					assert(!((hasSixtyFourBitImmediates())));
					if (((((sqInt)shifted)) >= 0)
					 && ((((sqInt)(shifted ^ (shifted << 1)))) >= 0)) {
						shifted = ((shifted << 1) | 1);
						goto l166;
					}
					/* begin eeInstantiateSmallClassIndex:format:numSlots: */
					objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
					assert(ClassLargePositiveIntegerCompactIndex != 0);
					assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
					/* begin allocateSmallNewSpaceSlots:format:classIndex: */
					assert(1 < (numSlotsMask()));
					newObj = GIV(freeStart);
					numBytes = BaseHeaderSize + (8);
					assert((numBytes % (allocationUnit())) == 0);
					assert((newObj % (allocationUnit())) == 0);
					if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
						if (!GIV(needGCFlag)) {
							/* begin scheduleScavenge */
							GIV(needGCFlag) = 1;
							forceInterruptCheck();
						}
						if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
							error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
							newLargeInteger = 0;
							goto l164;
						}
					}
					long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
					GIV(freeStart) += numBytes;
					newLargeInteger = newObj;
				l164:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
					
#          if VMBIGENDIAN
					byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) shifted) >> 24) & 0xFF);
					byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) shifted) >> 16) & 0xFF);
					byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) shifted) >> 8) & 0xFF);
					byteAtput((newLargeInteger + BaseHeaderSize), shifted & 0xFF);

#          else /* VMBIGENDIAN */
					long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), shifted);

#          endif /* VMBIGENDIAN */

					shifted = newLargeInteger;
				l166:	/* end maybeInlinePositive32BitIntegerFor: */;
					goto l165;

				l165:	/* end positive32BitIntegerFor: */;

					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
					GIV(stackPointer) = sp;
				}
			l167:	/* end primitiveBitShift */;
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l163;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((12 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l163:	/* end case */;
			break;
		case 349: /*93*/
			/* bytecodePrimDiv */
			{
				sqInt quotient;

				VM_LABEL(bytecodePrimDiv1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				quotient = doPrimitiveDivby(longAtPointer(localSP + (1 * BytesPerOop)), longAtPointer(localSP + (0 * BytesPerOop)));
				if (!GIV(primFailCode)) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), ((quotient << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l168;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((13 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l168:	/* end case */;
			break;
		case 350: /*94*/
			/* bytecodePrimBitAnd */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitAnd1);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg & rcvr);
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l169;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitAnd();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l169;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((14 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l169:	/* end case */;
			break;
		case 351: /*95*/
			/* bytecodePrimBitOr */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimBitOr1);
				arg = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((arg & 1))
				 && ((rcvr & 1))) {
					/* begin internalPop:thenPush: */
					longAtPointerput((localSP += (2 - 1) * BytesPerOop), arg | rcvr);
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l170;
				}
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				primitiveBitOr();
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				if (!GIV(primFailCode)) {
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l170;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((15 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l170:	/* end case */;
			break;
		case 352: /*96*/
			/* bytecodePrimAt */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt index1;
				sqInt newLargeInteger;
				usqInt newObj;
				usqInt numBytes;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots21;
				usqInt numSlots3;
				usqInt numSlots31;
				usqInt numSlots4;
				sqInt objFormat;
				sqInt objOop;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt result;
				sqInt result1;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;

				VM_LABEL(bytecodePrimAt1);
				result = 0;
				index = longAtPointer(localSP);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && ((index & 1))) {

					/* Index into atCache = 4N, for N = 0 ... 7 */

					atIx = rcvr & AtCacheMask;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						GIV(lkupClassTag) = (longAt(rcvr)) & (classIndexMask());
						/* begin fetchPointer:ofObject: */
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((16 * 2) << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag)))) {
							GIV(argumentCount) = 1;
							goto commonSendOrdinary;
							goto l171;
						}
						if (primitiveFunctionPointer == primitiveAt) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = long64At(rcvr);
							fmt1 = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
							if ((fmt1 == (indexablePointersFormat()))
							 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */

								GIV(primFailCode) = PrimErrBadReceiver;
								goto l180;
							}
							/* begin lengthOf:format: */
							/* begin numSlotsOfAny: */
							numSlots3 = byteAt(rcvr + 7);
							numSlots1 = (numSlots3 == (numSlotsMask())
								? longAt(rcvr - BaseHeaderSize)
								: numSlots3);
							if (fmt1 <= 5) {
								totalLength = numSlots1;
								goto l181;
							}
							if (fmt1 >= (firstByteFormat())) {

								/* bytes, including CompiledMethod */

								totalLength = (numSlots1 << (shiftForWord())) - (fmt1 & 7);
								goto l181;
							}
							if (fmt1 >= (firstShortFormat())) {
								totalLength = (numSlots1 << ((shiftForWord()) - 1)) - (fmt1 & 3);
								goto l181;
							}
							if (fmt1 >= (firstLongFormat())) {
								totalLength = (numSlots1 << ((shiftForWord()) - 2)) - (fmt1 & 1);
								goto l181;
							}
							if (fmt1 == (sixtyFourBitIndexableFormat())) {
								totalLength = ((usqInt) numSlots1) >> 1;
								goto l181;
							}
							totalLength = 0;
						l181:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt1 >= (sixtyFourBitIndexableFormat()))
							 || (fmt1 == 2)) {
								fixedFields1 = 0;
								goto l177;
							}
							if (fmt1 < 2) {
								fixedFields1 = totalLength;
								goto l177;
							}
							class = fetchClassOfNonImm(rcvr);
							/* begin fixedFieldsOfClassFormat: */
							fixedFields1 = (((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1)) & ((1 << (fixedFieldsFieldWidth())) - 1);
						l177:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt1;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields1);
						l180:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAt) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr1 = long64At(rcvr);
								fmt2 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
								/* begin lengthOf:format: */
								/* begin numSlotsOfAny: */
								numSlots21 = byteAt(rcvr + 7);
								numSlots4 = (numSlots21 == (numSlotsMask())
									? longAt(rcvr - BaseHeaderSize)
									: numSlots21);
								if (fmt2 <= 5) {
									totalLength1 = numSlots4;
									goto l172;
								}
								if (fmt2 >= (firstByteFormat())) {

									/* bytes, including CompiledMethod */

									totalLength1 = (numSlots4 << (shiftForWord())) - (fmt2 & 7);
									goto l172;
								}
								if (fmt2 >= (firstShortFormat())) {
									totalLength1 = (numSlots4 << ((shiftForWord()) - 1)) - (fmt2 & 3);
									goto l172;
								}
								if (fmt2 >= (firstLongFormat())) {
									totalLength1 = (numSlots4 << ((shiftForWord()) - 2)) - (fmt2 & 1);
									goto l172;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat())) {
									totalLength1 = ((usqInt) numSlots4) >> 1;
									goto l172;
								}
								totalLength1 = 0;
							l172:	/* end lengthOf:format: */;
								fixedFields2 = 0;

								/* special flag for strings */

								fmt2 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt2;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields2;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields2);
							l175:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 1;
								goto commonSendOrdinary;
								goto l171;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:cacheIndex: */
						index1 = (index >> 1);
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo(index1, 1))
						 && (oopisLessThanOrEqualTo(index1, stSize))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								result = longAt((rcvr + BaseHeaderSize) + (((index1 + fixedFields) - 1) << (shiftForWord())));
								goto l174;
							}
							if (fmt < (firstByteFormat())) {

								/* Bitmap */

								result1 = long32At((rcvr + BaseHeaderSize) + ((index1 - 1) << 2));
								/* begin positive32BitIntegerFor: */
								/* begin maybeInlinePositive32BitIntegerFor: */
								assert(!((hasSixtyFourBitImmediates())));
								if (((((sqInt)result1)) >= 0)
								 && ((((sqInt)(result1 ^ (result1 << 1)))) >= 0)) {
									result = ((result1 << 1) | 1);
									goto l178;
								}
								/* begin eeInstantiateSmallClassIndex:format:numSlots: */
								objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
								assert(ClassLargePositiveIntegerCompactIndex != 0);
								assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
								/* begin allocateSmallNewSpaceSlots:format:classIndex: */
								assert(1 < (numSlotsMask()));
								newObj = GIV(freeStart);
								numBytes = BaseHeaderSize + (8);
								assert((numBytes % (allocationUnit())) == 0);
								assert((newObj % (allocationUnit())) == 0);
								if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
									if (!GIV(needGCFlag)) {
										/* begin scheduleScavenge */
										GIV(needGCFlag) = 1;
										forceInterruptCheck();
									}
									if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
										error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
										newLargeInteger = 0;
										goto l182;
									}
								}
								long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
								GIV(freeStart) += numBytes;
								newLargeInteger = newObj;
							l182:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
								
#                if VMBIGENDIAN
								byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) result1) >> 24) & 0xFF);
								byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) result1) >> 16) & 0xFF);
								byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) result1) >> 8) & 0xFF);
								byteAtput((newLargeInteger + BaseHeaderSize), result1 & 0xFF);

#                else /* VMBIGENDIAN */
								long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), result1);

#                endif /* VMBIGENDIAN */

								result = newLargeInteger;
							l178:	/* end maybeInlinePositive32BitIntegerFor: */;
								goto l174;

							}
							if (fmt >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */
								/* String */
								/* Spur supports the String at:[put:] primitives on WideString */

								if ((fmt - 32) < (firstByteFormat())) {
									result1 = long32At((rcvr + BaseHeaderSize) + ((index1 - 1) << 2));
								}
								else {
									result1 = byteAt((rcvr + BaseHeaderSize) + (index1 - 1));
								}
								result = (result1 << (numTagBits())) + (characterTag());

								goto l174;
							}
							else {
								if ((fmt < (firstCompiledMethodFormat()))
								 || (index1 >= ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									result = (((byteAt((rcvr + BaseHeaderSize) + (index1 - 1))) << 1) | 1);
									goto l174;
								}
							}
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						result = (GIV(primFailCode) = reasonCode);
					l174:	/* end commonVariable:at:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (2 - 1) * BytesPerOop), result);
						goto l171;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((16 * 2) << (shiftForWord())));
				GIV(argumentCount) = 1;
				goto normalSend;
			}
		l171:	/* end case */;
			break;
		case 353: /*97*/
			/* bytecodePrimAtPut */
			{
				sqInt atIx;
				sqInt class;
				sqInt class1;
				sqInt fixedFields;
				sqInt fixedFields1;
				sqInt fixedFields2;
				sqInt fmt;
				sqInt fmt1;
				sqInt fmt2;
				sqLong hdr;
				sqLong hdr1;
				sqInt index;
				sqInt isCharacter;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				usqInt numSlots21;
				usqInt numSlots3;
				usqInt numSlots31;
				usqInt numSlots4;
				sqInt rcvr;
				sqInt reasonCode;
				sqInt stSize;
				sqInt totalLength;
				sqInt totalLength1;
				sqInt valToPut;
				sqInt value;

				VM_LABEL(bytecodePrimAtPut1);
				value = longAtPointer(localSP);
				index = longAtPointer(localSP + (1 * BytesPerOop));
				rcvr = longAtPointer(localSP + (2 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && ((index & 1))) {

					/* Index into atPutCache */

					atIx = (rcvr & AtCacheMask) + AtPutBase;
					if ((GIV(atCache)[atIx + AtCacheOop]) != rcvr) {
						GIV(lkupClassTag) = (longAt(rcvr)) & (classIndexMask());
						/* begin fetchPointer:ofObject: */
						GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((17 * 2) << (shiftForWord())));
						if (!(lookupInMethodCacheSelclassTag(GIV(messageSelector), GIV(lkupClassTag)))) {
							GIV(argumentCount) = 2;
							goto commonSendOrdinary;
							goto l183;
						}
						if (primitiveFunctionPointer == primitiveAtPut) {
							/* begin install:inAtCache:at:string: */
							assert(!(isContext(rcvr)));
							hdr = long64At(rcvr);
							fmt1 = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
							if ((fmt1 == (indexablePointersFormat()))
							 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {

								/* Contexts must not be put in the atCache, since their size is not constant */

								GIV(primFailCode) = PrimErrBadReceiver;
								goto l191;
							}
							/* begin lengthOf:format: */
							/* begin numSlotsOfAny: */
							numSlots3 = byteAt(rcvr + 7);
							numSlots1 = (numSlots3 == (numSlotsMask())
								? longAt(rcvr - BaseHeaderSize)
								: numSlots3);
							if (fmt1 <= 5) {
								totalLength = numSlots1;
								goto l192;
							}
							if (fmt1 >= (firstByteFormat())) {

								/* bytes, including CompiledMethod */

								totalLength = (numSlots1 << (shiftForWord())) - (fmt1 & 7);
								goto l192;
							}
							if (fmt1 >= (firstShortFormat())) {
								totalLength = (numSlots1 << ((shiftForWord()) - 1)) - (fmt1 & 3);
								goto l192;
							}
							if (fmt1 >= (firstLongFormat())) {
								totalLength = (numSlots1 << ((shiftForWord()) - 2)) - (fmt1 & 1);
								goto l192;
							}
							if (fmt1 == (sixtyFourBitIndexableFormat())) {
								totalLength = ((usqInt) numSlots1) >> 1;
								goto l192;
							}
							totalLength = 0;
						l192:	/* end lengthOf:format: */;
							/* begin fixedFieldsOf:format:length: */
							if ((fmt1 >= (sixtyFourBitIndexableFormat()))
							 || (fmt1 == 2)) {
								fixedFields1 = 0;
								goto l189;
							}
							if (fmt1 < 2) {
								fixedFields1 = totalLength;
								goto l189;
							}
							class = fetchClassOfNonImm(rcvr);
							/* begin fixedFieldsOfClassFormat: */
							fixedFields1 = (((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1)) & ((1 << (fixedFieldsFieldWidth())) - 1);
						l189:	/* end fixedFieldsOf:format:length: */;

							GIV(atCache)[atIx + AtCacheOop] = rcvr;
							GIV(atCache)[atIx + AtCacheFmt] = fmt1;
							GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields1;
							GIV(atCache)[atIx + AtCacheSize] = (totalLength - fixedFields1);
						l191:	/* end install:inAtCache:at:string: */;
						}
						else {
							if (primitiveFunctionPointer == primitiveStringAtPut) {
								/* begin install:inAtCache:at:string: */
								assert(!(isContext(rcvr)));
								hdr1 = long64At(rcvr);
								fmt2 = (((unsigned sqLong)hdr1) >> (formatShift())) & (formatMask());
								/* begin lengthOf:format: */
								/* begin numSlotsOfAny: */
								numSlots21 = byteAt(rcvr + 7);
								numSlots4 = (numSlots21 == (numSlotsMask())
									? longAt(rcvr - BaseHeaderSize)
									: numSlots21);
								if (fmt2 <= 5) {
									totalLength1 = numSlots4;
									goto l184;
								}
								if (fmt2 >= (firstByteFormat())) {

									/* bytes, including CompiledMethod */

									totalLength1 = (numSlots4 << (shiftForWord())) - (fmt2 & 7);
									goto l184;
								}
								if (fmt2 >= (firstShortFormat())) {
									totalLength1 = (numSlots4 << ((shiftForWord()) - 1)) - (fmt2 & 3);
									goto l184;
								}
								if (fmt2 >= (firstLongFormat())) {
									totalLength1 = (numSlots4 << ((shiftForWord()) - 2)) - (fmt2 & 1);
									goto l184;
								}
								if (fmt2 == (sixtyFourBitIndexableFormat())) {
									totalLength1 = ((usqInt) numSlots4) >> 1;
									goto l184;
								}
								totalLength1 = 0;
							l184:	/* end lengthOf:format: */;
								fixedFields2 = 0;

								/* special flag for strings */

								fmt2 += 32;

								GIV(atCache)[atIx + AtCacheOop] = rcvr;
								GIV(atCache)[atIx + AtCacheFmt] = fmt2;
								GIV(atCache)[atIx + AtCacheFixedFields] = fixedFields2;
								GIV(atCache)[atIx + AtCacheSize] = (totalLength1 - fixedFields2);
							l187:	/* end install:inAtCache:at:string: */;
							}
							else {
								GIV(argumentCount) = 2;
								goto commonSendOrdinary;
								goto l183;
							}
						}
					}
					if (!GIV(primFailCode)) {
						/* begin commonVariable:at:put:cacheIndex: */
						stSize = GIV(atCache)[atIx + AtCacheSize];
						if ((oopisGreaterThanOrEqualTo((index >> 1), 1))
						 && (oopisLessThanOrEqualTo((index >> 1), stSize))) {
							fmt = GIV(atCache)[atIx + AtCacheFmt];
							if (fmt <= (weakArrayFormat())) {
								assert(!(isContextNonImm(rcvr)));
								fixedFields = GIV(atCache)[atIx + AtCacheFixedFields];
								/* begin storePointer:ofObject:withValue: */
								assert(!(isForwarded(rcvr)));
								if (isOldObject(rcvr)) {

									/* most stores into young objects */

									if (((value & (tagMask())) == 0)
									 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
										/* begin possibleRootStoreInto: */
										if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
											remember(rcvr);
										}
									}
								}
								longAtput((rcvr + BaseHeaderSize) + (((((index >> 1)) + fixedFields) - 1) << (shiftForWord())), value);
								goto l186;
							}
							if (fmt < (firstByteFormat())) {

								/* Bitmap */

								valToPut = positive32BitValueOf(value);
								if (!GIV(primFailCode)) {
									long32Atput((rcvr + BaseHeaderSize) + ((((index >> 1)) - 1) << 2), valToPut);
									goto l186;
								}
								GIV(primFailCode) = PrimErrBadArgument;
								goto l186;
							}
							if (fmt >= 32) {

								/* Note fmt >= firstStringyFormat is an artificial flag for strings */

								isCharacter = (value & (tagMask())) == 2;
								if (!isCharacter) {
									GIV(primFailCode) = PrimErrBadArgument;
									goto l186;
								}
								valToPut = ((usqInt) (((usqInt)value))) >> (numTagBits());

								if ((fmt - 32) < (firstByteFormat())) {
									long32Atput((rcvr + BaseHeaderSize) + ((((index >> 1)) - 1) << 2), valToPut);
									goto l186;
								}
							}
							else {
								if ((fmt >= (firstCompiledMethodFormat()))
								 && (((index >> 1)) < ((((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1))) {
									GIV(primFailCode) = PrimErrBadIndex;
									goto l186;
								}
								valToPut = ((value & 1)
									? (value >> 1)
									: -1);
							}
							if (!((valToPut >= 0)
								 && (valToPut <= 0xFF))) {
								GIV(primFailCode) = PrimErrBadArgument;
								goto l186;
							}
							byteAtput((rcvr + BaseHeaderSize) + (((index >> 1)) - 1), valToPut);
							goto l186;
						}
						/* begin primitiveFailFor: */
						reasonCode = (isIndexable(rcvr)
							? PrimErrBadIndex
							: PrimErrBadReceiver);
						GIV(primFailCode) = reasonCode;
					l186:	/* end commonVariable:at:put:cacheIndex: */;
					}
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						/* begin internalPop:thenPush: */
						longAtPointerput((localSP += (3 - 1) * BytesPerOop), value);
						goto l183;
					}
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((17 * 2) << (shiftForWord())));
				GIV(argumentCount) = 2;
				goto normalSend;
			}
		l183:	/* end case */;
			break;
		case 354: /*98*/
			/* bytecodePrimSize */
			{
				sqInt ccIndex;
				sqInt ccIndex1;
				sqInt fmt;
				sqInt fmt1;
				sqInt isArray;
				sqInt isString;
				usqInt numSlots;
				usqInt numSlots1;
				usqInt numSlots11;
				usqInt numSlots2;
				sqInt rcvr;
				sqInt sz;

				VM_LABEL(bytecodePrimSize1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;

				/* Shortcut the mega-lookup for ByteString and Array, the two big consumers of cycles
				   here. Both of these have compact class indices and neither has any added fields. */

				rcvr = longAtPointer(localSP);
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isString = 0;
					goto l194;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isString = ClassByteStringCompactIndex == ccIndex;
				goto l194;

			l194:	/* end is:instanceOf:compactClassIndex: */;
				if (isString) {
					/* begin lengthOf:format: */
					fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots1 = byteAt(rcvr + 7);
					numSlots = (numSlots1 == (numSlotsMask())
						? longAt(rcvr - BaseHeaderSize)
						: numSlots1);
					if (fmt <= 5) {
						sz = numSlots;
						goto l195;
					}
					if (fmt >= (firstByteFormat())) {

						/* bytes, including CompiledMethod */

						sz = (numSlots << (shiftForWord())) - (fmt & 7);
						goto l195;
					}
					if (fmt >= (firstShortFormat())) {
						sz = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
						goto l195;
					}
					if (fmt >= (firstLongFormat())) {
						sz = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
						goto l195;
					}
					if (fmt == (sixtyFourBitIndexableFormat())) {
						sz = ((usqInt) numSlots) >> 1;
						goto l195;
					}
					sz = 0;
				l195:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l193;
				}
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isArray = 0;
					goto l196;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex1 = (longAt(rcvr)) & (classIndexMask());
				isArray = ClassArrayCompactIndex == ccIndex1;
				goto l196;

			l196:	/* end is:instanceOf:compactClassIndex: */;
				if (isArray) {
					/* begin lengthOf:format: */
					fmt1 = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
					/* begin numSlotsOfAny: */
					numSlots11 = byteAt(rcvr + 7);
					numSlots2 = (numSlots11 == (numSlotsMask())
						? longAt(rcvr - BaseHeaderSize)
						: numSlots11);
					if (fmt1 <= 5) {
						sz = numSlots2;
						goto l197;
					}
					if (fmt1 >= (firstByteFormat())) {

						/* bytes, including CompiledMethod */

						sz = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
						goto l197;
					}
					if (fmt1 >= (firstShortFormat())) {
						sz = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
						goto l197;
					}
					if (fmt1 >= (firstLongFormat())) {
						sz = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
						goto l197;
					}
					if (fmt1 == (sixtyFourBitIndexableFormat())) {
						sz = ((usqInt) numSlots2) >> 1;
						goto l197;
					}
					sz = 0;
				l197:	/* end lengthOf:format: */;
					longAtPointerput(localSP, ((sz << 1) | 1));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l193;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((18 * 2) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l193:	/* end case */;
			break;
		case 358: /*102*/
			/* bytecodePrimIdenticalV4 */
			{
				sqInt arg;
				sqInt rcvr;

				VM_LABEL(bytecodePrimIdenticalV4);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				arg = longAtPointer(localSP + (0 * BytesPerOop));
				if (((rcvr & (tagMask())) == 0)
				 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					rcvr = handleSpecialSelectorSendFaultForfpsp(rcvr, localFP, localSP);
				}
				if (((arg & (tagMask())) == 0)
				 && (((longAt(arg)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					arg = handleSpecialSelectorSendFaultForfpsp(arg, localFP, localSP);
				}
				/* begin booleanCheatV4: */
				if (rcvr == arg) {
					goto booleanCheatTrueV4;
				}
				else {
					goto booleanCheatFalseV4;
				}
			}
			break;
		case 361: /*105*/
			/* bytecodePrimValue */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValue1);
				rcvr = longAtPointer(localSP);
				GIV(argumentCount) = 0;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isBlock = 0;
					goto l199;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l199;

			l199:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l198;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((25 * 2) << (shiftForWord())));
				goto normalSend;
			}
		l198:	/* end case */;
			break;
		case 362: /*106*/
			/* bytecodePrimValueWithArg */
			{
				sqInt ccIndex;
				sqInt isBlock;
				sqInt rcvr;

				VM_LABEL(bytecodePrimValueWithArg1);
				rcvr = longAtPointer(localSP + (1 * BytesPerOop));
				GIV(argumentCount) = 1;
				/* begin is:instanceOf:compactClassIndex: */
				if ((rcvr & (tagMask())) != 0) {
					isBlock = 0;
					goto l201;
				}
				/* begin isClassOfNonImm:equalTo:compactClassIndex: */
				assert(!(isImmediate(rcvr)));
				ccIndex = (longAt(rcvr)) & (classIndexMask());
				isBlock = ClassBlockClosureCompactIndex == ccIndex;
				goto l201;

			l201:	/* end is:instanceOf:compactClassIndex: */;
				if (isBlock) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					primitiveClosureValue();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (!GIV(primFailCode)) {
						/* begin fetchNextBytecode */
						currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

						goto l200;
					}
					GIV(primFailCode) = 0;
				}
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((26 * 2) << (shiftForWord())));
				goto normalSend;
			}
		l200:	/* end case */;
			break;
		case 366: /*110*/
			/* bytecodePrimPointX */
			{
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointX1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & (tagMask())) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (XIndex << (shiftForWord()))));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l202;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((30 * 2) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l202:	/* end case */;
			break;
		case 367: /*111*/
			/* bytecodePrimPointY */
			{
				sqInt ok;
				sqInt rcvr;

				VM_LABEL(bytecodePrimPointY1);
				/* begin initPrimCall */
				GIV(primFailCode) = 0;
				rcvr = longAtPointer(localSP);
				/* begin assertClassOf:is: */
				ok = (rcvr & (tagMask())) == 0;
				if (ok) {
					/* begin isClassOfNonImm:equalTo: */
					assert(isNonImmediate(rcvr));
					ok = ((longAt(rcvr)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
				}
				/* begin success: */
				if (!ok) {

					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
				if (!GIV(primFailCode)) {
					/* begin internalStackTopPut: */
					longAtPointerput(localSP, longAt((rcvr + BaseHeaderSize) + (YIndex << (shiftForWord()))));
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

					goto l203;
				}
				GIV(primFailCode) = 0;
				/* begin fetchPointer:ofObject: */
				GIV(messageSelector) = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SpecialSelectors << (shiftForWord())))) + BaseHeaderSize) + ((0x1F * 2) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto normalSend;
			}
		l203:	/* end case */;
			break;
		case 416: /*160*/
		case 417: /*161*/
		case 418: /*162*/
		case 419: /*163*/
		case 420: /*164*/
		case 421: /*165*/
		case 422: /*166*/
		case 423: /*167*/
		case 424: /*168*/
		case 425: /*169*/
		case 426: /*170*/
		case 427: /*171*/
		case 428: /*172*/
		case 429: /*173*/
		case 430: /*174*/
		case 431: /*175*/
			/* sendAbsentImplicit0ArgsBytecode */
			{
				VM_LABEL(sendAbsentImplicit0ArgsBytecode);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + (((currentBytecode & 15) + LiteralStart) << (shiftForWord())));
				GIV(argumentCount) = 0;
				goto commonSendImplicitReceiver;
			}
			break;
		case 456: /*200*/
		case 457: /*201*/
		case 458: /*202*/
		case 459: /*203*/
		case 460: /*204*/
		case 461: /*205*/
		case 462: /*206*/
		case 463: /*207*/
			/* shortConditionalJumpTrue */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpTrue);
				/* begin jumplfTrueBy: */
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l204;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l204:	/* end jumplfTrueBy: */;
			}
			break;
		case 464: /*208*/
		case 465: /*209*/
		case 466: /*210*/
		case 467: /*211*/
		case 468: /*212*/
		case 469: /*213*/
		case 470: /*214*/
		case 471: /*215*/
			/* shortConditionalJumpFalse */
			{
				sqInt boolean;
				sqInt offset;

				VM_LABEL(shortConditionalJumpFalse1);
				/* begin jumplfFalseBy: */
				offset = (currentBytecode & 7) + 1;
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l205;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l205:	/* end jumplfFalseBy: */;
			}
			break;
		case 472: /*216*/
			/* returnReceiver */
			{
				VM_LABEL(returnReceiver1);
				localReturnValue = longAt(localFP + FoxReceiver);
				goto commonReturn;
			}
			break;
		case 474: /*218*/
			/* extReturnTopFromBlock */
			{
				VM_LABEL(extReturnTopFromBlock);
				if (extA == 0) {
					localReturnValue = longAtPointer(localSP);
					goto commonCallerReturn;
					goto l206;
				}
				error("shouldBeImplemented");
				extA = 0;
			}
		l206:	/* end case */;
			break;
		case 477: /*221*/
			/* extNopBytecode */
			{
				VM_LABEL(extNopBytecode);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = (extB = 0);
			}
			break;
		case 478: /*222*/
		case 479: /*223*/
		case 502: /*246*/
		case 503: /*247*/
		case 504: /*248*/
		case 511: /*255*/
			/* unknownBytecode */
			{
				VM_LABEL(unknownBytecode1);
				goto respondToUnknownBytecode;
			}
			break;
		case 480: /*224*/
			/* extABytecode */
			{
				VM_LABEL(extABytecode);
				extA = (((usqInt) extA << 8)) + (byteAtPointer(++localIP));
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 481: /*225*/
			/* extBBytecode */
			{
				sqInt byte;

				VM_LABEL(extBBytecode);
				byte = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extB = ((extB == 0)
				 && (byte > 0x7F)
					? byte - 256
					: (((usqInt) extB << 8)) + byte);
			}
			break;
		case 482: /*226*/
			/* extPushReceiverVariableBytecode */
			{
				char *callerFP;
				sqInt index;
				sqInt object;
				sqInt rcvr;
				sqInt senderOop;
				char *spouseFP;
				char *theSP;

				VM_LABEL(extPushReceiverVariableBytecode);
				index = (byteAtPointer(++localIP)) + (extA << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin pushMaybeContextReceiverVariable: */
				rcvr = longAt(localFP + FoxReceiver);
				if ((index <= StackPointerIndex)
				 && (((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex)) {
					/* begin internalPush: */
					/* begin instVar:ofContext: */
					assert(index < MethodIndex);
					assert(isContext(rcvr));
					if (!(((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))) {
						object = longAt((rcvr + BaseHeaderSize) + (index << (shiftForWord())));
						goto l207;
					}
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (isWidowedContext(rcvr)) {
						object = longAt((rcvr + BaseHeaderSize) + (index << (shiftForWord())));
						goto l207;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((senderOop & 1));
					spouseFP = pointerForOop(senderOop - 1);
					if (index == SenderIndex) {
						/* begin ensureCallerContext: */
						/* begin frameCallerFP: */
						callerFP = pointerForOop(longAt(spouseFP + FoxSavedFP));
						if (callerFP == 0) {

							/* base frame, context in saved ip slot (or base of stack in Cog) */

							object = longAt(spouseFP + FoxCallerContext);
							goto l207;
						}
						/* begin ensureFrameIsMarried:SP: */
						/* begin frameCallerStackPointer: */
						assert(!(isBaseFrame(spouseFP)));
						theSP = (spouseFP + ((FoxCallerSavedIP + BytesPerWord) + ((byteAt((spouseFP + FoxFrameFlags) + 1)) << (shiftForWord())))) + BytesPerWord;
						if ((byteAt((callerFP + FoxFrameFlags) + 2)) != 0) {
							assert(isContext(frameContext(callerFP)));
							object = longAt(callerFP + FoxThisContext);
							goto l207;
						}
						object = marryFrameSP(callerFP, theSP);
						goto l207;
					}
					if (index == StackPointerIndex) {
						assert((ReceiverIndex + (stackPointerIndexForFrame(spouseFP))) < (lengthOf(rcvr)));
						object = (((stackPointerIndexForFrame(spouseFP)) << 1) | 1);
						goto l207;
					}
					if (index == InstructionPointerIndex) {
						object = instructionPointerForFramecurrentFPcurrentIP(spouseFP, localFP, oopForPointer(localIP));
						goto l207;
					}
					error("bad index");
					object = 0;
				l207:	/* end instVar:ofContext: */;
					longAtPointerput((localSP -= BytesPerOop), object);
				}
				else {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), longAt((rcvr + BaseHeaderSize) + (index << (shiftForWord()))));
				}
			}
			break;
		case 483: /*227*/
			/* extPushLiteralVariableBytecode */
			{
				sqInt index;
				sqInt litVar;
				sqInt object;
				sqInt objOop;
				sqInt referent;

				VM_LABEL(extPushLiteralVariableBytecode);
				index = (byteAtPointer(++localIP)) + (extA << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin pushLiteralVariable: */
				
				/* push/store/popLiteralVariable all fetch a literal, and either read or write the literal's value field.
				   The fetch of the literal needs an explicit check (otherwise we would have to scan all literals in
				   all methods in the stack zone, and the entire method on return, and global variables are relatively
				   rare; in my work image 8.7% of literals are globals). */

				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + ((index + LiteralStart) << (shiftForWord())));
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize) + (0 << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0 << (shiftForWord())));
					}
					litVar = referent;
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), longAt((litVar + BaseHeaderSize) + (ValueIndex << (shiftForWord()))));

			}
			break;
		case 484: /*228*/
			/* extPushLiteralBytecode */
			{
				sqInt index;
				sqInt object;

				VM_LABEL(extPushLiteralBytecode);
				index = (byteAtPointer(++localIP)) + (extA << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin pushLiteralConstant: */
				/* begin internalPush: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				object = longAt((GIV(method) + BaseHeaderSize) + ((index + LiteralStart) << (shiftForWord())));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 485: /*229*/
			/* extPushIntegerBytecode */
			{
				sqInt value;

				VM_LABEL(extPushIntegerBytecode);
				value = (byteAtPointer(++localIP)) + (extB << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extB = 0;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), ((value << 1) | 1));
			}
			break;
		case 486: /*230*/
			/* longPushTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt index;
				sqInt object;

				VM_LABEL(longPushTemporaryVariableBytecode);
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				object = (index < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))
					? longAt((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord))
					: longAt(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord)));
				longAtPointerput((localSP -= BytesPerOop), object);
			}
			break;
		case 487: /*231*/
			/* pushNewArrayBytecode */
			{
				sqInt array;
				sqInt i;
				usqInt newObj;
				usqInt numBytes;
				sqInt popValues;
				sqInt size;

				VM_LABEL(pushNewArrayBytecode1);
				size = byteAtPointer(++localIP);
				popValues = size > 0x7F;
				size = size & 0x7F;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				assert((size >= 0)
				 && (ClassArrayCompactIndex != 0));
				assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(size < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((size <= 1
	? 8
	: (size + (size & 1)) * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						array = 0;
						goto l208;
					}
				}
				long64Atput(newObj, (((((usqLong) size)) << (numSlotsFullShift())) + (2 << (formatShift()))) + ClassArrayCompactIndex);
				GIV(freeStart) += numBytes;
				array = newObj;
			l208:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

				if (popValues) {
					for (i = 0; i < size; i += 1) {

						/* Assume: have just allocated a new Array; it must be young. Thus, can use unchecked stores. */

						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + BaseHeaderSize) + (i << (shiftForWord())), longAtPointer(localSP + (((size - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += size * BytesPerOop;
				}
				else {
					for (i = 0; i < size; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(array)));
						longAtput((array + BaseHeaderSize) + (i << (shiftForWord())), GIV(nilObj));
					}
				}
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), array);
			}
			break;
		case 488: /*232*/
			/* extStoreReceiverVariableBytecode */
			{
				sqInt anObject;
				sqInt index1;
				sqInt onCurrentPage;
				sqInt rcvr;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				sqInt variableIndex;

				VM_LABEL(extStoreReceiverVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (extA << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin storeMaybeContextReceiverVariable:withValue: */
				anObject = longAtPointer(localSP);
				rcvr = longAt(localFP + FoxReceiver);
				if ((variableIndex <= ReceiverIndex)
				 && ((((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && (((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(rcvr));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
						 && (!(isWidowedContext(rcvr))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(rcvr)));
						if (isOldObject(rcvr)) {

							/* most stores into young objects */

							if (((anObject & (tagMask())) == 0)
							 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(rcvr);
								}
							}
						}
						longAtput((rcvr + BaseHeaderSize) + (variableIndex << (shiftForWord())), anObject);
						if (variableIndex == StackPointerIndex) {
							/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
						}
						goto l209;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1);
					if (variableIndex == SenderIndex) {
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						index1 = pageIndexForstackMemorybytesPerPage(((void *) theFP), GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, anObject);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l209;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, rcvr);
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */

						if (((anObject & (tagMask())) == 0)
						 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (variableIndex << (shiftForWord())), anObject);
					if (variableIndex == StackPointerIndex) {
						/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l209:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */

						if (((anObject & (tagMask())) == 0)
						 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (variableIndex << (shiftForWord())), anObject);
				}
			}
			break;
		case 489: /*233*/
			/* extStoreLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt referent;
				sqInt variableIndex;

				VM_LABEL(extStoreLiteralVariableBytecode);
				variableIndex = (byteAtPointer(++localIP)) + (extA << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin storeLiteralVariable:withValue: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << (shiftForWord())));
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize) + (0 << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0 << (shiftForWord())));
					}
					litVar = referent;
				}
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(litVar)));
				if (isOldObject(litVar)) {

					/* most stores into young objects */

					if ((((longAtPointer(localSP)) & (tagMask())) == 0)
					 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(litVar);
						}
					}
				}
				longAtput((litVar + BaseHeaderSize) + (ValueIndex << (shiftForWord())), longAtPointer(localSP));
			}
			break;
		case 490: /*234*/
			/* longStoreTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt index;

				VM_LABEL(longStoreTemporaryVariableBytecode);
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (index < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
			}
			break;
		case 491: /*235*/
			/* extStoreAndPopReceiverVariableBytecode */
			{
				sqInt anObject;
				sqInt index1;
				sqInt onCurrentPage;
				sqInt rcvr;
				sqInt senderOop;
				char *theFP;
				StackPage *thePage;
				sqInt variableIndex;

				VM_LABEL(extStoreAndPopReceiverVariableBytecode);
				/* begin extStoreReceiverVariableBytecode */
				variableIndex = (byteAtPointer(++localIP)) + (extA << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin storeMaybeContextReceiverVariable:withValue: */
				anObject = longAtPointer(localSP);
				rcvr = longAt(localFP + FoxReceiver);
				if ((variableIndex <= ReceiverIndex)
				 && ((((longAt(rcvr)) & (classIndexMask())) == ClassMethodContextCompactIndex)
				 && (((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1)))) {
					/* begin instVar:ofContext:put: */
					assert(isMarriedOrWidowedContext(rcvr));
					/* begin writeBackHeadFramePointers */
					assert(GIV(stackPage) == (mostRecentlyUsedPage()));
					/* begin setHeadFP:andSP:inPage: */
					assert(localSP < localFP);
					assert((localSP < ((GIV(stackPage)->baseAddress)))
					 && (localSP > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
					assert((localFP < ((GIV(stackPage)->baseAddress)))
					 && (localFP > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
					(GIV(stackPage)->headFP = localFP);
					(GIV(stackPage)->headSP = localSP);
					assert(pageListIsWellFormed());
					if (!((((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
						 && (!(isWidowedContext(rcvr))))) {
						/* begin storePointer:ofObject:withValue: */
						assert(!(isForwarded(rcvr)));
						if (isOldObject(rcvr)) {

							/* most stores into young objects */

							if (((anObject & (tagMask())) == 0)
							 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
								/* begin possibleRootStoreInto: */
								if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
									remember(rcvr);
								}
							}
						}
						longAtput((rcvr + BaseHeaderSize) + (variableIndex << (shiftForWord())), anObject);
						if (variableIndex == StackPointerIndex) {
							/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
						}
						goto l210;
					}
					/* begin frameOfMarriedContext: */
					senderOop = longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())));
					/* begin withoutSmallIntegerTags: */
					assert((senderOop & 1));
					theFP = pointerForOop(senderOop - 1);
					if (variableIndex == SenderIndex) {
						/* begin stackPageFor: */
						/* begin stackPageAt: */
						index1 = pageIndexForstackMemorybytesPerPage(((void *) theFP), GIV(stackMemory), GIV(bytesPerPage));
						thePage = stackPageAtpages(index1, GIV(pages));
						assert(GIV(stackPage) == (mostRecentlyUsedPage()));
						onCurrentPage = thePage == GIV(stackPage);
						storeSenderOfFramewithValue(theFP, anObject);
						if (onCurrentPage) {
							localFP = (GIV(stackPage)->headFP);
							localSP = (GIV(stackPage)->headSP);
						}
						else {
							markStackPageMostRecentlyUsed(GIV(stackPage));
						}
						goto l210;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					externalDivorceFrameandContext(theFP, rcvr);
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */

						if (((anObject & (tagMask())) == 0)
						 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (variableIndex << (shiftForWord())), anObject);
					if (variableIndex == StackPointerIndex) {
						/* begin ensureContextIsExecutionSafeAfterAssignToStackPointer: */
					}
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					markStackPageMostRecentlyUsed(GIV(stackPage));
					assertValidExecutionPointersimbarline(((usqInt)localIP), localFP, localSP, 1, __LINE__);
				l210:	/* end instVar:ofContext:put: */;
				}
				else {
					/* begin storePointer:ofObject:withValue: */
					assert(!(isForwarded(rcvr)));
					if (isOldObject(rcvr)) {

						/* most stores into young objects */

						if (((anObject & (tagMask())) == 0)
						 && (oopisLessThan(anObject, GIV(newSpaceLimit)))) {
							/* begin possibleRootStoreInto: */
							if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
								remember(rcvr);
							}
						}
					}
					longAtput((rcvr + BaseHeaderSize) + (variableIndex << (shiftForWord())), anObject);
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 492: /*236*/
			/* extStoreAndPopLiteralVariableBytecode */
			{
				sqInt litVar;
				sqInt referent;
				sqInt variableIndex;

				VM_LABEL(extStoreAndPopLiteralVariableBytecode);
				/* begin extStoreLiteralVariableBytecode */
				variableIndex = (byteAtPointer(++localIP)) + (extA << 8);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				extA = 0;
				/* begin storeLiteralVariable:withValue: */
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				litVar = longAt((GIV(method) + BaseHeaderSize) + ((variableIndex + LiteralStart) << (shiftForWord())));
				if (((longAt(litVar)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
					/* begin followForwarded: */
					assert(isUnambiguouslyForwarder(litVar));
					referent = longAt((litVar + BaseHeaderSize) + (0 << (shiftForWord())));
					while (((referent & (tagMask())) == 0)
					 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						referent = longAt((referent + BaseHeaderSize) + (0 << (shiftForWord())));
					}
					litVar = referent;
				}
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(litVar)));
				if (isOldObject(litVar)) {

					/* most stores into young objects */

					if ((((longAtPointer(localSP)) & (tagMask())) == 0)
					 && (oopisLessThan(longAtPointer(localSP), GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(litVar))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(litVar);
						}
					}
				}
				longAtput((litVar + BaseHeaderSize) + (ValueIndex << (shiftForWord())), longAtPointer(localSP));
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 493: /*237*/
			/* longStoreAndPopTemporaryVariableBytecode */
			{
				sqInt frameNumArgs;
				sqInt index;

				VM_LABEL(longStoreAndPopTemporaryVariableBytecode);
				/* begin longStoreTemporaryVariableBytecode */
				index = byteAtPointer(++localIP);
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				if (index < ((frameNumArgs = byteAt((localFP + FoxFrameFlags) + 1)))) {
					longAtput((localFP + FoxCallerSavedIP) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				else {
					longAtput(((localFP + FoxReceiver) - BytesPerWord) + ((frameNumArgs - index) * BytesPerWord), longAtPointer(localSP));
				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			}
			break;
		case 494: /*238*/
			/* extSendBytecode */
			{
				sqInt byte;
				sqInt rcvr;
				sqInt tagBits;

				VM_LABEL(extSendBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((((usqInt) byte) >> 3) + (extA << 5)) + LiteralStart) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (extB << 3);
				extB = 0;
				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				GIV(lkupClassTag) = (((tagBits = rcvr & (tagMask()))) != 0
					? ((tagBits & 1) != 0
							? 1
							: tagBits)
					: (longAt(rcvr)) & (classIndexMask()));
				goto commonSendOrdinary;
			}
			break;
		case 495: /*239*/
			/* extSendSuperBytecode */
			{
				sqInt byte;

				VM_LABEL(extSendSuperBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((((usqInt) byte) >> 3) + (extA << 5)) + LiteralStart) << (shiftForWord())));
				extA = 0;
				
				GIV(argumentCount) = (byte & 7) + (extB << 3);
				extB = 0;
				goto superclassSend;
			}
		l211:	/* end case */;
			break;
		case 496: /*240*/
			/* extSendAbsentImplicitBytecode */
			{
				sqInt byte;

				VM_LABEL(extSendAbsentImplicitBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((((usqInt) byte) >> 3) + (extA << 5)) + LiteralStart) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (extB << 3);
				extB = 0;
				/* goto commonSendImplicitReceiver */
			}
			
		commonSendImplicitReceiver:
			/* commonSendImplicitReceiver */
			{
				sqInt actualLookupRule;
				sqInt candidateMixin;
				sqInt candidateMixinApplication;
				sqInt candidateReceiver;
				sqInt classTablePage;
				sqInt dictionary;
				sqInt errorCode;
				sqInt fieldIndex;
				sqInt fieldIndex1;
				sqInt found;
				sqInt hash;
				sqInt i;
				sqInt i1;
				sqInt index;
				usqInt length;
				sqInt localPrimIndex;
				usqInt mask;
				sqInt methodArray;
				sqInt methodHeader;
				sqInt methodReceiver;
				sqInt nArgs;
				sqInt nextSelector;
				usqInt numSlots;
				sqInt numTemps;
				usqInt object;
				sqInt objOop;
				sqInt objOop1;
				sqInt objOop11;
				sqInt objOop2;
				sqInt objOop3;
				sqInt objOop4;
				sqInt objOop5;
				sqInt oop;
				sqInt rcvr;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt succeeded;
				sqInt table;
				sqInt tagBits;
				sqInt tagBits1;
				sqInt tagBits2;
				sqInt wrapAround;

				VM_LABEL(commonSendImplicitReceiver);
				nArgs = 0;
				savedFramePointer = 0;
				savedStackPointer = 0;
				/* begin sendBreakpoint:receiver: */
				sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
				
				/* begin internalFindNewMethodImplicitReceiver */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				assert(!((isOopForwarded(GIV(localAbsentReceiver)))));
				GIV(lkupClassTag) = (((tagBits = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? ((tagBits & 1) != 0
							? 1
							: tagBits)
					: (longAt(GIV(localAbsentReceiver))) & (classIndexMask()));
				if (inlineLookupInNSMethodCacheSelclassTagmethodlookupRule(GIV(messageSelector), GIV(lkupClassTag), GIV(method), LookupRuleImplicit)) {
					if (!(GIV(localAbsentReceiverOrZero) == 0)) {
						GIV(localAbsentReceiver) = GIV(localAbsentReceiverOrZero);
					}
				}
				else {

					/* entry was not found in the cache; look it up the hard way */

					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
					 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
						if (((GIV(messageSelector) & (tagMask())) == 0)
						 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
						}
						if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
							GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
						}
					}
					/* begin classAtIndex: */
					assert((GIV(lkupClassTag) <= (tagMask()))
					 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
					/* begin fetchPointer:ofObject: */
					fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
					classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (fieldIndex << (shiftForWord())));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l248;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex1 = GIV(lkupClassTag) & ((1 << (classTableMajorIndexShift())) - 1);
					GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (fieldIndex1 << (shiftForWord())));
				l248:	/* end classAtIndex: */;
					/* begin lookupImplicitReceiverSend */
					GIV(messageSelector) = (((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))
						? noInlineFollowForwarded(GIV(messageSelector))
						: GIV(messageSelector));
					methodReceiver = longAt(localFP + FoxReceiver);
					candidateReceiver = methodReceiver;
					assert(!((isForwarded(GIV(method)))));
					candidateMixin = methodClassOf(GIV(method));
					GIV(localAbsentReceiverOrZero) = 0;
					while (1) {
						assert(!((isForwarded(candidateMixin))));
						assert(!((isForwarded(candidateReceiver))));
						candidateMixinApplication = findApplicationOfTargetMixinstartingAtBehavior(candidateMixin, (((tagBits2 = candidateReceiver & (tagMask()))) != 0
							? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (tagBits2 << (shiftForWord())))
							: fetchClassOfNonImm(candidateReceiver)));
						assert(!((candidateMixinApplication == 0)));
						assert(!((candidateMixinApplication == (nilObject()))));
						assert(!((isForwarded(candidateMixinApplication))));
						assert(addressCouldBeClassObj(candidateMixinApplication));
						/* begin followObjField:ofObject: */
						objOop = longAt((candidateMixinApplication + BaseHeaderSize) + (MethodDictionaryIndex << (shiftForWord())));
						assert(isNonImmediate(objOop));
						if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
							objOop = fixFollowedFieldofObjectwithInitialValue(MethodDictionaryIndex, candidateMixinApplication, objOop);
						}
						dictionary = objOop;
						/* begin lookupMethodInDictionary: */
						/* begin numSlotsOf: */
						flag("endianness");
						assert((classIndexOf(dictionary)) > (isForwardedObjectClassIndexPun()));
						numSlots = byteAt(dictionary + 7);
						length = (numSlots == (numSlotsMask())
							? longAt(dictionary - BaseHeaderSize)
							: numSlots);

						/* Use linear search on small dictionaries; its cheaper.
						   Also the limit can be set to force linear search of all dictionaries, which supports the
						   booting of images that need rehashing (e.g. because a tracer has generated an image
						   with different hashes but hasn't rehashed it yet.) */

						mask = (length - SelectorStart) - 1;
						if (mask <= GIV(methodDictLinearSearchLimit)) {
							index = 0;
							while (index <= mask) {
								nextSelector = longAt((dictionary + BaseHeaderSize) + ((index + SelectorStart) << (shiftForWord())));
								if (((nextSelector & (tagMask())) == 0)
								 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
									nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
								}
								if (nextSelector == GIV(messageSelector)) {
									/* begin followObjField:ofObject: */
									objOop5 = longAt((dictionary + BaseHeaderSize) + (MethodArrayIndex << (shiftForWord())));
									assert(isNonImmediate(objOop5));
									if (((longAt(objOop5)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
										objOop5 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop5);
									}
									methodArray = objOop5;
									/* begin followField:ofObject: */
									objOop2 = longAt((methodArray + BaseHeaderSize) + (index << (shiftForWord())));
									if (((objOop2 & (tagMask())) == 0)
									 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
										objOop2 = fixFollowedFieldofObjectwithInitialValue(index, methodArray, objOop2);
									}
									GIV(newMethod) = objOop2;
									found = 1;
									goto l247;
								}
								index += 1;
							}
							found = 0;
							goto l247;
						}

						/* It is assumed that there are some nils in this dictionary, and search will
						   stop when one is encountered. However, if there are no nils, then wrapAround
						   will be detected the second time the loop gets to the end of the table. */

						index = SelectorStart + (mask & (((GIV(messageSelector) & (tagMask())) != 0
	? ((GIV(messageSelector) & 1)
			? (GIV(messageSelector) >> 1)
			: ((usqInt) (((usqInt)GIV(messageSelector)))) >> (numTagBits()))
	: (/* begin hashBitsOf: */
		(objOop3 = GIV(messageSelector)),
		(hash = (long32At(objOop3 + 4)) & (identityHashHalfWordMask())),
		(hash == 0
				? ((hash = (newObjectHash()) & (identityHashHalfWordMask())),
					/* begin setHashBitsOf:to: */
					flag("endianness"),
					assert(((hash >= 0) && (hash <= (identityHashHalfWordMask())))),
					long32Atput(objOop3 + 4, ((((long32At(objOop3 + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash))
				: 0),
		hash))));
						wrapAround = 0;
						while (1) {
							nextSelector = longAt((dictionary + BaseHeaderSize) + (index << (shiftForWord())));
							if (nextSelector == GIV(nilObj)) {
								found = 0;
								goto l247;
							}
							if (((nextSelector & (tagMask())) == 0)
							 && (((longAt(nextSelector)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
								nextSelector = fixFollowedFieldofObjectwithInitialValue(index + SelectorStart, dictionary, nextSelector);
							}
							if (nextSelector == GIV(messageSelector)) {
								/* begin followObjField:ofObject: */
								objOop11 = longAt((dictionary + BaseHeaderSize) + (MethodArrayIndex << (shiftForWord())));
								assert(isNonImmediate(objOop11));
								if (((longAt(objOop11)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
									objOop11 = fixFollowedFieldofObjectwithInitialValue(MethodArrayIndex, dictionary, objOop11);
								}
								methodArray = objOop11;
								/* begin followField:ofObject: */
								objOop4 = longAt((methodArray + BaseHeaderSize) + ((index - SelectorStart) << (shiftForWord())));
								if (((objOop4 & (tagMask())) == 0)
								 && (((longAt(objOop4)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
									objOop4 = fixFollowedFieldofObjectwithInitialValue(index - SelectorStart, methodArray, objOop4);
								}
								GIV(newMethod) = objOop4;
								found = 1;
								goto l247;
							}
							index += 1;
							if (index == length) {
								if (wrapAround) {
									found = 0;
									goto l247;
								}
								wrapAround = 1;
								index = SelectorStart;
							}
						}
						found = 0;
					l247:	/* end lookupMethodInDictionary: */;
						if (found) {
							GIV(localAbsentReceiver) = candidateReceiver;
							actualLookupRule = lookupLexicalfromrule(GIV(messageSelector), candidateMixin, LookupRuleImplicit);
							goto l250;
						}
						/* begin followObjField:ofObject: */
						objOop1 = longAt((candidateMixin + BaseHeaderSize) + (EnclosingMixinIndex << (shiftForWord())));
						assert(isNonImmediate(objOop1));
						if (((longAt(objOop1)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
							objOop1 = fixFollowedFieldofObjectwithInitialValue(EnclosingMixinIndex, candidateMixin, objOop1);
						}
						candidateMixin = objOop1;
						assert(!((isForwarded(candidateMixin))));
						if (candidateMixin == GIV(nilObj)) break;
						GIV(localAbsentReceiverOrZero) = (candidateReceiver = followObjFieldofObject(EnclosingObjectIndex, candidateMixinApplication));
					}
					GIV(localAbsentReceiverOrZero) = 0;
					GIV(localAbsentReceiver) = methodReceiver;

					/* MNU lookup starts here. */

					GIV(lkupClass) = (((tagBits1 = methodReceiver & (tagMask()))) != 0
						? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (tagBits1 << (shiftForWord())))
						: fetchClassOfNonImm(methodReceiver));
					actualLookupRule = lookupProtectedstartingAtrule(GIV(messageSelector), GIV(lkupClass), LookupRuleImplicit);
				l250:	/* end lookupImplicitReceiverSend */;
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToNSCache(actualLookupRule);
				}
				/* begin shuffleArgumentsAndStoreAbsentReceiver: */

				/* a.k.a. self internalPush: anything */

				localSP -= BytesPerOop;
				for (i = 1; i <= GIV(argumentCount); i += 1) {
					oop = longAtPointer(localSP + (i * BytesPerOop));
					longAtPointerput(localSP + ((i - 1) * BytesPerOop), oop);
				}
				longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), GIV(localAbsentReceiver));
				/* begin internalExecuteNewMethod */
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 0xFF)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + ((localPrimIndex - 264) << (shiftForWord()))));
							goto l252;
						}
						if (localPrimIndex == 256) {
							goto l252;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l252;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l252;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l252;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 1) | 1));
					l252:	/* end internalQuickPrimitiveResponse */;
						goto l249;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
					assert((remapBufferCount()) == 0);
					
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					/* begin maybeRetryFailureDueToForwarding */
					if (GIV(primFailCode)
					 && (checkForAndFollowForwardedPrimitiveState())) {
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
					}
					/* begin maybeFailForLastObjectOverwrite */
					if (checkAllocFiller) {
						if (((freeStart()) < GIV(scavengeThreshold))
						 && ((longAt(freeStart())) != (freeStart()))) {
							GIV(primFailCode) = PrimErrWritePastObject;
						}
					}
					
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						browserPluginReturnIfNeeded();
						goto l249;
					}
				}
				/* begin internalActivateNewMethod */
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(newMethod)));
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
				numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
				assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

				/* could new rcvr be set at point of send? */

				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				assert(!(isOopForwarded(rcvr)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localIP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localFP);
				localFP = localSP;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
				/* begin setMethod:methodHeader: */
				GIV(method) = GIV(newMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert((methodHeaderOf(GIV(method))) == methodHeader);
				GIV(bytecodeSetSelector) = ((((sqInt) methodHeader)) < 0
					? 256
					: 0);

				/* begin internalPush: */
				object = (VMBIGENDIAN
					? ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
					: ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << 8)) + (0)) + (0));
				longAtPointerput((localSP -= BytesPerOop), object);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), rcvr);
				for (i1 = (GIV(argumentCount) + 1); i1 <= numTemps; i1 += 1) {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				}
				localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
				if (methodHeader & AlternateHeaderHasPrimFlag) {

					/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
					   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

					localIP += 3;
					if (GIV(primFailCode) != 0) {
						if ((byteAt(localIP + 1)) == (((((sqInt) methodHeader)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode))) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << (shiftForWord())));
								if (GIV(primFailCode) <= (numSlotsOf(table))) {
									errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << (shiftForWord())));
									goto l251;
								}
							}
							errorCode = ((GIV(primFailCode) << 1) | 1);
						l251:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
				}
				assert((frameNumArgs(localFP)) == GIV(argumentCount));
				assert(!(frameIsBlockActivation(localFP)));
				assert(!(frameHasContext(localFP)));
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
			l249:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 497: /*241*/
			/* extSendAbsentDynamicSuperBytecode */
			{
				sqInt byte;

				VM_LABEL(extSendAbsentDynamicSuperBytecode);
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((((usqInt) byte) >> 3) + (extA << 5)) + LiteralStart) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (extB << 3);
				extB = 0;
				/* goto commonSendDynamicSuper */
			}
			
		commonSendDynamicSuper:
			/* commonSendDynamicSuper */
			{
				sqInt actualLookupRule;
				sqInt classTablePage;
				sqInt errorCode;
				sqInt fieldIndex;
				sqInt fieldIndex1;
				sqInt hash1;
				sqInt i;
				sqInt i1;
				sqInt localPrimIndex;
				sqInt methodHeader;
				sqInt methodMixin;
				sqInt methodMixinApplication;
				sqInt nArgs;
				sqInt numTemps;
				usqInt object;
				sqInt objOop;
				sqInt oop;
				sqInt probe1;
				sqInt rcvr;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt succeeded;
				sqInt table;
				sqInt tagBits;
				sqInt tagBits1;

				VM_LABEL(commonSendDynamicSuper);
				nArgs = 0;
				savedFramePointer = 0;
				savedStackPointer = 0;
				/* begin sendBreakpoint:receiver: */
				sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
				
				/* begin internalFindNewMethodDynamicSuper */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				assert(!((isOopForwarded(GIV(localAbsentReceiver)))));
				GIV(lkupClassTag) = (((tagBits = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? ((tagBits & 1) != 0
							? 1
							: tagBits)
					: (longAt(GIV(localAbsentReceiver))) & (classIndexMask()));
				hash1 = (GIV(messageSelector) ^ GIV(lkupClassTag)) ^ (GIV(method) ^ LookupRuleDynamicSuper);

				/* first probe */

				probe1 = hash1 & NSMethodCacheMask;
				if (((((GIV(nsMethodCache)[probe1 + NSMethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheClassTag]) == GIV(lkupClassTag)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheCallingMethod]) == GIV(method)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheDepthOrLookupRule]) == LookupRuleDynamicSuper)) {
					GIV(newMethod) = GIV(nsMethodCache)[probe1 + NSMethodCacheTargetMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(nsMethodCache)[probe1 + NSMethodCachePrimFunction]));
					GIV(localAbsentReceiverOrZero) = GIV(nsMethodCache)[probe1 + NSMethodCacheActualReceiver];
					goto l256;
				}

				/* second probe */

				probe1 = (((usqInt) hash1) >> 1) & NSMethodCacheMask;
				if (((((GIV(nsMethodCache)[probe1 + NSMethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheClassTag]) == GIV(lkupClassTag)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheCallingMethod]) == GIV(method)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheDepthOrLookupRule]) == LookupRuleDynamicSuper)) {
					GIV(newMethod) = GIV(nsMethodCache)[probe1 + NSMethodCacheTargetMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(nsMethodCache)[probe1 + NSMethodCachePrimFunction]));
					GIV(localAbsentReceiverOrZero) = GIV(nsMethodCache)[probe1 + NSMethodCacheActualReceiver];
					goto l256;
				}
				probe1 = (((usqInt) hash1) >> 2) & NSMethodCacheMask;
				if (((((GIV(nsMethodCache)[probe1 + NSMethodCacheSelector]) == GIV(messageSelector))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheClassTag]) == GIV(lkupClassTag)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheCallingMethod]) == GIV(method)))
				 && ((GIV(nsMethodCache)[probe1 + NSMethodCacheDepthOrLookupRule]) == LookupRuleDynamicSuper)) {
					GIV(newMethod) = GIV(nsMethodCache)[probe1 + NSMethodCacheTargetMethod];
					primitiveFunctionPointer = ((void (*)()) (GIV(nsMethodCache)[probe1 + NSMethodCachePrimFunction]));
					GIV(localAbsentReceiverOrZero) = GIV(nsMethodCache)[probe1 + NSMethodCacheActualReceiver];
					goto l256;
				}
				/* end inlineLookupInNSMethodCacheSel:classTag:method:lookupRule:; fall through */
				/* begin externalizeIPandSP */
				GIV(instructionPointer) = oopForPointer(localIP);
				GIV(stackPointer) = localSP;
				GIV(framePointer) = localFP;
				if ((((GIV(messageSelector) & (tagMask())) == 0)
				 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
				 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
					if (((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
						GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
					}
					if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
						GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
					}
				}
				/* begin classAtIndex: */
				assert((GIV(lkupClassTag) <= (tagMask()))
				 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
				/* begin fetchPointer:ofObject: */
				fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
				classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (fieldIndex << (shiftForWord())));
				if (classTablePage == GIV(nilObj)) {
					GIV(lkupClass) = null;
					goto l253;
				}
				/* begin fetchPointer:ofObject: */
				fieldIndex1 = GIV(lkupClassTag) & ((1 << (classTableMajorIndexShift())) - 1);
				GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (fieldIndex1 << (shiftForWord())));
			l253:	/* end classAtIndex: */;
				/* begin lookupDynamicSuperSend */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				GIV(localAbsentReceiverOrZero) = 0;
				methodMixin = methodClassOf(GIV(method));
				methodMixinApplication = findApplicationOfTargetMixinstartingAtBehavior(methodMixin, (((tagBits1 = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (tagBits1 << (shiftForWord())))
					: fetchClassOfNonImm(GIV(localAbsentReceiver))));
				/* begin followField:ofObject: */
				objOop = longAt((methodMixinApplication + BaseHeaderSize) + (SuperclassIndex << (shiftForWord())));
				if (((objOop & (tagMask())) == 0)
				 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
					objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, methodMixinApplication, objOop);
				}
				GIV(lkupClass) = objOop;
				actualLookupRule = lookupProtectedstartingAtrule(GIV(messageSelector), GIV(lkupClass), LookupRuleDynamicSuper);
				/* begin internalizeIPandSP */
				localIP = pointerForOop(GIV(instructionPointer));
				localSP = pointerForOop(GIV(stackPointer));
				localFP = pointerForOop(GIV(framePointer));
				addNewMethodToNSCache(actualLookupRule);
			l256:	;

				/* begin shuffleArgumentsAndStoreAbsentReceiver: */

				/* a.k.a. self internalPush: anything */

				localSP -= BytesPerOop;
				for (i = 1; i <= GIV(argumentCount); i += 1) {
					oop = longAtPointer(localSP + (i * BytesPerOop));
					longAtPointerput(localSP + ((i - 1) * BytesPerOop), oop);
				}
				longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), GIV(localAbsentReceiver));
				/* begin internalExecuteNewMethod */
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 0xFF)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + ((localPrimIndex - 264) << (shiftForWord()))));
							goto l257;
						}
						if (localPrimIndex == 256) {
							goto l257;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l257;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l257;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l257;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 1) | 1));
					l257:	/* end internalQuickPrimitiveResponse */;
						goto l255;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
					assert((remapBufferCount()) == 0);
					
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					/* begin maybeRetryFailureDueToForwarding */
					if (GIV(primFailCode)
					 && (checkForAndFollowForwardedPrimitiveState())) {
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
					}
					/* begin maybeFailForLastObjectOverwrite */
					if (checkAllocFiller) {
						if (((freeStart()) < GIV(scavengeThreshold))
						 && ((longAt(freeStart())) != (freeStart()))) {
							GIV(primFailCode) = PrimErrWritePastObject;
						}
					}
					
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						browserPluginReturnIfNeeded();
						goto l255;
					}
				}
				/* begin internalActivateNewMethod */
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(newMethod)));
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
				numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
				assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

				/* could new rcvr be set at point of send? */

				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				assert(!(isOopForwarded(rcvr)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localIP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localFP);
				localFP = localSP;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
				/* begin setMethod:methodHeader: */
				GIV(method) = GIV(newMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert((methodHeaderOf(GIV(method))) == methodHeader);
				GIV(bytecodeSetSelector) = ((((sqInt) methodHeader)) < 0
					? 256
					: 0);

				/* begin internalPush: */
				object = (VMBIGENDIAN
					? ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
					: ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << 8)) + (0)) + (0));
				longAtPointerput((localSP -= BytesPerOop), object);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), rcvr);
				for (i1 = (GIV(argumentCount) + 1); i1 <= numTemps; i1 += 1) {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				}
				localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
				if (methodHeader & AlternateHeaderHasPrimFlag) {

					/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
					   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

					localIP += 3;
					if (GIV(primFailCode) != 0) {
						if ((byteAt(localIP + 1)) == (((((sqInt) methodHeader)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode))) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << (shiftForWord())));
								if (GIV(primFailCode) <= (numSlotsOf(table))) {
									errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << (shiftForWord())));
									goto l254;
								}
							}
							errorCode = ((GIV(primFailCode) << 1) | 1);
						l254:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
				}
				assert((frameNumArgs(localFP)) == GIV(argumentCount));
				assert(!(frameIsBlockActivation(localFP)));
				assert(!(frameHasContext(localFP)));
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
			l255:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 498: /*242*/
			/* extUnconditionalJump */
			{
				sqInt byte;
				sqInt offset;

				VM_LABEL(extUnconditionalJump);
				byte = byteAtPointer(++localIP);
				offset = byte + (extB << 8);
				extB = 0;
				localIP += offset;
				/* begin ifBackwardsCheckForEvents: */
				if ((offset < 0)
				 && (localSP < GIV(stackLimit))) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					checkForEventsMayContextSwitch(1);
					browserPluginReturnIfNeeded();
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 499: /*243*/
			/* extJumpIfTrue */
			{
				sqInt boolean;
				sqInt byte;
				sqInt offset;

				VM_LABEL(extJumpIfTrue);
				byte = byteAtPointer(++localIP);
				offset = byte + (extB << 8);
				extB = 0;
				/* begin jumplfTrueBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(trueObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(falseObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l212;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l212:	/* end jumplfTrueBy: */;
			}
			break;
		case 500: /*244*/
			/* extJumpIfFalse */
			{
				sqInt boolean;
				sqInt byte;
				sqInt offset;

				VM_LABEL(extJumpIfFalse);
				byte = byteAtPointer(++localIP);
				offset = byte + (extB << 8);
				extB = 0;
				/* begin jumplfFalseBy: */
				boolean = longAtPointer(localSP);
				if (boolean == GIV(falseObj)) {
					/* begin jump: */
					localIP = (localIP + offset) + 1;
					currentBytecode = (byteAtPointer(localIP)) + GIV(bytecodeSetSelector);

				}
				else {
					if (!(boolean == GIV(trueObj))) {
						/* begin internalMustBeBoolean */
						GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorMustBeBoolean << (shiftForWord())));
						GIV(argumentCount) = 0;
						goto normalSend;
						goto l213;
					}
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				}
				/* begin internalPop: */
				localSP += 1 * BytesPerOop;
			l213:	/* end jumplfFalseBy: */;
			}
			break;
		case 501: /*245*/
			/* extSendAbsentSelfBytecode */
			{
				sqInt actualLookupRule;
				sqInt byte;
				sqInt classTablePage;
				sqInt count;
				sqInt errorCode;
				sqInt fieldIndex;
				sqInt fieldIndex1;
				sqInt i;
				sqInt i1;
				sqInt localPrimIndex;
				sqInt methodHeader;
				sqInt mixinApplication;
				sqInt nArgs;
				sqInt numTemps;
				usqInt object;
				sqInt objOop;
				sqInt oop;
				sqInt rcvr;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt succeeded;
				sqInt table;
				sqInt tagBits;
				sqInt tagBits1;
				sqInt targetMixin;

				VM_LABEL(extSendAbsentSelfBytecode);
				nArgs = 0;
				savedFramePointer = 0;
				savedStackPointer = 0;
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((((usqInt) byte) >> 3) + (extA << 5)) + LiteralStart) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (extB << 3);
				extB = 0;
				/* begin commonSendOuter: */
				/* begin sendBreakpoint:receiver: */
				sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
				
				/* begin internalFindNewMethodOuter: */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				assert(!((isOopForwarded(GIV(localAbsentReceiver)))));
				GIV(lkupClassTag) = (((tagBits = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? ((tagBits & 1) != 0
							? 1
							: tagBits)
					: (longAt(GIV(localAbsentReceiver))) & (classIndexMask()));
				if (inlineLookupInNSMethodCacheSelclassTagmethodlookupRule(GIV(messageSelector), GIV(lkupClassTag), GIV(method), 0)) {
					if (!(GIV(localAbsentReceiverOrZero) == 0)) {
						GIV(localAbsentReceiver) = GIV(localAbsentReceiverOrZero);
					}
				}
				else {

					/* entry was not found in the cache; look it up the hard way */

					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
					 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
						if (((GIV(messageSelector) & (tagMask())) == 0)
						 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
						}
						if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
							GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
						}
					}
					/* begin classAtIndex: */
					assert((GIV(lkupClassTag) <= (tagMask()))
					 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
					/* begin fetchPointer:ofObject: */
					fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
					classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (fieldIndex << (shiftForWord())));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l216;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex1 = GIV(lkupClassTag) & ((1 << (classTableMajorIndexShift())) - 1);
					GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (fieldIndex1 << (shiftForWord())));
				l216:	/* end classAtIndex: */;
					/* begin lookupOuterSend: */
					GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
					GIV(localAbsentReceiverOrZero) = 0;
					targetMixin = methodClassOf(GIV(method));
					count = 0;
					while (count < 0) {
						count += 1;
						mixinApplication = findApplicationOfTargetMixinstartingAtBehavior(targetMixin, (((tagBits1 = GIV(localAbsentReceiver) & (tagMask()))) != 0
							? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (tagBits1 << (shiftForWord())))
							: fetchClassOfNonImm(GIV(localAbsentReceiver))));
						GIV(localAbsentReceiverOrZero) = (GIV(localAbsentReceiver) = followObjFieldofObject(EnclosingObjectIndex, mixinApplication));
						/* begin followObjField:ofObject: */
						objOop = longAt((targetMixin + BaseHeaderSize) + (EnclosingMixinIndex << (shiftForWord())));
						assert(isNonImmediate(objOop));
						if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
							objOop = fixFollowedFieldofObjectwithInitialValue(EnclosingMixinIndex, targetMixin, objOop);
						}
						targetMixin = objOop;
					}
					actualLookupRule = lookupLexicalfromrule(GIV(messageSelector), targetMixin, 0);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToNSCache(actualLookupRule);
				}
				/* begin shuffleArgumentsAndStoreAbsentReceiver: */

				/* a.k.a. self internalPush: anything */

				localSP -= BytesPerOop;
				for (i = 1; i <= GIV(argumentCount); i += 1) {
					oop = longAtPointer(localSP + (i * BytesPerOop));
					longAtPointerput(localSP + ((i - 1) * BytesPerOop), oop);
				}
				longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), GIV(localAbsentReceiver));
				/* begin internalExecuteNewMethod */
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 0xFF)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + ((localPrimIndex - 264) << (shiftForWord()))));
							goto l217;
						}
						if (localPrimIndex == 256) {
							goto l217;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l217;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l217;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l217;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 1) | 1));
					l217:	/* end internalQuickPrimitiveResponse */;
						goto l215;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
					assert((remapBufferCount()) == 0);
					
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					/* begin maybeRetryFailureDueToForwarding */
					if (GIV(primFailCode)
					 && (checkForAndFollowForwardedPrimitiveState())) {
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
					}
					/* begin maybeFailForLastObjectOverwrite */
					if (checkAllocFiller) {
						if (((freeStart()) < GIV(scavengeThreshold))
						 && ((longAt(freeStart())) != (freeStart()))) {
							GIV(primFailCode) = PrimErrWritePastObject;
						}
					}
					
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						browserPluginReturnIfNeeded();
						goto l215;
					}
				}
				/* begin internalActivateNewMethod */
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(newMethod)));
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
				numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
				assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

				/* could new rcvr be set at point of send? */

				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				assert(!(isOopForwarded(rcvr)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localIP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localFP);
				localFP = localSP;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
				/* begin setMethod:methodHeader: */
				GIV(method) = GIV(newMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert((methodHeaderOf(GIV(method))) == methodHeader);
				GIV(bytecodeSetSelector) = ((((sqInt) methodHeader)) < 0
					? 256
					: 0);

				/* begin internalPush: */
				object = (VMBIGENDIAN
					? ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
					: ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << 8)) + (0)) + (0));
				longAtPointerput((localSP -= BytesPerOop), object);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), rcvr);
				for (i1 = (GIV(argumentCount) + 1); i1 <= numTemps; i1 += 1) {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				}
				localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
				if (methodHeader & AlternateHeaderHasPrimFlag) {

					/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
					   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

					localIP += 3;
					if (GIV(primFailCode) != 0) {
						if ((byteAt(localIP + 1)) == (((((sqInt) methodHeader)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode))) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << (shiftForWord())));
								if (GIV(primFailCode) <= (numSlotsOf(table))) {
									errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << (shiftForWord())));
									goto l214;
								}
							}
							errorCode = ((GIV(primFailCode) << 1) | 1);
						l214:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
				}
				assert((frameNumArgs(localFP)) == GIV(argumentCount));
				assert(!(frameIsBlockActivation(localFP)));
				assert(!(frameHasContext(localFP)));
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
			l215:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		case 505: /*249*/
			/* callPrimitiveBytecode */
			{
				sqInt header;

				VM_LABEL(callPrimitiveBytecode1);
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(method)));
				header = longAt((GIV(method) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
				if ((header & AlternateHeaderHasPrimFlag)
				 && ((((sqInt)localIP)) == ((GIV(method) + ((LiteralStart + (literalCountOfMethodHeader(header))) * BytesPerOop)) + BaseHeaderSize))) {
					localIP = (localIP + (3)) - 1;
					/* begin fetchNextBytecode */
					currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);
					goto l218;
				}
				else {
					goto respondToUnknownBytecode;
					goto l218;
				}

			}
		l218:	/* end case */;
			break;
		case 509: /*253*/
			/* extPushClosureBytecode */
			{
				sqInt blockSize;
				sqInt byte;
				sqInt classObj;
				sqInt context;
				sqInt i;
				sqInt initialIP;
				sqInt knownClassIndex;
				sqInt newClosure;
				sqInt newClosure1;
				usqInt newObj;
				usqInt newObj1;
				sqInt numArgs;
				usqInt numBytes;
				usqInt numBytes1;
				sqInt numCopied;
				sqInt numSlots;
				sqInt numSlots1;
				sqInt objFormat;
				sqInt objFormat1;

				VM_LABEL(extPushClosureBytecode);
				byte = byteAtPointer(++localIP);
				numArgs = (byte & 7) + ((extA % 16) * 8);
				numCopied = ((((usqInt) byte) >> 3) & 7) + ((extA / 16) * 8);
				extA = 0;
				blockSize = (byteAtPointer(++localIP)) + (extB << 8);
				extB = 0;
				/* begin pushClosureNumArgs:copiedValues:blockSize: */
				/* begin ensureFrameIsMarried:SP: */
				if ((byteAt((localFP + FoxFrameFlags) + 2)) != 0) {
					assert(isContext(frameContext(localFP)));
					context = longAt(localFP + FoxThisContext);
					goto l220;
				}
				context = marryFrameSP(localFP, localSP + (numCopied * BytesPerOop));
			l220:	/* end ensureFrameIsMarried:SP: */;
				/* begin closureIn:numArgs:instructionPointer:numCopiedValues: */
				initialIP = ((oopForPointer(localIP)) + 2) - (GIV(method) + BaseHeaderSize);
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				objFormat = indexablePointersFormat();
				numSlots = ClosureFirstCopiedValueIndex + numCopied;
				assert((numSlots >= 0)
				 && (ClassBlockClosureCompactIndex != 0));
				assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassBlockClosureCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(numSlots < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * BytesPerOop));
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newClosure1 = 0;
						goto l221;
					}
				}
				long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassBlockClosureCompactIndex);
				GIV(freeStart) += numBytes;
				newClosure1 = newObj;
			l221:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;

				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureOuterContextIndex << (shiftForWord())), context);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureStartPCIndex << (shiftForWord())), ((initialIP << 1) | 1));
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(newClosure1)));
				longAtput((newClosure1 + BaseHeaderSize) + (ClosureNumArgsIndex << (shiftForWord())), ((numArgs << 1) | 1));
				newClosure = newClosure1;
				if (numCopied > 0) {
					for (i = 0; i < numCopied; i += 1) {

						/* Assume: have just allocated a new BlockClosure; it must be young.
						   Thus, can use unchecked stores. */

						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(newClosure)));
						longAtput((newClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << (shiftForWord())), longAtPointer(localSP + (((numCopied - i) - 1) * BytesPerOop)));
					}
					/* begin internalPop: */
					localSP += numCopied * BytesPerOop;
				}
				localIP += blockSize;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), newClosure);
			}
			break;
		case 510: /*254*/
			/* extSendAbsentOuterBytecode */
			{
				sqInt actualLookupRule;
				sqInt byte;
				sqInt classTablePage;
				sqInt count;
				sqInt depth;
				sqInt errorCode;
				sqInt fieldIndex;
				sqInt fieldIndex1;
				sqInt i;
				sqInt i1;
				sqInt localPrimIndex;
				sqInt methodHeader;
				sqInt mixinApplication;
				sqInt nArgs;
				sqInt numTemps;
				usqInt object;
				sqInt objOop;
				sqInt oop;
				sqInt rcvr;
				char *savedFramePointer;
				char *savedStackPointer;
				sqInt succeeded;
				sqInt table;
				sqInt tagBits;
				sqInt tagBits1;
				sqInt targetMixin;

				VM_LABEL(extSendAbsentOuterBytecode);
				nArgs = 0;
				savedFramePointer = 0;
				savedStackPointer = 0;
				byte = byteAtPointer(++localIP);
				/* begin literal: */
				assert(GIV(method) == (iframeMethod(localFP)));
				GIV(messageSelector) = longAt((GIV(method) + BaseHeaderSize) + ((((((usqInt) byte) >> 3) + (extA << 5)) + LiteralStart) << (shiftForWord())));
				extA = 0;
				GIV(argumentCount) = (byte & 7) + (extB << 3);
				extB = 0;
				depth = byteAtPointer(++localIP);
				/* begin commonSendOuter: */
				/* begin sendBreakpoint:receiver: */
				sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop)));
				
				/* begin internalFindNewMethodOuter: */
				GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
				assert(!((isOopForwarded(GIV(localAbsentReceiver)))));
				GIV(lkupClassTag) = (((tagBits = GIV(localAbsentReceiver) & (tagMask()))) != 0
					? ((tagBits & 1) != 0
							? 1
							: tagBits)
					: (longAt(GIV(localAbsentReceiver))) & (classIndexMask()));
				if (inlineLookupInNSMethodCacheSelclassTagmethodlookupRule(GIV(messageSelector), GIV(lkupClassTag), GIV(method), depth)) {
					if (!(GIV(localAbsentReceiverOrZero) == 0)) {
						GIV(localAbsentReceiver) = GIV(localAbsentReceiverOrZero);
					}
				}
				else {

					/* entry was not found in the cache; look it up the hard way */

					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					if ((((GIV(messageSelector) & (tagMask())) == 0)
					 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
					 || (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun()))) {
						if (((GIV(messageSelector) & (tagMask())) == 0)
						 && (((longAt(GIV(messageSelector))) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
							GIV(messageSelector) = handleForwardedSelectorFaultFor(GIV(messageSelector));
						}
						if (GIV(lkupClassTag) == (isForwardedObjectClassIndexPun())) {
							GIV(lkupClassTag) = handleForwardedSendFaultForTag(GIV(lkupClassTag));
						}
					}
					/* begin classAtIndex: */
					assert((GIV(lkupClassTag) <= (tagMask()))
					 || (GIV(lkupClassTag) >= (arrayClassIndexPun())));
					/* begin fetchPointer:ofObject: */
					fieldIndex = ((usqInt) GIV(lkupClassTag)) >> (classTableMajorIndexShift());
					classTablePage = longAt((GIV(hiddenRootsObj) + BaseHeaderSize) + (fieldIndex << (shiftForWord())));
					if (classTablePage == GIV(nilObj)) {
						GIV(lkupClass) = null;
						goto l224;
					}
					/* begin fetchPointer:ofObject: */
					fieldIndex1 = GIV(lkupClassTag) & ((1 << (classTableMajorIndexShift())) - 1);
					GIV(lkupClass) = longAt((classTablePage + BaseHeaderSize) + (fieldIndex1 << (shiftForWord())));
				l224:	/* end classAtIndex: */;
					/* begin lookupOuterSend: */
					GIV(localAbsentReceiver) = longAt(localFP + FoxReceiver);
					GIV(localAbsentReceiverOrZero) = 0;
					targetMixin = methodClassOf(GIV(method));
					count = 0;
					while (count < depth) {
						count += 1;
						mixinApplication = findApplicationOfTargetMixinstartingAtBehavior(targetMixin, (((tagBits1 = GIV(localAbsentReceiver) & (tagMask()))) != 0
							? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (tagBits1 << (shiftForWord())))
							: fetchClassOfNonImm(GIV(localAbsentReceiver))));
						GIV(localAbsentReceiverOrZero) = (GIV(localAbsentReceiver) = followObjFieldofObject(EnclosingObjectIndex, mixinApplication));
						/* begin followObjField:ofObject: */
						objOop = longAt((targetMixin + BaseHeaderSize) + (EnclosingMixinIndex << (shiftForWord())));
						assert(isNonImmediate(objOop));
						if (((longAt(objOop)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0) {
							objOop = fixFollowedFieldofObjectwithInitialValue(EnclosingMixinIndex, targetMixin, objOop);
						}
						targetMixin = objOop;
					}
					actualLookupRule = lookupLexicalfromrule(GIV(messageSelector), targetMixin, depth);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					addNewMethodToNSCache(actualLookupRule);
				}
				/* begin shuffleArgumentsAndStoreAbsentReceiver: */

				/* a.k.a. self internalPush: anything */

				localSP -= BytesPerOop;
				for (i = 1; i <= GIV(argumentCount); i += 1) {
					oop = longAtPointer(localSP + (i * BytesPerOop));
					longAtPointerput(localSP + ((i - 1) * BytesPerOop), oop);
				}
				longAtPointerput(localSP + (GIV(argumentCount) * BytesPerOop), GIV(localAbsentReceiver));
				/* begin internalExecuteNewMethod */
				if (primitiveFunctionPointer != 0) {
					if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
						/* begin internalQuickPrimitiveResponse */
						assert(isPrimitiveFunctionPointerAnIndex());
						localPrimIndex = ((sqInt) primitiveFunctionPointer);
						assert((localPrimIndex > 0xFF)
						 && (localPrimIndex < 520));
						if (localPrimIndex >= 264) {
							/* begin internalStackTopPut: */
							longAtPointerput(localSP, longAt(((longAtPointer(localSP)) + BaseHeaderSize) + ((localPrimIndex - 264) << (shiftForWord()))));
							goto l225;
						}
						if (localPrimIndex == 256) {
							goto l225;
						}
						if (localPrimIndex == 257) {
							longAtPointerput(localSP, GIV(trueObj));
							goto l225;
						}
						if (localPrimIndex == 258) {
							longAtPointerput(localSP, GIV(falseObj));
							goto l225;
						}
						if (localPrimIndex == 259) {
							longAtPointerput(localSP, GIV(nilObj));
							goto l225;
						}
						longAtPointerput(localSP, (((localPrimIndex - 261) << 1) | 1));
					l225:	/* end internalQuickPrimitiveResponse */;
						goto l223;
					}
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					/* begin slowPrimitiveResponse */
					assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
					assert((remapBufferCount()) == 0);
					
					/* begin initPrimCall */
					GIV(primFailCode) = 0;
					dispatchFunctionPointer(primitiveFunctionPointer);
					/* begin maybeRetryFailureDueToForwarding */
					if (GIV(primFailCode)
					 && (checkForAndFollowForwardedPrimitiveState())) {
						/* begin initPrimCall */
						GIV(primFailCode) = 0;
						dispatchFunctionPointer(primitiveFunctionPointer);
					}
					/* begin maybeFailForLastObjectOverwrite */
					if (checkAllocFiller) {
						if (((freeStart()) < GIV(scavengeThreshold))
						 && ((longAt(freeStart())) != (freeStart()))) {
							GIV(primFailCode) = PrimErrWritePastObject;
						}
					}
					
					if (GIV(nextProfileTick) > 0) {
						checkProfileTick(GIV(newMethod));
					}
					succeeded = !GIV(primFailCode);
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
					if (succeeded) {
						browserPluginReturnIfNeeded();
						goto l223;
					}
				}
				/* begin internalActivateNewMethod */
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(GIV(newMethod)));
				methodHeader = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
				numTemps = (((usqInt) methodHeader) >> MethodHeaderTempCountShift) & 0x3F;
				assert(GIV(argumentCount) == (argumentCountOfMethodHeader(methodHeader)));

				/* could new rcvr be set at point of send? */

				rcvr = longAtPointer(localSP + (GIV(argumentCount) * BytesPerOop));
				assert(!(isOopForwarded(rcvr)));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localIP);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), localFP);
				localFP = localSP;
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(newMethod));
				/* begin setMethod:methodHeader: */
				GIV(method) = GIV(newMethod);
				assert(isOopCompiledMethod(GIV(method)));
				assert((methodHeaderOf(GIV(method))) == methodHeader);
				GIV(bytecodeSetSelector) = ((((sqInt) methodHeader)) < 0
					? 256
					: 0);

				/* begin internalPush: */
				object = (VMBIGENDIAN
					? ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << ((BytesPerWord * 8) - 8))) + (0)) + (0)
					: ((1 + (((((usqInt) methodHeader) >> MethodHeaderArgCountShift) & 15) << 8)) + (0)) + (0));
				longAtPointerput((localSP -= BytesPerOop), object);
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				/* begin internalPush: */
				longAtPointerput((localSP -= BytesPerOop), rcvr);
				for (i1 = (GIV(argumentCount) + 1); i1 <= numTemps; i1 += 1) {
					/* begin internalPush: */
					longAtPointerput((localSP -= BytesPerOop), GIV(nilObj));
				}
				localIP = pointerForOop(((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader))) * BytesPerOop)) + BaseHeaderSize) - 1);
				if (methodHeader & AlternateHeaderHasPrimFlag) {

					/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
					   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

					localIP += 3;
					if (GIV(primFailCode) != 0) {
						if ((byteAt(localIP + 1)) == (((((sqInt) methodHeader)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode))) {
							/* begin getErrorObjectFromPrimFailCode */
							if (GIV(primFailCode) > 0) {
								table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << (shiftForWord())));
								if (GIV(primFailCode) <= (numSlotsOf(table))) {
									errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << (shiftForWord())));
									goto l222;
								}
							}
							errorCode = ((GIV(primFailCode) << 1) | 1);
						l222:	/* end getErrorObjectFromPrimFailCode */;
							longAtPointerput(localSP, errorCode);
						}
						GIV(primFailCode) = 0;
					}
				}
				assert((frameNumArgs(localFP)) == GIV(argumentCount));
				assert(!(frameIsBlockActivation(localFP)));
				assert(!(frameHasContext(localFP)));
				if (localSP < GIV(stackLimit)) {
					/* begin externalizeIPandSP */
					GIV(instructionPointer) = oopForPointer(localIP);
					GIV(stackPointer) = localSP;
					GIV(framePointer) = localFP;
					handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
					/* begin internalizeIPandSP */
					localIP = pointerForOop(GIV(instructionPointer));
					localSP = pointerForOop(GIV(stackPointer));
					localFP = pointerForOop(GIV(framePointer));
				}
			l223:	/* end internalExecuteNewMethod */;
				/* begin fetchNextBytecode */
				currentBytecode = (byteAtPointer(++localIP)) + GIV(bytecodeSetSelector);

			}
			break;
		}
	}

	/* undo the pre-increment of IP before returning */

	localIP -= 1;
	/* begin externalizeIPandSP */
	GIV(instructionPointer) = oopForPointer(localIP);
	GIV(stackPointer) = localSP;
	GIV(framePointer) = localFP;
	return null;
}


/*	For assert-checking */

	/* CogStackPage>>#addressIsInPage: */
static sqInt NoDbgRegParms
addressIsInPage(StackPage * self_in_addressIsInPage, char *address)
{
	return (((self_in_addressIsInPage->lastAddress)) < address)
	 && (address < ((self_in_addressIsInPage->baseAddress)));
}

	/* CogStackPage>>#isFree */
static sqInt NoDbgRegParms
isFree(StackPage * self_in_isFree)
{
	return ((self_in_isFree->baseFP)) == 0;
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPageNoAssert: */
static void NoDbgRegParms
freeStackPageNoAssert(StackPage *aPage)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *prev;

	(aPage->baseFP = 0);
	if (aPage == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = (GIV(mostRecentlyUsedPage)->prevPage);
		return;
	}
	if ((((prev = (aPage->prevPage))->baseFP)) == 0) {
		return;
	}
	(prev->nextPage = (aPage->nextPage));
	(((aPage->nextPage))->prevPage = prev);
	(aPage->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = aPage);
	(aPage->prevPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->nextPage = aPage);
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#freeStackPage: */
static sqInt NoDbgRegParms
freeStackPage(StackPage *aPage)
{
	freeStackPageNoAssert(aPage);
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (page == GIV(mostRecentlyUsedPage)) {
		return;
	}
	if (((page->prevPage)) == GIV(mostRecentlyUsedPage)) {
		GIV(mostRecentlyUsedPage) = page;
		assert(pageListIsWellFormed());
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->nextPage))->prevPage = page);
	(page->prevPage = GIV(mostRecentlyUsedPage));
	(page->nextPage = (GIV(mostRecentlyUsedPage)->nextPage));
	(GIV(mostRecentlyUsedPage)->nextPage = page);
	GIV(mostRecentlyUsedPage) = page;
	assert(pageListIsWellFormed());
}


/*	<InterpreterStackPage> */
/*	This method is used to move a page to a position in the list such that it
	cannot be deallocated when a new page is allocated, without changing the
	most recently
	used page. There must be at least 3 pages in the system. So making the
	page the MRU's prevPage is sufficient to ensure it won't be deallocated. */
/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#markStackPageNextMostRecentlyUsed: */
static void NoDbgRegParms
markStackPageNextMostRecentlyUsed(StackPage *page)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	assert(page != GIV(mostRecentlyUsedPage));
	if (((page->nextPage)) == GIV(mostRecentlyUsedPage)) {
		return;
	}
	(((page->prevPage))->nextPage = (page->nextPage));
	(((page->nextPage))->prevPage = (page->prevPage));
	(((GIV(mostRecentlyUsedPage)->prevPage))->nextPage = page);
	(page->prevPage = (GIV(mostRecentlyUsedPage)->prevPage));
	(page->nextPage = GIV(mostRecentlyUsedPage));
	(GIV(mostRecentlyUsedPage)->prevPage = page);
	assert(pageListIsWellFormed());
}


/*	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#newStackPage */
static StackPage *
newStackPage(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    StackPage *lruOrFree;

	lruOrFree = (GIV(mostRecentlyUsedPage)->nextPage);
	if (((lruOrFree->baseFP)) == 0) {
		return lruOrFree;
	}
	divorceFramesIn(lruOrFree);
	return lruOrFree;
}


/*	Answer if the stack page list is well-formed.
	MRUP-->used page<->used page<->used page<->used page<--LRUP
	^ <-next-prev-> ^
	| |
	v <-prev-next-> v
	free page<->free page<->free page<->free page */

	/* CogStackPages>>#pageListIsWellFormed */
static sqInt
pageListIsWellFormed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt count;
    sqInt limit;
    sqInt ok;
    StackPage *page;

	ok = 1;
	page = (GIV(mostRecentlyUsedPage)->nextPage);
	count = 1;
	limit = GIV(numStackPages) * 2;
	while ((((page->baseFP)) == 0)
	 && ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit))) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	while ((page != GIV(mostRecentlyUsedPage))
	 && (count <= limit)) {
		if (!(asserta(((((page->nextPage))->prevPage)) == page))) {
			ok = 0;
		}
		if (asserta(!(isFree(page)))) {
			if (!(asserta((addressIsInPage(page, (page->baseFP)))
				 && (addressIsInPage(page, (page->headSP)))))) {
				ok = 0;
			}
		}
		else {
			ok = 0;
		}
		page = (page->nextPage);
		count += 1;
	}
	if (!(asserta(count == (numStkPages())))) {
		ok = 0;
	}
	return ok;
}


/*	Answer the page for a page index.
	N.B. This is a zero-relative index. */

	/* CogStackPages>>#stackPageAt: */
static StackPage * NoDbgRegParms
stackPageAt(sqInt index)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return stackPageAtpages(index, GIV(pages));
}


/*	<Integer> */

	/* CogStackPages>>#stackPageFor: */
static StackPage * NoDbgRegParms
stackPageFor(void *pointer)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;

	/* begin stackPageAt: */
	index = pageIndexForstackMemorybytesPerPage(pointer, GIV(stackMemory), GIV(bytesPerPage));
	return stackPageAtpages(index, GIV(pages));
}

	/* CogStackPages>>#statAverageLivePagesWhenMapping */
static double
statAverageLivePagesWhenMapping(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (((double) GIV(statPageCountWhenMappingSum) )) / GIV(statNumMaps);
}


/*	Answer either a malloced string with the null-terminated contents of oop
	if oop is a string,
	or the null pointer if oop is nil, or fail. It is the client's
	responsibility to free the string later. */

	/* InterpreterPrimitives>>#cStringOrNullFor: */
char *
cStringOrNullFor(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    char *cString;
    sqInt fmt;
    sqInt isString;
    sqInt len;
    usqInt numSlots;
    usqInt numSlots1;

	/* begin is:instanceOf:compactClassIndex: */
	if ((oop & (tagMask())) != 0) {
		isString = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	isString = ClassByteStringCompactIndex == ccIndex;
	goto l2;

l2:	/* end is:instanceOf:compactClassIndex: */;
	if (!isString) {
		if (oop != GIV(nilObj)) {
			GIV(primFailCode) = PrimErrBadArgument;
		}
		return 0;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(oop + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? longAt(oop - BaseHeaderSize)
		: numSlots1);
	if (fmt <= 5) {
		len = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */

		len = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		len = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		len = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		len = ((usqInt) numSlots) >> 1;
		goto l1;
	}
	len = 0;
l1:	/* end lengthOf:format: */;
	if (len == 0) {
		return 0;
	}
	cString = malloc(len + 1);
	if (!(cString)) {
		GIV(primFailCode) = PrimErrNoCMemory;
		return 0;
	}
	memcpy(cString, firstIndexableField(oop), len);
	cString[len] = 0;
	return cString;
}


/*	In C, non-zero is true, so avoid computation by simply answering
	primFailCode in the C version.
 */

	/* InterpreterPrimitives>>#failed */
sqInt
failed(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}


/*	Answer true if integer object is negative.
	Fail if object pointed by oop i not an integer. */

	/* InterpreterPrimitives>>#isNegativeIntegerValueOf: */
static sqInt NoDbgRegParms
isNegativeIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt ok;
    sqInt smallInt;

	if ((oop & 1)) {
		smallInt = (oop >> 1);
		return smallInt < 0;
	}
	if ((oop & (tagMask())) == 0) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & (classIndexMask());
		ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
		goto l1;

	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (ok) {
			return 0;
		}
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex1 = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex1;
		goto l2;

	l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (ok) {
			return 1;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return 0;
}


/*	Return a Large Integer object for the given integer magnitude and sign */

	/* InterpreterPrimitives>>#magnitude64BitIntegerFor:neg: */
static sqInt NoDbgRegParms
magnitude64BitIntegerForneg(usqLong magnitude, sqInt isNegative)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt highWord;
    sqInt isSmall;
    sqInt largeClass;
    sqInt newLargeInteger;
    sqInt smallVal;
    sqInt sz;

	isSmall = (isNegative
		? magnitude <= ((MaxSmallInteger) + 1)
		: magnitude <= (MaxSmallInteger));
	if (isSmall) {
		smallVal = ((sqInt) magnitude);
		if (isNegative) {
			smallVal = 0 - smallVal;
		}
		return ((smallVal << 1) | 1);
	}
	if (isNegative) {
		/* begin knownClassAtIndex: */
		assert(((ClassLargeNegativeIntegerCompactIndex >= 1) && (ClassLargeNegativeIntegerCompactIndex <= (classTablePageSize()))));
		largeClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (ClassLargeNegativeIntegerCompactIndex << (shiftForWord())));
	}
	else {
		/* begin knownClassAtIndex: */
		assert(((ClassLargePositiveIntegerCompactIndex >= 1) && (ClassLargePositiveIntegerCompactIndex <= (classTablePageSize()))));
		largeClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (ClassLargePositiveIntegerCompactIndex << (shiftForWord())));
	}
	if (((highWord = magnitude >> 32)) == 0) {
		sz = 4;
	}
	else {
		sz = 5;
		if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
			sz += 1;
			if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
				sz += 1;
				if (!(((highWord = ((usqInt) highWord) >> 8)) == 0)) {
					sz += 1;
				}
			}
		}
	}

	newLargeInteger = instantiateClassindexableSize(largeClass, sz);
	
#  if VMBIGENDIAN
	if (sz > 4) {
		byteAtput((newLargeInteger + BaseHeaderSize) + 7, (magnitude >> 56) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 6, (magnitude >> 48) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 5, (magnitude >> 40) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 4, (magnitude >> 32) & 0xFF);
	}
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (magnitude >> 24) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (magnitude >> 16) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (magnitude >> 8) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize), magnitude & 0xFF);

#  else /* VMBIGENDIAN */
	if (sz > 4) {
		long32Atput((newLargeInteger + BaseHeaderSize) + (1 << 2), magnitude >> 32);
	}
	long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), magnitude);

#  endif /* VMBIGENDIAN */

	return newLargeInteger;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargeInteger. 
 */

	/* InterpreterPrimitives>>#magnitude64BitValueOf: */
static usqLong NoDbgRegParms
magnitude64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt ccIndex1;
    sqInt fmt;
    sqInt i;
    sqInt ok;
    sqInt smallIntValue;
    sqInt sz;
    usqLong value;

	if ((oop & 1)) {
		smallIntValue = (oop >> 1);
		if (smallIntValue < 0) {
			smallIntValue = 0 - smallIntValue;
		}
		return ((usqLong) smallIntValue);
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex1 = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex1;
	goto l2;

l2:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin isClassOfNonImm:equalTo:compactClassIndex: */
		assert(!(isImmediate(oop)));
		ccIndex = (longAt(oop)) & (classIndexMask());
		ok = ClassLargeNegativeIntegerCompactIndex == ccIndex;
		goto l1;

	l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
		if (!ok) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return 0;
		}
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	sz = ((numSlotsOf(oop)) << (shiftForWord())) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	value = byteAt((oop + BaseHeaderSize) + (sz - 1));
	for (i = (sz - 2); i >= 0; i += -1) {
		value = (value << 8) + (byteAt((oop + BaseHeaderSize) + i));
	}
	return value;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or a four-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive32BitValueOf: */
usqInt
positive32BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt fmt;
    sqInt ok;
    sqInt sz;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if ((value < 0)
		 || (0)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			value = 0;
		}
		return value;
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	sz = ((numSlotsOf(oop)) << (shiftForWord())) - (fmt & 7);
	if (sz > 4) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	return 
#  if VMBIGENDIAN
		(((byteAt((oop + BaseHeaderSize))) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24)
#  else /* VMBIGENDIAN */
		long32At((oop + BaseHeaderSize) + (0 << 2))
#  endif /* VMBIGENDIAN */
		;
}


/*	Convert the given object into an integer value.
	The object may be either a positive SmallInteger or an eight-byte
	LargePositiveInteger. 
 */

	/* InterpreterPrimitives>>#positive64BitValueOf: */
usqLong
positive64BitValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ccIndex;
    sqInt fmt;
    sqInt i;
    sqInt ok;
    sqInt sz;
    usqLong value;

	if ((oop & 1)) {
		if (((oop >> 1)) < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return (oop >> 1);
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	sz = ((numSlotsOf(oop)) << (shiftForWord())) - (fmt & 7);
	if (sz > (sizeof(sqLong))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	value = 0;
	for (i = 0; i < sz; i += 1) {
		value += (((usqLong) (byteAt((oop + BaseHeaderSize) + i)))) << (i * 8);
	}
	return value;
}


/*	Answer a value of an integer in address range, i.e up to the size of a
	machine word.
	The object may be either a positive SmallInteger or a LargePositiveInteger
	of size <= word size.
 */
/*	only two callers & one is primitiveNewWithArg */

	/* InterpreterPrimitives>>#positiveMachineIntegerValueOf: */
unsigned long
positiveMachineIntegerValueOf(sqInt oop)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt fmt;
    sqInt ok;
    sqInt value;

	if ((oop & 1)) {
		value = (oop >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return null;
		}
		return value;
	}
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop)));
	ccIndex = (longAt(oop)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = ((numSlotsOf(oop)) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return 0;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		return 
#    if VMBIGENDIAN
			(((((((byteAt((oop + BaseHeaderSize))) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24)) + ((byteAt((oop + BaseHeaderSize) + 4)) << 32)) + ((byteAt((oop + BaseHeaderSize) + 5)) << 40)) + ((byteAt((oop + BaseHeaderSize) + 6)) << 48)) + ((byteAt((oop + BaseHeaderSize) + 7)) << 56)
#    else /* VMBIGENDIAN */
			long64At((oop + BaseHeaderSize) + (0 << 3))
#    endif /* VMBIGENDIAN */
			;
	}
	else {
		return 
#    if VMBIGENDIAN
			(((byteAt((oop + BaseHeaderSize))) + ((byteAt((oop + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop + BaseHeaderSize) + 3)) << 24)
#    else /* VMBIGENDIAN */
			long32At((oop + BaseHeaderSize) + (0 << 2))
#    endif /* VMBIGENDIAN */
			;
	}
}

	/* InterpreterPrimitives>>#primitiveAdd */
static void
primitiveAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerResult;
    char *sp;

	/* begin pop2AndPushIntegerIfOK: */
	integerResult = (stackIntegerValue(1)) + (stackIntegerValue(0));
	if (!GIV(primFailCode)) {
		if ((((sqInt)(integerResult ^ (integerResult << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveAddLargeIntegers */
EXPORT(void)
primitiveAddLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt resultIsNegative;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (aIsNegative == bIsNegative) {

		/* Protect against overflow */

		if (a > (0xFFFFFFFFFFFFFFFFULL - b)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a + b;
		resultIsNegative = aIsNegative;
	}
	else {
		if (a >= b) {
			result = a - b;
			resultIsNegative = aIsNegative;
		}
		else {
			result = b - a;
			resultIsNegative = bIsNegative;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, resultIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Change the class of the argument to make it an instance of the
	receiver given that the format of the receiver matches the format of the
	argument's class.
	Fail if receiver or argument are SmallIntegers, or the receiver is an
	instance of a
	compact class and the argument isn't, or when the argument's class is
	compact and
	the receiver isn't, or when the format of the receiver is different from
	the format of
	the argument's class, or when the arguments class is fixed and the
	receiver's size
	differs from the size that an instance of the argument's class should
	have. 
 */

	/* InterpreterPrimitives>>#primitiveAdoptInstance */
static void
primitiveAdoptInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt err;
    sqInt i;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((arg & (tagMask())) != 0)
	 || ((GIV(argumentCount) > 1)
	 && (((rcvr & (tagMask())) != 0)
	 || (!(objCouldBeClassObj(rcvr)))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	err = changeClassOfto(arg, rcvr);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */

		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}


/*	Answer an array of all instances of the receiver that exist
	when the primitive is called, excluding any that may be
	garbage collected as a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllInstances */
EXPORT(void)
primitiveAllInstances(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt result;
    char *sp;

	
	/* For the mirror prims check that the class obj is actually a valid class. */

	if (!((GIV(argumentCount) < 1)
		 || ((((longAt(GIV(stackPointer))) & (tagMask())) == 0)
		 && (objCouldBeClassObj(longAt(GIV(stackPointer))))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}

	result = allInstancesOf(longAt(GIV(stackPointer)));
	if ((result & 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = (BaseHeaderSize * 2) + (((result >> 1)) * BytesPerOop);
		growOldSpaceByAtLeast(((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom)));
		result = allInstancesOf(longAt(GIV(stackPointer)));
		if ((result & 1)) {
			(GIV(primFailCode) = PrimErrNoMemory);
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}


/*	Answer an array of all objects that exist when the primitive
	is called, excluding those that may be garbage collected as
	a side effect of allocating the result array. */

	/* InterpreterPrimitives>>#primitiveAllObjects */
EXPORT(void)
primitiveAllObjects(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt delta;
    sqInt result;
    char *sp;

	result = allObjects();
	if ((result & 1)) {
		/* begin growToAccomodateContainerWithNumSlots: */
		delta = (BaseHeaderSize * 2) + (((result >> 1)) * BytesPerOop);
		growOldSpaceByAtLeast(((GIV(growHeadroom) < delta) ? delta : GIV(growHeadroom)));
		result = allObjects();
		if ((result & 1)) {
			(GIV(primFailCode) = PrimErrNoMemory);
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveArctan */
static void
primitiveArctan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	isFloat = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l1;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = atan(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecome */
static void
primitiveArrayBecome(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 1, 0);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	We must flush the method cache here, to eliminate stale references
	to mutated classes and/or selectors. */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWay */
static void
primitiveArrayBecomeOneWay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt ec;
    sqInt rcvr;

	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	ec = becomewithtwoWaycopyHash(rcvr, arg, 0, 1);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}


/*	Similar to primitiveArrayBecomeOneWay but accepts a third argument
	deciding whether to
	copy the receiver's element's identity hash over the argument's elementy's
	identity hash.
 */

	/* InterpreterPrimitives>>#primitiveArrayBecomeOneWayCopyHash */
static void
primitiveArrayBecomeOneWayCopyHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt copyHashFlag;
    sqInt ec;

	copyHashFlag = 0;
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		copyHashFlag = 1;
	}
	else {
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			copyHashFlag = 0;
		}
		else {
			GIV(primFailCode) = PrimErrBadArgument;
			return;
		}
	}
	ec = becomewithtwoWaycopyHash(longAt(GIV(stackPointer) + (2 * BytesPerWord)), longAt(GIV(stackPointer) + (1 * BytesPerWord)), 0, copyHashFlag);
	if (ec == PrimNoErr) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = ec;
	}
}

	/* InterpreterPrimitives>>#primitiveAsCharacter */
static void
primitiveAsCharacter(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt characterCode;
    sqInt characterObject;
    sqInt objOop;
    sqInt reasonCode;
    char *sp;

	characterCode = longAt(GIV(stackPointer));
	if (!(((characterCode & 1))
		 && (((characterCode = (characterCode >> 1)),
		((characterCode >= 0) && (characterCode <= ((1 << 30) - 1))))))) {
		/* begin primitiveFailFor: */
		reasonCode = (GIV(argumentCount) == 0
			? PrimErrBadReceiver
			: PrimErrBadArgument);
		(GIV(primFailCode) = reasonCode);
		return;
	}
	characterObject = (characterCode << (numTagBits())) + (characterTag());

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), characterObject);
	GIV(stackPointer) = sp;
}


/*	N.B. This will answer inexact results for integers with > 53 bits of
	magnitude. 
 */

	/* InterpreterPrimitives>>#primitiveAsFloat */
static void
primitiveAsFloat(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer));
	assert((rcvr & 1));
	/* begin pop:thenPushFloat: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), floatObjectOf(((double) ((rcvr >> 1)) )));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveAt */
static void
primitiveAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqLong hdr;
    sqInt index;
    sqInt integerValue;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objFormat;
    sqInt objOop;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt result;
    char *sp;
    sqInt sp1;
    sqInt sp2;
    sqInt stSize;
    sqInt totalLength;

	/* begin commonAt: */
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if ((rcvr & (tagMask())) != 0) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 1)
	 && (((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	index = (index >> 1);
	/* begin stObject:at: */
	hdr = long64At(rcvr);
	fmt = (((unsigned sqLong)hdr) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? longAt(rcvr - BaseHeaderSize)
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l5;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l5;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l5;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l5;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = ((usqInt) numSlots) >> 1;
		goto l5;
	}
	totalLength = 0;
l5:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l3;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l3;
	}
	class = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1)) & ((1 << (fixedFieldsFieldWidth())) - 1);
l3:	/* end fixedFieldsOf:format:length: */;
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp2 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp2 >> 1))) < (lengthOf(rcvr)));
			stSize = sp2;
			goto l2;
		}
		/* begin fetchStackPointerOf: */
		sp1 = longAt((rcvr + BaseHeaderSize) + (StackPointerIndex << (shiftForWord())));
		if (!((sp1 & 1))) {
			stSize = 0;
			goto l2;
		}
		assert((ReceiverIndex + ((sp1 >> 1))) < (lengthOf(rcvr)));
		stSize = (sp1 >> 1);
	l2:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize))
		 && ((((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			result = noInlineTemporaryin(index - 1, frameOfMarriedContext(rcvr));
			goto l6;
		}
	}
	else {
		stSize = totalLength - fixedFields;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize))) {
		/* begin subscript:with:format: */
		if (fmt <= 5) {
			result = longAt((rcvr + BaseHeaderSize) + (((index + fixedFields) - 1) << (shiftForWord())));
			goto l6;
		}
		if (fmt >= (firstByteFormat())) {
			result = (((byteAt((rcvr + BaseHeaderSize) + ((index + fixedFields) - 1))) << 1) | 1);
			goto l6;
		}
		/* begin positive32BitIntegerFor: */
		integerValue = long32At((rcvr + BaseHeaderSize) + (((index + fixedFields) - 1) << 2));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if (((((sqInt)integerValue)) >= 0)
		 && ((((sqInt)(integerValue ^ (integerValue << 1)))) >= 0)) {
			result = ((integerValue << 1) | 1);
			goto l6;
		}
		/* begin eeInstantiateSmallClassIndex:format:numSlots: */
		objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
		assert(ClassLargePositiveIntegerCompactIndex != 0);
		assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
		/* begin allocateSmallNewSpaceSlots:format:classIndex: */
		assert(1 < (numSlotsMask()));
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + (8);
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
				error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
				newLargeInteger = 0;
				goto l4;
			}
		}
		long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
		GIV(freeStart) += numBytes;
		newLargeInteger = newObj;
	l4:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
		
#    if VMBIGENDIAN
		byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#    else /* VMBIGENDIAN */
		long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), integerValue);

#    endif /* VMBIGENDIAN */

		result = newLargeInteger;
		goto l6;

	}
	/* begin primitiveFailFor: */
	reasonCode = (fmt <= 1
		? PrimErrBadReceiver
		: PrimErrBadIndex);
	GIV(primFailCode) = reasonCode;
	result = 0;
l6:	/* end stObject:at: */;
	if (!GIV(primFailCode)) {
		;
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAt: */;
}

	/* InterpreterPrimitives>>#primitiveAtPut */
static void
primitiveAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt class1;
    sqInt fixedFields;
    sqInt fixedFields1;
    sqInt fmt;
    sqInt fmt1;
    sqInt hdr;
    sqInt hdr1;
    sqInt index;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots2;
    sqInt rcvr;
    sqInt reasonCode;
    sqInt reasonCode1;
    char *sp;
    sqInt sp1;
    sqInt sp11;
    sqInt sp2;
    sqInt sp3;
    sqInt stSize;
    sqInt stSize1;
    sqInt totalLength;
    sqInt totalLength1;
    sqInt value;
    sqInt value1;
    usqInt valueToStore;
    usqInt valueToStore1;

	/* begin commonAtPut: */
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	value = longAt(GIV(stackPointer));
	if ((rcvr & (tagMask())) != 0) {
		GIV(primFailCode) = PrimErrInappropriate;
		goto l1;
	}
	if (((index & 1) == 0)
	 || ((GIV(argumentCount) > 2)
	 && (((longAt(rcvr)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l1;
	}
	index = (index >> 1);
	/* begin stObject:at:put: */
	hdr1 = long64At(rcvr);
	fmt1 = (((usqInt) hdr1) >> (formatShift())) & (formatMask());
	/* begin lengthOf:format: */
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(rcvr + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? longAt(rcvr - BaseHeaderSize)
		: numSlots11);
	if (fmt1 <= 5) {
		totalLength1 = numSlots2;
		goto l7;
	}
	if (fmt1 >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */

		totalLength1 = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
		goto l7;
	}
	if (fmt1 >= (firstShortFormat())) {
		totalLength1 = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
		goto l7;
	}
	if (fmt1 >= (firstLongFormat())) {
		totalLength1 = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
		goto l7;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat())) {
		totalLength1 = ((usqInt) numSlots2) >> 1;
		goto l7;
	}
	totalLength1 = 0;
l7:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt1 >= (sixtyFourBitIndexableFormat()))
	 || (fmt1 == 2)) {
		fixedFields1 = 0;
		goto l6;
	}
	if (fmt1 < 2) {
		fixedFields1 = totalLength1;
		goto l6;
	}
	class1 = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields1 = (((longAt((class1 + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1)) & ((1 << (fixedFieldsFieldWidth())) - 1);
l6:	/* end fixedFieldsOf:format:length: */;
	if ((fmt1 == (indexablePointersFormat()))
	 && ((hdr1 & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		/* begin stackPointerForMaybeMarriedContext: */
		if ((((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
		 && (!(isWidowedContext(rcvr)))) {
			sp3 = stackPointerIndexForFrame(frameOfMarriedContext(rcvr));
			assert((ReceiverIndex + ((sp3 >> 1))) < (lengthOf(rcvr)));
			stSize1 = sp3;
			goto l8;
		}
		/* begin fetchStackPointerOf: */
		sp11 = longAt((rcvr + BaseHeaderSize) + (StackPointerIndex << (shiftForWord())));
		if (!((sp11 & 1))) {
			stSize1 = 0;
			goto l8;
		}
		assert((ReceiverIndex + ((sp11 >> 1))) < (lengthOf(rcvr)));
		stSize1 = (sp11 >> 1);
	l8:	/* end stackPointerForMaybeMarriedContext: */;
		if ((oopisGreaterThanOrEqualTo(index, 1))
		 && ((oopisLessThanOrEqualTo(index, stSize1))
		 && ((((longAt((rcvr + BaseHeaderSize) + (SenderIndex << (shiftForWord())))) & 1))
		 && (!(isWidowedContext(rcvr)))))) {
			noInlineTemporaryinput(index - 1, frameOfMarriedContext(rcvr), value);
			goto l9;
		}
	}
	else {
		stSize1 = totalLength1 - fixedFields1;
	}
	if ((oopisGreaterThanOrEqualTo(index, (fmt1 >= (firstCompiledMethodFormat())
		? (((literalCountOf(rcvr)) + LiteralStart) * BytesPerOop) + 1
		: 1)))
	 && (oopisLessThanOrEqualTo(index, stSize1))) {
		/* begin subscript:with:storing:format: */
		if (fmt1 <= 5) {
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */

				if (((value & (tagMask())) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (((index + fixedFields1) - 1) << (shiftForWord())), value);
		}
		else {
			if (fmt1 >= (firstByteFormat())) {
				if (!((value & 1))) {
					GIV(primFailCode) = PrimErrBadIndex;
				}
				valueToStore1 = (value >> 1);
				if (!((valueToStore1 >= 0)
					 && (valueToStore1 <= 0xFF))) {
					GIV(primFailCode) = PrimErrBadArgument;
				}
				if (!GIV(primFailCode)) {
					byteAtput((rcvr + BaseHeaderSize) + ((index + fixedFields1) - 1), valueToStore1);
				}
			}
			else {

				/* long-word type objects */

				valueToStore1 = positive32BitValueOf(value);
				if (!GIV(primFailCode)) {
					long32Atput((rcvr + BaseHeaderSize) + (((index + fixedFields1) - 1) << 2), valueToStore1);
				}
			}
		}
	}
	else {
		/* begin primitiveFailFor: */
		reasonCode1 = (fmt1 <= 1
			? PrimErrBadReceiver
			: PrimErrBadIndex);
		GIV(primFailCode) = reasonCode1;
	}
l9:	/* end stObject:at:put: */;

	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), value);
		GIV(stackPointer) = sp;
	}
l1:	/* end commonAtPut: */;
}


/*	Set the cursor to the given shape. The Mac only supports 16x16 pixel
	cursors. Cursor offsets are handled by Smalltalk.
 */

	/* InterpreterPrimitives>>#primitiveBeCursor */
static void
primitiveBeCursor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsObj;
    sqInt cursorBitsIndex;
    sqInt cursorObj;
    sqInt depth;
    sqInt extentX;
    sqInt extentY;
    sqInt i;
    sqInt maskBitsIndex;
    sqInt maskObj;
    sqInt offsetObj;
    sqInt offsetX;
    sqInt offsetY;
    sqInt ourCursor;
    sqInt successBoolean;
    sqInt successBoolean1;
    sqInt successBoolean10;
    sqInt successBoolean11;
    sqInt successBoolean12;
    sqInt successBoolean2;
    sqInt successBoolean3;
    sqInt successBoolean4;
    sqInt successBoolean5;
    sqInt successBoolean6;
    sqInt successBoolean7;
    sqInt successBoolean8;
    sqInt successBoolean9;

	bitsObj = 0;
	cursorBitsIndex = 0;
	cursorObj = 0;
	depth = 0;
	extentX = 0;
	extentY = 0;
	i = 0;
	maskBitsIndex = 0;
	maskObj = 0;
	offsetObj = 0;
	ourCursor = 0;
	if (GIV(argumentCount) == 0) {
		cursorObj = longAt(GIV(stackPointer));
		maskBitsIndex = null;
	}
	if (GIV(argumentCount) == 1) {
		cursorObj = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		maskObj = longAt(GIV(stackPointer));
	}
	/* begin success: */
	if (!(GIV(argumentCount) < 2)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin success: */
	successBoolean11 = (((cursorObj & (tagMask())) == 0)
	 && (((((usqInt) (longAt(cursorObj))) >> (formatShift())) & (formatMask())) <= 5))
	 && ((lengthOfformat(cursorObj, (((usqInt) (longAt(cursorObj))) >> (formatShift())) & (formatMask()))) >= 5);
	if (!successBoolean11) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		bitsObj = longAt((cursorObj + BaseHeaderSize) + (0 << (shiftForWord())));
		extentX = fetchIntegerofObject(1, cursorObj);
		extentY = fetchIntegerofObject(2, cursorObj);
		depth = fetchIntegerofObject(3, cursorObj);
		offsetObj = longAt((cursorObj + BaseHeaderSize) + (4 << (shiftForWord())));
	}
	/* begin success: */
	successBoolean12 = (((offsetObj & (tagMask())) == 0)
	 && (((((usqInt) (longAt(offsetObj))) >> (formatShift())) & (formatMask())) <= 5))
	 && ((lengthOfformat(offsetObj, (((usqInt) (longAt(offsetObj))) >> (formatShift())) & (formatMask()))) >= 2);
	if (!successBoolean12) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		offsetX = fetchIntegerofObject(0, offsetObj);
		offsetY = fetchIntegerofObject(1, offsetObj);
		if ((GIV(argumentCount) == 0)
		 && (depth == 32)) {

			/* Support arbitrary-sized 32 bit ARGB forms --bf 3/1/2007 23:51 */

			/* begin success: */
			successBoolean = (extentX > 0)
			 && (extentY > 0);
			if (!successBoolean) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean1 = (offsetX >= (extentX * -1))
			 && (offsetX <= 0);
			if (!successBoolean1) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean2 = (offsetY >= (extentY * -1))
			 && (offsetY <= 0);
			if (!successBoolean2) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean3 = (((bitsObj & (tagMask())) == 0)
			 && (((((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask())) == (firstLongFormat())))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask()))) == (extentX * extentY));
			if (!successBoolean3) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
			
		}
		else {
			/* begin success: */
			successBoolean4 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean4) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean5 = (offsetX >= -16)
			 && (offsetX <= 0);
			if (!successBoolean5) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean6 = (offsetY >= -16)
			 && (offsetY <= 0);
			if (!successBoolean6) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean7 = (((bitsObj & (tagMask())) == 0)
			 && (((((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask())) == (firstLongFormat())))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask()))) == 16);
			if (!successBoolean7) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			cursorBitsIndex = bitsObj + BaseHeaderSize;
			
		}
	}
	if (GIV(argumentCount) == 1) {
		/* begin success: */
		successBoolean10 = (((maskObj & (tagMask())) == 0)
		 && (((((usqInt) (longAt(maskObj))) >> (formatShift())) & (formatMask())) <= 5))
		 && ((lengthOfformat(maskObj, (((usqInt) (longAt(maskObj))) >> (formatShift())) & (formatMask()))) >= 5);
		if (!successBoolean10) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			bitsObj = longAt((maskObj + BaseHeaderSize) + (0 << (shiftForWord())));
			extentX = fetchIntegerofObject(1, maskObj);
			extentY = fetchIntegerofObject(2, maskObj);
			depth = fetchIntegerofObject(3, maskObj);
		}
		if (!GIV(primFailCode)) {
			/* begin success: */
			successBoolean8 = (extentX == 16)
			 && ((extentY == 16)
			 && (depth == 1));
			if (!successBoolean8) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin success: */
			successBoolean9 = (((bitsObj & (tagMask())) == 0)
			 && (((((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask())) == (firstLongFormat())))
			 && ((lengthOfformat(bitsObj, (((usqInt) (longAt(bitsObj))) >> (formatShift())) & (formatMask()))) == 16);
			if (!successBoolean9) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			maskBitsIndex = bitsObj + BaseHeaderSize;
		}
	}
	if (!GIV(primFailCode)) {
		if (GIV(argumentCount) == 0) {
			if (depth == 32) {
				if (!(ioSetCursorARGB(cursorBitsIndex, extentX, extentY, offsetX, offsetY))) {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

					return;
				}
			}
			else {
				ioSetCursor(cursorBitsIndex, offsetX, offsetY);
			}
		}
		else {
			ioSetCursorWithMask(cursorBitsIndex, maskBitsIndex, offsetX, offsetY);
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Record the system Display object in the specialObjectsTable. */

	/* InterpreterPrimitives>>#primitiveBeDisplay */
static void
primitiveBeDisplay(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt rcvr;
    sqInt successBoolean;

	rcvr = longAt(GIV(stackPointer));
	/* begin success: */
	successBoolean = (((rcvr & (tagMask())) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) <= 5))
	 && ((lengthOfformat(rcvr, (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))) >= 4);
	if (!successBoolean) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((rcvr & (tagMask())) == 0)
			 && (oopisLessThan(rcvr, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << (shiftForWord())), rcvr);
	}
}


/*	make the basic beep noise */

	/* InterpreterPrimitives>>#primitiveBeep */
static void
primitiveBeep(void)
{
	ioBeep();
}

	/* InterpreterPrimitives>>#primitiveBehaviorHash */
static void
primitiveBehaviorHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBehavior;
    sqInt err;
    sqInt hash;
    sqInt hashOrError;
    char *sp;

	
	/* For the mirror prims check that the class obj is actually a valid class. */

	if (GIV(argumentCount) > 0) {
		if (!((((longAt(GIV(stackPointer))) & (tagMask())) == 0)
			 && (objCouldBeClassObj(longAt(GIV(stackPointer)))))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
	}

	assert((isNonImmediate(stackTop()))
	 && (addressCouldBeClassObj(stackTop())));
	/* begin ensureBehaviorHash: */
	aBehavior = longAt(GIV(stackPointer));
	assert(addressCouldBeClassObj(aBehavior));
	hashOrError = (((hash = (long32At(aBehavior + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(aBehavior)
				? (((err = enterIntoClassTable(aBehavior))) != 0
						? -err
						: (long32At(aBehavior + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (hashOrError >= 0) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((hashOrError << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		GIV(primFailCode) = -hashOrError;
	}
}

	/* InterpreterPrimitives>>#primitiveBitAnd */
static void
primitiveBitAnd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArgument;
    usqLong integerReceiver;
    sqInt integerValue;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt objFormat;
    sqInt oop;
    sqInt oop1;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));

	/* Comment out the short-cut.  Either the inline interpreter bytecode or the JIT primitive will handle this case.
	   ((objectMemory isIntegerObject: integerArgument)
	   and: [objectMemory isIntegerObject: integerReceiver])
	   ifTrue: [self pop: 2 thenPush: (integerArgument bitAnd: integerReceiver)]
	   ifFalse:
	   [ */

	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerArgument = positive32BitValueOf(integerArgument);
	integerReceiver = positive32BitValueOf(integerReceiver);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		/* begin positive32BitIntegerFor: */
		integerValue = ((sqInt) (integerArgument & integerReceiver));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if (((((sqInt)integerValue)) >= 0)
		 && ((((sqInt)(integerValue ^ (integerValue << 1)))) >= 0)) {
			oop1 = ((integerValue << 1) | 1);
			goto l3;
		}
		/* begin eeInstantiateSmallClassIndex:format:numSlots: */
		objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
		assert(ClassLargePositiveIntegerCompactIndex != 0);
		assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
		/* begin allocateSmallNewSpaceSlots:format:classIndex: */
		assert(1 < (numSlotsMask()));
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + (8);
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
				error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
				newLargeInteger = 0;
				goto l2;
			}
		}
		long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
		GIV(freeStart) += numBytes;
		newLargeInteger = newObj;
	l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
		
#    if VMBIGENDIAN
		byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#    else /* VMBIGENDIAN */
		long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), integerValue);

#    endif /* VMBIGENDIAN */

		oop1 = newLargeInteger;
	l3:	/* end maybeInlinePositive32BitIntegerFor: */;
		goto l1;

	l1:	/* end positive32BitIntegerFor: */;
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
		GIV(stackPointer) = sp1;
	}

}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitAndLargeIntegers */
EXPORT(void)
primitiveBitAndLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr & integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveBitOr */
static void
primitiveBitOr(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArgument;
    usqLong integerReceiver;
    sqInt integerValue;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt objFormat;
    sqInt oop;
    sqInt oop1;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));

	/* Comment out the short-cut.  Either the inline interpreter bytecode or the JIT primitive will handle this case.
	   ((objectMemory isIntegerObject: integerArgument)
	   and: [objectMemory isIntegerObject: integerReceiver])
	   ifTrue: [self pop: 2 thenPush: (integerArgument bitOr: integerReceiver)]
	   ifFalse:
	   [ */

	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerArgument = positive32BitValueOf(integerArgument);
	integerReceiver = positive32BitValueOf(integerReceiver);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		/* begin positive32BitIntegerFor: */
		integerValue = ((sqInt) (integerArgument | integerReceiver));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if (((((sqInt)integerValue)) >= 0)
		 && ((((sqInt)(integerValue ^ (integerValue << 1)))) >= 0)) {
			oop1 = ((integerValue << 1) | 1);
			goto l3;
		}
		/* begin eeInstantiateSmallClassIndex:format:numSlots: */
		objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
		assert(ClassLargePositiveIntegerCompactIndex != 0);
		assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
		/* begin allocateSmallNewSpaceSlots:format:classIndex: */
		assert(1 < (numSlotsMask()));
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + (8);
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
				error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
				newLargeInteger = 0;
				goto l2;
			}
		}
		long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
		GIV(freeStart) += numBytes;
		newLargeInteger = newObj;
	l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
		
#    if VMBIGENDIAN
		byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#    else /* VMBIGENDIAN */
		long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), integerValue);

#    endif /* VMBIGENDIAN */

		oop1 = newLargeInteger;
	l3:	/* end maybeInlinePositive32BitIntegerFor: */;
		goto l1;

	l1:	/* end positive32BitIntegerFor: */;
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
		GIV(stackPointer) = sp1;
	}

}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitOrLargeIntegers */
EXPORT(void)
primitiveBitOrLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr | integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Perform a bitShift. In 32-bits deal only with non-negative 32-bit
	integers. In 64-bits deal with signed 64-bit quantities (max (2^63)-1). */

	/* InterpreterPrimitives>>#primitiveBitShift */
static void
primitiveBitShift(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt objFormat;
    sqInt shifted;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	if (!((integerArgument & 1))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	integerReceiver = positive32BitValueOf(integerReceiver);

	if (!GIV(primFailCode)) {
		if (((integerArgument = (integerArgument >> 1))) >= 0) {

			/* Left shift -- must fail bits would be lost */

			if (!(integerArgument <= 0x1F)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = integerReceiver << integerArgument;
			
			if (!(integerReceiver == (((usqInt) shifted) >> integerArgument))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		else {

			/* Right shift -- OK to lose bits */

			if (!(integerArgument >= (-0x1F))) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			shifted = ((usqInt) integerReceiver) >> (0 - integerArgument);
		}
		/* begin positive32BitIntegerFor: */
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if (((((sqInt)shifted)) >= 0)
		 && ((((sqInt)(shifted ^ (shifted << 1)))) >= 0)) {
			shifted = ((shifted << 1) | 1);
			goto l3;
		}
		/* begin eeInstantiateSmallClassIndex:format:numSlots: */
		objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
		assert(ClassLargePositiveIntegerCompactIndex != 0);
		assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
		/* begin allocateSmallNewSpaceSlots:format:classIndex: */
		assert(1 < (numSlotsMask()));
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + (8);
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
				error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
				newLargeInteger = 0;
				goto l2;
			}
		}
		long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
		GIV(freeStart) += numBytes;
		newLargeInteger = newObj;
	l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
		
#    if VMBIGENDIAN
		byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) shifted) >> 24) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) shifted) >> 16) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) shifted) >> 8) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize), shifted & 0xFF);

#    else /* VMBIGENDIAN */
		long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), shifted);

#    endif /* VMBIGENDIAN */

		shifted = newLargeInteger;
	l3:	/* end maybeInlinePositive32BitIntegerFor: */;
		goto l1;

	l1:	/* end positive32BitIntegerFor: */;

		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), shifted);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitShiftLargeIntegers */
EXPORT(void)
primitiveBitShiftLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    sqInt integerPointer;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    sqInt shift;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		shift = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		shift = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	if (GIV(primFailCode)) {
		return;
	}
	if (shift >= 0) {

		/* Protect against overflow */


		/* This is to avoid undue (usqInt) cast */

		result = 0xFFFFFFFFFFFFFFFFULL;
		if ((shift >= 64)
		 || (a > (result >> shift))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		result = a << shift;
	}
	else {
		shift = 0 - shift;
		if (shift >= 64) {
			result = 0;
		}
		else {
			result = a >> shift;
		}
		if (aIsNegative
		 && ((result << shift) != a)) {
			result += 1;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveBitXor */
static void
primitiveBitXor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong integerArgument;
    usqLong integerReceiver;
    sqInt integerValue;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt objFormat;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    char *sp;
    char *sp1;
    char *sp2;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerArgument & 1))
	 && ((integerReceiver & 1))) {

		/* xoring will leave the tag bits zero, whether the tag is 1 or zero, so add it back in. */

		/* begin pop:thenPush: */
		oop = ((sqInt) ((integerArgument ^ integerReceiver) + 1));
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
	else {
		integerArgument = positive32BitValueOf(integerArgument);
		integerReceiver = positive32BitValueOf(integerReceiver);
		if (!GIV(primFailCode)) {
			/* begin pop:thenPush: */
			/* begin positive32BitIntegerFor: */
			integerValue = ((sqInt) (integerArgument ^ integerReceiver));
			/* begin maybeInlinePositive32BitIntegerFor: */
			assert(!((hasSixtyFourBitImmediates())));
			if (((((sqInt)integerValue)) >= 0)
			 && ((((sqInt)(integerValue ^ (integerValue << 1)))) >= 0)) {
				oop2 = ((integerValue << 1) | 1);
				goto l3;
			}
			/* begin eeInstantiateSmallClassIndex:format:numSlots: */
			objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
			assert(ClassLargePositiveIntegerCompactIndex != 0);
			assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
			/* begin allocateSmallNewSpaceSlots:format:classIndex: */
			assert(1 < (numSlotsMask()));
			newObj = GIV(freeStart);
			numBytes = BaseHeaderSize + (8);
			assert((numBytes % (allocationUnit())) == 0);
			assert((newObj % (allocationUnit())) == 0);
			if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
				if (!GIV(needGCFlag)) {
					/* begin scheduleScavenge */
					GIV(needGCFlag) = 1;
					forceInterruptCheck();
				}
				if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
					error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
					newLargeInteger = 0;
					goto l2;
				}
			}
			long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
			GIV(freeStart) += numBytes;
			newLargeInteger = newObj;
		l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
			
#      if VMBIGENDIAN
			byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
			byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
			byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
			byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#      else /* VMBIGENDIAN */
			long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), integerValue);

#      endif /* VMBIGENDIAN */

			oop2 = newLargeInteger;
		l3:	/* end maybeInlinePositive32BitIntegerFor: */;
			goto l1;

		l1:	/* end positive32BitIntegerFor: */;
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop2);
			GIV(stackPointer) = sp2;
		}

	}
}


/*	Primitive logical operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveBitXorLargeIntegers */
EXPORT(void)
primitiveBitXorLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    sqInt oopResult;
    char *sp;

	integerArg = positive64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = positive64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (GIV(primFailCode)) {
		return;
	}
	oopResult = positive64BitIntegerFor(integerRcvr ^ integerArg);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Reports bytes available at this moment. For more meaningful 
	results, calls to this primitive should be precedeed by a full 
	or incremental garbage collection. */

	/* InterpreterPrimitives>>#primitiveBytesLeft */
static void
primitiveBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    usqInt integerVal;
    char *sp;
    char *sp1;

	if (GIV(argumentCount) == 0) {

		/* old behavior - just return the size of free memory */

		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((GIV(totalFreeOldSpace) << 1) | 1));
		GIV(stackPointer) = sp;
		return;
	}
	if (GIV(argumentCount) == 1) {

		/* new behaviour -including or excluding swap space depending on aBool */

		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			aBool = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			aBool = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		aBool = null;
	l1:	/* end booleanValueOf: */;
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushInteger: */
			integerVal = (((GIV(totalFreeOldSpace) + ((((eden()).limit)) - GIV(freeStart))) + ((((pastSpace()).limit)) - GIV(pastSpaceStart))) + ((((futureSpace()).limit)) - (((futureSpace()).limit)))) - (interpreterAllocationReserveBytes());
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerVal << 1) | 1));
			GIV(stackPointer) = sp1;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	return;
}


/*	Perform a function call to a foreign function.
	Only invoked from method containing explicit external call spec.
	Due to this we use the pluggable prim mechanism explicitly here
	(the first literal of any FFI spec'ed method is an ExternalFunction
	and not an array as used in the pluggable primitive mechanism). */

	/* InterpreterPrimitives>>#primitiveCalloutToFFI */
static void
primitiveCalloutToFFI(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    static void *function = (void *)-1;
    void (*primitiveCallout)(void);

	/* begin functionForPrimitiveCallout */
	;
	if ((((sqInt)function)) == -1) {
		function = ioLoadFunctionFrom("primitiveCallout", "SqueakFFIPrims");
	}
	primitiveCallout = ((void (*)(void)) function);
	if (primitiveCallout == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		primitiveCallout();
	}
}


/*	Primitive. Change the class of the receiver into the class of the argument
	given that
	the format of the receiver matches the format of the argument's class.
	Fail if the
	receiver or argument are SmallIntegers, or the receiver is an instance of
	a compact
	class and the argument isn't, or when the argument's class is compact and
	the receiver
	isn't, or when the format of the receiver is different from the format of
	the argument's
	class, or when the arguments class is fixed and the receiver's size
	differs from the size
	that an instance of the argument's class should have. */

	/* InterpreterPrimitives>>#primitiveChangeClass */
static void
primitiveChangeClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt argClass;
    sqInt err;
    sqInt i;
    sqInt oop;
    sqInt oop1;
    sqInt rcvr;

	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		arg = null;
		goto l1;
	}
	arg = oop;
l1:	/* end stackObjectValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop1 & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l2;
	}
	rcvr = oop1;
l2:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	argClass = fetchClassOfNonImm(arg);
	err = changeClassOfto(rcvr, argClass);
	if (err == 0) {

		/* Flush at cache because rcvr's class has changed. */

		/* begin flushAtCache */
		for (i = 1; i <= AtCacheTotalSize; i += 1) {
			GIV(atCache)[i] = 0;
		}
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
	else {
		GIV(primFailCode) = err;
	}
	return;
}

	/* InterpreterPrimitives>>#primitiveClass */
static void
primitiveClass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    sqInt oop;
    char *sp;
    sqInt tagBits;

	instance = longAt(GIV(stackPointer));
	if ((GIV(argumentCount) > 0)
	 && (((instance & (tagMask())) == 0)
	 && (((longAt(instance)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPush: */
		oop = (((tagBits = instance & (tagMask()))) != 0
			? longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (tagBits << (shiftForWord())))
			: fetchClassOfNonImm(instance));
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Void the VM profile histograms. */

	/* InterpreterPrimitives>>#primitiveClearVMProfile */
static void
primitiveClearVMProfile(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioClearProfile();
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	When called with a single string argument, post the string to 
	the clipboard. When called with zero arguments, return a 
	string containing the current clipboard contents. */

	/* InterpreterPrimitives>>#primitiveClipboardText */
static void
primitiveClipboardText(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt formatField;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt s;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {
		s = longAt(GIV(stackPointer));
		if (!(((s & (tagMask())) == 0)
			 && (((((usqInt) (longAt(s))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		if (!GIV(primFailCode)) {
			/* begin numBytesOfBytes: */
			fmt = (((usqInt) (longAt(s))) >> (formatShift())) & (formatMask());
			assert(fmt >= (firstByteFormat()));
			sz = ((numSlotsOf(s)) << (shiftForWord())) - (fmt & 7);
			clipboardWriteFromAt(sz, s + BaseHeaderSize, 0);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = clipboardSize();
		/* begin allocateBytes:classIndex: */
		assert(addressCouldBeClassObj(classAtIndex(ClassByteStringCompactIndex)));
		assert((instSpecOfClass(classAtIndex(ClassByteStringCompactIndex))) == (firstByteFormat()));
		/* begin allocateSlots:format:classIndex: */
		numSlots = ((sz + BytesPerOop) - 1) / BytesPerOop;
		formatField = (firstByteFormat()) + ((8 - sz) & (BytesPerWord - 1));
		if (numSlots >= (numSlotsMask())) {
			newObj = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + ((numSlots + (numSlots & 1)) * BytesPerOop);
		}
		else {
			newObj = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			s = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, formatField, ClassByteStringCompactIndex);
			goto l1;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */

			flag("endianness");
			longAtput(GIV(freeStart), numSlots);
			longAtput(GIV(freeStart) + 4, (numSlotsMask()) << (numSlotsHalfShift()));
			long64Atput(newObj, headerForSlotsformatclassIndex(numSlotsMask(), formatField, ClassByteStringCompactIndex));
		}
		else {
			long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (formatField << (formatShift()))) + ClassByteStringCompactIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		s = newObj;
	l1:	/* end allocateSlots:format:classIndex: */;
		if (!(s)) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}

		clipboardReadIntoAt(sz, s + BaseHeaderSize, 0);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Take a boolean which if true turns or keeps clock logging on. Answer an
	array supplying
	the size of the clock logs, the address of the usecs log, the index in it,
	the address of the
	msecs log, and the index into it. */

	/* InterpreterPrimitives>>#primitiveClockLogAddresses */
EXPORT(sqInt)
primitiveClockLogAddresses(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt integerValue1;
    sqInt midx;
    void *msecs;
    sqInt newLargeInteger;
    sqInt newLargeInteger1;
    usqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numBytes1;
    sqInt objFormat;
    sqInt objFormat1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt objOop3;
    sqInt objOop4;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt result;
    sqInt runInNOut;
    char *sp;
    sqInt uidx;
    void *usecs;
    sqInt v1;
    sqInt v2;

	midx = 0;
	msecs = 0;
	uidx = 0;
	usecs = 0;
	if (GIV(argumentCount) != 1) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	runInNOut = (longAt(GIV(stackPointer) + (0 * BytesPerWord))) == GIV(trueObj);
	ioGetClockLogSizeUsecsIdxMsecsIdx((&runInNOut), (&usecs), (&uidx), (&msecs), (&midx));
	result = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassArray << (shiftForWord()))), 5);
	if (result == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pushRemappableOop: */
	assert(addressCouldBeOop(result));
	GIV(remapBuffer)[(GIV(remapBufferCount) += 1)] = result;
	if (!(GIV(remapBufferCount) <= RemapBufferSize)) {
		error("remapBuffer overflow");
	}
	/* begin storePointerUnchecked:ofObject:withValue: */
	objOop = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop)));
	longAtput((objOop + BaseHeaderSize) + (0 << (shiftForWord())), ((runInNOut << 1) | 1));
	/* begin positive32BitIntegerFor: */
	integerValue = ((usqInt)usecs);
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if (((((sqInt)integerValue)) >= 0)
	 && ((((sqInt)(integerValue ^ (integerValue << 1)))) >= 0)) {
		v1 = ((integerValue << 1) | 1);
		goto l4;
	}
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
	assert(ClassLargePositiveIntegerCompactIndex != 0);
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(1 < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + (8);
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l3;
		}
	}
	long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
l3:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
	
#  if VMBIGENDIAN
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#  else /* VMBIGENDIAN */
	long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), integerValue);

#  endif /* VMBIGENDIAN */

	v1 = newLargeInteger;
l4:	/* end maybeInlinePositive32BitIntegerFor: */;
	goto l1;

l1:	/* end positive32BitIntegerFor: */;
	/* begin positive32BitIntegerFor: */
	integerValue1 = ((usqInt)msecs);
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if (((((sqInt)integerValue1)) >= 0)
	 && ((((sqInt)(integerValue1 ^ (integerValue1 << 1)))) >= 0)) {
		v2 = ((integerValue1 << 1) | 1);
		goto l6;
	}
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat1 = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
	assert(ClassLargePositiveIntegerCompactIndex != 0);
	assert(((objFormat1 < (firstByteFormat())
	? objFormat1
	: objFormat1 & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(1 < (numSlotsMask()));
	newObj1 = GIV(freeStart);
	numBytes1 = BaseHeaderSize + (8);
	assert((numBytes1 % (allocationUnit())) == 0);
	assert((newObj1 % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes1) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger1 = 0;
			goto l5;
		}
	}
	long64Atput(newObj1, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat1 << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
	GIV(freeStart) += numBytes1;
	newLargeInteger1 = newObj1;
l5:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
	
#  if VMBIGENDIAN
	byteAtput((newLargeInteger1 + BaseHeaderSize) + 3, (((usqInt) integerValue1) >> 24) & 0xFF);
	byteAtput((newLargeInteger1 + BaseHeaderSize) + 2, (((usqInt) integerValue1) >> 16) & 0xFF);
	byteAtput((newLargeInteger1 + BaseHeaderSize) + 1, (((usqInt) integerValue1) >> 8) & 0xFF);
	byteAtput((newLargeInteger1 + BaseHeaderSize), integerValue1 & 0xFF);

#  else /* VMBIGENDIAN */
	long32Atput((newLargeInteger1 + BaseHeaderSize) + (0 << 2), integerValue1);

#  endif /* VMBIGENDIAN */

	v2 = newLargeInteger1;
l6:	/* end maybeInlinePositive32BitIntegerFor: */;
	goto l2;

l2:	/* end positive32BitIntegerFor: */;
	if (GIV(primFailCode)) {
		/* begin popRemappableOop */
		oop = GIV(remapBuffer)[GIV(remapBufferCount)];
		GIV(remapBufferCount) -= 1;
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin storePointer:ofObject:withValue: */
	objOop3 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop3)));
	if (isOldObject(objOop3)) {

		/* most stores into young objects */

		if (((v1 & (tagMask())) == 0)
		 && (oopisLessThan(v1, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objOop3))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(objOop3);
			}
		}
	}
	longAtput((objOop3 + BaseHeaderSize) + (1 << (shiftForWord())), v1);
	/* begin storePointerUnchecked:ofObject:withValue: */
	objOop1 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop1)));
	longAtput((objOop1 + BaseHeaderSize) + (2 << (shiftForWord())), ((uidx << 1) | 1));
	/* begin storePointer:ofObject:withValue: */
	objOop4 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop4)));
	if (isOldObject(objOop4)) {

		/* most stores into young objects */

		if (((v2 & (tagMask())) == 0)
		 && (oopisLessThan(v2, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(objOop4))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(objOop4);
			}
		}
	}
	longAtput((objOop4 + BaseHeaderSize) + (3 << (shiftForWord())), v2);
	/* begin storePointerUnchecked:ofObject:withValue: */
	objOop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	assert(!(isForwarded(objOop2)));
	longAtput((objOop2 + BaseHeaderSize) + (4 << (shiftForWord())), ((midx << 1) | 1));
	/* begin pop:thenPush: */
	/* begin popRemappableOop */
	oop2 = GIV(remapBuffer)[GIV(remapBufferCount)];
	GIV(remapBufferCount) -= 1;
	oop1 = oop2;
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oop1);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveClosureValue */
static void
primitiveClosureValue(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    char * object;
    sqInt object1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt theMethod;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (ClosureNumArgsIndex << (shiftForWord())));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << (shiftForWord())));
	if (!(((outerContext & (tagMask())) == 0)
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << (shiftForWord())));
	if (!(((closureMethod & (tagMask())) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	/* begin followField:ofObject: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, blockClosure, objOop);
	}
	outerContext1 = objOop;
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	/* begin followField:ofObject: */
	objOop1 = longAt((outerContext1 + BaseHeaderSize) + (MethodIndex << (shiftForWord())));
	if (((objOop1 & (tagMask())) == 0)
	 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(MethodIndex, outerContext1, objOop1);
	}
	theMethod = objOop1;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), theMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + (0)) + (1 << ((BytesPerWord * 8) - 24))
		: ((1 + (numArgs << 8)) + (0)) + (1 << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	/* begin followField:ofObject: */
	objOop2 = longAt((outerContext1 + BaseHeaderSize) + (ReceiverIndex << (shiftForWord())));
	if (((objOop2 & (tagMask())) == 0)
	 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop2 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext1, objOop2);
	}
	object1 = objOop2;
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (ClosureStartPCIndex << (shiftForWord())));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = theMethod;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 256
		: 0);

	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	An exact clone of primitiveClosureValue except that this version will not
	check for interrupts on stack overflow. It may invoke the garbage
	collector but will not switch processes. See
	checkForInterruptsMayContextSwitch:  */

	/* InterpreterPrimitives>>#primitiveClosureValueNoContextSwitch */
void
primitiveClosureValueNoContextSwitch(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt numArgs;
    sqInt numCopied;
    char * object;
    sqInt object1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    sqInt theMethod;

	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (ClosureNumArgsIndex << (shiftForWord())));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(GIV(argumentCount) == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << (shiftForWord())));
	if (!(((outerContext & (tagMask())) == 0)
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << (shiftForWord())));
	if (!(((closureMethod & (tagMask())) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	/* begin followField:ofObject: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, blockClosure, objOop);
	}
	outerContext1 = objOop;
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	/* begin followField:ofObject: */
	objOop1 = longAt((outerContext1 + BaseHeaderSize) + (MethodIndex << (shiftForWord())));
	if (((objOop1 & (tagMask())) == 0)
	 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(MethodIndex, outerContext1, objOop1);
	}
	theMethod = objOop1;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), theMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + (0)) + (1 << ((BytesPerWord * 8) - 24))
		: ((1 + (numArgs << 8)) + (0)) + (1 << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	/* begin followField:ofObject: */
	objOop2 = longAt((outerContext1 + BaseHeaderSize) + (ReceiverIndex << (shiftForWord())));
	if (((objOop2 & (tagMask())) == 0)
	 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop2 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext1, objOop2);
	}
	object1 = objOop2;
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (ClosureStartPCIndex << (shiftForWord())));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = theMethod;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 256
		: 0);

	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(0);
	}
}

	/* InterpreterPrimitives>>#primitiveClosureValueWithArgs */
static void
primitiveClosureValueWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt blockClosure;
    sqInt closureIP;
    sqInt closureMethod;
    sqInt i;
    sqInt index;
    sqInt numArgs;
    sqInt numCopied;
    usqInt numSlots;
    char * object;
    sqInt object1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop2;
    sqInt oop;
    sqInt oop1;
    sqInt outerContext;
    sqInt outerContext1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt theMethod;
    sqInt top;

	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift())) & (formatMask())) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask())
		? longAt(argumentArray - BaseHeaderSize)
		: numSlots);
	if (!(roomToPushNArgs(arraySize))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	blockClosure = longAt(GIV(stackPointer) + (GIV(argumentCount) * BytesPerWord));
	/* begin quickFetchInteger:ofObject: */
	oop = longAt((blockClosure + BaseHeaderSize) + (ClosureNumArgsIndex << (shiftForWord())));
	assert((oop & 1));
	numArgs = (oop >> 1);
	if (!(arraySize == numArgs)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	outerContext = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << (shiftForWord())));
	if (!(((outerContext & (tagMask())) == 0)
		 && (((longAt(outerContext)) & (classIndexMask())) == ClassMethodContextCompactIndex))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}

	/* Check if the closure's method is actually a CompiledMethod. */

	closureMethod = longAt((outerContext + BaseHeaderSize) + (MethodIndex << (shiftForWord())));
	if (!(((closureMethod & (tagMask())) == 0)
		 && (((((usqInt) (longAt(closureMethod))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	index = 1;
	while (index <= numArgs) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((index - 1) << (shiftForWord()))));
		GIV(stackPointer) = sp;
		index += 1;
	}
	/* begin activateNewClosureMethod:numArgs:mayContextSwitch: */
	/* begin followField:ofObject: */
	objOop = longAt((blockClosure + BaseHeaderSize) + (ClosureOuterContextIndex << (shiftForWord())));
	if (((objOop & (tagMask())) == 0)
	 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop = fixFollowedFieldofObjectwithInitialValue(ClosureOuterContextIndex, blockClosure, objOop);
	}
	outerContext1 = objOop;
	numCopied = (numSlotsOf(blockClosure)) - ClosureFirstCopiedValueIndex;
	/* begin followField:ofObject: */
	objOop1 = longAt((outerContext1 + BaseHeaderSize) + (MethodIndex << (shiftForWord())));
	if (((objOop1 & (tagMask())) == 0)
	 && (((longAt(objOop1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop1 = fixFollowedFieldofObjectwithInitialValue(MethodIndex, outerContext1, objOop1);
	}
	theMethod = objOop1;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp2;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), theMethod);
	GIV(stackPointer) = sp3;
	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + (0)) + (1 << ((BytesPerWord * 8) - 24))
		: ((1 + (numArgs << 8)) + (0)) + (1 << 24));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	/* begin followField:ofObject: */
	objOop2 = longAt((outerContext1 + BaseHeaderSize) + (ReceiverIndex << (shiftForWord())));
	if (((objOop2 & (tagMask())) == 0)
	 && (((longAt(objOop2)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		objOop2 = fixFollowedFieldofObjectwithInitialValue(ReceiverIndex, outerContext1, objOop2);
	}
	object1 = objOop2;
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), object1);
	GIV(stackPointer) = sp6;
	for (i = 0; i < numCopied; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), longAt((blockClosure + BaseHeaderSize) + ((i + ClosureFirstCopiedValueIndex) << (shiftForWord()))));
		GIV(stackPointer) = sp7;
	}
	assert(frameIsBlockActivation(GIV(framePointer)));
	assert(!(frameHasContext(GIV(framePointer))));
	/* begin quickFetchInteger:ofObject: */
	oop1 = longAt((blockClosure + BaseHeaderSize) + (ClosureStartPCIndex << (shiftForWord())));
	assert((oop1 & 1));
	closureIP = (oop1 >> 1);
	GIV(instructionPointer) = ((theMethod + closureIP) + BaseHeaderSize) - 2;
	/* begin setMethod: */
	GIV(method) = theMethod;
	assert(isOopCompiledMethod(GIV(method)));
	GIV(bytecodeSetSelector) = (methodUsesAlternateBytecodeSet(GIV(method))
		? 256
		: 0);

	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(1);
	}
}


/*	Primitive. Compare two byte-indexed objects for equality */

	/* InterpreterPrimitives>>#primitiveCompareBytes */
EXPORT(void)
primitiveCompareBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg1;
    sqInt arg2;
    sqInt fmt;
    sqInt fmt1;
    sqInt i;
    sqInt len1;
    sqInt len2;
    usqInt numBytes;
    usqInt numBytes1;
    usqInt numSlots;
    usqInt numSlots1;
    char *sp;
    char *sp1;
    char *sp2;
    char *sp3;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	arg1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	arg2 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((((arg1 & (tagMask())) == 0)
		 && (((((usqInt) (longAt(arg1))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))
		 && (((arg2 & (tagMask())) == 0)
		 && (((((usqInt) (longAt(arg2))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (arg1 == arg2) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin byteSizeOf: */
	if ((arg1 & (tagMask())) != 0) {
		len1 = 0;
		goto l1;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(arg1))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(arg1)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(arg1 + 7);
	numBytes = (numSlots == (numSlotsMask())
		? longAt(arg1 - BaseHeaderSize)
		: numSlots);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */

		len1 = numBytes - (fmt & 7);
		goto l3;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		len1 = numBytes;
		goto l3;
	}
	if (fmt >= (firstShortFormat())) {
		len1 = numBytes - ((fmt & 3) << 1);
		goto l3;
	}
	len1 = numBytes - ((fmt & 1) << 2);
l3:	/* end numBytesOf: */;
l1:	/* end byteSizeOf: */;
	/* begin byteSizeOf: */
	if ((arg2 & (tagMask())) != 0) {
		len2 = 0;
		goto l2;
	}
	/* begin numBytesOf: */
	fmt1 = (((usqInt) (longAt(arg2))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(arg2)) > (isForwardedObjectClassIndexPun()));
	numSlots1 = byteAt(arg2 + 7);
	numBytes1 = (numSlots1 == (numSlotsMask())
		? longAt(arg2 - BaseHeaderSize)
		: numSlots1);
	numBytes1 = numBytes1 << (shiftForWord());
	if (fmt1 >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */

		len2 = numBytes1 - (fmt1 & 7);
		goto l4;
	}
	if (fmt1 <= (sixtyFourBitIndexableFormat())) {
		len2 = numBytes1;
		goto l4;
	}
	if (fmt1 >= (firstShortFormat())) {
		len2 = numBytes1 - ((fmt1 & 3) << 1);
		goto l4;
	}
	len2 = numBytes1 - ((fmt1 & 1) << 2);
l4:	/* end numBytesOf: */;
l2:	/* end byteSizeOf: */;
	if (!(len1 == len2)) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp1;
		return;
	}
	for (i = 0; i < len1; i += 1) {
		if (!((byteAt((arg1 + BaseHeaderSize) + i)) == (byteAt((arg2 + BaseHeaderSize) + i)))) {
			/* begin pop:thenPush: */
			longAtput((sp2 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(falseObj));
			GIV(stackPointer) = sp2;
			return;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp3 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), GIV(trueObj));
	GIV(stackPointer) = sp3;
}


/*	Fill the receiver, which must be an indexable bytes or words 
	objects, with the given integer value. */

	/* InterpreterPrimitives>>#primitiveConstantFill */
static void
primitiveConstantFill(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqInt end;
    sqInt fillValue;
    usqInt i;
    sqInt rcvr;
    sqInt rcvrIsBytes;
    sqInt successBoolean;
    sqInt successBoolean1;

	fillValue = positive32BitValueOf(longAt(GIV(stackPointer)));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin success: */
	successBoolean1 = ((rcvr & (tagMask())) == 0)
	 && (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())));
	if (!successBoolean1) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	rcvrIsBytes = ((rcvr & (tagMask())) == 0)
	 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) >= (firstByteFormat()));
	if (rcvrIsBytes) {
		/* begin success: */
		successBoolean = (fillValue >= 0)
		 && (fillValue <= 0xFF);
		if (!successBoolean) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		end = rcvr + (((numSlotsOf(rcvr)) << (shiftForWord())) + BaseHeaderSize);
		i = rcvr + BaseHeaderSize;
		if (rcvrIsBytes) {
			fillValue = fillValue & 0xFF;
			fillValue = ((fillValue + (fillValue << 8)) + (fillValue << 16)) + (fillValue << 24);
		}
		while (i < end) {
			long32Atput(i, fillValue);
			i += 4;
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Start or stop the VM profiler. The first argument is a boolean
	to switch profiling on or off. The second argument is an integer or nil.
	If an integer it determines the maximum number of samples in the VM's
	sample buffer. Answer the current number of samples in the buffer. */

	/* InterpreterPrimitives>>#primitiveControlVMProfiling */
static void
primitiveControlVMProfiling(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bufferSize;
    sqInt numSamples;
    sqInt onOffBar;
    char *sp;

	if (GIV(argumentCount) != 2) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((onOffBar = longAt(GIV(stackPointer) + (1 * BytesPerWord)))) == GIV(trueObj)) {
		onOffBar = 1;
	}
	else {
		if (onOffBar == GIV(falseObj)) {
			onOffBar = 0;
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	if (((bufferSize = longAt(GIV(stackPointer)))) == GIV(nilObj)) {
		bufferSize = 0;
	}
	else {
		if (!(((bufferSize & 1))
			 && (((bufferSize = (bufferSize >> 1))) > 0))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
	}
	numSamples = ioControlNewProfile(onOffBar,bufferSize);
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), ((numSamples << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Primitive. Copy the state of the receiver from the argument. 
	Fail if receiver and argument are of a different class.
	Fail if the receiver or argument are contexts (because of context-to-stack
	mapping). Fail if receiver and argument have different lengths (for
	indexable objects).
	Fail if the objects are not in a fit state to be copied (e.g. married
	contexts and Cogged methods) */

	/* InterpreterPrimitives>>#primitiveCopyObject */
static void
primitiveCopyObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    sqInt fmt;
    sqInt i;
    usqInt length;
    usqInt numBytes;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    sqInt valuePointer;

	if (!(GIV(argumentCount) >= 1)) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}
	arg = longAt(GIV(stackPointer));
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((rcvr & (tagMask())) != 0) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if ((arg & (tagMask())) != 0) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (((longAt(rcvr)) & (classIndexMask())) != ((longAt(arg)) & (classIndexMask()))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	if (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))) {
		/* begin numBytesOf: */
		fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots1 = byteAt(rcvr + 7);
		numBytes = (numSlots1 == (numSlotsMask())
			? longAt(rcvr - BaseHeaderSize)
			: numSlots1);
		numBytes = numBytes << (shiftForWord());
		if (fmt >= (firstByteFormat())) {

			/* bytes (the common case), including CompiledMethod */

			length = ((sqInt) (numBytes - (fmt & 7)));
			goto l1;
		}
		if (fmt <= (sixtyFourBitIndexableFormat())) {
			length = ((sqInt) numBytes);
			goto l1;
		}
		if (fmt >= (firstShortFormat())) {
			length = ((sqInt) (numBytes - ((fmt & 3) << 1)));
			goto l1;
		}
		length = ((sqInt) (numBytes - ((fmt & 1) << 2)));
	l1:	/* end numBytesOf: */;
		if (!((((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) == ((((usqInt) (longAt(arg))) >> (formatShift())) & (formatMask())))
			 && (length == (numBytesOf(arg))))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		memcpy(((void *)(rcvr + BaseHeaderSize)), ((void *)(arg + BaseHeaderSize)), length);
	}
	else {
		if (!(isAppropriateForCopyObject(rcvr))) {
			(GIV(primFailCode) = PrimErrBadReceiver);
			return;
		}
		/* begin numSlotsOf: */
		flag("endianness");
		assert((classIndexOf(rcvr)) > (isForwardedObjectClassIndexPun()));
		numSlots = byteAt(rcvr + 7);
		length = (numSlots == (numSlotsMask())
			? longAt(rcvr - BaseHeaderSize)
			: numSlots);
		if (!((isAppropriateForCopyObject(arg))
			 && (length == (lengthOfformat(arg, (((usqInt) (longAt(arg))) >> (formatShift())) & (formatMask())))))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		for (i = 0; i < length; i += 1) {
			/* begin storePointer:ofObject:withValue: */
			valuePointer = longAt((arg + BaseHeaderSize) + (i << (shiftForWord())));
			assert(!(isForwarded(rcvr)));
			if (isOldObject(rcvr)) {

				/* most stores into young objects */

				if (((valuePointer & (tagMask())) == 0)
				 && (oopisLessThan(valuePointer, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(rcvr))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(rcvr);
					}
				}
			}
			longAtput((rcvr + BaseHeaderSize) + (i << (shiftForWord())), valuePointer);
		}
	}
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}


/*	Crash the VM by indirecting through a null pointer. If the sole argument
	is true crash in this thread, and if it is false crash in a new thread. If
	the argument is an integer use the method that implies.
	bit 0 = thread to crash in; 1 => this thread
	bit 1 = crash method; 0 => indirect through null pointer; 1 => call exit */

	/* InterpreterPrimitives>>#primitiveCrashVM */
EXPORT(sqInt)
primitiveCrashVM(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt crashInThisThread;

	if (((longAt(GIV(stackPointer))) & 1)) {
		crashInThisThread = ((longAt(GIV(stackPointer))) >> 1);
	}
	else {
		/* begin booleanValueOf: */
		if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
			crashInThisThread = 1;
			goto l1;
		}
		if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
			crashInThisThread = 0;
			goto l1;
		}
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		crashInThisThread = null;
	l1:	/* end booleanValueOf: */;
	}
	if (GIV(primFailCode)
	 || (GIV(argumentCount) != 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	crashInThisOrAnotherThread(crashInThisThread);
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Pass in a non-negative value to disable the architectures powermanager if
	any, zero to enable. This is a named (not numbered) primitive in the null
	module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveDisablePowerManager */
EXPORT(sqInt)
primitiveDisablePowerManager(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integer;
    sqInt integerPointer;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integer = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integer = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioDisablePowerManager(integer);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveDiv */
static void
primitiveDiv(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt quotient;
    char *sp;

	quotient = doPrimitiveDivby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)(quotient ^ (quotient << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((quotient << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}

	/* InterpreterPrimitives>>#primitiveDivide */
static void
primitiveDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerReceiver;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerReceiver = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerReceiver = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArgument = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArgument = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if ((integerArgument != 0)
	 && ((integerReceiver % integerArgument) == 0)) {
		/* begin pop2AndPushIntegerIfOK: */
		if (!GIV(primFailCode)) {
			if ((((sqInt)((integerReceiver / integerArgument) ^ ((integerReceiver / integerArgument) << 1)))) >= 0) {
				/* begin pop:thenPush: */
				longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (((integerReceiver / integerArgument) << 1) | 1));
				GIV(stackPointer) = sp;
			}
			else {
				/* begin success: */
				
				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}

			}
		}
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivideLargeIntegers */
EXPORT(void)
primitiveDivideLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if (!((b != 0)
		 && ((a % b) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveDivLargeIntegers */
EXPORT(void)
primitiveDivLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong rem;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	if (!(a == 0)) {
		if (!(bIsNegative == aIsNegative)) {

			/* Round toward negative infinity */

			rem = a % b;
			if (!(rem == 0)) {

				/* This can not overflow, because b > 1, otherwise rem = 0 */

				result += 1;
			}
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Attempt to enter a CriticalSection/Mutex. If not owned, set the owner to
	the current
	process and answer false. If owned by the current process answer true.
	Otherwise suspend the process. Answer if the receiver is owned by the
	current process.
	For simulation if there is an argument it is taken to be the effective
	activeProcess (see Process>>effectiveProcess). */

	/* InterpreterPrimitives>>#primitiveEnterCriticalSection */
static void
primitiveEnterCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt activeProc;
    sqInt criticalSection;
    sqInt objOop;
    sqInt owningProcess;
    sqInt owningProcessIndex;
    char *sp;
    char *sp1;
    char *sp2;

	if (GIV(argumentCount) > 0) {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer) + (1 * BytesPerWord));
		activeProc = longAt(GIV(stackPointer));
	}
	else {

		/* rcvr */

		criticalSection = longAt(GIV(stackPointer));
		/* begin fetchPointer:ofObject: */
		/* begin fetchPointer:ofObject: */
		objOop = longAt(((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SchedulerAssociation << (shiftForWord())))) + BaseHeaderSize) + (ValueIndex << (shiftForWord())));
		activeProc = longAt((objOop + BaseHeaderSize) + (ActiveProcessIndex << (shiftForWord())));
	}

	/* CriticalSections are laid out like Semaphores */

	owningProcessIndex = ExcessSignalsIndex;
	owningProcess = longAt((criticalSection + BaseHeaderSize) + (owningProcessIndex << (shiftForWord())));
	if (owningProcess == GIV(nilObj)) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		if (isOldObject(criticalSection)) {

			/* most stores into young objects */

			if (((activeProc & (tagMask())) == 0)
			 && (oopisLessThan(activeProc, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(criticalSection))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(criticalSection);
				}
			}
		}
		longAtput((criticalSection + BaseHeaderSize) + (owningProcessIndex << (shiftForWord())), activeProc);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
		GIV(stackPointer) = sp;
		return;
	}
	if (owningProcess == activeProc) {
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(trueObj));
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), GIV(falseObj));
	GIV(stackPointer) = sp2;
	addLastLinktoList(activeProc, criticalSection);
	transferTo(wakeHighestPriority());
}

	/* InterpreterPrimitives>>#primitiveEqual */
static void
primitiveEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver == integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (positiveMachineIntegerValueOf(integerReceiver)) == (positiveMachineIntegerValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveEqualLargeIntegers */
EXPORT(void)
primitiveEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr == integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Exit the critical section.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveExitCriticalSection */
static void
primitiveExitCriticalSection(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt criticalSection;
    sqInt owningProcess;
    sqInt owningProcessIndex;


	/* rcvr */

	criticalSection = longAt(GIV(stackPointer));

	/* CriticalSections are laid out like Semaphores */

	owningProcessIndex = ExcessSignalsIndex;
	if (isEmptyList(criticalSection)) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		longAtput((criticalSection + BaseHeaderSize) + (owningProcessIndex << (shiftForWord())), GIV(nilObj));
	}
	else {

		/* store check unnecessary because criticalSection referred to owningProcess
		   via its FirstLinkIndex slot before owningProcess was removed. */

		owningProcess = removeFirstLinkOfList(criticalSection);
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(criticalSection)));
		longAtput((criticalSection + BaseHeaderSize) + (owningProcessIndex << (shiftForWord())), owningProcess);
		resumepreemptedYieldingIf(owningProcess, GIV(preemptionYields));
	}
}

	/* InterpreterPrimitives>>#primitiveExitToDebugger */
static void
primitiveExitToDebugger(void)
{
	error("Exit to debugger at user request");
}


/*	Computes E raised to the receiver power. */

	/* InterpreterPrimitives>>#primitiveExp */
static void
primitiveExp(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	isFloat = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l1;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = exp(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Exponent part of this float. */

	/* InterpreterPrimitives>>#primitiveExponent */
static void
primitiveExponent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double frac;
    sqInt isFloat;
    sqInt oop;
    int pwr;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	isFloat = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l1;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {

		/* rcvr = frac * 2^pwr, where frac is in [0.5..1.0) */

		frac = frexp(rcvr, &pwr);
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), (((pwr - 1) << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Set general (unspecified) primitive failure. Don't overwrite an error code
	that has already been set. */
/*	Use returnTypeC: #sqInt because that's the way it is defined in sq.h.
	Use no explicit return so that Slang doesn't fail an inlining type-check
	when a primitive with return type void uses ^self primitiveFail to exit. */

	/* InterpreterPrimitives>>#primitiveFail */
sqInt
primitiveFail(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Set specific primitive failure.
	N.B. primitiveFailFor: PrimNoErr is expected to clear the primFailCode. */

	/* InterpreterPrimitives>>#primitiveFailFor: */
sqInt
primitiveFailFor(sqInt reasonCode)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return (GIV(primFailCode) = reasonCode);
}

	/* InterpreterPrimitives>>#primitiveFailureCode */
sqInt
primitiveFailureCode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(primFailCode);
}

	/* InterpreterPrimitives>>#primitiveFetchNextMourner */
static void
primitiveFetchNextMourner(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mourner;
    char *sp;

	mourner = popObjStack(GIV(mournQueue));
	if (mourner == null) {
		GIV(primFailCode) = PrimErrNotFound;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), mourner);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatAdd */
static void
primitiveFloatAdd(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatAdd:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	isFloat1 = ((argOop & (tagMask())) == 0)
	 && (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr + arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAt */
static void
primitiveFloatAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt integerValue;
    sqInt integerValue1;
    sqInt newLargeInteger;
    sqInt newLargeInteger1;
    usqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    usqInt numBytes1;
    sqInt objFormat;
    sqInt objFormat1;
    sqInt rcvr;
    sqInt reasonCode;
    usqInt result;
    char *sp;
    char *sp1;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	index = longAt(GIV(stackPointer));
	if (index == ConstOne) {
		/* begin positive32BitIntegerFor: */
		/* begin fetchLong32:ofFloatObject: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		integerValue = long32At((rcvr + BaseHeaderSize) + (fieldIndex << 2));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if (((((sqInt)integerValue)) >= 0)
		 && ((((sqInt)(integerValue ^ (integerValue << 1)))) >= 0)) {
			result = ((integerValue << 1) | 1);
			goto l4;
		}
		/* begin eeInstantiateSmallClassIndex:format:numSlots: */
		objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
		assert(ClassLargePositiveIntegerCompactIndex != 0);
		assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
		/* begin allocateSmallNewSpaceSlots:format:classIndex: */
		assert(1 < (numSlotsMask()));
		newObj = GIV(freeStart);
		numBytes = BaseHeaderSize + (8);
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj % (allocationUnit())) == 0);
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
				error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
				newLargeInteger = 0;
				goto l3;
			}
		}
		long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
		GIV(freeStart) += numBytes;
		newLargeInteger = newObj;
	l3:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
		
#    if VMBIGENDIAN
		byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
		byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#    else /* VMBIGENDIAN */
		long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), integerValue);

#    endif /* VMBIGENDIAN */

		result = newLargeInteger;
	l4:	/* end maybeInlinePositive32BitIntegerFor: */;
		goto l1;

	l1:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin positive32BitIntegerFor: */
		/* begin fetchLong32:ofFloatObject: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		integerValue1 = long32At((rcvr + BaseHeaderSize) + (fieldIndex1 << 2));
		/* begin maybeInlinePositive32BitIntegerFor: */
		assert(!((hasSixtyFourBitImmediates())));
		if (((((sqInt)integerValue1)) >= 0)
		 && ((((sqInt)(integerValue1 ^ (integerValue1 << 1)))) >= 0)) {
			result = ((integerValue1 << 1) | 1);
			goto l6;
		}
		/* begin eeInstantiateSmallClassIndex:format:numSlots: */
		objFormat1 = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
		assert(ClassLargePositiveIntegerCompactIndex != 0);
		assert(((objFormat1 < (firstByteFormat())
	? objFormat1
	: objFormat1 & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
		/* begin allocateSmallNewSpaceSlots:format:classIndex: */
		assert(1 < (numSlotsMask()));
		newObj1 = GIV(freeStart);
		numBytes1 = BaseHeaderSize + (8);
		assert((numBytes1 % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		if ((GIV(freeStart) + numBytes1) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			if ((GIV(freeStart) + numBytes1) > (((eden()).limit))) {
				error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
				newLargeInteger1 = 0;
				goto l5;
			}
		}
		long64Atput(newObj1, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat1 << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
		GIV(freeStart) += numBytes1;
		newLargeInteger1 = newObj1;
	l5:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
		
#    if VMBIGENDIAN
		byteAtput((newLargeInteger1 + BaseHeaderSize) + 3, (((usqInt) integerValue1) >> 24) & 0xFF);
		byteAtput((newLargeInteger1 + BaseHeaderSize) + 2, (((usqInt) integerValue1) >> 16) & 0xFF);
		byteAtput((newLargeInteger1 + BaseHeaderSize) + 1, (((usqInt) integerValue1) >> 8) & 0xFF);
		byteAtput((newLargeInteger1 + BaseHeaderSize), integerValue1 & 0xFF);

#    else /* VMBIGENDIAN */
		long32Atput((newLargeInteger1 + BaseHeaderSize) + (0 << 2), integerValue1);

#    endif /* VMBIGENDIAN */

		result = newLargeInteger1;
	l6:	/* end maybeInlinePositive32BitIntegerFor: */;
		goto l2;

	l2:	/* end positive32BitIntegerFor: */;
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}


/*	Provide platform-independent access to 32-bit words comprising
	a Float. Map index 1 onto the most significant word and index 2
	onto the least significant word. */

	/* InterpreterPrimitives>>#primitiveFloatAtPut */
static void
primitiveFloatAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fieldIndex;
    sqInt fieldIndex1;
    sqInt index;
    sqInt oopToStore;
    sqInt rcvr;
    sqInt reasonCode;
    char *sp;
    char *sp1;
    usqInt valueToStore;

	oopToStore = longAt(GIV(stackPointer));
	valueToStore = positive32BitValueOf(oopToStore);
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	
	if (index == ConstOne) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex = (VMBIGENDIAN
			? 0
			: 1);
		long32Atput((rcvr + BaseHeaderSize) + (fieldIndex << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp;
		return;
	}
	if (index == ConstTwo) {
		/* begin storeLong32:ofObject:withValue: */
		fieldIndex1 = (VMBIGENDIAN
			? 1
			: 0);
		long32Atput((rcvr + BaseHeaderSize) + (fieldIndex1 << 2), valueToStore);
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), oopToStore);
		GIV(stackPointer) = sp1;
		return;
	}
	/* begin primitiveFailFor: */
	reasonCode = ((index & 1)
		? PrimErrBadIndex
		: PrimErrBadArgument);
	GIV(primFailCode) = reasonCode;
}

	/* InterpreterPrimitives>>#primitiveFloatDivide */
static void
primitiveFloatDivide(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatDivide:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	isFloat1 = ((argOop & (tagMask())) == 0)
	 && (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	/* begin success: */
	if (!(arg != 0.0)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr / arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatEqual */
static void
primitiveFloatEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt isFloat;
    sqInt isFloat1;
    sqInt oop;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer));
	isFloat1 = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterOrEqual */
static void
primitiveFloatGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt isFloat;
    sqInt isFloat1;
    sqInt oop;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatGreaterOrEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer));
	isFloat1 = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr >= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatGreaterThan */
static void
primitiveFloatGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt isFloat;
    sqInt isFloat1;
    sqInt oop;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatGreater:thanArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer));
	isFloat1 = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr > arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessOrEqual */
static void
primitiveFloatLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt isFloat;
    sqInt isFloat1;
    sqInt oop;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatLessOrEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer));
	isFloat1 = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr <= arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatLessThan */
static void
primitiveFloatLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt isFloat;
    sqInt isFloat1;
    sqInt oop;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatLess:thanArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer));
	isFloat1 = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr < arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatMultiply */
static void
primitiveFloatMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatMultiply:byArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	isFloat1 = ((argOop & (tagMask())) == 0)
	 && (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr * arg));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatNotEqual */
static void
primitiveFloatNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt aBool;
    double arg;
    sqInt isFloat;
    sqInt isFloat1;
    sqInt oop;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatEqual:toArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if (((longAt(GIV(stackPointer))) & 1)) {
		arg = ((double) (((longAt(GIV(stackPointer))) >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer));
	isFloat1 = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	aBool = rcvr == arg;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (!aBool
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveFloatSubtract */
static void
primitiveFloatSubtract(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double arg;
    sqInt argOop;
    sqInt isFloat;
    sqInt isFloat1;
    double rcvr;
    sqInt rcvrOop;
    double result;
    double result1;
    char *sp;

	/* begin primitiveFloatSubtract:fromArg: */
	rcvrOop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argOop = longAt(GIV(stackPointer));
	/* begin loadFloatOrIntFrom: */
	if ((rcvrOop & 1)) {
		rcvr = ((double) ((rcvrOop >> 1)) );
		goto l1;
	}
	/* begin floatValueOf: */
	isFloat = ((rcvrOop & (tagMask())) == 0)
	 && (((longAt(rcvrOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(rcvrOop + BaseHeaderSize, result);
		rcvr = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l3:	/* end floatValueOf: */;
l1:	/* end loadFloatOrIntFrom: */;
	/* begin loadFloatOrIntFrom: */
	if ((argOop & 1)) {
		arg = ((double) ((argOop >> 1)) );
		goto l2;
	}
	/* begin floatValueOf: */
	isFloat1 = ((argOop & (tagMask())) == 0)
	 && (((longAt(argOop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(argOop + BaseHeaderSize, result1);
		arg = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	arg = 0.0;
l4:	/* end floatValueOf: */;
l2:	/* end loadFloatOrIntFrom: */;
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushFloat: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), floatObjectOf(rcvr - arg));
		GIV(stackPointer) = sp;
	}
	return;
}


/*	Clear the method lookup cache. This must be done after every programming
	change. 
 */

	/* InterpreterPrimitives>>#primitiveFlushCache */
static void
primitiveFlushCache(void)
{
	flushMethodCache();
}


/*	Primitive. Flush all the existing external primitives in the image thus
	forcing a reload on next invokation.
 */

	/* InterpreterPrimitives>>#primitiveFlushExternalPrimitives */
static void
primitiveFlushExternalPrimitives(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt address;
    sqInt address1;
    sqInt firstBytecode;
    sqInt firstBytecode1;
    sqInt firstBytecode2;
    sqInt i;
    usqInt limit;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt methodHeader2;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt objOop;
    sqInt objOop1;
    sqInt objOop11;
    sqInt objOop2;
    sqInt oop;
    sqInt prevObj;
    sqInt prevObj1;
    sqInt prevPrevObj;
    sqInt prevPrevObj1;
    sqInt primBits;
    sqInt primBits1;
    sqInt primBits2;
    sqInt primIdx;

	/* begin flushExternalPrimitives */
	/* begin allObjectsDo: */
	/* begin allNewSpaceObjectsDo: */
	/* begin allNewSpaceEntitiesDo: */

	/* After a scavenge eden is empty, futureSpace is empty, and all newSpace objects are
	   in pastSpace.  Objects are allocated in eden.  So enumerate only pastSpace and eden. */

	prevPrevObj = (prevObj = null);
	assert((((pastSpace()).start)) < (((eden()).start)));
	/* begin objectStartingAt: */
	address = ((pastSpace()).start);
	numSlots = byteAt(address + 7);
	objOop1 = (numSlots == (numSlotsMask())
		? address + BaseHeaderSize
		: address);
	limit = GIV(pastSpaceStart);
	while (oopisLessThan(objOop1, limit)) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & (classIndexMask())) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */

				/* begin primitiveIndexOfMethod:header: */
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objOop1));
				methodHeader = longAt((objOop1 + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
				if (methodHeader & AlternateHeaderHasPrimFlag) {
					firstBytecode = (objOop1 + ((LiteralStart + (((methodHeader >> 1)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
					primIdx = (byteAt(firstBytecode + 1)) + ((byteAt(firstBytecode + 2)) << 8);
				}
				else {
					primIdx = 0;
				}

				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */

					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, limit);
	}
	/* begin objectStartingAt: */
	address1 = ((eden()).start);
	numSlots1 = byteAt(address1 + 7);
	objOop1 = (numSlots1 == (numSlotsMask())
		? address1 + BaseHeaderSize
		: address1);
	while (oopisLessThan(objOop1, GIV(freeStart))) {
		assert(isEnumerableObjectNoAssert(objOop1));
		if (!(((longAt(objOop1)) & (classIndexMask())) == 0)) {
			if (((((usqInt) (longAt(objOop1))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {

				/* This is a compiled method */

				/* begin primitiveIndexOfMethod:header: */
				/* begin methodHeaderOf: */
				assert(isCompiledMethod(objOop1));
				methodHeader1 = longAt((objOop1 + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
				if (methodHeader1 & AlternateHeaderHasPrimFlag) {
					firstBytecode1 = (objOop1 + ((LiteralStart + (((methodHeader1 >> 1)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
					primIdx = (byteAt(firstBytecode1 + 1)) + ((byteAt(firstBytecode1 + 2)) << 8);
				}
				else {
					primIdx = 0;
				}

				if (primIdx == PrimitiveExternalCallIndex) {

					/* It's primitiveExternalCall */

					flushExternalPrimitiveOf(objOop1);
				}
			}
		}


		prevPrevObj = prevObj;
		prevObj = objOop1;
		objOop1 = objectAfterlimit(objOop1, GIV(freeStart));
	}
	
	
	/* begin allOldSpaceObjectsDo: */
	/* begin allOldSpaceObjectsFrom:do: */
	/* begin allOldSpaceEntitiesFrom:do: */
	assert(isOldObject(GIV(nilObj)));
	prevPrevObj1 = (prevObj1 = null);
	objOop11 = GIV(nilObj);
	while (1) {
		assert((objOop11 % (allocationUnit())) == 0);
		if (!(oopisLessThan(objOop11, GIV(endOfMemory)))) break;
		assert((long64At(objOop11)) != 0);
		if (isEnumerableObject(objOop11)) {
			if (!(((longAt(objOop11)) & (classIndexMask())) == 0)) {
				if (((((usqInt) (longAt(objOop11))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {

					/* This is a compiled method */

					/* begin primitiveIndexOfMethod:header: */
					/* begin methodHeaderOf: */
					assert(isCompiledMethod(objOop11));
					methodHeader2 = longAt((objOop11 + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
					if (methodHeader2 & AlternateHeaderHasPrimFlag) {
						firstBytecode2 = (objOop11 + ((LiteralStart + (((methodHeader2 >> 1)) & AlternateHeaderNumLiteralsMask)) * BytesPerOop)) + BaseHeaderSize;
						primIdx = (byteAt(firstBytecode2 + 1)) + ((byteAt(firstBytecode2 + 2)) << 8);
					}
					else {
						primIdx = 0;
					}

					if (primIdx == PrimitiveExternalCallIndex) {

						/* It's primitiveExternalCall */

						flushExternalPrimitiveOf(objOop11);
					}
				}
			}

		}

		prevPrevObj1 = prevObj1;
		prevObj1 = objOop11;
		objOop11 = objectAfterlimit(objOop11, GIV(endOfMemory));
	}
	
	
	flushMethodCache();
	/* begin flushExternalPrimitiveTable */
	for (i = 0; i < MaxExternalPrimitiveTableSize; i += 1) {
		externalPrimitiveTable[i] = 0;
	}
	GIV(externalPrimitiveTableFirstFreeIndex) = 0;
}


/*	On some platforms, this primitive forces enqueued display updates to be
	processed immediately. On others, it does nothing.
 */

	/* InterpreterPrimitives>>#primitiveForceDisplayUpdate */
static void
primitiveForceDisplayUpdate(void)
{
	ioForceDisplayUpdate();
}


/*	On platforms that support it, this primitive prints the receiver, assumed
	to be a Form, to the default printer.
 */

	/* InterpreterPrimitives>>#primitiveFormPrint */
static void
primitiveFormPrint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bitsArray;
    sqInt bitsArraySize;
    sqInt depth;
    sqInt fmt;
    sqInt h;
    double hScale;
    sqInt isFloat;
    sqInt isFloat1;
    sqInt landscapeFlag;
    usqInt numBytes;
    usqInt numSlots;
    sqInt ok;
    sqInt oop;
    sqInt oop1;
    sqInt pixelsPerWord;
    sqInt rcvr;
    double result;
    double result1;
    double vScale;
    sqInt w;
    sqInt wordsPerLine;

	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		landscapeFlag = 1;
		goto l2;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		landscapeFlag = 0;
		goto l2;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */

	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	landscapeFlag = null;
l2:	/* end booleanValueOf: */;
	/* begin floatValueOf: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	isFloat = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		vScale = result;
		goto l3;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	vScale = 0.0;
l3:	/* end floatValueOf: */;
	/* begin floatValueOf: */
	oop1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	isFloat1 = ((oop1 & (tagMask())) == 0)
	 && (((longAt(oop1)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat1) {
		;
		fetchFloatAtinto(oop1 + BaseHeaderSize, result1);
		hScale = result1;
		goto l4;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	hScale = 0.0;
l4:	/* end floatValueOf: */;
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if (!((((rcvr & (tagMask())) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) <= 5))
		 && ((lengthOfformat(rcvr, (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))) >= 4))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

	}
	if (!GIV(primFailCode)) {
		bitsArray = longAt((rcvr + BaseHeaderSize) + (0 << (shiftForWord())));
		w = fetchIntegerofObject(1, rcvr);
		h = fetchIntegerofObject(2, rcvr);
		depth = fetchIntegerofObject(3, rcvr);
		if (!((w > 0)
			 && (h > 0))) {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
		pixelsPerWord = 32 / depth;
		wordsPerLine = (w + (pixelsPerWord - 1)) / pixelsPerWord;
		if (((bitsArray & (tagMask())) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(bitsArray))) >> (formatShift())) & (formatMask())))) {
			/* begin numBytesOf: */
			fmt = (((usqInt) (longAt(bitsArray))) >> (formatShift())) & (formatMask());
			/* begin numSlotsOf: */
			flag("endianness");
			assert((classIndexOf(bitsArray)) > (isForwardedObjectClassIndexPun()));
			numSlots = byteAt(bitsArray + 7);
			numBytes = (numSlots == (numSlotsMask())
				? longAt(bitsArray - BaseHeaderSize)
				: numSlots);
			numBytes = numBytes << (shiftForWord());
			if (fmt >= (firstByteFormat())) {

				/* bytes (the common case), including CompiledMethod */

				bitsArraySize = numBytes - (fmt & 7);
				goto l1;
			}
			if (fmt <= (sixtyFourBitIndexableFormat())) {
				bitsArraySize = numBytes;
				goto l1;
			}
			if (fmt >= (firstShortFormat())) {
				bitsArraySize = numBytes - ((fmt & 3) << 1);
				goto l1;
			}
			bitsArraySize = numBytes - ((fmt & 1) << 2);
		l1:	/* end numBytesOf: */;
			/* begin success: */
			if (!(bitsArraySize == ((wordsPerLine * h) * 4))) {

				/* Don't overwrite an error code that has already been set. */

				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
	if (!GIV(primFailCode)) {
		ok = ioFormPrint(bitsArray + BaseHeaderSize, w, h, depth, hScale, vScale, landscapeFlag);
		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 3 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveFractionalPart */
static void
primitiveFractionalPart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double frac;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;
    double trunc;

	trunc = 0;
	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	isFloat = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l1;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		frac = modf(rcvr, (&trunc));
		/* begin pushFloat: */
		/* begin push: */
		object = floatObjectOf(frac);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Fetch the system attribute with the given integer ID. The 
	result is a string, which will be empty if the attribute is not 
	defined. */

	/* InterpreterPrimitives>>#primitiveGetAttribute */
static void
primitiveGetAttribute(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt attr;
    sqInt integerPointer;
    sqInt s;
    char *sp;
    sqInt sz;

	sz = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		attr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		attr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		sz = attributeSize(attr);
	}
	if (!GIV(primFailCode)) {
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteString << (shiftForWord()))), sz);
		getAttributeIntoLength(attr, s + BaseHeaderSize, sz);
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), s);
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Answer the VM's current log directory */

	/* InterpreterPrimitives>>#primitiveGetLogDirectory */
EXPORT(sqInt)
primitiveGetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    char*ptr;
    char *sp;
    sqInt stringOop;
    sqInt sz;

	ptr = ioGetLogDirectory();
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = strlen(ptr);
	stringOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteString << (shiftForWord()))), sz);
	for (i = 0; i < sz; i += 1) {
		byteAtput((stringOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), stringOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Return the next input event from the VM event queue. */

	/* InterpreterPrimitives>>#primitiveGetNextEvent */
static void
primitiveGetNextEvent(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;
    long eventTypeIs;
    long evtBuf[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    sqInt i;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt objFormat;
    long value;

	arg = longAt(GIV(stackPointer));
	if (!((((arg & (tagMask())) == 0)
		 && (((((usqInt) (longAt(arg))) >> (formatShift())) & (formatMask())) == 2))
		 && ((slotSizeOf(arg)) == 8))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	ioGetNextEvent(((sqInputEvent*) evtBuf));
	if (GIV(primFailCode)) {
		return;
	}
	eventTypeIs = evtBuf[0];
	/* begin storeInteger:ofObject:withValue: */
	if ((((sqInt)((evtBuf[0]) ^ ((evtBuf[0]) << 1)))) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(arg)));
		longAtput((arg + BaseHeaderSize) + (0 << (shiftForWord())), (((evtBuf[0]) << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	if (eventTypeIs == 6) {

		/* Event is Complex, assume evtBuf is populated correctly and return */

		for (i = 1; i <= 7; i += 1) {
			value = evtBuf[i];
			/* begin storePointer:ofObject:withValue: */
			assert(!(isForwarded(arg)));
			if (isOldObject(arg)) {

				/* most stores into young objects */

				if (((value & (tagMask())) == 0)
				 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
					/* begin possibleRootStoreInto: */
					if (!(((((usqInt) (longAt(arg))) >> (rememberedBitShift())) & 1) != 0)) {
						remember(arg);
					}
				}
			}
			longAtput((arg + BaseHeaderSize) + (i << (shiftForWord())), value);
		}
	}
	else {

		/* Event time stamp */

		/* begin storeInteger:ofObject:withValue: */
		if ((((sqInt)(((evtBuf[1]) & MillisecondClockMask) ^ (((evtBuf[1]) & MillisecondClockMask) << 1)))) >= 0) {
			/* begin storePointerUnchecked:ofObject:withValue: */
			assert(!(isForwarded(arg)));
			longAtput((arg + BaseHeaderSize) + (1 << (shiftForWord())), ((((evtBuf[1]) & MillisecondClockMask) << 1) | 1));
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (GIV(primFailCode)) {
			return;
		}
		for (i = 2; i <= 7; i += 1) {
			value = evtBuf[i];
			if ((((sqInt)(value ^ (value << 1)))) >= 0) {
				/* begin storeInteger:ofObject:withValue: */
				if ((((sqInt)(value ^ (value << 1)))) >= 0) {
					/* begin storePointerUnchecked:ofObject:withValue: */
					assert(!(isForwarded(arg)));
					longAtput((arg + BaseHeaderSize) + (i << (shiftForWord())), ((value << 1) | 1));
				}
				else {
					/* begin primitiveFail */
					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}
				}
			}
			else {
				/* begin positive32BitIntegerFor: */
				/* begin maybeInlinePositive32BitIntegerFor: */
				assert(!((hasSixtyFourBitImmediates())));
				if (((((sqInt)value)) >= 0)
				 && ((((sqInt)(value ^ (value << 1)))) >= 0)) {
					value = ((value << 1) | 1);
					goto l3;
				}
				/* begin eeInstantiateSmallClassIndex:format:numSlots: */
				objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
				assert(ClassLargePositiveIntegerCompactIndex != 0);
				assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
				/* begin allocateSmallNewSpaceSlots:format:classIndex: */
				assert(1 < (numSlotsMask()));
				newObj = GIV(freeStart);
				numBytes = BaseHeaderSize + (8);
				assert((numBytes % (allocationUnit())) == 0);
				assert((newObj % (allocationUnit())) == 0);
				if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
					if (!GIV(needGCFlag)) {
						/* begin scheduleScavenge */
						GIV(needGCFlag) = 1;
						forceInterruptCheck();
					}
					if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
						error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
						newLargeInteger = 0;
						goto l2;
					}
				}
				long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
				GIV(freeStart) += numBytes;
				newLargeInteger = newObj;
			l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
				
#        if VMBIGENDIAN
				byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) value) >> 24) & 0xFF);
				byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) value) >> 16) & 0xFF);
				byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) value) >> 8) & 0xFF);
				byteAtput((newLargeInteger + BaseHeaderSize), value & 0xFF);

#        else /* VMBIGENDIAN */
				long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), value);

#        endif /* VMBIGENDIAN */

				value = newLargeInteger;
			l3:	/* end maybeInlinePositive32BitIntegerFor: */;
				goto l1;

			l1:	/* end positive32BitIntegerFor: */;

				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(arg)));
				if (isOldObject(arg)) {

					/* most stores into young objects */

					if (((value & (tagMask())) == 0)
					 && (oopisLessThan(value, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(arg))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(arg);
						}
					}
				}
				longAtput((arg + BaseHeaderSize) + (i << (shiftForWord())), value);
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive. Answer the OS window's label */

	/* InterpreterPrimitives>>#primitiveGetWindowLabel */
EXPORT(sqInt)
primitiveGetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt labelOop;
    char*ptr;
    char *sp;
    sqInt sz;

	ptr = ioGetWindowLabel();
	if (ptr == null) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	sz = strlen(ptr);
	labelOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteString << (shiftForWord()))), sz);
	for (i = 0; i < sz; i += 1) {
		byteAtput((labelOop + BaseHeaderSize) + i, ptr[i]);
	}
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), labelOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveGetWindowSize */
EXPORT(sqInt)
primitiveGetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt h;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt object;
    sqInt objFormat;
    sqInt pointResult;
    char *sp;
    sqInt w;

	w = ioGetWindowWidth();
	h = ioGetWindowHeight();
	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin push: */
	/* begin makePointwithxValue:yValue: */
	/* begin eeInstantiateSmallClass:numSlots: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << (shiftForWord())));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1))) >> (fixedFieldsFieldWidth())) & (formatMask());
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (XIndex << (shiftForWord())), ((w << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << (shiftForWord())), ((h << 1) | 1));
	object = pointResult;
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveGreaterOrEqual */
static void
primitiveGreaterOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		;
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver >= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterOrEqualLargeIntegers */
EXPORT(void)
primitiveGreaterOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr >= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGreaterThan */
static void
primitiveGreaterThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		;
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver > integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveGreaterThanLargeIntegers */
EXPORT(void)
primitiveGreaterThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr > integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveGrowMemoryByAtLeast */
static void
primitiveGrowMemoryByAtLeast(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ammount;
    sqInt segSize;
    char *sp;

	ammount = longAt(GIV(stackPointer));
	if (!((ammount & 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	segSize = growOldSpaceByAtLeast((ammount >> 1));
	if (segSize == null) {
		GIV(primFailCode) = PrimErrNoMemory;
	}
	else {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((segSize << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Answer the heartbeat frequency in beats per second. If the argument is
	true, reset the frequency measure. */

	/* InterpreterPrimitives>>#primitiveHeartbeatFrequency */
EXPORT(sqInt)
primitiveHeartbeatFrequency(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt objFormat;
    sqInt oop;
    sqInt reset;
    char *sp;

	reset = (GIV(argumentCount) == 1)
	 && ((longAt(GIV(stackPointer))) == GIV(trueObj));
	/* begin pop:thenPush: */
	/* begin positive32BitIntegerFor: */
	integerValue = ioHeartbeatFrequency(reset);
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if (((((sqInt)integerValue)) >= 0)
	 && ((((sqInt)(integerValue ^ (integerValue << 1)))) >= 0)) {
		oop = ((integerValue << 1) | 1);
		goto l3;
	}
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
	assert(ClassLargePositiveIntegerCompactIndex != 0);
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(1 < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + (8);
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l2;
		}
	}
	long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
	
#  if VMBIGENDIAN
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#  else /* VMBIGENDIAN */
	long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), integerValue);

#  endif /* VMBIGENDIAN */

	oop = newLargeInteger;
l3:	/* end maybeInlinePositive32BitIntegerFor: */;
	goto l1;

l1:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the value of the high resolution clock if this system has any. The
	exact frequency of the high res clock is undefined specifically so that we
	can use processor dependent instructions (like RDTSC). The only use for
	the high res clock is for profiling where we can allocate time based on
	sub-msec resolution of the high res clock. If no high-resolution counter
	is available, the platform should return zero.
 */

	/* InterpreterPrimitives>>#primitiveHighResClock */
EXPORT(sqInt)
primitiveHighResClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	/* begin push: */
	object = positive64BitIntegerFor(ioHighResClock());
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	is the receiver/first argument the same object as the (last) argument?.
	pop argumentCount because this can be used as a mirror primitive. */

	/* InterpreterPrimitives>>#primitiveIdentical */
static void
primitiveIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	if ((((otherObject & (tagMask())) == 0)
	 && (((longAt(otherObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))
	 || ((GIV(argumentCount) > 1)
	 && (((thisObject & (tagMask())) == 0)
	 && (((longAt(thisObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))))) {
		GIV(primFailCode) = PrimErrBadArgument;
	}
	else {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject == otherObject
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveIdentityHash */
static void
primitiveIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hash;
    sqInt integerVal;
    char *sp;
    sqInt thisReceiver;

	thisReceiver = longAt(GIV(stackPointer));
	if (((thisReceiver & (tagMask())) != 0)
	 || ((GIV(argumentCount) > 0)
	 && (((longAt(thisReceiver)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	else {
		/* begin pop:thenPushInteger: */
		/* begin hashBitsOf: */
		hash = (long32At(thisReceiver + 4)) & (identityHashHalfWordMask());
		if (hash == 0) {

			/* would like to assert
			   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
			   but instance-specific behaviors that are instances of themselves may
			   fail this test. */

			hash = (newObjectHash()) & (identityHashHalfWordMask());
			/* begin setHashBitsOf:to: */
			flag("endianness");
			assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
			long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
		}
		integerVal = hash;
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((integerVal << 1) | 1));
		GIV(stackPointer) = sp;
	}
}


/*	Answer an integer identifying the type of image. The image version number
	may identify the format of the image (e.g. 32 or 64-bit word size) or
	specific requirements
	of the image (e.g. block closure support required).
	
	This is a named (not numbered) primitive in the null module (ie the VM)
 */

	/* InterpreterPrimitives>>#primitiveImageFormatVersion */
EXPORT(sqInt)
primitiveImageFormatVersion(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt isSpurFlag;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt objFormat;
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	/* begin positive32BitIntegerFor: */
	/* begin imageFormatVersion */
	isSpurFlag = 16;
	integerValue = (6505) + isSpurFlag;
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if (((((sqInt)integerValue)) >= 0)
	 && ((((sqInt)(integerValue ^ (integerValue << 1)))) >= 0)) {
		oop = ((integerValue << 1) | 1);
		goto l3;
	}
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
	assert(ClassLargePositiveIntegerCompactIndex != 0);
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(1 < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + (8);
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l2;
		}
	}
	long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
	
#  if VMBIGENDIAN
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#  else /* VMBIGENDIAN */
	long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), integerValue);

#  endif /* VMBIGENDIAN */

	oop = newLargeInteger;
l3:	/* end maybeInlinePositive32BitIntegerFor: */;
	goto l1;

l1:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	When called with a single string argument, record the string as the
	current image file name. When called with zero arguments, return a string
	containing the current image file name.
 */

	/* InterpreterPrimitives>>#primitiveImageName */
static void
primitiveImageName(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ok;
    sqInt okToRename;
    sqInt s;
    void *sCRIfn;
    char *sp;
    sqInt sz;

	if (GIV(argumentCount) == 1) {

		/* If the security plugin can be loaded, use it to check for rename permission.
		   If not, assume it's ok */

		sCRIfn = ioLoadFunctionFrom("secCanRenameImage", "SecurityPlugin");
		if (sCRIfn != 0) {
			okToRename = ((sqInt (*)(void))sCRIfn)();
			if (!okToRename) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
		}
		s = longAt(GIV(stackPointer));
		/* begin assertClassOf:is: */
		ok = (s & (tagMask())) == 0;
		if (ok) {
			/* begin isClassOfNonImm:equalTo: */
			assert(isNonImmediate(s));
			ok = ((longAt(s)) & (classIndexMask())) == ((long32At((longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteString << (shiftForWord())))) + 4)) & (identityHashHalfWordMask()));
		}
		/* begin success: */
		if (!ok) {

			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
		if (!GIV(primFailCode)) {
			sz = stSizeOf(s);
			imageNamePutLength(s + BaseHeaderSize, sz);
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
	}
	else {
		sz = imageNameSize();
		s = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteString << (shiftForWord()))), sz);
		imageNameGetLength(s + BaseHeaderSize, sz);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), s);
		GIV(stackPointer) = sp;
	}
}


/*	For a Smalllnteger, answer itself.
	For a Character, answer its code as an unsigned integer.
	For a SmallFloat, answer the signed, but unadjusted bit pattern (so as to
	keep the result a SmallInteger).
	This is a good value for an immediate's hash. */

	/* InterpreterPrimitives>>#primitiveImmediateAsInteger */
static void
primitiveImmediateAsInteger(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;
    sqInt value;

	value = 0;
	oop = longAt(GIV(stackPointer));
	if ((oop & 1)) {
		value = (oop >> 1);
	}
	else {
		if ((oop & (tagMask())) == 2) {
			value = ((usqInt) (((usqInt)oop))) >> (numTagBits());
		}
		else {
			(GIV(primFailCode) = PrimErrBadReceiver);
			return;

		}
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Register the input semaphore. If the argument is not a 
	Semaphore, unregister the current input semaphore. */

	/* InterpreterPrimitives>>#primitiveInputSemaphore */
static void
primitiveInputSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((arg & 1)) {

		/* If arg is integer, then use it as an index
		   into the external objects array and install it
		   as the new event semaphore */

		ioSetInputSemaphore((arg >> 1));
		if (!GIV(primFailCode)) {
			/* begin pop: */
			GIV(stackPointer) += 1 * BytesPerWord;
		}
		return;
	}
	if (TheInputSemaphore == null) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if ((arg == GIV(nilObj))
	 || (((arg & (tagMask())) == 0)
	 && (((longAt(arg)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << (shiftForWord())))))))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((arg & (tagMask())) == 0)
			 && (oopisLessThan(arg, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheInputSemaphore << (shiftForWord())), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Return an integer indicating the reason for the most recent input
	interrupt. 
 */

	/* InterpreterPrimitives>>#primitiveInputWord */
static void
primitiveInputWord(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((0 << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the 32bit signed integer contents of a words receiver */

	/* InterpreterPrimitives>>#primitiveIntegerAt */
static void
primitiveIntegerAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt fmt;
    sqInt index;
    sqInt integerPointer;
    int intValue;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt object;
    sqInt rcvr;
    char *sp;
    char *sp1;
    sqInt sz;
    sqInt value;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & (tagMask())) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) == (firstLongFormat())))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? longAt(rcvr - BaseHeaderSize)
		: numSlots1);
	if (fmt <= 5) {
		sz = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */

		sz = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		sz = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		sz = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		sz = ((usqInt) numSlots) >> 1;
		goto l1;
	}
	sz = 0;
l1:	/* end lengthOf:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}

	/* for zero indexing */

	addr = (rcvr + BaseHeaderSize) + ((index - 1) * 4);
	value = intAt(addr);
	/* begin pop: */
	GIV(stackPointer) += 2 * BytesPerWord;
	if ((((sqInt)(value ^ (value << 1)))) >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), ((value << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {

		/* 32 bit int may have been stored in 32 or 64 bit sqInt */

		intValue = value;
		/* begin push: */
		/* begin signed32BitIntegerFor: */
		object = noInlineSigned32BitIntegerFor(intValue);
		goto l2;

	l2:	/* end signed32BitIntegerFor: */;
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp1;
	}
}


/*	Return the 32bit signed integer contents of a words receiver */

	/* InterpreterPrimitives>>#primitiveIntegerAtPut */
static void
primitiveIntegerAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt addr;
    sqInt fmt;
    sqInt index;
    sqInt integerPointer;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt sz;
    int value;
    sqInt valueOop;

	valueOop = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	value = signed32BitValueOf(valueOop);
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(((rcvr & (tagMask())) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) == (firstLongFormat())))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	/* begin lengthOf:format: */
	fmt = (((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? longAt(rcvr - BaseHeaderSize)
		: numSlots1);
	if (fmt <= 5) {
		sz = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */

		sz = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		sz = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		sz = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		sz = ((usqInt) numSlots) >> 1;
		goto l1;
	}
	sz = 0;
l1:	/* end lengthOf:format: */;
	if (!((index >= 1)
		 && (index <= sz))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}

	/* for zero indexing */

	addr = (rcvr + BaseHeaderSize) + ((index - 1) * 4);
	value = intAtput(addr, value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), valueOop);
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer the number of interrupt checks per milliseconds that we
	execute on this machine. This can be used to adjust the sub-msecs profiler
	to check (roughly) 
	n times per millisecond.
 */

	/* InterpreterPrimitives>>#primitiveInterruptChecksPerMSec */
EXPORT(sqInt)
primitiveInterruptChecksPerMSec(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin pop:thenPush: */
	oop = (((ioHeartbeatMilliseconds()) << 1) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Register the user interrupt semaphore. If the argument is 
	not a Semaphore, unregister the current interrupt 
	semaphore. */

	/* InterpreterPrimitives>>#primitiveInterruptSemaphore */
static void
primitiveInterruptSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (((arg & (tagMask())) == 0)
	 && (((longAt(arg)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << (shiftForWord())))))))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((arg & (tagMask())) == 0)
			 && (oopisLessThan(arg, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheInterruptSemaphore << (shiftForWord())), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = PrimErrBadArgument;
	}
}


/*	Primitive. 'Invoke' an object like a function, sending the special message
	run: originalSelector with: arguments in: aReceiver.
	 */

	/* InterpreterPrimitives>>#primitiveInvokeObjectAsMethod */
static void
primitiveInvokeObjectAsMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt errorCode;
    sqInt i;
    sqInt i1;
    sqInt lookupClassTag;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt numArgs;
    sqInt numTemps;
    usqInt object;
    sqInt rcvr;
    sqInt runArgs;
    sqInt runReceiver;
    char *savedFramePointer;
    char *savedStackPointer;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp31;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    sqInt tagBits;
    sqInt top;
    sqInt top1;
    sqInt valuePointer;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	/* begin eeInstantiateClassIndex:format:numSlots: */
	assert((GIV(argumentCount) >= 0)
	 && (ClassArrayCompactIndex != 0));
	assert((2) == (instSpecOfClass(knownClassAtIndex(ClassArrayCompactIndex))));
	runArgs = allocateNewSpaceSlotsformatclassIndex(GIV(argumentCount), 2, ClassArrayCompactIndex);

	for (i = (GIV(argumentCount) - 1); i >= 0; i += -1) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		/* begin popStack */
		top1 = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		valuePointer = top1;
		assert(!(isForwarded(runArgs)));
		longAtput((runArgs + BaseHeaderSize) + (i << (shiftForWord())), valuePointer);
	}
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	runReceiver = top;
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp;
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(messageSelector));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), runArgs);
	GIV(stackPointer) = sp2;
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), runReceiver);
	GIV(stackPointer) = sp3;
	GIV(messageSelector) = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (SelectorRunWithIn << (shiftForWord())));
	GIV(argumentCount) = 3;
	if (((tagBits = GIV(newMethod) & (tagMask()))) != 0) {
		lookupClassTag = ((tagBits & 1) != 0
			? 1
			: tagBits);
	}
	else {
		lookupClassTag = (longAt(GIV(newMethod))) & (classIndexMask());
	}
	findNewMethodInClassTag(lookupClassTag);
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	/* begin justActivateNewMethod */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp31 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp31;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	GIV(bytecodeSetSelector) = ((((sqInt) methodHeader1)) < 0
		? 256
		: 0);

	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (numArgs << 8)) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i1 = (numArgs + 1); i1 <= numTemps; i1 += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader1))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((sqInt) methodHeader1)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << (shiftForWord())));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
}


/*	Answer if running on a big endian machine. */

	/* InterpreterPrimitives>>#primitiveIsBigEnder */
EXPORT(sqInt)
primitiveIsBigEnder(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), (VMBIGENDIAN
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Answer if the receiver is pinned, i.e. immobile. */

	/* InterpreterPrimitives>>#primitiveIsPinned */
static void
primitiveIsPinned(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt obj;
    char *sp;
    sqInt trueOrFalse;

	obj = longAt(GIV(stackPointer));
	if (((obj & (tagMask())) != 0)
	 || (((longAt(obj)) & ((classIndexMask()) - (isForwardedObjectClassIndexPun()))) == 0)) {
		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	/* begin pop:thenPushBool: */
	trueOrFalse = (((((usqInt) (longAt(obj))) >> 30) & 1) != 0
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Primitive. Answer whether the OS window is currently partially or fully
	obscured. 
 */

	/* InterpreterPrimitives>>#primitiveIsWindowObscured */
EXPORT(sqInt)
primitiveIsWindowObscured(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt object;
    char *sp;
    sqInt trueOrFalse;

	/* begin pop: */
	GIV(stackPointer) += (GIV(argumentCount) + 1) * BytesPerWord;
	/* begin pushBool: */
	trueOrFalse = ioIsWindowObscured();
	/* begin push: */
	object = (trueOrFalse
		? GIV(trueObj)
		: GIV(falseObj));
	longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and remove it from the input buffer. The low byte
	is the 8-bit ISO character. The next four bits are the Smalltalk modifier
	bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveKbdNext */
static void
primitiveKbdNext(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioGetKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ((keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the next keycode and without removing it from the input buffer. The
	low byte is the 8-bit ISO character. The next four bits are the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveKbdPeek */
static void
primitiveKbdPeek(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt keystrokeWord;
    char *sp;
    char *sp1;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	keystrokeWord = ioPeekKeystroke();
	if (keystrokeWord >= 0) {
		/* begin pushInteger: */
		/* begin push: */
		longAtput((sp1 = GIV(stackPointer) - BytesPerWord), ((keystrokeWord << 1) | 1));
		GIV(stackPointer) = sp1;
	}
	else {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessOrEqual */
static void
primitiveLessOrEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		;
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver <= integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessOrEqualLargeIntegers */
EXPORT(void)
primitiveLessOrEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr <= integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveLessThan */
static void
primitiveLessThan(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    char *sp;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		;
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver < integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveLessThanLargeIntegers */
EXPORT(void)
primitiveLessThanLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr < integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	Primitive. Return the n-th builtin module name. */

	/* InterpreterPrimitives>>#primitiveListBuiltinModule */
static void
primitiveListBuiltinModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListBuiltinModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteString << (shiftForWord()))), length);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	Primitive. Return the n-th loaded external module name. */

	/* InterpreterPrimitives>>#primitiveListExternalModule */
static void
primitiveListExternalModule(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt i;
    sqInt index;
    sqInt integerPointer;
    sqInt length;
    char *moduleName;
    sqInt nameOop;
    char *sp;
    char *sp1;

	if (!(GIV(argumentCount) == 1)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (index <= 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	moduleName = ioListLoadedModule(index);
	if (moduleName == null) {
		/* begin pop: */
		GIV(stackPointer) += 2 * BytesPerWord;
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp;
		return;
	}
	length = strlen(moduleName);
	nameOop = instantiateClassindexableSize(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassByteString << (shiftForWord()))), length);
	for (i = 0; i < length; i += 1) {
		byteAtput((nameOop + BaseHeaderSize) + i, moduleName[i]);
	}
	forceInterruptCheck();
	/* begin pop:thenPush: */
	longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), nameOop);
	GIV(stackPointer) = sp1;
}


/*	This primitive is called from Squeak as...
	<imageSegment> loadSegmentFrom: aWordArray outPointers: anArray. */
/*	This primitive will load a binary image segment created by
	primitiveStoreImageSegment. It expects the outPointer array to be of the
	proper size, and the wordArray to be well
	formed. It will return as its value the original array of roots, and the
	erstwhile segmentWordArray will have been truncated to a size of one word,
	i.e. retaining the version
	stamp. If this primitive should fail, the segmentWordArray will, sadly,
	have been reduced to
	an unrecognizable and unusable jumble. But what more could you have done
	with it anyway? */

	/* InterpreterPrimitives>>#primitiveLoadImageSegment */
static void
primitiveLoadImageSegment(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt outPointerArray;
    sqInt result;
    sqInt segmentWordArray;
    char *sp;

	outPointerArray = longAt(GIV(stackPointer));

	/* Essential type checks */

	segmentWordArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((((outPointerArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(outPointerArray))) >> (formatShift())) & (formatMask())) == 2))
		 && (((segmentWordArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(segmentWordArray))) >> (formatShift())) & (formatMask())) == (firstLongFormat()))))) {

		/* Must be indexable words */

		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = loadImageSegmentFromoutPointers(segmentWordArray, outPointerArray);
	if (oopisGreaterThan(result, segmentWordArray)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), result);
		GIV(stackPointer) = sp;
	}
	else {
		GIV(primFailCode) = result;
	}
}


/*	Return the value of the microsecond clock as an integer. The microsecond
	clock is at
	least 60 bits wide which means it'll get to around August 38435 before it
	wraps around. */

	/* InterpreterPrimitives>>#primitiveLocalMicrosecondClock */
static void
primitiveLocalMicrosecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(ioLocalMicrosecondsNow());
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Natural log. */

	/* InterpreterPrimitives>>#primitiveLogN */
static void
primitiveLogN(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	isFloat = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l1;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = log(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}


/*	Register the low-space semaphore. If the argument is not a 
	Semaphore, unregister the current low-space Semaphore. */

	/* InterpreterPrimitives>>#primitiveLowSpaceSemaphore */
static void
primitiveLowSpaceSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt arg;

	arg = longAt(GIV(stackPointer));
	if ((arg == GIV(nilObj))
	 || (((arg & (tagMask())) == 0)
	 && (((longAt(arg)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << (shiftForWord())))))))) {
		/* begin splObj:put: */
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(GIV(specialObjectsOop))));
		if (isOldObject(GIV(specialObjectsOop))) {

			/* most stores into young objects */

			if (((arg & (tagMask())) == 0)
			 && (oopisLessThan(arg, GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(GIV(specialObjectsOop)))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(GIV(specialObjectsOop));
				}
			}
		}
		longAtput((GIV(specialObjectsOop) + BaseHeaderSize) + (TheLowSpaceSemaphore << (shiftForWord())), arg);
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = PrimErrBadArgument;
	}
}

	/* InterpreterPrimitives>>#primitiveMakePoint */
static void
primitiveMakePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt pt;
    sqInt rcvr;
    char *sp;

	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & 1))
		 || (((rcvr & (tagMask())) == 0)
		 && (((longAt(rcvr)) & (classIndexMask())) == ClassFloatCompactIndex)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin eeInstantiateSmallClass:numSlots: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << (shiftForWord())));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1))) >> (fixedFieldsFieldWidth())) & (formatMask());
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pt = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pt = newObj;
l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pt)));
	longAtput((pt + BaseHeaderSize) + (XIndex << (shiftForWord())), rcvr);
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pt)));
	longAtput((pt + BaseHeaderSize) + (YIndex << (shiftForWord())), longAt(GIV(stackPointer)));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), pt);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMaxIdentityHash */
static void
primitiveMaxIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerVal;
    char *sp;

	/* begin pop:thenPushInteger: */
	integerVal = identityHashHalfWordMask();
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((integerVal << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Return the method an external primitive was defined in */

	/* InterpreterPrimitives>>#primitiveMethod */
usqInt
primitiveMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	return GIV(newMethod);
}


/*	Return the value of the millisecond clock as an integer. Note that the
	millisecond clock wraps around periodically. On some platforms it can wrap
	daily. The range is limited to SmallInteger maxVal / 2 to allow delays of
	up to that length without overflowing a SmallInteger.
 */

	/* InterpreterPrimitives>>#primitiveMillisecondClock */
static void
primitiveMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = ((((ioMSecs()) & MillisecondClockMask) << 1) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Provide access to the millisecond clock mask to support calculation
	of durations based on the millisecond clock value. */

	/* InterpreterPrimitives>>#primitiveMillisecondClockMask */
EXPORT(sqInt)
primitiveMillisecondClockMask(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((MillisecondClockMask << 1) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMod */
static void
primitiveMod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt mod;
    char *sp;

	mod = doPrimitiveModby(longAt(GIV(stackPointer) + (1 * BytesPerWord)), longAt(GIV(stackPointer)));
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)(mod ^ (mod << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((mod << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveModLargeIntegers */
EXPORT(void)
primitiveModLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}

	/* Handle remainder of same sign as argument */

	result = a % b;
	if (!(result == 0)) {
		if (!(bIsNegative == aIsNegative)) {
			result = b - result;
		}
	}
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return the mouse button state. The low three bits encode the state of the
	<red><yellow><blue> mouse buttons. The next four bits encode the Smalltalk
	modifier bits <cmd><option><ctrl><shift>.
 */

	/* InterpreterPrimitives>>#primitiveMouseButtons */
static void
primitiveMouseButtons(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt buttonWord;
    char *sp;

	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
	buttonWord = ioGetButtonState();
	/* begin pushInteger: */
	/* begin push: */
	longAtput((sp = GIV(stackPointer) - BytesPerWord), ((buttonWord << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Obsolete on virtually all platforms; old style input polling code.
	Return a Point indicating current position of the mouse. Note that mouse
	coordinates may be negative if the mouse moves above or to the left of the
	top-left corner of the Smalltalk window.
 */

	/* InterpreterPrimitives>>#primitiveMousePoint */
static void
primitiveMousePoint(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt oop;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;
    sqInt x;
    sqInt y;

	pointWord = ioMousePoint();
	/* begin signExtend16: */
	if ((((((usqInt) pointWord) >> 16) & 0xFFFF) & 32768) == 0) {
		x = (((usqInt) pointWord) >> 16) & 0xFFFF;
		goto l1;
	}
	else {
		x = ((((usqInt) pointWord) >> 16) & 0xFFFF) - 65536;
		goto l1;
	}
l1:	/* end signExtend16: */;
	/* begin signExtend16: */
	if (((pointWord & 0xFFFF) & 32768) == 0) {
		y = pointWord & 0xFFFF;
		goto l2;
	}
	else {
		y = (pointWord & 0xFFFF) - 65536;
		goto l2;
	}
l2:	/* end signExtend16: */;
	/* begin pop:thenPush: */
	/* begin makePointwithxValue:yValue: */
	/* begin eeInstantiateSmallClass:numSlots: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << (shiftForWord())));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1))) >> (fixedFieldsFieldWidth())) & (formatMask());
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l3;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
l3:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (XIndex << (shiftForWord())), ((x << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << (shiftForWord())), ((y << 1) | 1));
	oop = pointResult;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveMultiply */
static void
primitiveMultiply(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {

		/* check for C overflow by seeing if computation is reversible */

		integerResult = integerRcvr * integerArg;
		if ((integerArg == 0)
		 || ((integerResult / integerArg) == integerRcvr)) {
			/* begin pop2AndPushIntegerIfOK: */
			if (!GIV(primFailCode)) {
				if ((((sqInt)(integerResult ^ (integerResult << 1)))) >= 0) {
					/* begin pop:thenPush: */
					longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
					GIV(stackPointer) = sp;
				}
				else {
					/* begin success: */
					
					/* Don't overwrite an error code that has already been set. */

					if (!GIV(primFailCode)) {
						GIV(primFailCode) = 1;
					}

				}
			}
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveMultiplyLargeIntegers */
EXPORT(void)
primitiveMultiplyLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (GIV(primFailCode)) {
		return;
	}
	if ((a > 1)
	 && ((b > 1)
	 && (a > (0xFFFFFFFFFFFFFFFFULL / b)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	result = a * b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative != bIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}

	/* InterpreterPrimitives>>#primitiveNew */
static void
primitiveNew(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classFormat;
    sqInt classIndex;
    sqInt classObj;
    sqInt classObj1;
    sqInt err;
    sqInt hash;
    sqInt instSpec;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    sqInt numSlots;
    sqInt obj;
    sqInt oop;
    usqInt p;
    sqInt reasonCode;
    char *sp;
    char *sp1;
    sqInt spaceOkay;

	spaceOkay = 0;
	
	/* For the mirror prims check that the class obj is actually a valid class. */

	if (!((GIV(argumentCount) < 1)
		 || (objCouldBeClassObj(longAt(GIV(stackPointer)))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}

	
	/* Allocate a new fixed-size instance.  Fail if the allocation would leave
	   less than lowSpaceThreshold bytes free. This *will not* cause a GC :-) */

	/* begin instantiateClass: */
	classObj1 = longAt(GIV(stackPointer));
	classFormat = ((longAt((classObj1 + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1);
	instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth())) & (formatMask());
	if (!((instSpec <= 1)
		 || (instSpec == 5))) {
		obj = null;
		goto l2;
	}
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(classObj1));
	classIndex = (((hash = (long32At(classObj1 + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(classObj1)
				? (((err = enterIntoClassTable(classObj1))) != 0
						? -err
						: (long32At(classObj1 + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (classIndex < 0) {
		GIV(primFailCode) = -classIndex;
		obj = null;
		goto l2;
	}
	numSlots = classFormat & ((1 << (fixedFieldsFieldWidth())) - 1);
	/* begin allocateSlots:format:classIndex: */
	if (numSlots >= (numSlotsMask())) {
		newObj1 = GIV(freeStart) + BaseHeaderSize;
		numBytes = (BaseHeaderSize + BaseHeaderSize) + ((numSlots + (numSlots & 1)) * BytesPerOop);
	}
	else {
		newObj1 = GIV(freeStart);
		numBytes = BaseHeaderSize + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * BytesPerOop));
	}
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
		goto l1;
	}
	if (numSlots >= (numSlotsMask())) {

		/* for header parsing we put a saturated slot count in the prepended overflow size word */

		flag("endianness");
		longAtput(GIV(freeStart), numSlots);
		longAtput(GIV(freeStart) + 4, (numSlotsMask()) << (numSlotsHalfShift()));
		long64Atput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(), instSpec, classIndex));
	}
	else {
		long64Atput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (instSpec << (formatShift()))) + classIndex);
	}
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj1 % (allocationUnit())) == 0);
	GIV(freeStart) += numBytes;
	newObj = newObj1;
l1:	/* end allocateSlots:format:classIndex: */;
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8) {
			longAtput(p, GIV(nilObj));
			longAtput(p + 4, GIV(nilObj));
		}
	}
	obj = newObj;
l2:	/* end instantiateClass: */;
	if (obj == null) {
		/* begin primitiveFailFor: */
		reasonCode = (isFixedSizePointerFormat(instSpecOfClassFormat(((longAt(((longAt(GIV(stackPointer))) + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1)))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}

}

	/* InterpreterPrimitives>>#primitiveNewMethod */
static void
primitiveNewMethod(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytecodeCount;
    sqInt class;
    sqInt classFormat;
    sqInt classIndex;
    sqInt err;
    sqInt hash;
    sqInt header;
    sqInt i;
    usqInt instSpec;
    sqInt literalCount;
    sqInt newObj;
    usqInt newObj1;
    usqInt numBytes;
    sqInt numSlots;
    usqInt p;
    sqInt reasonCode;
    sqInt size;
    char *sp;
    sqInt theMethod;

	header = longAt(GIV(stackPointer));
	bytecodeCount = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((header & 1))
		 && (((bytecodeCount & 1))
		 && (((bytecodeCount = (bytecodeCount >> 1))) >= 0)))) {
		GIV(primFailCode) = PrimErrBadArgument;
		return;
	}
	class = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin literalCountOfMethodHeader: */
	assert((header & 1));
	literalCount = ((header >> 1)) & AlternateHeaderNumLiteralsMask;
	size = ((literalCount + LiteralStart) * BytesPerOop) + bytecodeCount;
	/* begin instantiateCompiledMethodClass:indexableSize: */
	classFormat = ((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1);
	instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth())) & (formatMask());
	if (instSpec != (firstCompiledMethodFormat())) {
		theMethod = null;
		goto l2;
	}
	numSlots = (size + 3) / 4;
	instSpec += (4 - size) & 3;
	/* begin ensureBehaviorHash: */
	assert(addressCouldBeClassObj(class));
	classIndex = (((hash = (long32At(class + 4)) & (identityHashHalfWordMask()))) != 0
		? hash
		: (objCouldBeClassObj(class)
				? (((err = enterIntoClassTable(class))) != 0
						? -err
						: (long32At(class + 4)) & (identityHashHalfWordMask()))
				: -PrimErrBadReceiver));
	if (classIndex < 0) {
		GIV(primFailCode) = -classIndex;
		theMethod = null;
		goto l2;
	}
	if (numSlots > ((1 << (fixedFieldsFieldWidth())) - 1)) {
		if (numSlots > (((512 * 1024) * 1024) - 1)) {
			theMethod = null;
			goto l2;
		}
		newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, ((numSlots == 0
	? 8
	: (numSlots + (numSlots & 1)) << (shiftForWord()))) + ((numSlots >= (numSlotsMask())
	? BaseHeaderSize + BaseHeaderSize
	: BaseHeaderSize)), instSpec, classIndex);
	}
	else {
		/* begin allocateSlots:format:classIndex: */
		if (numSlots >= (numSlotsMask())) {
			newObj1 = GIV(freeStart) + BaseHeaderSize;
			numBytes = (BaseHeaderSize + BaseHeaderSize) + ((numSlots + (numSlots & 1)) * BytesPerOop);
		}
		else {
			newObj1 = GIV(freeStart);
			numBytes = BaseHeaderSize + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * BytesPerOop));
		}
		if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
			if (!GIV(needGCFlag)) {
				/* begin scheduleScavenge */
				GIV(needGCFlag) = 1;
				forceInterruptCheck();
			}
			newObj = allocateSlotsInOldSpacebytesformatclassIndex(numSlots, numBytes, instSpec, classIndex);
			goto l1;
		}
		if (numSlots >= (numSlotsMask())) {

			/* for header parsing we put a saturated slot count in the prepended overflow size word */

			flag("endianness");
			longAtput(GIV(freeStart), numSlots);
			longAtput(GIV(freeStart) + 4, (numSlotsMask()) << (numSlotsHalfShift()));
			long64Atput(newObj1, headerForSlotsformatclassIndex(numSlotsMask(), instSpec, classIndex));
		}
		else {
			long64Atput(newObj1, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (instSpec << (formatShift()))) + classIndex);
		}
		assert((numBytes % (allocationUnit())) == 0);
		assert((newObj1 % (allocationUnit())) == 0);
		GIV(freeStart) += numBytes;
		newObj = newObj1;
	l1:	/* end allocateSlots:format:classIndex: */;
	}
	if (!(newObj == null)) {
		/* begin fillObj:numSlots:with: */
		assert(oopisLessThan(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1, addressAfter(newObj)));
		for (p = (((usqInt)(newObj + BaseHeaderSize))); p <= (((usqInt)(((newObj + BaseHeaderSize) + (numSlots * BytesPerOop)) - 1))); p += 8) {
			longAtput(p, 0);
			longAtput(p + 4, 0);
		}
	}
	theMethod = newObj;
l2:	/* end instantiateCompiledMethodClass:indexableSize: */;
	if (!(theMethod)) {
		/* begin primitiveFailFor: */
		reasonCode = (isCompiledMethodFormat(instSpecOfClassFormat(((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1)))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		GIV(primFailCode) = reasonCode;
		return;
	}

	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(theMethod)));
	longAtput((theMethod + BaseHeaderSize) + (HeaderIndex << (shiftForWord())), header);
	for (i = 1; i <= literalCount; i += 1) {
		/* begin storePointer:ofObject:withValue: */
		assert(!(isForwarded(theMethod)));
		if (isOldObject(theMethod)) {

			/* most stores into young objects */

			if (((GIV(nilObj) & (tagMask())) == 0)
			 && (oopisLessThan(GIV(nilObj), GIV(newSpaceLimit)))) {
				/* begin possibleRootStoreInto: */
				if (!(((((usqInt) (longAt(theMethod))) >> (rememberedBitShift())) & 1) != 0)) {
					remember(theMethod);
				}
			}
		}
		longAtput((theMethod + BaseHeaderSize) + (i << (shiftForWord())), GIV(nilObj));
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), theMethod);
	GIV(stackPointer) = sp;
}


/*	Allocate a new indexable instance. Fail if the allocation would leave less
	than lowSpaceThreshold bytes free. May cause a GC.
 */

	/* InterpreterPrimitives>>#primitiveNewWithArg */
static void
primitiveNewWithArg(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bs;
    sqInt ccIndex;
    sqInt classObj;
    sqInt fmt;
    sqInt instSpec;
    sqInt obj;
    sqInt ok;
    sqInt oop;
    sqInt oop1;
    sqInt reasonCode;
    unsigned long size;
    char *sp;
    char *sp1;
    sqInt spaceOkay;
    sqInt value;

	spaceOkay = 0;
	
	/* For the mirror prims check that the class obj is actually a valid class. */

	if (!((GIV(argumentCount) < 2)
		 || (addressCouldBeClassObj(longAt(GIV(stackPointer) + (1 * BytesPerWord)))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}

	/* begin positiveMachineIntegerValueOf: */
	oop1 = longAt(GIV(stackPointer));
	if ((oop1 & 1)) {
		value = (oop1 >> 1);
		if (value < 0) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			size = null;
			goto l2;
		}
		size = value;
		goto l2;
	}
	if ((oop1 & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	/* begin isClassOfNonImm:equalTo:compactClassIndex: */
	assert(!(isImmediate(oop1)));
	ccIndex = (longAt(oop1)) & (classIndexMask());
	ok = ClassLargePositiveIntegerCompactIndex == ccIndex;
	goto l1;

l1:	/* end isClassOfNonImm:equalTo:compactClassIndex: */;
	if (!ok) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	/* begin numBytesOfBytes: */
	fmt = (((usqInt) (longAt(oop1))) >> (formatShift())) & (formatMask());
	assert(fmt >= (firstByteFormat()));
	bs = ((numSlotsOf(oop1)) << (shiftForWord())) - (fmt & 7);
	if (bs > (sizeof(unsigned long))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		size = 0;
		goto l2;
	}
	if (((sizeof(unsigned long)) == 8)
	 && (bs > 4)) {
		size = 
#    if VMBIGENDIAN
			(((((((byteAt((oop1 + BaseHeaderSize))) + ((byteAt((oop1 + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop1 + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop1 + BaseHeaderSize) + 3)) << 24)) + ((byteAt((oop1 + BaseHeaderSize) + 4)) << 32)) + ((byteAt((oop1 + BaseHeaderSize) + 5)) << 40)) + ((byteAt((oop1 + BaseHeaderSize) + 6)) << 48)) + ((byteAt((oop1 + BaseHeaderSize) + 7)) << 56)
#    else /* VMBIGENDIAN */
			long64At((oop1 + BaseHeaderSize) + (0 << 3))
#    endif /* VMBIGENDIAN */
			;
		goto l2;
	}
	else {
		size = 
#    if VMBIGENDIAN
			(((byteAt((oop1 + BaseHeaderSize))) + ((byteAt((oop1 + BaseHeaderSize) + 1)) << 8)) + ((byteAt((oop1 + BaseHeaderSize) + 2)) << 16)) + ((byteAt((oop1 + BaseHeaderSize) + 3)) << 24)
#    else /* VMBIGENDIAN */
			long32At((oop1 + BaseHeaderSize) + (0 << 2))
#    endif /* VMBIGENDIAN */
			;
		goto l2;
	}
l2:	/* end positiveMachineIntegerValueOf: */;
	if (GIV(primFailCode)) {

		/* positiveMachineIntegerValueOf: succeeds only for non-negative integers. */

		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	obj = instantiateClassindexableSize(longAt(GIV(stackPointer) + (1 * BytesPerWord)), size);
	if (obj == null) {
		/* begin instSpecOfClassFormat: */
		instSpec = (((usqInt) (((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1))) >> (fixedFieldsFieldWidth())) & (formatMask());
		/* begin primitiveFailFor: */
		reasonCode = (((instSpec >= 2)
		 && ((instSpec <= (weakArrayFormat()))
		 || (instSpec >= (sixtyFourBitIndexableFormat()))))
		 && (!(instSpec >= (firstCompiledMethodFormat())))
			? PrimErrNoMemory
			: PrimErrBadReceiver);
		GIV(primFailCode) = reasonCode;
	}
	else {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), obj);
		GIV(stackPointer) = sp;
	}

}

	/* InterpreterPrimitives>>#primitiveNextInstance */
static void
primitiveNextInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualObj;
    sqInt address;
    sqInt classIndex;
    usqInt numSlots;
    sqInt object;
    char *sp;
    sqInt subsequentObject;

	object = longAt(GIV(stackPointer));
	if (!((object & (tagMask())) != 0)) {
		/* begin instanceAfter: */
		actualObj = object;
		classIndex = (longAt(object)) & (classIndexMask());
		if (oopisGreaterThanOrEqualToandLessThan(object, ((eden()).start), GIV(freeStart))) {
			while (1) {
				actualObj = objectAfterlimit(actualObj, GIV(freeStart));
				if (!(oopisLessThan(actualObj, GIV(freeStart)))) break;
				if (classIndex == ((longAt(actualObj)) & (classIndexMask()))) {
					subsequentObject = actualObj;
					goto l1;
				}
			}
			if (oopisGreaterThan(GIV(pastSpaceStart), ((pastSpace()).start))) {
				/* begin objectStartingAt: */
				address = ((pastSpace()).start);
				numSlots = byteAt(address + 7);
				actualObj = (numSlots == (numSlotsMask())
					? address + BaseHeaderSize
					: address);
			}
			else {
				actualObj = GIV(nilObj);
			}
		}
		if (oopisGreaterThanOrEqualToandLessThan(actualObj, ((pastSpace()).start), GIV(pastSpaceStart))) {
			while (1) {
				actualObj = objectAfterlimit(actualObj, GIV(pastSpaceStart));
				if (!(oopisLessThan(actualObj, GIV(pastSpaceStart)))) break;
				if (classIndex == ((longAt(actualObj)) & (classIndexMask()))) {
					subsequentObject = actualObj;
					goto l1;
				}
			}
			actualObj = GIV(nilObj);
		}
		while (1) {
			actualObj = objectAfterlimit(actualObj, GIV(endOfMemory));
			if (!(oopisLessThan(actualObj, GIV(endOfMemory)))) break;
			if (classIndex == ((longAt(actualObj)) & (classIndexMask()))) {
				subsequentObject = actualObj;
				goto l1;
			}
		}
		subsequentObject = null;
	l1:	/* end instanceAfter: */;
		if (!(subsequentObject == null)) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), subsequentObject);
			GIV(stackPointer) = sp;
			return;
		}
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
}


/*	Return the object following the receiver in the heap. Return the
	SmallInteger zero when there are no more objects.
 */

	/* InterpreterPrimitives>>#primitiveNextObject */
static void
primitiveNextObject(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt instance;
    char *sp;
    char *sp1;

	instance = accessibleObjectAfter(longAt(GIV(stackPointer)));
	if (instance == null) {
		/* begin pop:thenPushInteger: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((0 << 1) | 1));
		GIV(stackPointer) = sp;
	}
	else {
		assert(isInMemory(instance));
		/* begin pop:thenPush: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), instance);
		GIV(stackPointer) = sp1;
	}
}


/*	A placeholder for primitives that haven't been implemented or are being
	withdrawn gradually. Just absorbs any arguments and returns the receiver.
 */

	/* InterpreterPrimitives>>#primitiveNoop */
static void
primitiveNoop(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	/* begin pop: */
	GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
}

	/* InterpreterPrimitives>>#primitiveNotEqual */
static void
primitiveNotEqual(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArgument;
    sqInt integerReceiver;
    sqInt result;
    char *sp;
    char *sp1;

	integerArgument = longAt(GIV(stackPointer));
	integerReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((integerReceiver & integerArgument) & 1) != 0) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerReceiver != integerArgument
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
	else {
		result = (positiveMachineIntegerValueOf(integerReceiver)) != (positiveMachineIntegerValueOf(integerArgument));
		if (!GIV(primFailCode)) {
			/* begin pop:thenPushBool: */
			longAtput((sp1 = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (result
				? GIV(trueObj)
				: GIV(falseObj)));
			GIV(stackPointer) = sp1;
		}
	}
}


/*	Primitive comparison operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveNotEqualLargeIntegers */
EXPORT(void)
primitiveNotEqualLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqLong integerArg;
    sqLong integerRcvr;
    char *sp;

	integerArg = signed64BitValueOf(longAt(GIV(stackPointer) + (0 * BytesPerWord)));
	integerRcvr = signed64BitValueOf(longAt(GIV(stackPointer) + (1 * BytesPerWord)));
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), (integerRcvr != integerArg
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	is the receiver/first argument not the same object as the (last)
	argument?. pop argumentCount because this can be used as a mirror
	primitive. 
 */

	/* InterpreterPrimitives>>#primitiveNotIdentical */
static void
primitiveNotIdentical(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt otherObject;
    sqInt referent;
    sqInt referent1;
    char *sp;
    sqInt thisObject;

	otherObject = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	thisObject = longAt(GIV(stackPointer));
	if (((otherObject & (tagMask())) == 0)
	 && (((longAt(otherObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		assert(GIV(argumentCount) > 1);
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(thisObject));
		referent = longAt((thisObject + BaseHeaderSize) + (0 << (shiftForWord())));
		while (((referent & (tagMask())) == 0)
		 && (((longAt(referent)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent = longAt((referent + BaseHeaderSize) + (0 << (shiftForWord())));
		}
		otherObject = referent;
	}
	if (((thisObject & (tagMask())) == 0)
	 && (((longAt(thisObject)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
		/* begin followForwarded: */
		assert(isUnambiguouslyForwarder(thisObject));
		referent1 = longAt((thisObject + BaseHeaderSize) + (0 << (shiftForWord())));
		while (((referent1 & (tagMask())) == 0)
		 && (((longAt(referent1)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			referent1 = longAt((referent1 + BaseHeaderSize) + (0 << (shiftForWord())));
		}
		thisObject = referent1;
	}
	/* begin pop:thenPushBool: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (thisObject != otherObject
		? GIV(trueObj)
		: GIV(falseObj)));
	GIV(stackPointer) = sp;
}


/*	Defined for CompiledMethods only */

	/* InterpreterPrimitives>>#primitiveObjectAt */
static void
primitiveObjectAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt integerPointer;
    char *sp;
    sqInt thisReceiver;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		index = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		index = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (GIV(primFailCode)) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	thisReceiver = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!((index > 0)
		 && (index <= ((literalCountOfMethodHeader(methodHeaderOf(thisReceiver))) + LiteralStart)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), longAt((thisReceiver + BaseHeaderSize) + ((index - 1) << (shiftForWord()))));
	GIV(stackPointer) = sp;
}


/*	Store a literal into a CompiledMethod at the given index. Defined for
	CompiledMethods only.
 */

	/* InterpreterPrimitives>>#primitiveObjectAtPut */
static void
primitiveObjectAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt newValue;
    char *sp;
    sqInt thisReceiver;

	newValue = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (((index & 1) == 0)
	 || ((index == ConstOne)
	 && ((newValue & 1) == 0))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	index = (index >> 1);
	thisReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!((index > 0)
		 && (index <= ((literalCountOfMethodHeader(methodHeaderOf(thisReceiver))) + LiteralStart)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	/* begin storePointer:ofObject:withValue: */
	assert(!(isForwarded(thisReceiver)));
	if (isOldObject(thisReceiver)) {

		/* most stores into young objects */

		if (((newValue & (tagMask())) == 0)
		 && (oopisLessThan(newValue, GIV(newSpaceLimit)))) {
			/* begin possibleRootStoreInto: */
			if (!(((((usqInt) (longAt(thisReceiver))) >> (rememberedBitShift())) & 1) != 0)) {
				remember(thisReceiver);
			}
		}
	}
	longAtput((thisReceiver + BaseHeaderSize) + ((index - 1) << (shiftForWord())), newValue);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), newValue);
	GIV(stackPointer) = sp;
}


/*	Return the value of the millisecond clock as an integer, using the old
	method prior to the 64-bit microsecond clock.
 */

	/* InterpreterPrimitives>>#primitiveOriginalMillisecondClock */
EXPORT(sqInt)
primitiveOriginalMillisecondClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	oop = ((((ioOldMSecs()) & MillisecondClockMask) << 1) | 1);
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	primitivePathTo: anObject using: stack <Array> followWeak: boolean
	Answer a path to anObject from the root that does not pass through
	the current context */

	/* InterpreterPrimitives>>#primitivePathToUsing */
EXPORT(sqInt)
primitivePathToUsing(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt current;
    sqInt err;
    sqInt fmt;
    sqInt fmt1;
    sqInt fmt2;
    sqInt followWeak;
    usqInt freeStartAtStart;
    sqInt goal;
    sqInt i;
    sqInt i1;
    sqInt iLimiT;
    sqInt iLimiT1;
    sqInt index;
    sqInt next;
    usqInt numSlots;
    usqInt numSlots1;
    usqInt numSlots11;
    usqInt numSlots12;
    usqInt numSlots2;
    usqInt numSlots3;
    sqInt path;
    char *sp;
    sqInt stack;
    sqInt stackp;
    sqInt stackSize;

	err = 0;
	/* begin externalWriteBackHeadFramePointers */
	assert((GIV(framePointer) - GIV(stackPointer)) < (LargeContextSlots * BytesPerOop));
	assert(GIV(stackPage) == (mostRecentlyUsedPage()));
	/* begin setHeadFP:andSP:inPage: */
	assert(GIV(stackPointer) < GIV(framePointer));
	assert((GIV(stackPointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(stackPointer) > (((GIV(stackPage)->realStackLimit)) - (LargeContextSlots * BytesPerOop))));
	assert((GIV(framePointer) < ((GIV(stackPage)->baseAddress)))
	 && (GIV(framePointer) > (((GIV(stackPage)->realStackLimit)) - ((LargeContextSlots * BytesPerOop) / 2))));
	(GIV(stackPage)->headFP = GIV(framePointer));
	(GIV(stackPage)->headSP = GIV(stackPointer));
	assert(pageListIsWellFormed());
	if (!(GIV(argumentCount) >= 2)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	if (!(((longAt(GIV(stackPointer))) == GIV(trueObj))
		 || ((longAt(GIV(stackPointer))) == GIV(falseObj)))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	/* begin pathTo:using:followWeak: */
	goal = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	stack = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	followWeak = (longAt(GIV(stackPointer))) == GIV(trueObj);
	if (!(((stack & (tagMask())) == 0)
		 && (((((usqInt) (longAt(stack))) >> (formatShift())) & (formatMask())) == 2))) {
		err = PrimErrBadArgument;
		goto l4;
	}
	assert(allObjectsUnmarked());

	/* check no allocations during search */

	freeStartAtStart = freeStart();
	beRootIfOld(stack);
	/* begin lengthOf:format: */
	fmt1 = (((usqInt) (longAt(stack))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots11 = byteAt(stack + 7);
	numSlots2 = (numSlots11 == (numSlotsMask())
		? longAt(stack - BaseHeaderSize)
		: numSlots11);
	if (fmt1 <= 5) {
		stackSize = numSlots2;
		goto l2;
	}
	if (fmt1 >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */

		stackSize = (numSlots2 << (shiftForWord())) - (fmt1 & 7);
		goto l2;
	}
	if (fmt1 >= (firstShortFormat())) {
		stackSize = (numSlots2 << ((shiftForWord()) - 1)) - (fmt1 & 3);
		goto l2;
	}
	if (fmt1 >= (firstLongFormat())) {
		stackSize = (numSlots2 << ((shiftForWord()) - 2)) - (fmt1 & 1);
		goto l2;
	}
	if (fmt1 == (sixtyFourBitIndexableFormat())) {
		stackSize = ((usqInt) numSlots2) >> 1;
		goto l2;
	}
	stackSize = 0;
l2:	/* end lengthOf:format: */;
	/* begin mark: */
	setIsMarkedOfto(stack, 1);
	current = GIV(specialObjectsOop);
	/* begin mark: */
	setIsMarkedOfto(current, 1);
	/* begin lengthOf:format: */
	fmt2 = (((usqInt) (longAt(current))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOfAny: */
	numSlots12 = byteAt(current + 7);
	numSlots3 = (numSlots12 == (numSlotsMask())
		? longAt(current - BaseHeaderSize)
		: numSlots12);
	if (fmt2 <= 5) {
		index = numSlots3;
		goto l3;
	}
	if (fmt2 >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */

		index = (numSlots3 << (shiftForWord())) - (fmt2 & 7);
		goto l3;
	}
	if (fmt2 >= (firstShortFormat())) {
		index = (numSlots3 << ((shiftForWord()) - 1)) - (fmt2 & 3);
		goto l3;
	}
	if (fmt2 >= (firstLongFormat())) {
		index = (numSlots3 << ((shiftForWord()) - 2)) - (fmt2 & 1);
		goto l3;
	}
	if (fmt2 == (sixtyFourBitIndexableFormat())) {
		index = ((usqInt) numSlots3) >> 1;
		goto l3;
	}
	index = 0;
l3:	/* end lengthOf:format: */;
	stackp = 0;
	while(1) {
		while (((index -= 1)) >= -1) {
			if ((((((usqInt)current)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)current)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)current)) <= (((usqInt)GIV(pages))))))) {
				if (index >= 0) {
					next = fieldofFrame(index, ((char *) current));
				}
				else {
					next = GIV(nilObj);
				}
			}
			else {
				if (index >= 0) {
					if (((longAt(current)) & (classIndexMask())) == ClassMethodContextCompactIndex) {
						next = fieldOrSenderFPofContext(index, current);
					}
					else {
						next = longAt((current + BaseHeaderSize) + (index << (shiftForWord())));
					}
				}
				else {
					next = fetchClassOfNonImm(current);
				}
			}
			if ((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))) {
				assert(isFrameonPage(((char *) next), stackPageFor(((char *) next))));
			}
			else {
				assert(checkOkayOop(next));
			}
			if (next == goal) {
				assert(freeStartAtStart == (freeStart()));
				unmarkAfterPathTo();
				/* begin storePointer:ofObject:withValue: */
				assert(!(isForwarded(stack)));
				if (isOldObject(stack)) {

					/* most stores into young objects */

					if (((current & (tagMask())) == 0)
					 && (oopisLessThan(current, GIV(newSpaceLimit)))) {
						/* begin possibleRootStoreInto: */
						if (!(((((usqInt) (longAt(stack))) >> (rememberedBitShift())) & 1) != 0)) {
							remember(stack);
						}
					}
				}
				longAtput((stack + BaseHeaderSize) + (stackp << (shiftForWord())), current);
				pruneStackstackp(stack, stackp);
				err = 0;
				goto l4;
			}
			if (((next & 1) == 0)
			 && (((((((usqInt)next)) & (BytesPerWord - 1)) == 0)
			 && ((((((usqInt)next)) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)next)) <= (((usqInt)GIV(pages))))))
				? !(((longAt(next + FoxFrameFlags)) & 2) != 0)
				: (!(((((usqInt) (longAt(next + 4))) >> 23) & 1) != 0))
					 && (((((next & (tagMask())) == 0)
					 && (((((usqInt) (longAt(next))) >> (formatShift())) & (formatMask())) <= 5))
					 || (((((usqInt) (longAt(next))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
					 && (followWeak
					 || (!(isWeakFormat((((usqInt) (longAt(next))) >> (formatShift())) & (formatMask()))))))))) {
				if ((stackp + 2) > stackSize) {
					assert(freeStartAtStart == (freeStart()));
					unmarkAfterPathTo();
					/* begin nilFieldsOf: */
					for (i = 0, iLimiT = ((numSlotsOf(stack)) - 1); i <= iLimiT; i += 1) {
						/* begin storePointerUnchecked:ofObject:withValue: */
						assert(!(isForwarded(stack)));
						longAtput((stack + BaseHeaderSize) + (i << (shiftForWord())), GIV(nilObj));
					}
					err = PrimErrBadIndex;
					goto l4;
				}
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(stack)));
				longAtput((stack + BaseHeaderSize) + (stackp << (shiftForWord())), current);
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(stack)));
				longAtput((stack + BaseHeaderSize) + ((stackp + 1) << (shiftForWord())), ((index << 1) | 1));
				stackp += 2;
				if ((((((usqInt)(((char *) next)))) & (BytesPerWord - 1)) == 0)
				 && ((((((usqInt)(((char *) next)))) >= (((usqInt)GIV(stackMemory)))) && ((((usqInt)(((char *) next)))) <= (((usqInt)GIV(pages))))))) {
					/* begin markFrame: */
					longAtput(next + FoxFrameFlags, (longAt(next + FoxFrameFlags)) | 2);
					index = CtxtTempFrameStart + (stackPointerIndexForFrame(((char *) next)));
				}
				else {
					/* begin mark: */
					setIsMarkedOfto(next, 1);
					if (((((usqInt) (longAt(next))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())) {
						index = (literalCountOfMethodHeader(methodHeaderOf(next))) + LiteralStart;
					}
					else {
						/* begin lengthOf:format: */
						fmt = (((usqInt) (longAt(next))) >> (formatShift())) & (formatMask());
						/* begin numSlotsOfAny: */
						numSlots1 = byteAt(next + 7);
						numSlots = (numSlots1 == (numSlotsMask())
							? longAt(next - BaseHeaderSize)
							: numSlots1);
						if (fmt <= 5) {
							index = numSlots;
							goto l1;
						}
						if (fmt >= (firstByteFormat())) {

							/* bytes, including CompiledMethod */

							index = (numSlots << (shiftForWord())) - (fmt & 7);
							goto l1;
						}
						if (fmt >= (firstShortFormat())) {
							index = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
							goto l1;
						}
						if (fmt >= (firstLongFormat())) {
							index = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
							goto l1;
						}
						if (fmt == (sixtyFourBitIndexableFormat())) {
							index = ((usqInt) numSlots) >> 1;
							goto l1;
						}
						index = 0;
					l1:	/* end lengthOf:format: */;
					}
				}
				current = next;
			}
		}
		if (current == GIV(specialObjectsOop)) {
			assert(freeStartAtStart == (freeStart()));
			unmarkAfterPathTo();
			/* begin nilFieldsOf: */
			for (i1 = 0, iLimiT1 = ((numSlotsOf(stack)) - 1); i1 <= iLimiT1; i1 += 1) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(stack)));
				longAtput((stack + BaseHeaderSize) + (i1 << (shiftForWord())), GIV(nilObj));
			}
			err = PrimErrNotFound;
			goto l4;
		}
		index = ((longAt((stack + BaseHeaderSize) + ((stackp - 1) << (shiftForWord())))) >> 1);
		current = longAt((stack + BaseHeaderSize) + ((stackp - 2) << (shiftForWord())));
		stackp -= 2;
	}
l4:	/* end pathTo:using:followWeak: */;
	if (err != 0) {
		return (GIV(primFailCode) = err);
	}
	path = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), path);
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitivePerformInSuperclass */
static void
primitivePerformInSuperclass(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argumentArray;
    usqInt arraySize;
    sqInt currentClass;
    sqInt delta;
    sqInt err;
    sqInt errorCode;
    sqInt hash;
    sqInt i;
    sqInt index;
    sqInt lookupClass;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt nItems;
    sqInt numArgs;
    usqInt numSlots;
    sqInt numTemps;
    usqInt object;
    sqInt objOop;
    sqInt offset;
    sqInt performArgCount;
    sqInt rcvr;
    sqInt rcvr1;
    char *savedFramePointer;
    char *savedStackPointer;
    sqInt selector;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt tagBits2;
    sqInt top;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	rcvr = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	lookupClass = longAt(GIV(stackPointer));
	if ((GIV(argumentCount) > 3)
	 && (((rcvr & (tagMask())) == 0)
	 && (((longAt(rcvr)) & (classIndexMask())) == (isForwardedObjectClassIndexPun())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (((tagBits = rcvr & (tagMask()))) != 0) {
		currentClass = longAt((GIV(classTableFirstPage) + BaseHeaderSize) + (tagBits << (shiftForWord())));
	}
	else {
		currentClass = fetchClassOfNonImm(rcvr);
	}
	while (currentClass != lookupClass) {
		/* begin followField:ofObject: */
		objOop = longAt((currentClass + BaseHeaderSize) + (SuperclassIndex << (shiftForWord())));
		if (((objOop & (tagMask())) == 0)
		 && (((longAt(objOop)) & (classIndexMask())) == (isForwardedObjectClassIndexPun()))) {
			objOop = fixFollowedFieldofObjectwithInitialValue(SuperclassIndex, currentClass, objOop);
		}
		currentClass = objOop;
		if (currentClass == GIV(nilObj)) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
	}
	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	selector = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((argumentArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift())) & (formatMask())) == 2))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l3;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask())
		? longAt(argumentArray - BaseHeaderSize)
		: numSlots);
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l3;
	}

	/* Push newMethod to save it in case of failure,
	   then push the actual receiver and the args in the array. */

	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((index - 1) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), rcvr);
	
	findNewMethodInClassTag((lookupClass == null
		? (((tagBits1 = rcvr & (tagMask()))) != 0
				? ((tagBits1 & 1) != 0
						? 1
						: tagBits1)
				: (longAt(rcvr)) & (classIndexMask()))
		: (/* begin classTagForClass: */
			assert(addressCouldBeClassObj(lookupClass)),
			/* begin ensureBehaviorHash: */
			assert(addressCouldBeClassObj(lookupClass)),
			(((hash = (long32At(lookupClass + 4)) & (identityHashHalfWordMask()))) != 0
					? hash
					: (objCouldBeClassObj(lookupClass)
							? (((err = enterIntoClassTable(lookupClass))) != 0
									? -err
									: (long32At(lookupClass + 4)) & (identityHashHalfWordMask()))
							: -PrimErrBadReceiver)))));
	if ((((GIV(newMethod) & (tagMask())) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */

		assert((stackTop()) == ((arraySize == 0
	? rcvr
	: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		nItems = arraySize + 1;
		GIV(stackPointer) += nItems * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l3;
	}

	/* +2 = receiver + saved newMethod */

	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	/* begin justActivateNewMethod */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */

	rcvr1 = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr1)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	GIV(bytecodeSetSelector) = ((((sqInt) methodHeader1)) < 0
		? 256
		: 0);

	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (numArgs << 8)) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr1);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader1))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((sqInt) methodHeader1)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << (shiftForWord())));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
l3:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}

	/* InterpreterPrimitives>>#primitivePerformWithArgs */
static void
primitivePerformWithArgs(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt actualReceiver;
    sqInt argumentArray;
    usqInt arraySize;
    sqInt delta;
    sqInt err;
    sqInt errorCode;
    sqInt hash;
    sqInt i;
    sqInt index;
    sqInt methodHeader;
    sqInt methodHeader1;
    sqInt nArgs;
    sqInt nItems;
    sqInt numArgs;
    usqInt numSlots;
    sqInt numTemps;
    usqInt object;
    sqInt offset;
    sqInt performArgCount;
    sqInt rcvr;
    char *savedFramePointer;
    char *savedStackPointer;
    sqInt selector;
    char *sp;
    char *sp1;
    char *sp11;
    char *sp2;
    char *sp21;
    char *sp3;
    char *sp4;
    char *sp5;
    char *sp6;
    char *sp7;
    sqInt table;
    sqInt tagBits;
    sqInt tagBits1;
    sqInt top;

	nArgs = 0;
	savedFramePointer = 0;
	savedStackPointer = 0;
	/* begin primitiveObject:perform:withArguments:lookedUpIn: */
	actualReceiver = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	selector = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	argumentArray = longAt(GIV(stackPointer));
	if (!(((argumentArray & (tagMask())) == 0)
		 && (((((usqInt) (longAt(argumentArray))) >> (formatShift())) & (formatMask())) == 2))) {
		GIV(primFailCode) = PrimErrBadArgument;
		goto l3;
	}
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(argumentArray)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(argumentArray + 7);
	arraySize = (numSlots == (numSlotsMask())
		? longAt(argumentArray - BaseHeaderSize)
		: numSlots);
	if (arraySize > (LargeContextSlots - CtxtTempFrameStart)) {
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l3;
	}

	/* Push newMethod to save it in case of failure,
	   then push the actual receiver and the args in the array. */

	performArgCount = GIV(argumentCount);
	/* begin push: */
	longAtput((sp1 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp1;
	/* begin push: */
	longAtput((sp2 = GIV(stackPointer) - BytesPerWord), actualReceiver);
	GIV(stackPointer) = sp2;
	for (index = 1; index <= arraySize; index += 1) {
		/* begin push: */
		longAtput((sp = GIV(stackPointer) - BytesPerWord), longAt((argumentArray + BaseHeaderSize) + ((index - 1) << (shiftForWord()))));
		GIV(stackPointer) = sp;
	}
	GIV(argumentCount) = arraySize;
	GIV(messageSelector) = selector;
	/* begin sendBreakpoint:receiver: */
	sendBreakpointreceiver(firstFixedFieldOfMaybeImmediate(GIV(messageSelector)), lengthOfMaybeImmediate(GIV(messageSelector)), actualReceiver);
	
	findNewMethodInClassTag((((tagBits1 = actualReceiver & (tagMask()))) != 0
		? ((tagBits1 & 1) != 0
				? 1
				: tagBits1)
		: (longAt(actualReceiver)) & (classIndexMask())));
	if ((((GIV(newMethod) & (tagMask())) == 0)
	 && (((((usqInt) (longAt(GIV(newMethod)))) >> (formatShift())) & (formatMask())) >= (firstCompiledMethodFormat())))
	 && ((argumentCountOf(GIV(newMethod))) != GIV(argumentCount))) {

		/* Restore the state by popping the array entries, the actual receiver and the saved
		   newMethod, leaving the selector and array, and fail.  N.B.  If an MNU has happened
		   then argumentCount will match newMethod, so this code will not be reached. */
		/* These asserts check that an MNU has not occurred if the argumentCount doesn't match the newMethod. */

		assert((stackTop()) == ((arraySize == 0
	? actualReceiver
	: fetchPointerofObject(arraySize - 1, argumentArray))));
		assert(GIV(argumentCount) == arraySize);
		/* begin pop: */
		nItems = arraySize + 1;
		GIV(stackPointer) += nItems * BytesPerWord;
		/* begin popStack */
		top = longAt(GIV(stackPointer));
		GIV(stackPointer) += BytesPerWord;
		GIV(newMethod) = top;
		GIV(primFailCode) = PrimErrBadNumArgs;
		goto l3;
	}

	/* +2 = receiver + saved newMethod */

	delta = BytesPerWord * (performArgCount + 2);
	for (offset = (GIV(argumentCount) * BytesPerWord); offset >= 0; offset += (-BytesPerWord)) {
		longAtput((GIV(stackPointer) + offset) + delta, longAt(GIV(stackPointer) + offset));
	}
	/* begin pop: */
	GIV(stackPointer) += (performArgCount + 2) * BytesPerWord;
	/* begin executeNewMethod */
	if (primitiveFunctionPointer != 0) {
		if ((((unsigned long) primitiveFunctionPointer)) <= MaxQuickPrimitiveIndex) {
			externalQuickPrimitiveResponse();
			goto l1;
		}
		/* begin slowPrimitiveResponse */
		assert(!(isOopForwarded(stackValue(GIV(argumentCount)))));
		assert((remapBufferCount()) == 0);
		
		/* begin initPrimCall */
		GIV(primFailCode) = 0;
		dispatchFunctionPointer(primitiveFunctionPointer);
		/* begin maybeRetryFailureDueToForwarding */
		if (GIV(primFailCode)
		 && (checkForAndFollowForwardedPrimitiveState())) {
			/* begin initPrimCall */
			GIV(primFailCode) = 0;
			dispatchFunctionPointer(primitiveFunctionPointer);
		}
		/* begin maybeFailForLastObjectOverwrite */
		if (checkAllocFiller) {
			if (((freeStart()) < GIV(scavengeThreshold))
			 && ((longAt(freeStart())) != (freeStart()))) {
				GIV(primFailCode) = PrimErrWritePastObject;
			}
		}
		
		if (GIV(nextProfileTick) > 0) {
			checkProfileTick(GIV(newMethod));
		}
		!GIV(primFailCode);
		if (!GIV(primFailCode)) {
			goto l1;
		}
	}
	/* begin activateNewMethod */
	/* begin justActivateNewMethod */
	/* begin methodHeaderOf: */
	assert(isCompiledMethod(GIV(newMethod)));
	methodHeader1 = longAt((GIV(newMethod) + BaseHeaderSize) + (HeaderIndex << (shiftForWord())));
	numTemps = (((usqInt) methodHeader1) >> MethodHeaderTempCountShift) & 0x3F;
	numArgs = (((usqInt) methodHeader1) >> MethodHeaderArgCountShift) & 15;

	/* could new rcvr be set at point of send? */

	rcvr = longAt(GIV(stackPointer) + (numArgs * BytesPerWord));
	assert(!(isOopForwarded(rcvr)));
	/* begin push: */
	longAtput((sp11 = GIV(stackPointer) - BytesPerWord), GIV(instructionPointer));
	GIV(stackPointer) = sp11;
	/* begin push: */
	longAtput((sp21 = GIV(stackPointer) - BytesPerWord), GIV(framePointer));
	GIV(stackPointer) = sp21;
	GIV(framePointer) = GIV(stackPointer);
	/* begin push: */
	longAtput((sp3 = GIV(stackPointer) - BytesPerWord), GIV(newMethod));
	GIV(stackPointer) = sp3;
	/* begin setMethod:methodHeader: */
	GIV(method) = GIV(newMethod);
	assert(isOopCompiledMethod(GIV(method)));
	assert((methodHeaderOf(GIV(method))) == methodHeader1);
	GIV(bytecodeSetSelector) = ((((sqInt) methodHeader1)) < 0
		? 256
		: 0);

	/* begin push: */
	object = (VMBIGENDIAN
		? ((1 + (numArgs << ((BytesPerWord * 8) - 8))) + (0)) + (0)
		: ((1 + (numArgs << 8)) + (0)) + (0));
	longAtput((sp4 = GIV(stackPointer) - BytesPerWord), object);
	GIV(stackPointer) = sp4;
	/* begin push: */
	longAtput((sp5 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
	GIV(stackPointer) = sp5;
	/* begin push: */
	longAtput((sp6 = GIV(stackPointer) - BytesPerWord), rcvr);
	GIV(stackPointer) = sp6;
	for (i = (numArgs + 1); i <= numTemps; i += 1) {
		/* begin push: */
		longAtput((sp7 = GIV(stackPointer) - BytesPerWord), GIV(nilObj));
		GIV(stackPointer) = sp7;
	}
	GIV(instructionPointer) = ((GIV(newMethod) + ((LiteralStart + (literalCountOfMethodHeader(methodHeader1))) * BytesPerOop)) + BaseHeaderSize) - 1;
	if (methodHeader1 & AlternateHeaderHasPrimFlag) {

		/* Skip the CallPrimitive bytecode, if it's there, and store the error code if the method starts
		   with a long store temp.  Strictly no need to skip the store because it's effectively a noop. */

		GIV(instructionPointer) += 3;
		if (GIV(primFailCode) != 0) {
			if ((byteAt(GIV(instructionPointer) + 1)) == (((((sqInt) methodHeader1)) < 0
		? AltLongStoreBytecode
		: LongStoreBytecode))) {
				/* begin getErrorObjectFromPrimFailCode */
				if (GIV(primFailCode) > 0) {
					table = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (PrimErrTableIndex << (shiftForWord())));
					if (GIV(primFailCode) <= (numSlotsOf(table))) {
						errorCode = longAt((table + BaseHeaderSize) + ((GIV(primFailCode) - 1) << (shiftForWord())));
						goto l2;
					}
				}
				errorCode = ((GIV(primFailCode) << 1) | 1);
			l2:	/* end getErrorObjectFromPrimFailCode */;
				longAtPointerput(GIV(stackPointer), errorCode);
			}
			GIV(primFailCode) = 0;
		}
	}
	methodHeader = methodHeader1;
	if (GIV(stackPointer) < GIV(stackLimit)) {
		handleStackOverflowOrEventAllowContextSwitch(canContextSwitchIfActivatingheader(GIV(newMethod), methodHeader));
	}
l1:	/* end executeNewMethod */;
	/* begin initPrimCall */
	GIV(primFailCode) = 0;
l3:	/* end primitiveObject:perform:withArguments:lookedUpIn: */;
}


/*	Primitive. Answer the last primitive method sampled by the profiler. */

	/* InterpreterPrimitives>>#primitiveProfilePrimitive */
EXPORT(sqInt)
primitiveProfilePrimitive(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileMethod));
	GIV(stackPointer) = sp;
	GIV(profileMethod) = GIV(nilObj);
}


/*	Primitive. Answer the last sample taken by the profiler, or nil if the
	profiler isn't active.
	See also primitiveProfileStart.
 */

	/* InterpreterPrimitives>>#primitiveProfileSample */
EXPORT(sqInt)
primitiveProfileSample(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    char *sp;

	if (!(GIV(argumentCount) == 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), GIV(profileProcess));
	GIV(stackPointer) = sp;
	GIV(profileProcess) = GIV(nilObj);
}


/*	Primitive. Install the semaphore to be used for profiling, 
	or nil if no semaphore should be used.
	See also primitiveProfileStart. */

	/* InterpreterPrimitives>>#primitiveProfileSemaphore */
EXPORT(sqInt)
primitiveProfileSemaphore(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt sema;

	if (!(GIV(argumentCount) == 1)) {
		return (GIV(primFailCode) = PrimErrBadNumArgs);
	}
	sema = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	if (!((sema == GIV(nilObj))
		 || (((sema & (tagMask())) == 0)
		 && (((longAt(sema)) & (classIndexMask())) == (rawHashBitsOf(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassSemaphore << (shiftForWord()))))))))) {
		return (GIV(primFailCode) = PrimErrBadArgument);
	}
	GIV(profileSemaphore) = sema;
	GIV(profileProcess) = (GIV(profileMethod) = GIV(nilObj));
	/* begin pop: */
	GIV(stackPointer) += 1 * BytesPerWord;
}


/*	Primitive. Begin profiling execution every by using the interrupt
	check-counter instead of a time-based process (which is limited to timing
	resolution and triggers off the same signal that many of the processes
	being profiled trigger off leading to consistently wrong results).
	The argument is the number of interrupt checks (method activations) to let
	go by before taking a sample. The sample is being stored in the
	profileSample iVar which can be retrieved by executing
	primitiveProfileSample. When a sample is taken, it signals the semaphore
	specified in primitiveProfileSemaphore.
	If the argument is less or equal to zero, it disables profiling.
 */

	/* InterpreterPrimitives>>#primitiveProfileStart */
EXPORT(sqInt)
primitiveProfileStart(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt deltaTicks;
    sqInt integerPointer;

	if (!(GIV(argumentCount) == 1)) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		deltaTicks = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		deltaTicks = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		GIV(nextProfileTick) = (ioHighResClock()) + deltaTicks;
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveQuit */
static void
primitiveQuit(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	ioExitWithErrorCode((GIV(argumentCount) == 1
		? ((longAt(GIV(stackPointer))) >> 1)
		: 0));
}


/*	Rounds negative results towards zero. */

	/* InterpreterPrimitives>>#primitiveQuo */
static void
primitiveQuo(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerArg;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerRcvr;
    sqInt integerResult;
    char *sp;

	integerResult = 0;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		integerRcvr = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerRcvr = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		integerArg = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		integerArg = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin success: */
	if (!(integerArg != 0)) {

		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (!GIV(primFailCode)) {
		integerResult = (integerRcvr > 0
			? (integerArg > 0
					? integerRcvr / integerArg
					: 0 - (integerRcvr / (0 - integerArg)))
			: (integerArg > 0
					? 0 - ((0 - integerRcvr) / integerArg)
					: (0 - integerRcvr) / (0 - integerArg)));
	}
	/* begin pop2AndPushIntegerIfOK: */
	if (!GIV(primFailCode)) {
		if ((((sqInt)(integerResult ^ (integerResult << 1)))) >= 0) {
			/* begin pop:thenPush: */
			longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((integerResult << 1) | 1));
			GIV(stackPointer) = sp;
		}
		else {
			/* begin success: */
			
			/* Don't overwrite an error code that has already been set. */

			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}

		}
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveQuoLargeIntegers */
EXPORT(void)
primitiveQuoLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt bIsNegative;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	bIsNegative = isNegativeIntegerValueOf(oopArg);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a / b;
	oopResult = magnitude64BitIntegerForneg(result, bIsNegative != aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Relinquish the processor for up to the given number of microseconds. The
	exact behavior of this primitive is platform dependent.
 */

	/* InterpreterPrimitives>>#primitiveRelinquishProcessor */
static void
primitiveRelinquishProcessor(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt microSecs;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		microSecs = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		microSecs = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {

		/* DO NOT allow relinquishing the processor while we are profiling since this
		   may skew the time base for our measures (it may reduce processor speed etc).
		   Instead we go full speed, therefore measuring the precise time we spend in the
		   inner idle loop as a busy loop. */

		if (GIV(nextProfileTick) == 0) {
			ioRelinquishProcessorForMicroseconds(microSecs);
		}
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Primitive arithmetic operations for large integers in 64 bit range */

	/* InterpreterPrimitives>>#primitiveRemLargeIntegers */
EXPORT(void)
primitiveRemLargeIntegers(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong a;
    sqInt aIsNegative;
    usqLong b;
    sqInt oopArg;
    sqInt oopRcvr;
    sqInt oopResult;
    usqLong result;
    char *sp;

	oopArg = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	oopRcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	aIsNegative = isNegativeIntegerValueOf(oopRcvr);
	a = magnitude64BitValueOf(oopRcvr);
	b = magnitude64BitValueOf(oopArg);
	if (b == 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	if (GIV(primFailCode)) {
		return;
	}
	result = a % b;
	oopResult = magnitude64BitIntegerForneg(result, aIsNegative);
	if (!GIV(primFailCode)) {
		/* begin pop:thenPush: */
		longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), oopResult);
		GIV(stackPointer) = sp;
	}
}


/*	Put this process on the scheduler's lists thus allowing it to proceed next
	time there is
	a chance for processes of it's priority level. It must go to the back of
	its run queue so
	as not to preempt any already running processes at this level. If the
	process's priority
	is higher than the current process, preempt the current process. */

	/* InterpreterPrimitives>>#primitiveResume */
static void
primitiveResume(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt proc;


	/* rcvr */

	proc = longAt(GIV(stackPointer));
	if (!(isContext(longAt((proc + BaseHeaderSize) + (SuspendedContextIndex << (shiftForWord())))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	resumepreemptedYieldingIf(proc, GIV(preemptionYields));
}


/*	The character scanner primitive. */

	/* InterpreterPrimitives>>#primitiveScanCharacters */
static void
primitiveScanCharacters(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt ascii;
    sqInt glyphIndex;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt kernDelta;
    sqInt maxGlyph;
    sqInt nextDestX;
    sqInt nilOop;
    sqInt oop;
    sqInt oop1;
    sqInt oop2;
    sqInt rcvr;
    sqInt scanDestX;
    sqInt scanLastIndex;
    sqInt scanMap;
    sqInt scanRightX;
    sqInt scanStartIndex;
    sqInt scanStopIndex;
    sqInt scanXTable;
    sqInt sourceString;
    sqInt sourceX;
    sqInt sourceX2;
    char *sp;
    char *sp1;
    char *sp2;
    sqInt stopReason;
    sqInt stops;

	if (!(GIV(argumentCount) == 6)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		kernDelta = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		kernDelta = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		stops = null;
		goto l2;
	}
	stops = oop;
l2:	/* end stackObjectValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		scanRightX = (integerPointer1 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanRightX = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop1 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	if ((oop1 & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		sourceString = null;
		goto l4;
	}
	sourceString = oop1;
l4:	/* end stackObjectValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (4 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		scanStopIndex = (integerPointer2 >> 1);
		goto l5;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStopIndex = 0;
		goto l5;
	}
l5:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (5 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		scanStartIndex = (integerPointer3 >> 1);
		goto l6;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		scanStartIndex = 0;
		goto l6;
	}
l6:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop2 = longAt(GIV(stackPointer) + (6 * BytesPerWord));
	if ((oop2 & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		rcvr = null;
		goto l7;
	}
	rcvr = oop2;
l7:	/* end stackObjectValue: */;
	if (GIV(primFailCode)) {
		return;
	}
	if (!(((stops & (tagMask())) == 0)
		 && (((((usqInt) (longAt(stops))) >> (formatShift())) & (formatMask())) == 2))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((slotSizeOf(stops)) >= 258)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!(((sourceString & (tagMask())) == 0)
		 && (((((usqInt) (longAt(sourceString))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((scanStartIndex > 0)
		 && ((scanStopIndex > 0)
		 && (scanStopIndex <= (byteSizeOf(sourceString)))))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((((rcvr & (tagMask())) == 0)
		 && (((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask())) <= 5))
		 && ((slotSizeOf(rcvr)) >= 4))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	scanDestX = fetchIntegerofObject(0, rcvr);
	scanLastIndex = fetchIntegerofObject(1, rcvr);
	scanXTable = longAt((rcvr + BaseHeaderSize) + (2 << (shiftForWord())));
	scanMap = longAt((rcvr + BaseHeaderSize) + (3 << (shiftForWord())));
	if (!((((scanXTable & (tagMask())) == 0)
		 && (((((usqInt) (longAt(scanXTable))) >> (formatShift())) & (formatMask())) == 2))
		 && (((scanMap & (tagMask())) == 0)
		 && (((((usqInt) (longAt(scanMap))) >> (formatShift())) & (formatMask())) == 2)))) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (!((slotSizeOf(scanMap)) == 256)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	if (GIV(primFailCode)) {
		return;
	}

	/* Okay, here we go. We have eliminated nearly all failure
	   conditions, to optimize the inner fetches. */

	maxGlyph = (slotSizeOf(scanXTable)) - 2;
	scanLastIndex = scanStartIndex;
	nilOop = GIV(nilObj);
	while (scanLastIndex <= scanStopIndex) {

		/* Known to be okay since scanStartIndex > 0 and scanStopIndex <= sourceString size */


		/* Known to be okay since stops size >= 258 */

		ascii = byteAt((sourceString + BaseHeaderSize) + (scanLastIndex - 1));
		if (!(((stopReason = longAt((stops + BaseHeaderSize) + (ascii << (shiftForWord()))))) == nilOop)) {

			/* Store everything back and get out of here since some stop conditionn needs to be checked */

			if (!((((sqInt)(scanDestX ^ (scanDestX << 1)))) >= 0)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)(scanDestX ^ (scanDestX << 1)))) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (0 << (shiftForWord())), ((scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)(scanLastIndex ^ (scanLastIndex << 1)))) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (1 << (shiftForWord())), ((scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop: */
			GIV(stackPointer) += 7 * BytesPerWord;
			/* begin push: */
			longAtput((sp = GIV(stackPointer) - BytesPerWord), stopReason);
			GIV(stackPointer) = sp;
			return;
		}

		/* fail if the glyphIndex is out of range */

		glyphIndex = fetchIntegerofObject(ascii, scanMap);
		if (GIV(primFailCode)
		 || ((glyphIndex < 0)
		 || (glyphIndex > maxGlyph))) {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
			return;
		}
		sourceX = fetchIntegerofObject(glyphIndex, scanXTable);

		/* Above may fail if non-integer entries in scanXTable */

		sourceX2 = fetchIntegerofObject(glyphIndex + 1, scanXTable);
		if (GIV(primFailCode)) {
			return;
		}
		nextDestX = (scanDestX + sourceX2) - sourceX;
		if (nextDestX > scanRightX) {

			/* Store everything back and get out of here since we got to the right edge */

			if (!((((sqInt)(scanDestX ^ (scanDestX << 1)))) >= 0)) {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
				return;
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)(scanDestX ^ (scanDestX << 1)))) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (0 << (shiftForWord())), ((scanDestX << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin storeInteger:ofObject:withValue: */
			if ((((sqInt)(scanLastIndex ^ (scanLastIndex << 1)))) >= 0) {
				/* begin storePointerUnchecked:ofObject:withValue: */
				assert(!(isForwarded(rcvr)));
				longAtput((rcvr + BaseHeaderSize) + (1 << (shiftForWord())), ((scanLastIndex << 1) | 1));
			}
			else {
				/* begin primitiveFail */
				if (!GIV(primFailCode)) {
					GIV(primFailCode) = 1;
				}
			}
			/* begin pop:thenPush: */
			longAtput((sp1 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + BaseHeaderSize) + ((CrossedX - 1) << (shiftForWord()))));
			GIV(stackPointer) = sp1;
			return;
		}
		scanDestX = nextDestX + kernDelta;
		scanLastIndex += 1;
	}
	if (!((((sqInt)(scanDestX ^ (scanDestX << 1)))) >= 0)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return;
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((sqInt)(scanDestX ^ (scanDestX << 1)))) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(rcvr)));
		longAtput((rcvr + BaseHeaderSize) + (0 << (shiftForWord())), ((scanDestX << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin storeInteger:ofObject:withValue: */
	if ((((sqInt)(scanStopIndex ^ (scanStopIndex << 1)))) >= 0) {
		/* begin storePointerUnchecked:ofObject:withValue: */
		assert(!(isForwarded(rcvr)));
		longAtput((rcvr + BaseHeaderSize) + (1 << (shiftForWord())), ((scanStopIndex << 1) | 1));
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
	}
	/* begin pop:thenPush: */
	longAtput((sp2 = GIV(stackPointer) + ((7 - 1) * BytesPerWord)), longAt((stops + BaseHeaderSize) + ((EndOfRun - 1) << (shiftForWord()))));
	GIV(stackPointer) = sp2;
}


/*	Return a SmallInteger indicating the current depth of the OS screen.
	Negative values are used to imply LSB type pixel format an there is some
	support in the VM for handling either MSB or LSB
 */

	/* InterpreterPrimitives>>#primitiveScreenDepth */
EXPORT(sqInt)
primitiveScreenDepth(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt depth;
    char *sp;

	depth = ioScreenDepth();
	if (GIV(primFailCode)) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		return null;
	}
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), ((depth << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Answer a point indicating the current size of the Smalltalk window.
	Currently there is a limit of 65535 in each direction because the
	point is encoded into a single 32bit value in the image header.
	This might well become a problem one day */

	/* InterpreterPrimitives>>#primitiveScreenSize */
static void
primitiveScreenSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt classObj;
    sqInt knownClassIndex;
    usqInt newObj;
    usqInt numBytes;
    sqInt numSlots;
    sqInt objFormat;
    sqInt oop;
    sqInt pointResult;
    sqInt pointWord;
    char *sp;

	pointWord = ioScreenSize();
	/* begin pop:thenPush: */
	/* begin makePointwithxValue:yValue: */
	/* begin eeInstantiateSmallClass:numSlots: */
	classObj = longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (ClassPoint << (shiftForWord())));
	numSlots = YIndex + 1;
	assert((rawHashBitsOf(classObj)) != 0);
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	knownClassIndex = (long32At(classObj + 4)) & (identityHashHalfWordMask());
	/* begin instSpecOfClassFormat: */
	objFormat = (((usqInt) (((longAt((classObj + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1))) >> (fixedFieldsFieldWidth())) & (formatMask());
	assert((numSlots >= 0)
	 && (knownClassIndex != 0));
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(knownClassIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(numSlots < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + ((numSlots <= 1
	? 8
	: (numSlots + (numSlots & 1)) * BytesPerOop));
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			pointResult = 0;
			goto l1;
		}
	}
	long64Atput(newObj, (((((usqLong) numSlots)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + knownClassIndex);
	GIV(freeStart) += numBytes;
	pointResult = newObj;
l1:	/* end eeInstantiateSmallClass:numSlots: */;
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (XIndex << (shiftForWord())), ((((((usqInt) pointWord) >> 16) & 0xFFFF) << 1) | 1));
	/* begin storePointerUnchecked:ofObject:withValue: */
	assert(!(isForwarded(pointResult)));
	longAtput((pointResult + BaseHeaderSize) + (YIndex << (shiftForWord())), (((pointWord & 0xFFFF) << 1) | 1));
	oop = pointResult;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Return the number of seconds since January 1, 1901 as an integer. */

	/* InterpreterPrimitives>>#primitiveSecondsClock */
static void
primitiveSecondsClock(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerValue;
    sqInt newLargeInteger;
    usqInt newObj;
    usqInt numBytes;
    sqInt objFormat;
    sqInt oop;
    char *sp;

	/* begin pop:thenPush: */
	/* begin positive32BitIntegerFor: */
	integerValue = ioSecondsNow();
	/* begin maybeInlinePositive32BitIntegerFor: */
	assert(!((hasSixtyFourBitImmediates())));
	if (((((sqInt)integerValue)) >= 0)
	 && ((((sqInt)(integerValue ^ (integerValue << 1)))) >= 0)) {
		oop = ((integerValue << 1) | 1);
		goto l3;
	}
	/* begin eeInstantiateSmallClassIndex:format:numSlots: */
	objFormat = (firstByteFormat()) + ((8 - 4) & (BytesPerWord - 1));
	assert(ClassLargePositiveIntegerCompactIndex != 0);
	assert(((objFormat < (firstByteFormat())
	? objFormat
	: objFormat & (byteFormatMask()))) == (instSpecOfClass(knownClassAtIndex(ClassLargePositiveIntegerCompactIndex))));
	/* begin allocateSmallNewSpaceSlots:format:classIndex: */
	assert(1 < (numSlotsMask()));
	newObj = GIV(freeStart);
	numBytes = BaseHeaderSize + (8);
	assert((numBytes % (allocationUnit())) == 0);
	assert((newObj % (allocationUnit())) == 0);
	if ((GIV(freeStart) + numBytes) > GIV(scavengeThreshold)) {
		if (!GIV(needGCFlag)) {
			/* begin scheduleScavenge */
			GIV(needGCFlag) = 1;
			forceInterruptCheck();
		}
		if ((GIV(freeStart) + numBytes) > (((eden()).limit))) {
			error("no room in eden for allocateSmallNewSpaceSlots:format:classIndex:");
			newLargeInteger = 0;
			goto l2;
		}
	}
	long64Atput(newObj, (((((usqLong) 1)) << (numSlotsFullShift())) + (objFormat << (formatShift()))) + ClassLargePositiveIntegerCompactIndex);
	GIV(freeStart) += numBytes;
	newLargeInteger = newObj;
l2:	/* end allocateSmallNewSpaceSlots:format:classIndex: */;
	
#  if VMBIGENDIAN
	byteAtput((newLargeInteger + BaseHeaderSize) + 3, (((usqInt) integerValue) >> 24) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 2, (((usqInt) integerValue) >> 16) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize) + 1, (((usqInt) integerValue) >> 8) & 0xFF);
	byteAtput((newLargeInteger + BaseHeaderSize), integerValue & 0xFF);

#  else /* VMBIGENDIAN */
	long32Atput((newLargeInteger + BaseHeaderSize) + (0 << 2), integerValue);

#  endif /* VMBIGENDIAN */

	oop = newLargeInteger;
l3:	/* end maybeInlinePositive32BitIntegerFor: */;
	goto l1;

l1:	/* end positive32BitIntegerFor: */;
	longAtput((sp = GIV(stackPointer) + ((1 - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Set to OS to the requested display mode.
	See also DisplayScreen setDisplayDepth:extent:fullscreen: */

	/* InterpreterPrimitives>>#primitiveSetDisplayMode */
static void
primitiveSetDisplayMode(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt d;
    sqInt fsFlag;
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt okay;
    char *sp;
    sqInt w;

	okay = 0;
	/* begin booleanValueOf: */
	if ((longAt(GIV(stackPointer))) == GIV(trueObj)) {
		fsFlag = 1;
		goto l1;
	}
	if ((longAt(GIV(stackPointer))) == GIV(falseObj)) {
		fsFlag = 0;
		goto l1;
	}
	/* begin success: */
	
	/* Don't overwrite an error code that has already been set. */

	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}

	fsFlag = null;
l1:	/* end booleanValueOf: */;
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		d = (integerPointer2 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		d = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		okay = ioSetDisplayMode(w, h, d, fsFlag);
	}
	if (!GIV(primFailCode)) {
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + ((5 - 1) * BytesPerWord)), (okay
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
	}
}


/*	On platforms that support it, set full-screen mode to the value of the
	boolean argument.
 */

	/* InterpreterPrimitives>>#primitiveSetFullScreen */
static void
primitiveSetFullScreen(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt argOop;

	argOop = longAt(GIV(stackPointer));
	if (argOop == GIV(trueObj)) {
		ioSetFullScreen(1);
	}
	else {
		if (argOop == GIV(falseObj)) {
			ioSetFullScreen(0);
		}
		else {
			/* begin primitiveFail */
			if (!GIV(primFailCode)) {
				GIV(primFailCode) = 1;
			}
		}
	}
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
}


/*	Set the user interrupt keycode. The keycode is an integer whose encoding
	is described in the comment for primitiveKbdNext.
 */

	/* InterpreterPrimitives>>#primitiveSetInterruptKey */
static void
primitiveSetInterruptKey(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt integerPointer;
    sqInt keycode;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		keycode = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		keycode = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		/* begin setInterruptKeycode: */
		GIV(interruptKeycode) = keycode;
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Set the VM's log directory */

	/* InterpreterPrimitives>>#primitiveSetLogDirectory */
EXPORT(sqInt)
primitiveSetLogDirectory(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    usqInt numBytes;
    usqInt numSlots;
    sqInt stringOop;
    sqInt sz;

	stringOop = longAt(GIV(stackPointer));
	if (!(((stringOop & (tagMask())) == 0)
		 && (((((usqInt) (longAt(stringOop))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin byteSizeOf: */
	if ((stringOop & (tagMask())) != 0) {
		sz = 0;
		goto l1;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(stringOop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(stringOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(stringOop + 7);
	numBytes = (numSlots == (numSlotsMask())
		? longAt(stringOop - BaseHeaderSize)
		: numSlots);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */

		sz = numBytes - (fmt & 7);
		goto l2;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		sz = numBytes;
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		sz = numBytes - ((fmt & 3) << 1);
		goto l2;
	}
	sz = numBytes - ((fmt & 1) << 2);
l2:	/* end numBytesOf: */;
l1:	/* end byteSizeOf: */;
	ioSetLogDirectoryOfSize(firstIndexableField(stringOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveSetOrHasIdentityHash */
static void
primitiveSetOrHasIdentityHash(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt hasHash;
    sqInt hash;
    sqInt hash1;
    sqInt integerPointer;
    sqInt oldHash;
    sqInt oop;
    char *sp;
    char *sp1;
    sqInt thisReceiver;

	if (GIV(argumentCount) == 0) {
		hasHash = (((longAt(GIV(stackPointer))) & (tagMask())) == 0)
		 && ((long32At((longAt(GIV(stackPointer))) + 4)) & (identityHashHalfWordMask()));
		/* begin pop:thenPushBool: */
		longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (hasHash
			? GIV(trueObj)
			: GIV(falseObj)));
		GIV(stackPointer) = sp;
		return;
	}
	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		hash = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		hash = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackObjectValue: */
	oop = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if ((oop & (tagMask())) != 0) {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		thisReceiver = null;
		goto l2;
	}
	thisReceiver = oop;
l2:	/* end stackObjectValue: */;
	if (!GIV(primFailCode)) {
		/* begin hashBitsOf: */
		hash1 = (long32At(thisReceiver + 4)) & (identityHashHalfWordMask());
		if (hash1 == 0) {

			/* would like to assert
			   self assert: (coInterpreter addressCouldBeClassObj: objOop) not
			   but instance-specific behaviors that are instances of themselves may
			   fail this test. */

			hash1 = (newObjectHash()) & (identityHashHalfWordMask());
			/* begin setHashBitsOf:to: */
			flag("endianness");
			assert(((hash1 >= 0) && (hash1 <= (identityHashHalfWordMask()))));
			long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash1);
		}
		oldHash = hash1;
		/* begin setHashBitsOf:to: */
		flag("endianness");
		assert(((hash >= 0) && (hash <= (identityHashHalfWordMask()))));
		long32Atput(thisReceiver + 4, ((((long32At(thisReceiver + 4)) | (identityHashHalfWordMask())) - (identityHashHalfWordMask()))) + hash);
		/* begin pop:thenPushInteger: */
		longAtput((sp1 = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), ((oldHash << 1) | 1));
		GIV(stackPointer) = sp1;
	}
}


/*	Primitive. Set the OS window's label */

	/* InterpreterPrimitives>>#primitiveSetWindowLabel */
EXPORT(sqInt)
primitiveSetWindowLabel(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt fmt;
    sqInt labelOop;
    usqInt numBytes;
    usqInt numSlots;
    sqInt sz;

	labelOop = longAt(GIV(stackPointer));
	if (!(((labelOop & (tagMask())) == 0)
		 && (((((usqInt) (longAt(labelOop))) >> (formatShift())) & (formatMask())) >= (firstByteFormat())))) {
		/* begin success: */
		
		/* Don't overwrite an error code that has already been set. */

		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}

		return null;
	}
	/* begin byteSizeOf: */
	if ((labelOop & (tagMask())) != 0) {
		sz = 0;
		goto l1;
	}
	/* begin numBytesOf: */
	fmt = (((usqInt) (longAt(labelOop))) >> (formatShift())) & (formatMask());
	/* begin numSlotsOf: */
	flag("endianness");
	assert((classIndexOf(labelOop)) > (isForwardedObjectClassIndexPun()));
	numSlots = byteAt(labelOop + 7);
	numBytes = (numSlots == (numSlotsMask())
		? longAt(labelOop - BaseHeaderSize)
		: numSlots);
	numBytes = numBytes << (shiftForWord());
	if (fmt >= (firstByteFormat())) {

		/* bytes (the common case), including CompiledMethod */

		sz = numBytes - (fmt & 7);
		goto l2;
	}
	if (fmt <= (sixtyFourBitIndexableFormat())) {
		sz = numBytes;
		goto l2;
	}
	if (fmt >= (firstShortFormat())) {
		sz = numBytes - ((fmt & 3) << 1);
		goto l2;
	}
	sz = numBytes - ((fmt & 1) << 2);
l2:	/* end numBytesOf: */;
l1:	/* end byteSizeOf: */;
	ioSetWindowLabelOfSize(firstIndexableField(labelOop), sz);
	if (!GIV(primFailCode)) {
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Primitive. Answer the OS window's size (extent) */

	/* InterpreterPrimitives>>#primitiveSetWindowSize */
EXPORT(sqInt)
primitiveSetWindowSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt h;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt w;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		h = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		h = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		w = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		w = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	if (!GIV(primFailCode)) {
		ioSetWindowWidthHeight(w, h);
		/* begin pop: */
		GIV(stackPointer) += GIV(argumentCount) * BytesPerWord;
	}
}


/*	Treat the receiver, which can be indexible by either bytes or words, as
	an array of signed 16-bit values. Answer the contents of the given index.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word.  */

	/* InterpreterPrimitives>>#primitiveShortAt */
static void
primitiveShortAt(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	index = longAt(GIV(stackPointer));
	if (!((index & 1))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((rcvr & (tagMask())) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	index = (index >> 1);
	if (!((index >= 1)
		 && (index <= (((usqInt) (numBytesOf(rcvr))) >> 1)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	value = shortAt((rcvr + BaseHeaderSize) + ((index - 1) << 1));
	/* begin pop:thenPushInteger: */
	longAtput((sp = GIV(stackPointer) + ((2 - 1) * BytesPerWord)), ((value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Treat the receiver, which can be indexible by either bytes or words, as an
	array of signed 16-bit values. Set the contents of the given index to the
	given value.
	Note that the index specifies the i-th 16-bit entry, not the i-th byte or
	word. 
 */

	/* InterpreterPrimitives>>#primitiveShortAtPut */
static void
primitiveShortAtPut(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt index;
    sqInt rcvr;
    char *sp;
    sqInt value;

	value = longAt(GIV(stackPointer));
	index = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	if (!(((value & 1))
		 && (((index & 1))
		 && (((value = (value >> 1)),
		(value >= -32768)
			 && (value <= 0x7FFF)))))) {
		(GIV(primFailCode) = PrimErrBadArgument);
		return;
	}
	rcvr = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	if (!(((rcvr & (tagMask())) == 0)
		 && (isPureBitsFormat((((usqInt) (longAt(rcvr))) >> (formatShift())) & (formatMask()))))) {
		(GIV(primFailCode) = PrimErrInappropriate);
		return;
	}
	index = (index >> 1);
	if (!((index >= 1)
		 && (index <= (((usqInt) (numBytesOf(rcvr))) >> 1)))) {
		(GIV(primFailCode) = PrimErrBadIndex);
		return;
	}
	shortAtput((rcvr + BaseHeaderSize) + ((index - 1) << 1), value);
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + ((3 - 1) * BytesPerWord)), ((value << 1) | 1));
	GIV(stackPointer) = sp;
}


/*	Force the given rectangular section of the Display to be 
	copied to the screen. */

	/* InterpreterPrimitives>>#primitiveShowDisplayRect */
static void
primitiveShowDisplayRect(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bottom;
    sqInt integerPointer;
    sqInt integerPointer1;
    sqInt integerPointer2;
    sqInt integerPointer3;
    sqInt left;
    sqInt right;
    sqInt top;

	/* begin stackIntegerValue: */
	integerPointer = longAt(GIV(stackPointer) + (0 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer & 1)) {
		bottom = (integerPointer >> 1);
		goto l1;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		bottom = 0;
		goto l1;
	}
l1:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer1 = longAt(GIV(stackPointer) + (1 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer1 & 1)) {
		top = (integerPointer1 >> 1);
		goto l2;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		top = 0;
		goto l2;
	}
l2:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer2 = longAt(GIV(stackPointer) + (2 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer2 & 1)) {
		right = (integerPointer2 >> 1);
		goto l3;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		right = 0;
		goto l3;
	}
l3:	/* end stackIntegerValue: */;
	/* begin stackIntegerValue: */
	integerPointer3 = longAt(GIV(stackPointer) + (3 * BytesPerWord));
	/* begin checkedIntegerValueOf: */
	if ((integerPointer3 & 1)) {
		left = (integerPointer3 >> 1);
		goto l4;
	}
	else {
		/* begin primitiveFail */
		if (!GIV(primFailCode)) {
			GIV(primFailCode) = 1;
		}
		left = 0;
		goto l4;
	}
l4:	/* end stackIntegerValue: */;
	displayBitsOfLeftTopRightBottom(longAt((GIV(specialObjectsOop) + BaseHeaderSize) + (TheDisplay << (shiftForWord()))), left, top, right, bottom);
	if (!GIV(primFailCode)) {
		ioForceDisplayUpdate();
		/* begin pop: */
		GIV(stackPointer) += 4 * BytesPerWord;
	}
}


/*	Synchronously signal the semaphore.
	This may change the active process as a result. */

	/* InterpreterPrimitives>>#primitiveSignal */
static void
primitiveSignal(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
	synchronousSignal(longAt(GIV(stackPointer)));
}


/*	Set the low-water mark for free space. When the free space falls
	below this level, the new and new: primitives fail and system attempts
	to allocate space (e.g., to create a method context) cause the low-space
	semaphore (if one is registered) to be signalled. */

	/* InterpreterPrimitives>>#primitiveSignalAtBytesLeft */
static void
primitiveSignalAtBytesLeft(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt bytes;

	bytes = longAt(GIV(stackPointer));
	if (((bytes & 1))
	 && (((bytes = (bytes >> 1))) >= 0)) {
		/* begin lowSpaceThreshold: */
		GIV(lowSpaceThreshold) = bytes;
		if (GIV(totalFreeOldSpace) < bytes) {
			growOldSpaceByAtLeast(bytes - GIV(totalFreeOldSpace));
		}
		assert(GIV(totalFreeOldSpace) >= GIV(lowSpaceThreshold));
		/* begin pop: */
		GIV(stackPointer) += 1 * BytesPerWord;
	}
	else {
		GIV(primFailCode) = PrimErrBadArgument;
	}
}

	/* InterpreterPrimitives>>#primitiveSine */
static void
primitiveSine(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    double f;
    sqInt isFloat;
    sqInt object;
    sqInt oop;
    double rcvr;
    double result;
    char *sp;
    sqInt top;

	/* begin popFloat */
	/* begin floatValueOf: */
	/* begin popStack */
	top = longAt(GIV(stackPointer));
	GIV(stackPointer) += BytesPerWord;
	oop = top;
	isFloat = ((oop & (tagMask())) == 0)
	 && (((longAt(oop)) & (classIndexMask())) == ClassFloatCompactIndex);
	if (isFloat) {
		;
		fetchFloatAtinto(oop + BaseHeaderSize, result);
		rcvr = result;
		goto l1;
	}
	/* begin primitiveFail */
	if (!GIV(primFailCode)) {
		GIV(primFailCode) = 1;
	}
	rcvr = 0.0;
l1:	/* end floatValueOf: */;
	if (!GIV(primFailCode)) {
		/* begin pushFloat: */
		f = sin(rcvr);
		/* begin push: */
		object = floatObjectOf(f);
		longAtput((sp = GIV(stackPointer) - BytesPerWord), object);
		GIV(stackPointer) = sp;
	}
	else {
		/* begin unPop: */
		GIV(stackPointer) -= 1 * BytesPerWord;
	}
}

	/* InterpreterPrimitives>>#primitiveSize */
static void
primitiveSize(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt class;
    sqInt fixedFields;
    sqInt fmt;
    sqInt hdr;
    usqInt numSlots;
    usqInt numSlots1;
    sqInt rcvr;
    char *sp;
    sqInt totalLength;

	rcvr = longAt(GIV(stackPointer));
	if (((rcvr & (tagMask())) != 0)
	 || (((hdr = long64At(rcvr)),
	((fmt = (((usqInt) hdr) >> (formatShift())) & (formatMask()))) < 2))) {

		/* This is not an indexable object */

		(GIV(primFailCode) = PrimErrBadReceiver);
		return;
	}
	if ((fmt == (indexablePointersFormat()))
	 && ((hdr & (classIndexMask())) == ClassMethodContextCompactIndex)) {
		primitiveContextSize();
		return;
	}
	/* begin lengthOf:format: */
	/* begin numSlotsOfAny: */
	numSlots1 = byteAt(rcvr + 7);
	numSlots = (numSlots1 == (numSlotsMask())
		? longAt(rcvr - BaseHeaderSize)
		: numSlots1);
	if (fmt <= 5) {
		totalLength = numSlots;
		goto l1;
	}
	if (fmt >= (firstByteFormat())) {

		/* bytes, including CompiledMethod */

		totalLength = (numSlots << (shiftForWord())) - (fmt & 7);
		goto l1;
	}
	if (fmt >= (firstShortFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 1)) - (fmt & 3);
		goto l1;
	}
	if (fmt >= (firstLongFormat())) {
		totalLength = (numSlots << ((shiftForWord()) - 2)) - (fmt & 1);
		goto l1;
	}
	if (fmt == (sixtyFourBitIndexableFormat())) {
		totalLength = ((usqInt) numSlots) >> 1;
		goto l1;
	}
	totalLength = 0;
l1:	/* end lengthOf:format: */;
	/* begin fixedFieldsOf:format:length: */
	if ((fmt >= (sixtyFourBitIndexableFormat()))
	 || (fmt == 2)) {
		fixedFields = 0;
		goto l2;
	}
	if (fmt < 2) {
		fixedFields = totalLength;
		goto l2;
	}
	class = fetchClassOfNonImm(rcvr);
	/* begin fixedFieldsOfClassFormat: */
	fixedFields = (((longAt((class + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1)) & ((1 << (fixedFieldsFieldWidth())) - 1);
l2:	/* end fixedFieldsOf:format:length: */;
	/* begin pop:thenPush: */
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), (((totalLength - fixedFields) << 1) | 1));
	GIV(stackPointer) = sp;
}

	/* InterpreterPrimitives>>#primitiveSizeInBytes */
static void
primitiveSizeInBytes(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    usqLong byteSize;
    sqInt oop;
    char *sp;

	byteSize = (((longAt(GIV(stackPointer))) & (tagMask())) != 0
		? 0
		: bytesInObject(longAt(GIV(stackPointer))));
	/* begin pop:thenPush: */
	oop = positive64BitIntegerFor(byteSize);
	longAtput((sp = GIV(stackPointer) + (((GIV(argumentCount) + 1) - 1) * BytesPerWord)), oop);
	GIV(stackPointer) = sp;
}


/*	Answer the byte size of an instance of the receiver. If num args > 0
	then the last argument is a variable size and the size answered is the
	size of an instance of the receiver with that many indexable elements. */

	/* InterpreterPrimitives>>#primitiveSizeInBytesOfInstance */
static void
primitiveSizeInBytesOfInstance(void)
{   DECL_MAYBE_SQ_GLOBAL_STRUCT
    sqInt byteSize;
    sqInt classFormat;
    sqInt classFormat1;
    sqInt code;
    sqInt err;
    sqInt instSpec;
    sqInt instSpec1;
    sqInt nElements;
    usqInt numSlots;
    sqInt numSlots1;
    sqInt oop;
    char *sp;
    char *sp1;

	
	/* Support VMMirror>>byteSizeOfInstanceOf:WithIndexableVariables: */

	if (GIV(argumentCount) > 2) {
		(GIV(primFailCode) = PrimErrBadNumArgs);
		return;
	}

	err = -1;
	if (GIV(argumentCount) >= 1) {
		if (!(((longAt(GIV(stackPointer))) & 1))) {
			(GIV(primFailCode) = PrimErrBadArgument);
			return;
		}
		/* begin byteSizeOfInstanceOf:withIndexableSlots:errInto: */
		nElements = ((longAt(GIV(stackPointer))) >> 1);
		classFormat = ((longAt(((longAt(GIV(stackPointer) + (1 * BytesPerWord))) + BaseHeaderSize) + (InstanceSpecificationIndex << (shiftForWord())))) >> 1);
		instSpec = (((usqInt) classFormat) >> (fixedFieldsFieldWidth())) & (formatMask());
		
		switch (instSpec) {
		case 2:
			numSlots = nElements;
			break;
		case indexablePointersFormat():
		case weakArrayFormat():
			numSlots = (classFormat & ((1 << (fixedFieldsFieldWidth())) - 1)) + nElements;
			break;
		case sixtyFourBitIndexableFormat():
			numSlots = nElements * 2;
			break;
		case firstLongFormat():
			numSlots = nElements;
			break;
		case firstShortFormat():
			numSlots = (nElements + 1) / 2;
			break;
		case firstByteFormat():
		case firstCompiledMethodFormat():
			numSlots = (nElements + (BytesPerOop - 1)) / BytesPerOop;
			break;
		default:
			code = -PrimErrBadReceiver;
			byteSize = (err = code);

			goto l1;
