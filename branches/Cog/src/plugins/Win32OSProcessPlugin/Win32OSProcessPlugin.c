/* Automatically generated by
	VMPluginCodeGenerator VMMaker.oscog-eem.499 uuid: f45b31f0-3fe3-4706-8fde-a339bb89f94f
   from
	Win32OSProcessPlugin VMConstruction-Plugins-OSProcessPlugin.oscog-eem.44 uuid: 946fd79a-b249-4f25-8d13-11c6a087296f
 */
static char __buildInfo[] = "Win32OSProcessPlugin VMConstruction-Plugins-OSProcessPlugin.oscog-eem.44 uuid: 946fd79a-b249-4f25-8d13-11c6a087296f " __DATE__ ;
/* D T Lewis - Win32OSProcessPlugin.c translated from class
   Win32OSProcessPlugin of OSProcessPlugin version 4.3.3 Cog */



#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/types.h>
#include <windows.h>
#include <process.h>

/* Default EXPORT macro that does nothing (see comment in sq.h): */
#define EXPORT(returnType) returnType

/* Do not include the entire sq.h file but just those parts needed. */
/*  The virtual machine proxy definition */
#include "sqVirtualMachine.h"
/* Configuration options */
#include "sqConfig.h"
/* Platform specific definitions */
#include "sqPlatformSpecific.h"

#define true 1
#define false 0
#define null 0  /* using 'null' because nil is predefined in Think C */
#ifdef SQUEAK_BUILTIN_PLUGIN
#undef EXPORT
// was #undef EXPORT(returnType) but screws NorCroft cc
#define EXPORT(returnType) static returnType
#endif

#include "FilePlugin.h"
#include "SocketPlugin.h"
#include "sqWin32.h"
#include "sqMemoryAccess.h"


/*** Constants ***/
#define BytesPerWord 4
#define FILEHANDLETYPE FILE *  /* the type of low level stream to be used in a struct SQFile */
#define PrimErrBadArgument 3
#define READCHARARRAYSIZE 512	/* Corresponds to expected max size of external semaphore table */
									/* Table expands dynamically, so just use a big number */
#define SESSIONIDENTIFIERTYPE int


/*** Function Prototypes ***/
static void * callocWrappersize(sqInt count, sqInt objectSize);
static sqInt copyBytesFromtolength(void *charArray1, void *charArray2, sqInt len);
static sqInt createPipeForReaderwriter(FILEHANDLETYPE *readerIOStreamPtr, FILEHANDLETYPE *writerIOStreamPtr);
static HANDLE createThreadMutex(void);
static char * cStringFromString(sqInt aString);
static HANDLE exitThreadMutexHandle(void);
static FILEHANDLETYPE fileHandleFrom(sqInt sqFileStructByteArray);
static sqInt fileRecordSize(void);
static SQFile * fileValueOf(sqInt anSQFileRecord);
static char ** fixPointersInArrayOfStringswithOffsets(sqInt flattenedStrings, sqInt offsets);
static VirtualMachine * getInterpreter(void);
EXPORT(const char*) getModuleName(void);
static sqInt getThisSessionIdentifier(void);
static sqInt halt(void);
static DWORD WINAPI handleAnyChildProc(void *args);
static HANDLE handleFromSQFile(sqInt anSQFileRecord);
static HANDLE handleFrom(sqInt aHandleObject);
static sqInt handleObjectFrom(HANDLE aHandle);
EXPORT(sqInt) initialiseModule(void);
static sqInt initializeModuleForPlatform(void);
static sqInt isNonNullSQFile(sqInt objectPointer);
static sqInt isNullSQSocket(sqInt objectPointer);
static sqInt isSQFileObject(sqInt objectPointer);
static sqInt isSQSocketObject(sqInt objectPointer);
static sqInt isValidFileSession(sqInt objectPointer);
static sqInt makePipeForReaderwriter(FILEHANDLETYPE *readerIOStreamPtr, FILEHANDLETYPE *writerIOStreamPtr);
EXPORT(sqInt) moduleUnloaded(char *aModuleName);
static sqInt msg(char *s);
static sqInt newSQFileByteArray(void);
static sqInt newSQSocketByteArray(void);
static void * pointerFrom(sqInt aByteArray);
EXPORT(sqInt) primitiveAllocConsole(void);
EXPORT(sqInt) primitiveBufferValuesAt(void);
EXPORT(sqInt) primitiveCanAccessChildProcess(void);
EXPORT(sqInt) primitiveCloseHandle(void);
EXPORT(sqInt) primitiveCommand(void);
EXPORT(sqInt) primitiveCommandWithInputOutputError(void);
EXPORT(sqInt) primitiveCreatePipe(void);
EXPORT(sqInt) primitiveCreatePipeWithSessionIdentifier(void);
EXPORT(sqInt) primitiveFixPointersInArrayOfStrings(void);
EXPORT(sqInt) primitiveFreeConsole(void);
EXPORT(sqInt) primitiveGetCurrentWorkingDirectory(void);
EXPORT(sqInt) primitiveGetEnvironmentStrings(void);
EXPORT(sqInt) primitiveGetExitStatusForHandle(void);
EXPORT(sqInt) primitiveGetMainThreadHandle(void);
EXPORT(sqInt) primitiveGetMainThreadID(void);
EXPORT(sqInt) primitiveGetPid(void);
EXPORT(sqInt) primitiveGetPidHandle(void);
EXPORT(sqInt) primitiveGetSession(void);
EXPORT(sqInt) primitiveGetStdError(void);
EXPORT(sqInt) primitiveGetStdInput(void);
EXPORT(sqInt) primitiveGetStdOutput(void);
EXPORT(sqInt) primitiveLastReadFor(void);
EXPORT(sqInt) primitiveLastReadForStoreIn(void);
EXPORT(sqInt) primitiveMakePipe(void);
EXPORT(sqInt) primitiveMakePipeWithSessionIdentifier(void);
EXPORT(sqInt) primitiveModuleName(void);
EXPORT(sqInt) primitiveNextFromSignaling(void);
EXPORT(sqInt) primitiveOneShot(void);
EXPORT(sqInt) primitiveSetStdErr(void);
EXPORT(sqInt) primitiveSetStdIn(void);
EXPORT(sqInt) primitiveSetStdOut(void);
EXPORT(sqInt) primitiveSetWaitForAnyProcessExitThenSignalSemaphoreWithIndex(void);
EXPORT(sqInt) primitiveSizeOfInt(void);
EXPORT(sqInt) primitiveSizeOfPointer(void);
EXPORT(sqInt) primitiveTerminateThread(void);
EXPORT(sqInt) primitiveVersionString(void);
static DWORD WINAPI readCharThreadIndexhandle(sqInt index, HANDLE handle);
static DWORD WINAPI readCharThread(void *args);
static HANDLE readThreadMutexHandle(void);
static BOOL releaseThreadMutex(HANDLE aHandle);
static sqInt sandboxSecurity(void);
static sqInt securityHeurisitic(void);
static SESSIONIDENTIFIERTYPE sessionIdentifierFrom(sqInt aByteArray);
EXPORT(sqInt) setInterpreter(struct VirtualMachine*anInterpreter);
EXPORT(sqInt) shutdownModule(void);
static sqInt sizeOfHandle(void);
static sqInt sizeOfInt(void);
static sqInt sizeOfPointer(void);
static sqInt sizeOfSession(void);
static int socketDescriptorFrom(sqInt sqSocketOop);
static sqInt socketRecordSize(void);
static SocketPtr socketValueOf(sqInt anSQSocketRecord);
static sqInt startHandlerThreadForAnycountsignalingSemaphoreAt(HANDLE *handleArrayPointer, sqInt arraySize, sqInt semaphoreIndex);
static HANDLE stdErrHandle(void);
static HANDLE stderrHandle(void);
static HANDLE stdInHandle(void);
static HANDLE stdinHandle(void);
static HANDLE stdOutHandle(void);
static HANDLE stdoutHandle(void);
static sqInt stringFromCString(const char *aCString);
static HANDLE threadMutexHandle(void);
static char * transientCStringFromString(sqInt aString);
static char * versionString(void);
static DWORD waitForThreadMutex(HANDLE aHandle);


/*** Variables ***/

#if !defined(SQUEAK_BUILTIN_PLUGIN)
static void * (*arrayValueOf)(sqInt oop);
static sqInt (*byteSizeOf)(sqInt oop);
static sqInt (*classArray)(void);
static sqInt (*classByteArray)(void);
static sqInt (*classString)(void);
static sqInt (*failed)(void);
static sqInt (*falseObject)(void);
static void * (*firstIndexableField)(sqInt oop);
static sqInt (*getThisSessionID)(void);
static sqInt (*instantiateClassindexableSize)(sqInt classPointer, sqInt size);
static sqInt (*integerObjectOf)(sqInt value);
static sqInt (*integerValueOf)(sqInt oop);
static void * (*ioLoadFunctionFrom)(char *functionName, char *moduleName);
static sqInt (*isBytes)(sqInt oop);
static sqInt (*nilObject)(void);
static sqInt (*pop)(sqInt nItems);
static sqInt (*popthenPush)(sqInt nItems, sqInt oop);
static sqInt (*popRemappableOop)(void);
static sqInt (*positive32BitIntegerFor)(sqInt integerValue);
static sqInt (*primitiveFail)(void);
static sqInt (*primitiveFailFor)(sqInt reasonCode);
static sqInt (*push)(sqInt object);
static sqInt (*pushInteger)(sqInt integerValue);
static sqInt (*pushRemappableOop)(sqInt oop);
static sqInt (*signalSemaphoreWithIndex)(sqInt semaIndex);
static sqInt (*sizeOfSTArrayFromCPrimitive)(void *cPtr);
static sqInt (*stObjectatput)(sqInt array, sqInt index, sqInt value);
static sqInt (*stSizeOf)(sqInt oop);
static sqInt (*stackIntegerValue)(sqInt offset);
static sqInt (*stackObjectValue)(sqInt offset);
static sqInt (*stackValue)(sqInt offset);
static sqInt (*storePointerofObjectwithValue)(sqInt index, sqInt oop, sqInt valuePointer);
static sqInt (*trueObject)(void);
#else /* !defined(SQUEAK_BUILTIN_PLUGIN) */
extern void * arrayValueOf(sqInt oop);
extern sqInt byteSizeOf(sqInt oop);
extern sqInt classArray(void);
extern sqInt classByteArray(void);
extern sqInt classString(void);
extern sqInt failed(void);
extern sqInt falseObject(void);
extern void * firstIndexableField(sqInt oop);
extern sqInt getThisSessionID(void);
extern sqInt instantiateClassindexableSize(sqInt classPointer, sqInt size);
extern sqInt integerObjectOf(sqInt value);
extern sqInt integerValueOf(sqInt oop);
extern void * ioLoadFunctionFrom(char *functionName, char *moduleName);
extern sqInt isBytes(sqInt oop);
extern sqInt nilObject(void);
extern sqInt pop(sqInt nItems);
extern sqInt popthenPush(sqInt nItems, sqInt oop);
extern sqInt popRemappableOop(void);
extern sqInt positive32BitIntegerFor(sqInt integerValue);
extern sqInt primitiveFail(void);
extern sqInt primitiveFailFor(sqInt reasonCode);
extern sqInt push(sqInt object);
extern sqInt pushInteger(sqInt integerValue);
extern sqInt pushRemappableOop(sqInt oop);
extern sqInt signalSemaphoreWithIndex(sqInt semaIndex);
extern sqInt sizeOfSTArrayFromCPrimitive(void *cPtr);
extern sqInt stObjectatput(sqInt array, sqInt index, sqInt value);
extern sqInt stSizeOf(sqInt oop);
extern sqInt stackIntegerValue(sqInt offset);
extern sqInt stackObjectValue(sqInt offset);
extern sqInt stackValue(sqInt offset);
extern sqInt storePointerofObjectwithValue(sqInt index, sqInt oop, sqInt valuePointer);
extern sqInt trueObject(void);
extern
#endif
struct VirtualMachine* interpreterProxy;
static const char *moduleName =
#ifdef SQUEAK_BUILTIN_PLUGIN
	"Win32OSProcessPlugin VMConstruction-Plugins-OSProcessPlugin.oscog-eem.44 (i)"
#else
	"Win32OSProcessPlugin VMConstruction-Plugins-OSProcessPlugin.oscog-eem.44 (e)"
#endif
;
static int osprocessSandboxSecurity;
static int readCharArraySize = READCHARARRAYSIZE;
static unsigned char readCharBufferArray[READCHARARRAYSIZE];
static DWORD readCharCountArray[READCHARARRAYSIZE];
static int readCharStatusArray[READCHARARRAYSIZE];
static DWORD readCharThreadIdArray[READCHARARRAYSIZE];


/*** Macros ***/
#define sessionIdentifierFromSqFile(sqFile) (((SQFile *)(sqFile))->sessionID)



/*	Using malloc() and calloc() is something I would like to avoid, since it
	is likely to cause problems some time in the future if somebody redesigns
	object memory allocation. This wrapper just makes it easy to find senders
	of calloc() in my code. -dtl */

static void *
callocWrappersize(sqInt count, sqInt objectSize)
{
	return calloc(count, objectSize);
}


/*	self cCode: 'memcpy(charArray2, charArray1, len' */

static sqInt
copyBytesFromtolength(void *charArray1, void *charArray2, sqInt len)
{
	memcpy(charArray2, charArray1, len);
}


/*	Create a pipe and populate the readerIOStream and writerIOStream
	variables. Answer true for success, else false */

static sqInt
createPipeForReaderwriter(FILEHANDLETYPE *readerIOStreamPtr, FILEHANDLETYPE *writerIOStreamPtr)
{
	return CreatePipe(readerIOStreamPtr, writerIOStreamPtr, NULL, 0);
}


/*	Answer a HANDLE for a new mutex semaphore. */

static HANDLE
createThreadMutex(void)
{
	return CreateMutex(NULL, false, NULL);
}


/*	Answer a new null-terminated C string copied from aString. The C string
	is allocated from the C runtime heap. See transientCStringFromString for
	a version which allocates from object memory.
	Caution: This may invoke the garbage collector. */

static char *
cStringFromString(sqInt aString)
{
    char *cString;
    sqInt len;
    char *sPtr;

	sPtr = arrayValueOf(aString);
	len = sizeOfSTArrayFromCPrimitive(sPtr);

	/* Space for a null terminated C string. */

	cString = callocWrappersize(len + 1, 1);
	(char *) strncpy (cString, sPtr, len);
	return cString;
}


/*	Answer a HANDLE for a mutex semaphore for the child handler thread. */

static HANDLE
exitThreadMutexHandle(void)
{
    static HANDLE h= 0;

	if (h == null) {
		h = createThreadMutex();
	}
	return h;
}


/*	Answer a file handle from a SQFile structure. On most platforms, this
	will be a (FILE *). On Win32, it is a HANDLE. */

static FILEHANDLETYPE
fileHandleFrom(sqInt sqFileStructByteArray)
{
    SQFile *sqFile;

	sqFile = arrayValueOf(sqFileStructByteArray);
	return sqFile->file;
}


/*	Return the size of a Smalltalk file record in bytes. */

static sqInt
fileRecordSize(void)
{
	return sizeof(SQFile);
}


/*	Return a pointer to the first byte of of the SQFile data structure file
	record within
	anSQFileRecord, which is expected to be a ByteArray of size
	self>>fileRecordSize. 
 */

static SQFile *
fileValueOf(sqInt anSQFileRecord)
{
	return arrayValueOf(anSQFileRecord);
}


/*	The image constructs a flattened string of all the argument and/or
	environment strings.
	There is room at the beginning for the null-terminated array of pointers
	to strings.
	The rest of the string contains the null-terminated strings. */
/*	Use the address offsets in offsetArray to fix up the pointers in
	cStringArray. The result is a C array of pointers to char, used for argv
	and env vectors.
 */

static char **
fixPointersInArrayOfStringswithOffsets(sqInt flattenedStrings, sqInt offsets)
{
    sqInt count;
    sqInt idx;
    sqInt *offsetArray;
    char **ptr;
    usqInt sz;
    sqInt val;

	count = stSizeOf(offsets);
	offsetArray = firstIndexableField(offsets);
	sz = ((usqInt)(byteSizeOf(flattenedStrings)));
	if ((count * (sizeof(char *))) >= sz) {
		primitiveFailFor(PrimErrBadArgument);
		return 0;
	}
	ptr = ((char **) (arrayValueOf(flattenedStrings)));
	idx = 0;
	while (idx < count) {
		val = integerValueOf(offsetArray[idx]);
		if ((((usqInt)val)) >= sz) {
			primitiveFailFor(PrimErrBadArgument);
			return 0;
		}
		ptr[idx] = ((((char *) ptr)) + val);
		idx += 1;
	}
	if ((ptr[idx]) != 0) {
		primitiveFailFor(PrimErrBadArgument);
	}
	return (failed()
		? 0
		: ptr);
}


/*	Note: This is coded so that plugins can be run from Squeak. */

static VirtualMachine *
getInterpreter(void)
{
	return interpreterProxy;
}


/*	Note: This is hardcoded so it can be run from Squeak.
	The module name is used for validating a module *after*
	it is loaded to check if it does really contain the module
	we're thinking it contains. This is important! */

EXPORT(const char*)
getModuleName(void)
{
	return moduleName;
}

static sqInt
getThisSessionIdentifier(void)
{
	return getThisSessionID();
}

static sqInt
halt(void)
{
	;
	return 0;
}


/*	Wait for a process HANDLE to exit, then signal the Semaphore at index.
	Answer the exit status of the process. This is the code to be executed in
	a thread to provide
	asychronous notification of an external process exit.
 */

static DWORD WINAPI
handleAnyChildProc(void *args)
{
    HANDLE aHandle;
    volatile int count;
    DWORD exitStatus;
    static HANDLE h= 0;
    volatile LPHANDLE handles;
    volatile int index;
    struct {int count; HANDLE *handles; int semaIndex;} *threadArgs;

	threadArgs = args;
	count= threadArgs->count;
	handles= threadArgs->handles;
	index= threadArgs->semaIndex;
	/* begin releaseThreadMutex: */
	/* begin exitThreadMutexHandle */
	if (h == null) {
		h = createThreadMutex();
	}
	aHandle = h;
	ReleaseMutex(aHandle);
	exitStatus = WaitForMultipleObjects(count, handles, FALSE, INFINITE);
	signalSemaphoreWithIndex(index);
	return exitStatus;
}

static HANDLE
handleFromSQFile(sqInt anSQFileRecord)
{
    SQFile *sqFile;

	if (!((isBytes(anSQFileRecord))
		 && ((stSizeOf(anSQFileRecord)) == (sizeof(SQFile))))) {
		primitiveFail();
		return null;
	}
	/* begin fileValueOf: */
	sqFile = arrayValueOf(anSQFileRecord);
	return sqFile->file;
}


/*	Answer the HANDLE represented by aHandleObject. */

static HANDLE
handleFrom(sqInt aHandleObject)
{
    union {void *address; unsigned char bytes[sizeof(void *)];} handleUnion;
    sqInt idx;
    unsigned char *ptr;

	if (!((isBytes(aHandleObject))
		 && ((stSizeOf(aHandleObject)) == (sizeOfHandle())))) {
		primitiveFail();
		return null;
	}
	ptr = arrayValueOf(aHandleObject);
	idx = 0;
	while (idx < (sizeOfHandle())) {
		handleUnion.bytes[idx] = ptr[idx];
		idx += 1;
	}
	return handleUnion.address;
}


/*	Answer an object which contains the value of a HANDLE. */

static sqInt
handleObjectFrom(HANDLE aHandle)
{
    sqInt handleOop;
    union {HANDLE handle; char bytes[sizeof(HANDLE)];} handleUnion;
    sqInt idx;
    unsigned char *ptr;
    sqInt size;

	handleUnion.handle = aHandle;
	size = sizeOfHandle();
	handleOop = instantiateClassindexableSize(classByteArray(), size);
	ptr = arrayValueOf(handleOop);
	idx = 0;
	while (idx < size) {
		ptr[idx]= handleUnion.bytes[idx];
		idx += 1;
	}
	return handleOop;
}

EXPORT(sqInt)
initialiseModule(void)
{
	osprocessSandboxSecurity = -1;
	/* begin initializeModuleForPlatform */
	return 1;
}


/*	Platform specific initialization */

static sqInt
initializeModuleForPlatform(void)
{
}


/*	Check for the common failure mode of a SQFile record with all zeros. */

static sqInt
isNonNullSQFile(sqInt objectPointer)
{
    unsigned idx;
    unsigned char *sqFileBytes;

	sqFileBytes = arrayValueOf(objectPointer);
	idx = 0;
	while (idx < (sizeof(SQFile))) {
		if ((sqFileBytes[idx]) != 0) {
			return 1;
		}
		idx += 1;
	}
	return 0;
}


/*	Check for the common failure mode of a SQSocket record with all zeros. */

static sqInt
isNullSQSocket(sqInt objectPointer)
{
    sqInt idx;
    unsigned char *sqSocketBytes;

	sqSocketBytes = arrayValueOf(objectPointer);
	idx = 0;
	while (idx < (socketRecordSize())) {
		if ((sqSocketBytes[idx]) != 0) {
			return 0;
		}
		idx += 1;
	}
	return 1;
}


/*	Answer true if objectPointer appears to be a valid SQFile ByteArray.
	This check is appropriate if objectPointer has been passed as a parameter
	to a primitive, and is expected to represent a valid file reference. */

static sqInt
isSQFileObject(sqInt objectPointer)
{
	return (((isBytes(objectPointer))
 && ((byteSizeOf(objectPointer)) == (sizeof(SQFile))))
 && ((getThisSessionID()) == (sessionIdentifierFromSqFile(arrayValueOf(objectPointer)))))
	 && (isNonNullSQFile(objectPointer));
}


/*	Answer true if objectPointer appears to be a valid SQSocket ByteArray.
	This check
	is appropriate if objectPointer has been passed as a parameter to a
	primitive, and
	is expected to represent a valid socket reference.
 */

static sqInt
isSQSocketObject(sqInt objectPointer)
{
	return ((isBytes(objectPointer))
 && ((byteSizeOf(objectPointer)) == (socketRecordSize())))
	 && (!(isNullSQSocket(objectPointer)));
}


/*	Answer true if the file session matches the current interpreter session
	identifier. 
 */

static sqInt
isValidFileSession(sqInt objectPointer)
{
	return (getThisSessionID()) == (sessionIdentifierFromSqFile(arrayValueOf(objectPointer)));
}


/*	Create a pipe and populate the readerIOStream and writerIOStream
	variables. Answer true for success, else false */

static sqInt
makePipeForReaderwriter(FILEHANDLETYPE *readerIOStreamPtr, FILEHANDLETYPE *writerIOStreamPtr)
{
	return CreatePipe(readerIOStreamPtr, writerIOStreamPtr, NULL, 0);
}


/*	The module with the given name was just unloaded.
	Make sure we have no dangling references. */

EXPORT(sqInt)
moduleUnloaded(char *aModuleName)
{
}

static sqInt
msg(char *s)
{
	fprintf(stderr, "\n%s: %s", moduleName, s);
	return 0;
}


/*	Answer a new ByteArray sized to contain a SQFile data structure. */

static sqInt
newSQFileByteArray(void)
{
	return instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
}


/*	Answer a new ByteArray sized to contain a SQSocket data structure. */

static sqInt
newSQSocketByteArray(void)
{
	return instantiateClassindexableSize(classByteArray(), socketRecordSize());
}


/*	Answer the pointer represented by aByteArray. */

static void *
pointerFrom(sqInt aByteArray)
{
    sqInt idx;
    union {void *address; unsigned char bytes[sizeof(void *)];} pointerUnion;
    unsigned char *ptr;

	if (!((isBytes(aByteArray))
		 && ((stSizeOf(aByteArray)) == (sizeOfPointer())))) {
		return null;
	}
	ptr = arrayValueOf(aByteArray);
	idx = 0;
	while (idx < (sizeOfPointer())) {
		pointerUnion.bytes[idx] = ptr[idx];
		idx += 1;
	}
	return pointerUnion.address;
}


/*	Allocate a console if not already allocated. Answer true on success. */

EXPORT(sqInt)
primitiveAllocConsole(void)
{
	if (AllocConsole()) {
		popthenPush(1, trueObject());
	}
	else {
		popthenPush(1, falseObject());
	}
}


/*	For debugging only. Answer the current values of readCharBufferArray,
	readCharCountArray, and readCharStatusArray at index, an integer
	corresponding to a semaphore for one read handler thread. Answer an Array
	with the buffered
	character, the character count, and the status value.
 */

EXPORT(sqInt)
primitiveBufferValuesAt(void)
{
    unsigned char byte;
    DWORD count;
    sqInt index;
    sqInt result;
    int status;

	index = stackIntegerValue(0);
	byte = readCharBufferArray[index];
	count = readCharCountArray[index];
	status = readCharStatusArray[index];
	result = instantiateClassindexableSize(classArray(), 3);
	storePointerofObjectwithValue(0, result, positive32BitIntegerFor(byte));
	storePointerofObjectwithValue(1, result, positive32BitIntegerFor(count));
	storePointerofObjectwithValue(2, result, positive32BitIntegerFor(status));
	popthenPush(2, result);
}


/*	Answer true if the OS process represented by a HANDLE can be accessed by
	this OS process.
 */

EXPORT(sqInt)
primitiveCanAccessChildProcess(void)
{
    DWORD exitStatus;
    HANDLE handle;

	if (((handle = handleFrom(stackObjectValue(0)))) == null) {
		return null;
	}
	if (((GetExitCodeProcess(handle, &exitStatus)) != 0)
	 && (exitStatus == STILL_ACTIVE)) {
		popthenPush(2, trueObject());
	}
	else {
		popthenPush(2, falseObject());
	}
}


/*	Close the specified handle, which may refer to a process, a thread, or
	some other Win32 object. */

EXPORT(sqInt)
primitiveCloseHandle(void)
{
    HANDLE handle;
    sqInt handleOop;
    BOOL result;

	handleOop = stackObjectValue(0);
	if (((handle = handleFrom(handleOop))) == null) {
		return null;
	}
	result = CloseHandle(handle);
	pop(2);
	if (result != 0) {
		push(trueObject());
	}
	else {
		push(falseObject());
	}
}


/*	Create a process to run commandString. Answer an Array formed from the
	PROCESS_INFORMATION structure for the new process. The caller is expected
	to close the process and thread handles when they are no longer needed.
	The result array contains hProcess, hThread, dwProcessId, dwThreadId.
	
	This primitive has been replaced by #primitiveCommandWithInputOutputError,
	and will be removed in future versions of OSProcess.
 */

EXPORT(sqInt)
primitiveCommand(void)
{
    sqInt commandString;
    void *cStringPtr;
    sqInt processInformation;
    PROCESS_INFORMATION procInfo;
    STARTUPINFO startUp;

	commandString = stackObjectValue(0);
	cStringPtr = cStringFromString(commandString);
	GetStartupInfo (&startUp);
	startUp.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
	startUp.hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
	startUp.hStdError = GetStdHandle(STD_ERROR_HANDLE);
	if (!(CreateProcess(NULL, cStringPtr, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, NULL, NULL, &startUp, &procInfo))) {
		return primitiveFail();
	}
	pushRemappableOop(positive32BitIntegerFor(procInfo.dwThreadId));
	pushRemappableOop(positive32BitIntegerFor(procInfo.dwProcessId));
	pushRemappableOop(handleObjectFrom(procInfo.hThread));
	pushRemappableOop(handleObjectFrom(procInfo.hProcess));
	processInformation = instantiateClassindexableSize(classArray(), 4);
	storePointerofObjectwithValue(0, processInformation, popRemappableOop());
	storePointerofObjectwithValue(1, processInformation, popRemappableOop());
	storePointerofObjectwithValue(2, processInformation, popRemappableOop());
	storePointerofObjectwithValue(3, processInformation, popRemappableOop());
	pop(2);
	push(processInformation);
}


/*	Create a process to run commandString, using the specified input, output,
	and error streams. If any of the input, output, or error streams is nil,
	then the current values of these handles in this OS process will be passed
	to the
	new process. Answer an Array formed from the PROCESS_INFORMATION
	structure for the new process. The caller is expected to close the process
	and thread handles when they are no longer needed. The result array
	contains hProcess, hThread, dwProcessId, dwThreadId.
 */

EXPORT(sqInt)
primitiveCommandWithInputOutputError(void)
{
    sqInt commandString;
    void *cStringPtr;
    HANDLE errorHandle;
    HANDLE inputHandle;
    HANDLE outputHandle;
    sqInt processInformation;
    PROCESS_INFORMATION procInfo;
    STARTUPINFO startUp;
    sqInt stdErr;
    sqInt stdIn;
    sqInt stdOut;

	stdErr = stackObjectValue(0);
	stdOut = stackObjectValue(1);
	stdIn = stackObjectValue(2);
	commandString = stackObjectValue(3);
	cStringPtr = cStringFromString(commandString);
	if (stdIn == (nilObject())) {
		inputHandle = stdInHandle();
	}
	else {
		inputHandle = handleFromSQFile(stdIn);
	}
	if (stdOut == (nilObject())) {
		outputHandle = stdOutHandle();
	}
	else {
		outputHandle = handleFromSQFile(stdOut);
	}
	if (stdErr == (nilObject())) {
		errorHandle = stdErrHandle();
	}
	else {
		errorHandle = handleFromSQFile(stdErr);
	}
	GetStartupInfo (&startUp);
	startUp.hStdInput = inputHandle;
	startUp.hStdOutput = outputHandle;
	startUp.hStdError = errorHandle;
	if (!(CreateProcess(NULL, cStringPtr, NULL, NULL, TRUE, NORMAL_PRIORITY_CLASS, NULL, NULL, &startUp, &procInfo))) {
		return primitiveFail();
	}
	pushRemappableOop(positive32BitIntegerFor(procInfo.dwThreadId));
	pushRemappableOop(positive32BitIntegerFor(procInfo.dwProcessId));
	pushRemappableOop(handleObjectFrom(procInfo.hThread));
	pushRemappableOop(handleObjectFrom(procInfo.hProcess));
	processInformation = instantiateClassindexableSize(classArray(), 4);
	storePointerofObjectwithValue(0, processInformation, popRemappableOop());
	storePointerofObjectwithValue(1, processInformation, popRemappableOop());
	storePointerofObjectwithValue(2, processInformation, popRemappableOop());
	storePointerofObjectwithValue(3, processInformation, popRemappableOop());
	pop(5);
	push(processInformation);
}


/*	Create a pipe, and answer an array of two file handles for the pipe writer
	and reader.
	The readerIOStream and writerIOStream variables represent the low level
	pipe streams,
	which will be of type (FILE *) or HANDLE, depending on what the FilePlugin
	support code is using to represent file streams. FILEHANDLETYPE is defined
	in my subclasses
	in the #declareCVarsIn: class method.
 */

EXPORT(sqInt)
primitiveCreatePipe(void)
{
    sqInt arrayResult;
    sqInt reader;
    FILEHANDLETYPE readerIOStream;
    FILEHANDLETYPE *readerIOStreamPtr;
    SQFile *readerPtr;
    SESSIONIDENTIFIERTYPE thisSession;
    sqInt writer;
    FILEHANDLETYPE writerIOStream;
    FILEHANDLETYPE *writerIOStreamPtr;
    SQFile *writerPtr;


	/* Create the anonymous OS pipe */

	thisSession = getThisSessionID();
	readerIOStreamPtr = (&readerIOStream);
	writerIOStreamPtr = (&writerIOStream);
	if (!(createPipeForReaderwriter(readerIOStreamPtr, writerIOStreamPtr))) {
		return primitiveFail();
	}
	writer = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	writerPtr = arrayValueOf(writer);
	writerPtr->file = writerIOStream;
	writerPtr->sessionID = thisSession;
	writerPtr->writable = 1;
	writerPtr->lastOp = 0;
	pushRemappableOop(writer);
	reader = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	readerPtr = arrayValueOf(reader);
	readerPtr->file = readerIOStream;
	readerPtr->sessionID = thisSession;
	readerPtr->writable = 0;
	readerPtr->lastOp = 0;
	pushRemappableOop(reader);
	arrayResult = instantiateClassindexableSize(classArray(), 2);
	stObjectatput(arrayResult, 1, popRemappableOop());
	stObjectatput(arrayResult, 2, popRemappableOop());
	popthenPush(1, arrayResult);
}


/*	Create a pipe, and answer an array of two file handles for the pipe writer
	and reader.
	The session identifier is passed as the parameter to this primitive. Use
	this variant
	if the session identifier is not available directly in the VM (as may be
	the case if
	it is not possible to link from this plugin to a variable elsewhere in the
	VM). The readerIOStream and writerIOStream variables represent the low
	level pipe streams,
	which will be of type (FILE *) or HANDLE, depending on what the FilePlugin
	support code is using to represent file streams. FILEHANDLETYPE is defined
	in my subclasses
	in the #declareCVarsIn: class method.
 */

EXPORT(sqInt)
primitiveCreatePipeWithSessionIdentifier(void)
{
    sqInt arrayResult;
    sqInt reader;
    FILEHANDLETYPE readerIOStream;
    FILEHANDLETYPE *readerIOStreamPtr;
    SQFile *readerPtr;
    SESSIONIDENTIFIERTYPE thisSession;
    sqInt writer;
    FILEHANDLETYPE writerIOStream;
    FILEHANDLETYPE *writerIOStreamPtr;
    SQFile *writerPtr;


	/* Create the anonymous OS pipe */

	thisSession = sessionIdentifierFrom(stackObjectValue(0));
	readerIOStreamPtr = (&readerIOStream);
	writerIOStreamPtr = (&writerIOStream);
	if (!(createPipeForReaderwriter(readerIOStreamPtr, writerIOStreamPtr))) {
		return primitiveFail();
	}
	writer = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	writerPtr = arrayValueOf(writer);
	writerPtr->file = writerIOStream;
	writerPtr->sessionID = thisSession;
	writerPtr->writable = 1;
	writerPtr->lastOp = 0;
	pushRemappableOop(writer);
	reader = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	readerPtr = arrayValueOf(reader);
	readerPtr->file = readerIOStream;
	readerPtr->sessionID = thisSession;
	readerPtr->writable = 0;
	readerPtr->lastOp = 0;
	pushRemappableOop(reader);
	arrayResult = instantiateClassindexableSize(classArray(), 2);
	stObjectatput(arrayResult, 1, popRemappableOop());
	stObjectatput(arrayResult, 2, popRemappableOop());
	popthenPush(2, arrayResult);
}


/*	This primitive exists only for purposes of testing the
	fixPointersInArrayOfStrings:withOffsets:count: method. I believe it to be
	reasonably machine and compiler independent, but have no way of verifying
	this on a variety of machines, so I'll leave this test method here in case
	someone runs into problems on other hardware or compilers. -dtl */

EXPORT(sqInt)
primitiveFixPointersInArrayOfStrings(void)
{
    sqInt count;
    sqInt cStringArray;
    sqInt offsetArray;

	count = stackIntegerValue(0);
	offsetArray = stackObjectValue(1);
	cStringArray = stackObjectValue(2);
	if ((failed())
	 || ((fixPointersInArrayOfStringswithOffsets(cStringArray, offsetArray)) == 0)) {
		primitiveFail();
	}
	else {
		popthenPush(4, cStringArray);
	}
}


/*	Deallocate the console if allocated. Answer true on success. */

EXPORT(sqInt)
primitiveFreeConsole(void)
{
	if (FreeConsole()) {
		popthenPush(1, trueObject());
	}
	else {
		popthenPush(1, falseObject());
	}
}


/*	Answer a string containing the current working directory. */

EXPORT(sqInt)
primitiveGetCurrentWorkingDirectory(void)
{
    char *buffer;
    sqInt charSize;
    DWORD cwdLen;
    sqInt cwdString;
    DWORD requiredLen;


	/* Determine required size of result buffer (this form counts the terminating null) */

	charSize = sizeof(TCHAR);
	requiredLen = GetCurrentDirectory(0, 0);
	if (requiredLen == 0) {
		return primitiveFail();
	}

	/* Call GetCurrentDirectory() again to get the actual result (which does not count the terminating null (!!)) */

	buffer = alloca(requiredLen * charSize);
	cwdLen = GetCurrentDirectory(requiredLen, buffer);
	if ((cwdLen == 0)
	 || (cwdLen > requiredLen)) {
		return primitiveFail();
	}
	cwdString = instantiateClassindexableSize(classString(), cwdLen * charSize);
	strncpy(arrayValueOf(cwdString), buffer, cwdLen * charSize);
	popthenPush(1, cwdString);
}


/*	Answer the environment block in the form of an Array of Strings. The
	caller is expected to parse the strings into a dictionary of keys and
	values. 
 */

EXPORT(sqInt)
primitiveGetEnvironmentStrings(void)
{
    sqInt count;
    sqInt envArray;
    sqInt len;
    sqInt newString;
    TCHAR *p;
    TCHAR *pVarBlock;
    sqInt string;


	/* Count the environment strings so the result array can be pre-allocated.
	   This minimizes the number of objects which must be pushed onto the
	   stack of remappable objects. */

	pVarBlock = GetEnvironmentStrings();
	p = pVarBlock;
	count = 0;
	while (*p != 0) {
		count += 1;
		while (*p != 0) {
			p += 1;
		}
		p += 1;
	}

	/* Populate the array. */

	envArray = instantiateClassindexableSize(classArray(), count);
	p = pVarBlock;
	count = 0;
	while (*p != 0) {
		count += 1;
		pushRemappableOop(envArray);
		/* begin stringFromCString: */
		len = strlen(p);
		newString = instantiateClassindexableSize(classString(), len);
		strncpy(arrayValueOf(newString), p, len);
		string = newString;
		envArray = popRemappableOop();
		stObjectatput(envArray, count, string);
		while (*p != 0) {
			p += 1;
		}
		p += 1;
	}
	FreeEnvironmentStrings(pVarBlock);
	popthenPush(1, envArray);
}


/*	Answer the exit status for the process represented by a HANDLE. Fail if
	the process is still active, or if the GetExitCodeProcess call fails. */

EXPORT(sqInt)
primitiveGetExitStatusForHandle(void)
{
    DWORD exitStatus;
    HANDLE handle;

	if (((handle = handleFrom(stackObjectValue(0)))) == null) {
		return null;
	}
	if ((GetExitCodeProcess(handle, &exitStatus)) != 0) {
		if (exitStatus == STILL_ACTIVE) {

			/* Child process is still active, fail the primitive */

			return primitiveFail();
		}
		popthenPush(2, positive32BitIntegerFor(exitStatus));
	}
	else {
		return primitiveFail();
	}
}


/*	Answer the ID of my main thread. */

EXPORT(sqInt)
primitiveGetMainThreadHandle(void)
{
    HANDLE handle;
    sqInt handleOop;

	handle = GetCurrentThread();
	handleOop = handleObjectFrom(handle);
	popthenPush(1, handleOop);
}


/*	Answer the ID of my main thread. */

EXPORT(sqInt)
primitiveGetMainThreadID(void)
{
    DWORD tid;
    sqInt tidOop;

	tid = GetCurrentThreadId();
	tidOop = positive32BitIntegerFor(tid);
	popthenPush(1, tidOop);
}


/*	Answer the process ID of my OS process */

EXPORT(sqInt)
primitiveGetPid(void)
{
    DWORD pid;
    sqInt pidOop;

	pid = GetCurrentProcessId();
	pidOop = positive32BitIntegerFor(pid);
	popthenPush(1, pidOop);
}


/*	Answer the handle for my OS process */

EXPORT(sqInt)
primitiveGetPidHandle(void)
{
    HANDLE handle;
    sqInt handleOop;

	handle = GetCurrentProcess();
	handleOop = handleObjectFrom(handle);
	popthenPush(1, handleOop);
}


/*	Answer the unique session identifier for this Smalltalk instance running
	in this
	OS process. The C integer value is coerced into a Smalltalk ByteArray to
	preserve the full range of possible values.
 */

EXPORT(sqInt)
primitiveGetSession(void)
{
    void *charArray1;
    unsigned char *sessionByteArrayPointer;
    sqInt sessionIDSize;
    sqInt sessionOop;
    SESSIONIDENTIFIERTYPE thisSessionID;

	thisSessionID = getThisSessionID();
	sessionIDSize = sizeof(thisSessionID);
	sessionOop = instantiateClassindexableSize(classByteArray(), sessionIDSize);
	sessionByteArrayPointer = arrayValueOf(sessionOop);
	if (thisSessionID == null) {
		return primitiveFail();
	}
	/* begin copyBytesFrom:to:length: */
	charArray1 = (unsigned char *)&thisSessionID;
	memcpy(sessionByteArrayPointer, charArray1, sessionIDSize);
	popthenPush(1, sessionOop);
}


/*	Answer a two element array containing the sqFile data structure
	representing standard error stream for my OS process, and a flag (true or
	false) to indicate
	whether the sqFile data structure contains a valid HANDLE. If no standard
	error stream is available for this OS process, the sqFile data structure
	will contain an
	invalid HANDLE value, which will result in failures on subsequent
	accesses. 
 */

EXPORT(sqInt)
primitiveGetStdError(void)
{
    SQFile *file;
    sqInt fileOop;
    HANDLE handle;
    HANDLE invalid;
    sqInt result;
    SESSIONIDENTIFIERTYPE thisSession;

	thisSession = sessionIdentifierFrom(stackObjectValue(0));
	invalid = INVALID_HANDLE_VALUE;
	result = instantiateClassindexableSize(classArray(), 2);
	fileOop = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	file = arrayValueOf(fileOop);
	handle = GetStdHandle(STD_ERROR_HANDLE);
	if (handle != invalid) {
		stObjectatput(result, 2, trueObject());
	}
	else {
		stObjectatput(result, 2, falseObject());
	}
	file->file = handle;
	file->sessionID = thisSession;
	file->writable = 1;
	file->lastOp = 0;
	stObjectatput(result, 1, fileOop);
	pop(2);
	push(result);
}


/*	Answer a two element array containing the sqFile data structure
	representing standard input stream for my OS process, and a flag (true or
	false) to indicate
	whether the sqFile data structure contains a valid HANDLE. If no standard
	input stream is available for this OS process, the sqFile data structure
	will contain an
	invalid HANDLE value, which will result in failures on subsequent
	accesses. 
 */

EXPORT(sqInt)
primitiveGetStdInput(void)
{
    SQFile *file;
    sqInt fileOop;
    HANDLE handle;
    HANDLE invalid;
    sqInt result;
    SESSIONIDENTIFIERTYPE thisSession;

	thisSession = sessionIdentifierFrom(stackObjectValue(0));
	invalid = INVALID_HANDLE_VALUE;
	result = instantiateClassindexableSize(classArray(), 2);
	fileOop = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	file = arrayValueOf(fileOop);
	handle = GetStdHandle(STD_INPUT_HANDLE);
	if (handle != invalid) {
		stObjectatput(result, 2, trueObject());
	}
	else {
		stObjectatput(result, 2, falseObject());
	}
	file->file = handle;
	file->sessionID = thisSession;
	file->writable = 0;
	file->lastOp = 0;
	stObjectatput(result, 1, fileOop);
	pop(2);
	push(result);
}


/*	Answer a two element array containing the sqFile data structure
	representing standard output stream for my OS process, and a flag (true or
	false) to indicate
	whether the sqFile data structure contains a valid HANDLE. If no standard
	output stream is available for this OS process, the sqFile data structure
	will contain an
	invalid HANDLE value, which will result in failures on subsequent
	accesses. 
 */

EXPORT(sqInt)
primitiveGetStdOutput(void)
{
    SQFile *file;
    sqInt fileOop;
    HANDLE handle;
    HANDLE invalid;
    sqInt result;
    SESSIONIDENTIFIERTYPE thisSession;

	thisSession = sessionIdentifierFrom(stackObjectValue(0));
	invalid = INVALID_HANDLE_VALUE;
	result = instantiateClassindexableSize(classArray(), 2);
	fileOop = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	file = arrayValueOf(fileOop);
	handle = GetStdHandle(STD_OUTPUT_HANDLE);
	if (handle != invalid) {
		stObjectatput(result, 2, trueObject());
	}
	else {
		stObjectatput(result, 2, falseObject());
	}
	file->file = handle;
	file->sessionID = thisSession;
	file->writable = 1;
	file->lastOp = 0;
	stObjectatput(result, 1, fileOop);
	pop(2);
	push(result);
}


/*	A character has been read into an external buffer corresponding to
	aSemaphoreIndex, and is now available. Answer the integer value of the
	character, or nil if no character
	was read, or -1 if an error occurred on the read.
 */

EXPORT(sqInt)
primitiveLastReadFor(void)
{
    sqInt index;
    sqInt result;

	index = stackIntegerValue(0);
	if (readCharStatusArray[index]) {
		if ((readCharCountArray[index]) < 1) {
			result = nilObject();
		}
		else {
			result = integerObjectOf(readCharBufferArray[index]);
		}
	}
	else {
		result = integerObjectOf(-1);
	}
	popthenPush(2, result);
}


/*	A character has been read into an external buffer corresponding to
	aSemaphoreIndex, and is now available. Answer the integer value of the
	character, or nil if no character
	was read, or -1 if an error occurred on the read. Store the full results
	of the most
	recent read into a three element array provided by the sender. Contents of
	the array
	will be status of the read call, character read, and character count
	(which should
	always be 1).
 */

EXPORT(sqInt)
primitiveLastReadForStoreIn(void)
{
    sqInt index;
    sqInt result;
    sqInt resultArray;

	index = stackIntegerValue(1);
	resultArray = stackValue(0);
	stObjectatput(resultArray, 1, positive32BitIntegerFor(readCharStatusArray[index]));
	stObjectatput(resultArray, 2, integerObjectOf(readCharBufferArray[index]));
	stObjectatput(resultArray, 3, integerObjectOf(readCharCountArray[index]));
	if (readCharStatusArray[index]) {
		if ((readCharCountArray[index]) < 1) {
			result = nilObject();
		}
		else {
			result = integerObjectOf(readCharBufferArray[index]);
		}
	}
	else {
		result = integerObjectOf(-1);
	}
	popthenPush(3, result);
}


/*	Create a pipe, and answer an array of two file handles for the pipe writer
	and reader.
	The readerIOStream and writerIOStream variables represent the low level
	pipe streams,
	which will be of type (FILE *) or HANDLE, depending on what the FilePlugin
	support code is using to represent file streams. FILEHANDLETYPE is defined
	in my subclasses
	in the #declareCVarsIn: class method.
 */

EXPORT(sqInt)
primitiveMakePipe(void)
{
    sqInt arrayResult;
    sqInt reader;
    FILEHANDLETYPE readerIOStream;
    FILEHANDLETYPE *readerIOStreamPtr;
    SQFile *readerPtr;
    SESSIONIDENTIFIERTYPE thisSession;
    sqInt writer;
    FILEHANDLETYPE writerIOStream;
    FILEHANDLETYPE *writerIOStreamPtr;
    SQFile *writerPtr;


	/* Create the anonymous OS pipe */

	thisSession = getThisSessionID();
	readerIOStreamPtr = (&readerIOStream);
	writerIOStreamPtr = (&writerIOStream);
	if (!(makePipeForReaderwriter(readerIOStreamPtr, writerIOStreamPtr))) {
		return primitiveFail();
	}
	writer = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	writerPtr = arrayValueOf(writer);
	writerPtr->file = writerIOStream;
	writerPtr->sessionID = thisSession;
	writerPtr->writable = 1;
	writerPtr->lastOp = 0;
	pushRemappableOop(writer);
	reader = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	readerPtr = arrayValueOf(reader);
	readerPtr->file = readerIOStream;
	readerPtr->sessionID = thisSession;
	readerPtr->writable = 0;
	readerPtr->lastOp = 0;
	pushRemappableOop(reader);
	arrayResult = instantiateClassindexableSize(classArray(), 2);
	stObjectatput(arrayResult, 1, popRemappableOop());
	stObjectatput(arrayResult, 2, popRemappableOop());
	pop(1);
	push(arrayResult);
}


/*	Create a pipe, and answer an array of two file handles for the pipe writer
	and reader.
	The session identifier is passed as the parameter to this primitive. Use
	this variant
	if the session identifier is not available directly in the VM (as may be
	the case if
	it is not possible to link from this plugin to a variable elsewhere in the
	VM). The readerIOStream and writerIOStream variables represent the low
	level pipe streams,
	which will be of type (FILE *) or HANDLE, depending on what the FilePlugin
	support code is using to represent file streams. FILEHANDLETYPE is defined
	in my subclasses
	in the #declareCVarsIn: class method.
 */

EXPORT(sqInt)
primitiveMakePipeWithSessionIdentifier(void)
{
    sqInt arrayResult;
    sqInt reader;
    FILEHANDLETYPE readerIOStream;
    FILEHANDLETYPE *readerIOStreamPtr;
    SQFile *readerPtr;
    SESSIONIDENTIFIERTYPE thisSession;
    sqInt writer;
    FILEHANDLETYPE writerIOStream;
    FILEHANDLETYPE *writerIOStreamPtr;
    SQFile *writerPtr;


	/* Create the anonymous OS pipe */

	thisSession = sessionIdentifierFrom(stackObjectValue(0));
	readerIOStreamPtr = (&readerIOStream);
	writerIOStreamPtr = (&writerIOStream);
	if (!(makePipeForReaderwriter(readerIOStreamPtr, writerIOStreamPtr))) {
		return primitiveFail();
	}
	writer = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	writerPtr = arrayValueOf(writer);
	writerPtr->file = writerIOStream;
	writerPtr->sessionID = thisSession;
	writerPtr->writable = 1;
	writerPtr->lastOp = 0;
	pushRemappableOop(writer);
	reader = instantiateClassindexableSize(classByteArray(), sizeof(SQFile));
	/* begin fileValueOf: */
	readerPtr = arrayValueOf(reader);
	readerPtr->file = readerIOStream;
	readerPtr->sessionID = thisSession;
	readerPtr->writable = 0;
	readerPtr->lastOp = 0;
	pushRemappableOop(reader);
	arrayResult = instantiateClassindexableSize(classArray(), 2);
	stObjectatput(arrayResult, 1, popRemappableOop());
	stObjectatput(arrayResult, 2, popRemappableOop());
	pop(2);
	push(arrayResult);
}


/*	Answer a string containing the module name string for this plugin. */

EXPORT(sqInt)
primitiveModuleName(void)
{
	popthenPush(1, stringFromCString(getModuleName()));
}


/*	Read the next character from anIOHandle (a SQFile struct) into a buffer in
	the VM. When
	the read completes, signal the specified Semaphore to notify that the
	character is available.
	Answer the handle of the new thread, or nil on error.
 */

EXPORT(sqInt)
primitiveNextFromSignaling(void)
{
    HANDLE handle;
    HANDLE hThread;
    static int index;
    static struct {int index; HANDLE handle;} threadArgs;
    DWORD threadID;

	index = stackIntegerValue(0);
	if (index >= readCharArraySize) {
		return primitiveFail();
	}
	waitForThreadMutex(readThreadMutexHandle());
	handle = handleFromSQFile(stackObjectValue(1));
	if (handle == null) {
		return null;
	}
	readCharBufferArray[index] = 0;
	readCharCountArray[index] = 0;
	readCharStatusArray[index] = 0;
	threadArgs.index = index;
	threadArgs.handle = handle;
	
#if !defined(STACK_SIZE_PARAM_IS_A_RESERVATION)
	
#define STACK_SIZE_PARAM_IS_A_RESERVATION 0x10000
	
#endif

	/* Safety net: Remember the identity of the thread which should be active for this
	   semaphore index. */

	hThread = CreateThread(NULL, 1024, readCharThread, &threadArgs, STACK_SIZE_PARAM_IS_A_RESERVATION, &threadID);
	readCharThreadIdArray[index] = threadID;
	if (hThread == null) {
		return nilObject();
	}
	popthenPush(3, handleObjectFrom(hThread));
}


/*	Anwer true the first time this primitive is called in a Squeak session,
	and false thereafter.
 */

EXPORT(sqInt)
primitiveOneShot(void)
{
    static int thisPrimHasBeenCalled= 0;

	if (thisPrimHasBeenCalled == 0) {
		thisPrimHasBeenCalled = 1;
		popthenPush(1, trueObject());
	}
	else {
		popthenPush(1, falseObject());
	}
}


/*	Set the file handle for standard error of my OS process to the handle
	passed in a SQFile struct.
 */

EXPORT(sqInt)
primitiveSetStdErr(void)
{
    FILEHANDLETYPE handle;
    sqInt sqFileOop;

	sqFileOop = stackValue(0);
	if (!((((isBytes(sqFileOop))
 && ((byteSizeOf(sqFileOop)) == (sizeof(SQFile))))
 && ((getThisSessionID()) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop)))))
		 && (isNonNullSQFile(sqFileOop)))) {
		return primitiveFail();
	}
	handle = fileHandleFrom(sqFileOop);
	if (SetStdHandle(STD_ERROR_HANDLE, handle)) {
		popthenPush(2, trueObject());
	}
	else {
		popthenPush(2, falseObject());
	}
}


/*	Set the file handle for standard input of my OS process to the handle
	passed in a SQFile struct.
 */

EXPORT(sqInt)
primitiveSetStdIn(void)
{
    FILEHANDLETYPE handle;
    sqInt sqFileOop;

	sqFileOop = stackValue(0);
	if (!((((isBytes(sqFileOop))
 && ((byteSizeOf(sqFileOop)) == (sizeof(SQFile))))
 && ((getThisSessionID()) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop)))))
		 && (isNonNullSQFile(sqFileOop)))) {
		return primitiveFail();
	}
	handle = fileHandleFrom(sqFileOop);
	if (SetStdHandle(STD_INPUT_HANDLE, handle)) {
		popthenPush(2, trueObject());
	}
	else {
		popthenPush(2, falseObject());
	}
}


/*	Set the file handle for standard output of my OS process to the handle
	passed in a SQFile struct.
 */

EXPORT(sqInt)
primitiveSetStdOut(void)
{
    FILEHANDLETYPE handle;
    sqInt sqFileOop;

	sqFileOop = stackValue(0);
	if (!((((isBytes(sqFileOop))
 && ((byteSizeOf(sqFileOop)) == (sizeof(SQFile))))
 && ((getThisSessionID()) == (sessionIdentifierFromSqFile(arrayValueOf(sqFileOop)))))
		 && (isNonNullSQFile(sqFileOop)))) {
		return primitiveFail();
	}
	handle = fileHandleFrom(sqFileOop);
	if (SetStdHandle(STD_OUTPUT_HANDLE, handle)) {
		popthenPush(2, trueObject());
	}
	else {
		popthenPush(2, falseObject());
	}
}


/*	Set up a thread to wait for a process HANDLE to exit, then signal the
	Semaphore at index. This provides asychronous notification of an external
	process exit. Answer
	the handle of the handler thread.
 */

EXPORT(sqInt)
primitiveSetWaitForAnyProcessExitThenSignalSemaphoreWithIndex(void)
{
    sqInt arraySize;
    static HANDLE handleArray[MAXIMUM_WAIT_OBJECTS];
    sqInt handleArrayOop;
    unsigned int *handleArrayOopPtr;
    static HANDLE *handleArrayPtr;
    sqInt handleCount;
    sqInt idx;
    sqInt semaIndex;
    sqInt threadInformation;

	semaIndex = stackIntegerValue(0);
	handleArrayOop = stackObjectValue(1);
	handleArrayOopPtr = firstIndexableField(handleArrayOop);
	handleCount = stSizeOf(handleArrayOop);
	arraySize = MAXIMUM_WAIT_OBJECTS;
	if (handleCount > arraySize) {
		return primitiveFail();
	}
	idx = 0;
	while (idx < handleCount) {
		handleArray[idx] = (handleFrom(handleArrayOopPtr[idx]));
		idx += 1;
	}
	handleArrayPtr = handleArray;
	threadInformation = startHandlerThreadForAnycountsignalingSemaphoreAt(handleArrayPtr, handleCount, semaIndex);
	popthenPush(3, threadInformation);
}


/*	Size in bytes of an integer, for this C compiler on this machine. */

EXPORT(sqInt)
primitiveSizeOfInt(void)
{
	pop(1);
	pushInteger(sizeOfInt());
}


/*	Size in bytes of a void pointer, for this C compiler on this machine. */

EXPORT(sqInt)
primitiveSizeOfPointer(void)
{
	pop(1);
	pushInteger(sizeOfPointer());
}


/*	Kill the thread. No cleanup is performed, so use with caution for a thread
	which is (for example) manipulating a mutex. Answer true for success, else
	false. 
 */

EXPORT(sqInt)
primitiveTerminateThread(void)
{
    HANDLE handle;

	if (((handle = handleFrom(stackObjectValue(0)))) == null) {
		return null;
	}
	if (TerminateThread(handle, 0)) {
		popthenPush(2, trueObject());
	}
	else {
		popthenPush(2, falseObject());
	}
}


/*	Answer a string containing the version string for this plugin. */

EXPORT(sqInt)
primitiveVersionString(void)
{
	pop(1);
	push(stringFromCString(versionString()));
}


/*	This is the thread procedure for reading one character from a file or pipe
	handle. The values of index and handle have been passed on the local
	thread stack, so they are now local to the thread which is executing this
	method. Once the values are safely on a local thread stack, the mutex
	semaphore is released, allowing other threads to be created. */

static DWORD WINAPI
readCharThreadIndexhandle(sqInt index, HANDLE handle)
{
    HANDLE aHandle;
    static HANDLE h= 0;
    sqInt status;


	/* Release mutex, allowing additional threads to be set up */

	/* begin releaseThreadMutex: */
	/* begin readThreadMutexHandle */
	if (h == null) {
		h = createThreadMutex();
	}
	aHandle = h;
	ReleaseMutex(aHandle);
	status = ReadFile(handle, &readCharBufferArray[index], 1, &readCharCountArray[index], NULL);
	readCharStatusArray[index] = status;
	if ((GetCurrentThreadId()) == (readCharThreadIdArray[index])) {

		/* Signal Squeak that the character is now available */

		signalSemaphoreWithIndex(index);
	}
	else {

		/* Invalidate any data we just placed in the buffer */

		readCharBufferArray[index] = 0;
		readCharCountArray[index] = 0;
		readCharStatusArray[index] = 0;
	}
	return status;
}


/*	This is the entry point for the thread procedure for reading one character
	from a file or pipe handle. There may be many instances of this thread
	procedure, in
	which case each thread may be distinguished by the index value with which
	it is
	called. Remember the index value by saving it in a variable on the thread
	stack. Read one character, and signal a Smalltalk Semaphore to indicate
	completion. 
 */

static DWORD WINAPI
readCharThread(void *args)
{
    HANDLE handle;
    sqInt index;
    struct {int index; HANDLE handle;} *threadArgs;

	threadArgs = args;
	index = threadArgs->index;
	handle = threadArgs->handle;
	return readCharThreadIndexhandle(index, handle);
}


/*	Answer a HANDLE for a mutex semaphore for sychronizing setup of read
	threads. 
 */

static HANDLE
readThreadMutexHandle(void)
{
    static HANDLE h= 0;

	if (h == null) {
		h = createThreadMutex();
	}
	return h;
}


/*	To be called at the end of a critical section. */

static BOOL
releaseThreadMutex(HANDLE aHandle)
{
	return ReleaseMutex(aHandle);
}


/*	Answer 1 if running in secure mode, else 0. The osprocessSandboxSecurity
	variable is initialized to -1. On the first call to this method, set its
	value to
	either 0 (user has full access to the plugin) or 1 (user is not permitted
	to do
	dangerous things).
 */

static sqInt
sandboxSecurity(void)
{
	if (osprocessSandboxSecurity < 0) {
		osprocessSandboxSecurity = securityHeurisitic();
	}
	return osprocessSandboxSecurity;
}


/*	Answer 0 to permit full access to OSProcess functions, or 1 if access
	should be
	restricted for dangerous functions. The rules are:
	- If the security plugin is not present, grant full access
	- If the security plugin can be loaded, restrict access unless user has
	all of secCanWriteImage, secHasFileAccess and secHasSocketAccess */
/*	FIXME: This function has not been tested. -dtl */
/*	If the security plugin can be loaded, use it to check. If not, assume it's
	ok 
 */

static sqInt
securityHeurisitic(void)
{
    sqInt canWriteImage;
    sqInt hasFileAccess;
    sqInt hasSocketAccess;
    void (*sCWIfn)(void);
    void (*sHFAfn)(void);
    void (*sHSAfn)(void);

	sCWIfn = ioLoadFunctionFrom("secCanWriteImage", "SecurityPlugin");
	if (sCWIfn == 0) {
		return 0;
	}
	canWriteImage =  ((int (*) (void)) sCWIfn)();
	sHFAfn = ioLoadFunctionFrom("secHasFileAccess", "SecurityPlugin");
	if (sHFAfn == 0) {
		return 0;
	}
	hasFileAccess =  ((int (*) (void)) sHFAfn)();
	sHSAfn = ioLoadFunctionFrom("secHasSocketAccess", "SecurityPlugin");
	if (sHSAfn == 0) {
		return 0;
	}
	hasSocketAccess =  ((int (*) (void)) sHSAfn)();
	if ((canWriteImage
 && (hasFileAccess))
	 && (hasSocketAccess)) {
		return 0;
	}
	else {
		return 1;
	}
}


/*	Answer a session ID represented by aByteArray. The session ID is used in
	the SQFile structure. If that data structure changes, we should see
	compiler warnings about type mismatch with SESSIONIDENTIFIERTYPE. */

static SESSIONIDENTIFIERTYPE
sessionIdentifierFrom(sqInt aByteArray)
{
    sqInt idx;
    unsigned char *session;
    union {SESSIONIDENTIFIERTYPE session; unsigned char bytes[sizeof(SESSIONIDENTIFIERTYPE)];} sessionUnion;

	if (!((isBytes(aByteArray))
		 && ((stSizeOf(aByteArray)) == (sizeOfSession())))) {
		return null;
	}
	session = arrayValueOf(aByteArray);
	idx = 0;
	while (idx < (sizeOfSession())) {
		sessionUnion.bytes[idx] = session[idx];
		idx += 1;
	}
	return sessionUnion.session;
}


/*	Note: This is coded so that it can be run in Squeak. */

EXPORT(sqInt)
setInterpreter(struct VirtualMachine*anInterpreter)
{
    sqInt ok;

	interpreterProxy = anInterpreter;
	ok = ((interpreterProxy->majorVersion()) == (VM_PROXY_MAJOR))
	 && ((interpreterProxy->minorVersion()) >= (VM_PROXY_MINOR));
	if (ok) {
		
#if !defined(SQUEAK_BUILTIN_PLUGIN)
		arrayValueOf = interpreterProxy->arrayValueOf;
		byteSizeOf = interpreterProxy->byteSizeOf;
		classArray = interpreterProxy->classArray;
		classByteArray = interpreterProxy->classByteArray;
		classString = interpreterProxy->classString;
		failed = interpreterProxy->failed;
		falseObject = interpreterProxy->falseObject;
		firstIndexableField = interpreterProxy->firstIndexableField;
		getThisSessionID = interpreterProxy->getThisSessionID;
		instantiateClassindexableSize = interpreterProxy->instantiateClassindexableSize;
		integerObjectOf = interpreterProxy->integerObjectOf;
		integerValueOf = interpreterProxy->integerValueOf;
		ioLoadFunctionFrom = interpreterProxy->ioLoadFunctionFrom;
		isBytes = interpreterProxy->isBytes;
		nilObject = interpreterProxy->nilObject;
		pop = interpreterProxy->pop;
		popthenPush = interpreterProxy->popthenPush;
		popRemappableOop = interpreterProxy->popRemappableOop;
		positive32BitIntegerFor = interpreterProxy->positive32BitIntegerFor;
		primitiveFail = interpreterProxy->primitiveFail;
		primitiveFailFor = interpreterProxy->primitiveFailFor;
		push = interpreterProxy->push;
		pushInteger = interpreterProxy->pushInteger;
		pushRemappableOop = interpreterProxy->pushRemappableOop;
		signalSemaphoreWithIndex = interpreterProxy->signalSemaphoreWithIndex;
		sizeOfSTArrayFromCPrimitive = interpreterProxy->sizeOfSTArrayFromCPrimitive;
		stObjectatput = interpreterProxy->stObjectatput;
		stSizeOf = interpreterProxy->stSizeOf;
		stackIntegerValue = interpreterProxy->stackIntegerValue;
		stackObjectValue = interpreterProxy->stackObjectValue;
		stackValue = interpreterProxy->stackValue;
		storePointerofObjectwithValue = interpreterProxy->storePointerofObjectwithValue;
		trueObject = interpreterProxy->trueObject;
#endif /* !defined(SQUEAK_BUILTIN_PLUGIN) */
	}
	return ok;
}

EXPORT(sqInt)
shutdownModule(void)
{
}

static sqInt
sizeOfHandle(void)
{
	return sizeof(HANDLE);
}


/*	Size in bytes of an integer, for this C compiler on this machine. */

static sqInt
sizeOfInt(void)
{
	return sizeof(int);
}


/*	Size in bytes of a void pointer, for this C compiler on this machine. */

static sqInt
sizeOfPointer(void)
{
	return sizeof(void *);
}


/*	Size of a SESSIONIDENTIFIERTYPE. Should match usage in the SQFile data
	structure, otherwise we should get compiler warnings. */

static sqInt
sizeOfSession(void)
{
	return sizeof(SESSIONIDENTIFIERTYPE);
}


/*	Answer the OS file descriptor, an integer value, from a SQSocket data
	structure, or answer -1 if unable to obtain the file descriptor (probably
	due to receiving
	an incorrect type of object as aFileHandle).
	
	Warning: The first element of privateSocketStruct happens to be the Unix
	file number of the socket. See sqUnixSocket.c for the definition. This
	method takes
	advantage of this, and will break if anyone ever redefines the data
	structure. 
 */

static int
socketDescriptorFrom(sqInt sqSocketOop)
{
    void *privateSocketStruct;
    SocketPtr sqSocket;

	/* begin socketValueOf: */
	sqSocket = arrayValueOf(sqSocketOop);
	privateSocketStruct = sqSocket->privateSocketPtr;
	if (privateSocketStruct == 0) {
		return -1;
	}
	return * (int *) privateSocketStruct;
}


/*	Answer the size of a SQSocket data structure in bytes. */

static sqInt
socketRecordSize(void)
{
	return sizeof(SQSocket);
}


/*	Return a pointer to the first byte of of the SQsocket data structure
	socket record within
	anSQSocketRecord, which is expected to be a ByteArray of size
	self>>socketRecordSize. 
 */

static SocketPtr
socketValueOf(sqInt anSQSocketRecord)
{
	return arrayValueOf(anSQSocketRecord);
}


/*	Wait for a process HANDLE to exit, then signal the Semaphore at index.
	Answer the thread ID of the handler. This is the code to be executed in a
	thread to provide
	asychronous notification of an external process exit.
 */

static sqInt
startHandlerThreadForAnycountsignalingSemaphoreAt(HANDLE *handleArrayPointer, sqInt arraySize, sqInt semaphoreIndex)
{
    HANDLE hThread;
    static struct {int count; HANDLE *handles; int semaIndex;} threadArgs;
    DWORD threadID;
    sqInt threadInformation;


	/* Complete setup of one handler before doing the next. Mutex will be
	   released in the newly started thread. */

	waitForThreadMutex(exitThreadMutexHandle());
	threadArgs.count= arraySize;
	threadArgs.handles= handleArrayPointer;
	threadArgs.semaIndex= semaphoreIndex;
	
#if !defined(STACK_SIZE_PARAM_IS_A_RESERVATION)
	
#define STACK_SIZE_PARAM_IS_A_RESERVATION 0x10000
	
#endif
	hThread = CreateThread(NULL, 1024, handleAnyChildProc, &threadArgs, STACK_SIZE_PARAM_IS_A_RESERVATION, &threadID);
	if (hThread == null) {
		return nilObject();
	}
	pushRemappableOop(positive32BitIntegerFor(threadID));
	pushRemappableOop(handleObjectFrom(hThread));
	threadInformation = instantiateClassindexableSize(classArray(), 2);
	storePointerofObjectwithValue(0, threadInformation, popRemappableOop());
	storePointerofObjectwithValue(1, threadInformation, popRemappableOop());
	return threadInformation;
}


/*	Answer the pseudo HANDLE for standard error. */

static HANDLE
stdErrHandle(void)
{
	return (HANDLE) STD_ERROR_HANDLE;
}

static HANDLE
stderrHandle(void)
{
    HANDLE h;

	h = GetStdHandle(STD_ERROR_HANDLE);
	if (h == INVALID_HANDLE_VALUE) {
		primitiveFail();
	}
	return h;
}


/*	Answer the pseudo HANDLE for standard input. */

static HANDLE
stdInHandle(void)
{
	return (HANDLE) STD_INPUT_HANDLE;
}

static HANDLE
stdinHandle(void)
{
    HANDLE h;

	h = GetStdHandle(STD_INPUT_HANDLE);
	if (h == INVALID_HANDLE_VALUE) {
		primitiveFail();
	}
	return h;
}


/*	Answer the pseudo HANDLE for standard output. */

static HANDLE
stdOutHandle(void)
{
	return (HANDLE) STD_OUTPUT_HANDLE;
}

static HANDLE
stdoutHandle(void)
{
    HANDLE h;

	h = GetStdHandle(STD_OUTPUT_HANDLE);
	if (h == INVALID_HANDLE_VALUE) {
		primitiveFail();
	}
	return h;
}


/*	Answer a new String copied from a null-terminated C string.
	Caution: This may invoke the garbage collector. */

static sqInt
stringFromCString(const char *aCString)
{
    sqInt len;
    sqInt newString;

	len = strlen(aCString);
	newString = instantiateClassindexableSize(classString(), len);
	strncpy(arrayValueOf(newString), aCString, len);
	return newString;
}


/*	Answer a HANDLE for a mutex semaphore. */

static HANDLE
threadMutexHandle(void)
{
    static HANDLE h= 0;

	if (h == 0) {
		h = CreateMutex(NULL, false, NULL);
	}
	return h;
}


/*	Answer a new null-terminated C string copied from aString.
	The string is allocated in object memory, and will be moved
	without warning by the garbage collector. Any C pointer
	reference the the result is valid only until the garbage
	collector next runs. Therefore, this method should only be used
	within a single primitive in a section of code in which the
	garbage collector is guaranteed not to run. Note also that
	this method may itself invoke the garbage collector prior
	to allocating the new C string.
	
	Warning: The result of this method will be invalidated by the
	next garbage collection, including a GC triggered by creation
	of a new object within a primitive. Do not call this method
	twice to obtain two string pointers.
 */

static char *
transientCStringFromString(sqInt aString)
{
    char *cString;
    sqInt len;
    sqInt newString;
    char *stringPtr;


	/* Allocate space for a null terminated C string. */

	len = sizeOfSTArrayFromCPrimitive(arrayValueOf(aString));
	pushRemappableOop(aString);
	newString = instantiateClassindexableSize(classString(), len + 1);
	stringPtr = arrayValueOf(popRemappableOop());

	/* Point to the actual C string. */

	cString = arrayValueOf(newString);
	(char *)strncpy(cString, stringPtr, len);
	cString[len] = 0;
	return cString;
}


/*	Answer a string containing the version string for this plugin. Handle MNU
	errors, which can occur if class InterpreterPlugin has been removed from
	the system.
	
	Important: When this method is changed, the class side method must also be
	changed to match.
 */
/*	4.0 supports 64bit code base */

static char *
versionString(void)
{
    static char version[]= "4.3.3 Cog";

	return version;
}


/*	To be called before entering a critical section. */

static DWORD
waitForThreadMutex(HANDLE aHandle)
{
	return WaitForSingleObject(aHandle, INFINITE);
}


#ifdef SQUEAK_BUILTIN_PLUGIN

void* Win32OSProcessPlugin_exports[][3] = {
	{"Win32OSProcessPlugin", "getModuleName", (void*)getModuleName},
	{"Win32OSProcessPlugin", "initialiseModule", (void*)initialiseModule},
	{"Win32OSProcessPlugin", "moduleUnloaded", (void*)moduleUnloaded},
	{"Win32OSProcessPlugin", "primitiveAllocConsole", (void*)primitiveAllocConsole},
	{"Win32OSProcessPlugin", "primitiveBufferValuesAt", (void*)primitiveBufferValuesAt},
	{"Win32OSProcessPlugin", "primitiveCanAccessChildProcess", (void*)primitiveCanAccessChildProcess},
	{"Win32OSProcessPlugin", "primitiveCloseHandle", (void*)primitiveCloseHandle},
	{"Win32OSProcessPlugin", "primitiveCommand", (void*)primitiveCommand},
	{"Win32OSProcessPlugin", "primitiveCommandWithInputOutputError", (void*)primitiveCommandWithInputOutputError},
	{"Win32OSProcessPlugin", "primitiveCreatePipe", (void*)primitiveCreatePipe},
	{"Win32OSProcessPlugin", "primitiveCreatePipeWithSessionIdentifier", (void*)primitiveCreatePipeWithSessionIdentifier},
	{"Win32OSProcessPlugin", "primitiveFixPointersInArrayOfStrings", (void*)primitiveFixPointersInArrayOfStrings},
	{"Win32OSProcessPlugin", "primitiveFreeConsole", (void*)primitiveFreeConsole},
	{"Win32OSProcessPlugin", "primitiveGetCurrentWorkingDirectory", (void*)primitiveGetCurrentWorkingDirectory},
	{"Win32OSProcessPlugin", "primitiveGetEnvironmentStrings", (void*)primitiveGetEnvironmentStrings},
	{"Win32OSProcessPlugin", "primitiveGetExitStatusForHandle", (void*)primitiveGetExitStatusForHandle},
	{"Win32OSProcessPlugin", "primitiveGetMainThreadHandle", (void*)primitiveGetMainThreadHandle},
	{"Win32OSProcessPlugin", "primitiveGetMainThreadID", (void*)primitiveGetMainThreadID},
	{"Win32OSProcessPlugin", "primitiveGetPid", (void*)primitiveGetPid},
	{"Win32OSProcessPlugin", "primitiveGetPidHandle", (void*)primitiveGetPidHandle},
	{"Win32OSProcessPlugin", "primitiveGetSession", (void*)primitiveGetSession},
	{"Win32OSProcessPlugin", "primitiveGetStdError", (void*)primitiveGetStdError},
	{"Win32OSProcessPlugin", "primitiveGetStdInput", (void*)primitiveGetStdInput},
	{"Win32OSProcessPlugin", "primitiveGetStdOutput", (void*)primitiveGetStdOutput},
	{"Win32OSProcessPlugin", "primitiveLastReadFor", (void*)primitiveLastReadFor},
	{"Win32OSProcessPlugin", "primitiveLastReadForStoreIn", (void*)primitiveLastReadForStoreIn},
	{"Win32OSProcessPlugin", "primitiveMakePipe", (void*)primitiveMakePipe},
	{"Win32OSProcessPlugin", "primitiveMakePipeWithSessionIdentifier", (void*)primitiveMakePipeWithSessionIdentifier},
	{"Win32OSProcessPlugin", "primitiveModuleName", (void*)primitiveModuleName},
	{"Win32OSProcessPlugin", "primitiveNextFromSignaling", (void*)primitiveNextFromSignaling},
	{"Win32OSProcessPlugin", "primitiveOneShot", (void*)primitiveOneShot},
	{"Win32OSProcessPlugin", "primitiveSetStdErr", (void*)primitiveSetStdErr},
	{"Win32OSProcessPlugin", "primitiveSetStdIn", (void*)primitiveSetStdIn},
	{"Win32OSProcessPlugin", "primitiveSetStdOut", (void*)primitiveSetStdOut},
	{"Win32OSProcessPlugin", "primitiveSetWaitForAnyProcessExitThenSignalSemaphoreWithIndex", (void*)primitiveSetWaitForAnyProcessExitThenSignalSemaphoreWithIndex},
	{"Win32OSProcessPlugin", "primitiveSizeOfInt", (void*)primitiveSizeOfInt},
	{"Win32OSProcessPlugin", "primitiveSizeOfPointer", (void*)primitiveSizeOfPointer},
	{"Win32OSProcessPlugin", "primitiveTerminateThread", (void*)primitiveTerminateThread},
	{"Win32OSProcessPlugin", "primitiveVersionString", (void*)primitiveVersionString},
	{"Win32OSProcessPlugin", "setInterpreter", (void*)setInterpreter},
	{"Win32OSProcessPlugin", "shutdownModule", (void*)shutdownModule},
	{NULL, NULL, NULL}
};

#endif /* ifdef SQ_BUILTIN_PLUGIN */
